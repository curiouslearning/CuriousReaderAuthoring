/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2);

var _WaveformInit = __webpack_require__(3);

var _WaveformInit2 = _interopRequireDefault(_WaveformInit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Load library
H5P = H5P || {};
H5PEditor.widgets.waveformInit = H5PEditor.WaveformInit = _WaveformInit2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _h5pParent = __webpack_require__(4);

var _h5pParent2 = _interopRequireDefault(_h5pParent);

var _globals = __webpack_require__(6);

var _wavesurfer = __webpack_require__(7);

var _wavesurfer2 = _interopRequireDefault(_wavesurfer);

var _wavesurferCursor = __webpack_require__(8);

var _wavesurferCursor2 = _interopRequireDefault(_wavesurferCursor);

var _wavesurferRegions = __webpack_require__(9);

var _wavesurferRegions2 = _interopRequireDefault(_wavesurferRegions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WaveformInit = function WaveformInit(parent, field, params, setValue) {
  this.parent = parent;
  this.field = field;
  this.params = params;
  this.setValue = setValue;

  this.id = null;
  this.crAudioIndex = 0;
  this.container = null;
  this.audioParams = this.parent.parent.parent.params.params;
  this.startTime = this.parent.params.startDuration != undefined ? this.parent.params.startDuration : 0;
  this.endTime = this.parent.params.endDuration != undefined ? this.parent.params.endDuration : 0.2;
  this.audioDuration;
};

WaveformInit.prototype = Object.create(_h5pParent2.default.prototype);
WaveformInit.prototype.constructor = WaveformInit;

/**
 * Initialize the waveform editor.
 * @param {*} $wrapper 
 */
WaveformInit.prototype.init = function () {
  var _this = this;

  var self = this;
  if (!self.container || self.container && self.container.length == 0) return;
  var wavesurfer = _wavesurfer2.default.create({
    container: self.container[0],
    waveColor: 'green',
    progressColor: 'grey',
    fillParent: true,
    responsive: true,
    barHeight: 8,
    plugins: [_wavesurferRegions2.default.create({
      regionsMinLength: 0.1,
      maxRegions: 1,
      regions: [{
        start: self.startTime,
        end: self.endTime,
        loop: false,
        color: 'rgba(250, 203, 110, 0.5)'
      }],
      dragSelection: {
        slop: 5
      }
    })]
  });

  (0, _globals.jQuery)('.wavesurfer-handle').css("width", "4px");
  (0, _globals.jQuery)('.wavesurfer-handle').css("background-color", "#707070");

  var region = void 0;
  self.crAudioIndex = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields.length;
  // let path = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex- 1].params.files ? H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].params.files[0].path : undefined;
  var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[0].parent.params.subContentId;
  var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
  // let id =  self.parent.parent.parent.params.subContentId;
  if (path != undefined && id != undefined) {
    var file = H5P.getPath(path, id);
    _globals.jQuery.get(file).done(function () {
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    }).fail(function () {
      var id = H5PEditor.contentId;
      var file = H5P.getPath(path, id);
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    });
  }

  wavesurfer.on('ready', function () {
    region = Object.values(wavesurfer.regions.list)[0];
    var width = self.parent.parent.parent.parent.cp.width + self.parent.parent.parent.parent.cp.width * 0.25;
    self.audioDuration = wavesurfer.getDuration();
    // wavesurfer.params.minPxPerSec = width / wavesurfer.getDuration();
    // wavesurfer.drawBuffer();

    // let regionId = self.id + "playRegion"
    // let $playRegionButton = '<button id = '+ regionId +' class = "playRegion">Play</button>'
    // $('#' + self.id).find('.wavesurfer-region').append($playRegionButton)
    // $('#' + regionId).on('click', function (e) {
    //   e.stopPropagation()
    //   if (region != undefined) {
    //     region.play()
    //   }
    // })
    var waveform = self.container[0];
    var waveformParent = waveform.parentElement.parentElement;
    console.log(waveformParent);
    var startDurationField = waveformParent.querySelector('.field-name-startDuration');
    var endDurationField = waveformParent.querySelector('.field-name-endDuration');

    console.log(startDurationField);
    console.log(endDurationField);
  });

  console.log("Testing: ");
  if (self.container[0]) {
    var waveform = self.container[0];
    var waveformParent = waveform.parentElement.parentElement;
    console.log(waveformParent);
    var startDurationField = waveformParent.querySelector('.field-name-startDuration');
    var endDurationField = waveformParent.querySelector('.field-name-endDuration');

    if (startDurationField && endDurationField) {
      var startDurationFieldInput = startDurationField.querySelector('input');
      var endDurationFieldInput = endDurationField.querySelector('input');

      console.log(startDurationFieldInput);
      console.log(endDurationFieldInput);

      startDurationFieldInput.addEventListener("focusout", function (e) {
        if (region != undefined) {
          var value = e.target.value;
          if (!isNaN(value)) {
            if (parseFloat(value) > self.audioDuration) {
              value = 0.0;
            }
            var inputStartTime = parseFloat(value);
            var inputEndTime = region.end <= parseFloat(value) ? parseFloat(value) + 0.2 : region.end;
            params = {
              start: inputStartTime.toFixed(4),
              end: inputEndTime.toFixed(4)
            };
            region.update(params);
          } else {
            (0, _globals.jQuery)(_this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
          }
        }
      });

      endDurationFieldInput.addEventListener("focusout", function (e) {
        if (region != undefined) {
          var value = e.target.value;
          if (!isNaN(value)) {
            if (parseFloat(value) > self.audioDuration) {
              value = self.audioDuration - 0.05;
            }
            var inputStartTime = parseFloat(value) <= region.start ? 0 : region.start;
            var inputEndTime = parseFloat(value);
            params = {
              start: inputStartTime.toFixed(4),
              end: inputEndTime.toFixed(4)
            };
            region.update(params);
          } else {
            (0, _globals.jQuery)(_this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
          }
        }
      });
    }
  }

  wavesurfer.on('region-updated', function (event) {
    _this.start = event.start;
    _this.end = event.end;
    _this.$startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
    _this.$endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
    _this.$startinput.val(_this.start.toFixed(4));
    _this.$endinput.val(_this.end.toFixed(4));
    _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + _this.start.toFixed(4));
    _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + _this.end.toFixed(4));
  });

  (0, _globals.jQuery)(self.container).parents('.h5p-craudio-editor').find(".h5p-add-file").first().parent().find('ul').on('DOMSubtreeModified', function () {
    // let path = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex- 1].params.files ? H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].params.files[0].path : undefined;
    var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].parent.params.subContentId;
    var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
    if (path != undefined && id != undefined) {
      var _file = H5P.getPath(path, id);
      _globals.jQuery.get(_file).done(function () {
        setTimeout(function () {
          wavesurfer.load(_file);
        }, 1000);
      }).fail(function () {
        var id = H5PEditor.contentId;
        var file = H5P.getPath(path, id);
        setTimeout(function () {
          wavesurfer.load(file);
        }, 1000);
      });
    }
    if (region != undefined) {
      var $startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
      var $endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
      $startinput.val(0);
      $endinput.val(0.2);
      _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + 0);
      _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + 0.2);
      params = {
        start: 0,
        end: 0.2
      };
      region.update(params);
    }
  });

  if (this.id != null) {
    var regionId = this.id + "playRegion";
    var $playRegionButton = (0, _globals.jQuery)('<button id = ' + regionId + ' class = "playRegion">Play</button>');
    (0, _globals.jQuery)(self.container).parent('div').append($playRegionButton);
    (0, _globals.jQuery)($playRegionButton).on('click', function () {
      if (region != undefined) {
        region.play();
      }
    });
  }
};

/**
 * Append the field to the wrapper.
 * @public
 * @param {H5P.jQuery} $wrapper
 */
WaveformInit.prototype.appendTo = function ($wrapper) {
  var self = this;
  var id = ns.getNextFieldId(this.field);
  var html = H5PEditor.createFieldMarkup(this.field, '<div class="waveform" id="' + id + '" class="h5p-color-picker">', id);
  self.$item = H5PEditor.$(html);
  this.setId(id);
  var wordText = this.parent.params.text != undefined ? this.parent.params.text : '';
  $wrapper.append('<h1 class="test">Select word(s)</h1>');
  // $wrapper.append('<label class="h5peditor-label"><input id="field-words-125" type="checkbox">Will Do Animation</label>')
  //let checkBoxElementForWord=$wrapper.append(this.getSentence(self.parent.parent.parent.parent.cp.slides,self.parent.parent.parent.parent.cp.currentSlideIndex))
  var checkBoxElementForWord = $wrapper.append(this.getSentence(self.parent.parent.parent.parent.cp.slides, this.parent.parent.parent.params.params.currIndex, this.parent.params.text));
  self.$item.appendTo($wrapper);
  self.container = self.$item.find('#' + this.id);
  (0, _globals.jQuery)(checkBoxElementForWord).on('change', function (event) {
    if ((0, _globals.jQuery)('#' + event.target.id).is(':checked')) {
      wordText = wordText + ' ' + event.target.value + ' ';
      (0, _globals.jQuery)('#' + event.target.id).attr('checked', true);
      this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
      this.$word.val(wordText.trim().replace(/  +/g, ' '));
      (0, _globals.jQuery)(this.$word).attr('checked', true);
      self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
      //WaveformInit.self2.setValue(H5PEditor.CuriousReader.findField("text",self2.parent.field.fields),"Sam-ple data")
    } else {
      (0, _globals.jQuery)('#' + event.target.id).attr('checked', false);
      var tempWordText = wordText.replace(event.target.value, '');
      wordText = tempWordText;
      this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
      self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
      (0, _globals.jQuery)(this.$word).attr('checked', false);
      this.$word.val(wordText.trim().replace(/  +/g, ' '));
    }
  });
  self.setValue(self.findField("text", self.parent.field.fields), "" + this.parent.params.text);
  self.init();
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.setId = function (id) {
  this.id = id;
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.validate = function () {
  // this.hide();
  // return (this.params !== undefined && this.params.length !== 0);
};

WaveformInit.prototype.getSentence = function (slides, slideIndex, prevData) {
  var sentenceWords = [];
  var splittedPrevData = prevData != undefined ? prevData.split(' ') : [];
  for (var i = 0; i < slides[slideIndex].elements.length; i++) {

    if (slides[slideIndex].elements[i].action.library.split(' ')[0] == "H5P.CRAdvancedText") {
      var checkBoxWord = '';
      sentenceWords = (0, _globals.jQuery)(slides[slideIndex].elements[i].action.params.text)[0].innerText.split(' ');
      for (var j = 0; j < sentenceWords.length; j++) {
        var def = splittedPrevData.indexOf(sentenceWords[j]) !== -1 ? true : false;
        if (sentenceWords[j].replace(/  +/g, ' ') != '') {
          if (def) {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + j + ' type="checkbox" value="' + sentenceWords[j] + '"checked>' + sentenceWords[j] + '</label>';
          } else {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + j + ' type="checkbox" value="' + sentenceWords[j] + '">' + sentenceWords[j] + '</label>';
          }
        }
      }
    }
  }
  return checkBoxWord;
};

WaveformInit.prototype.remove = function () {};
exports.default = WaveformInit;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Child = __webpack_require__(5);
var EventDispatcher = H5P.EventDispatcher;

/**
 * @class
 */
function Parent(constructor, parameters) {
  var self = this;
  EventDispatcher.call(self);

  self.children = [];

  /**
   * Update the internal indexes of the children.
   *
   * @private
   * @param {number} from Where to start
   */
  var updateIndexes = function updateIndexes(from) {
    for (var i = from; i < self.children.length; i++) {
      self.children[i].index = i;
    }
  };

  /**
   * Give a new child to this parent.
   *
   * @param {*} childParameters Launch parameters
   */
  self.addChild = function (childParameters, index) {
    if (index === undefined) {
      index = self.children.length;
    }

    // Create a new child with the current instance as its parent
    var instance = new Child(index, self);

    if (index === self.children.length) {
      // Added at the end
      self.children.push(instance);
    } else {
      // Inserted at a specific location
      self.children.splice(index, 0, instance);
      updateIndexes(index);
    }

    // Run original constructor
    constructor.call(instance, childParameters);

    return instance;
  };

  /**
   * Remova a new child from its parent.
   *
   * @param {number} index
   */
  self.removeChild = function (index) {
    // Remove from array
    self.children.splice(index, 1);

    // Update internal indexes
    updateIndexes(index);
  };

  /**
   * Move the child into a new position
   *
   * @param {number} oldIndex
   * @param {number} newIndex
   */
  self.moveChild = function (oldIndex, newIndex) {
    var child = self.children.splice(oldIndex, 1)[0];
    self.children.splice(newIndex, 0, child);

    updateIndexes(newIndex < oldIndex ? newIndex : oldIndex);
  };

  if (parameters) {
    for (var i = 0; i < parameters.length; i++) {
      self.addChild(parameters[i]);
    }
  }
}

Parent.prototype = Object.create(EventDispatcher.prototype);
Parent.prototype.constructor = Parent;

module.exports = Parent;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @class
 */
function Child(index, parent) {
  var self = this;

  self.index = index;
  self.parent = parent;
}

module.exports = Child;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var jQuery = exports.jQuery = H5P.jQuery;
var EventDispatcher = exports.EventDispatcher = H5P.EventDispatcher;
var JoubelUI = exports.JoubelUI = H5P.JoubelUI;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/var __webpack_modules__ = {

        /***/"./src/drawer.canvasentry.js":
        /*!***********************************!*\
          !*** ./src/drawer.canvasentry.js ***!
          \***********************************/
        /***/function srcDrawerCanvasentryJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _style = _interopRequireDefault(__webpack_require__( /*! ./util/style */"./src/util/style.js"));

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./util/get-id */"./src/util/get-id.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * The `CanvasEntry` class represents an element consisting of a wave `canvas`
           * and an (optional) progress wave `canvas`.
           *
           * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
           * render a waveform, depending on the zoom level.
           */
          var CanvasEntry = /*#__PURE__*/function () {
            function CanvasEntry() {
              _classCallCheck(this, CanvasEntry);

              /**
               * The wave node
               *
               * @type {HTMLCanvasElement}
               */
              this.wave = null;
              /**
               * The wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.waveCtx = null;
              /**
               * The (optional) progress wave node
               *
               * @type {HTMLCanvasElement}
               */

              this.progress = null;
              /**
               * The (optional) progress wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.progressCtx = null;
              /**
               * Start of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.start = 0;
              /**
               * End of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.end = 1;
              /**
               * Unique identifier for this entry
               *
               * @type {string}
               */

              this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
              /**
               * Canvas 2d context attributes
               *
               * @type {object}
               */

              this.canvasContextAttributes = {};
            }
            /**
             * Store the wave canvas element and create the 2D rendering context
             *
             * @param {HTMLCanvasElement} element The wave `canvas` element.
             */

            _createClass(CanvasEntry, [{
              key: "initWave",
              value: function initWave(element) {
                this.wave = element;
                this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Store the progress wave canvas element and create the 2D rendering
               * context
               *
               * @param {HTMLCanvasElement} element The progress wave `canvas` element.
               */

            }, {
              key: "initProgress",
              value: function initProgress(element) {
                this.progress = element;
                this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Update the dimensions
               *
               * @param {number} elementWidth Width of the entry
               * @param {number} totalWidth Total width of the multi canvas renderer
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(elementWidth, totalWidth, width, height) {
                // where the canvas starts and ends in the waveform, represented as a
                // decimal between 0 and 1
                this.start = this.wave.offsetLeft / totalWidth || 0;
                this.end = this.start + elementWidth / totalWidth; // set wave canvas dimensions

                this.wave.width = width;
                this.wave.height = height;
                var elementSize = {
                  width: elementWidth + 'px'
                };
                (0, _style.default)(this.wave, elementSize);

                if (this.hasProgressCanvas) {
                  // set progress canvas dimensions
                  this.progress.width = width;
                  this.progress.height = height;
                  (0, _style.default)(this.progress, elementSize);
                }
              }
              /**
               * Clear the wave and progress rendering contexts
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                // wave
                this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height); // progress

                if (this.hasProgressCanvas) {
                  this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
                }
              }
              /**
               * Set the fill styles for wave and progress
               *
               * @param {string} waveColor Fill color for the wave canvas
               * @param {?string} progressColor Fill color for the progress canvas
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(waveColor, progressColor) {
                this.waveCtx.fillStyle = waveColor;

                if (this.hasProgressCanvas) {
                  this.progressCtx.fillStyle = progressColor;
                }
              }
              /**
               * Set the canvas transforms for wave and progress
               *
               * @param {boolean} vertical Whether to render vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(vertical) {
                if (vertical) {
                  // Reflect the waveform across the line y = -x
                  this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);

                  if (this.hasProgressCanvas) {
                    this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);
                  }
                }
              }
              /**
               * Draw a rectangle for wave and progress
               *
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRects",
              value: function fillRects(x, y, width, height, radius) {
                this.fillRectToContext(this.waveCtx, x, y, width, height, radius);

                if (this.hasProgressCanvas) {
                  this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
                }
              }
              /**
               * Draw the actual rectangle on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRectToContext",
              value: function fillRectToContext(ctx, x, y, width, height, radius) {
                if (!ctx) {
                  return;
                }

                if (radius) {
                  this.drawRoundedRect(ctx, x, y, width, height, radius);
                } else {
                  ctx.fillRect(x, y, width, height);
                }
              }
              /**
               * Draw a rounded rectangle on Canvas
               *
               * @param {CanvasRenderingContext2D} ctx Canvas context
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               *
               * @return {void}
               * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
               */

            }, {
              key: "drawRoundedRect",
              value: function drawRoundedRect(ctx, x, y, width, height, radius) {
                if (height === 0) {
                  return;
                } // peaks are float values from -1 to 1. Use absolute height values in
                // order to correctly calculate rounded rectangle coordinates


                if (height < 0) {
                  height *= -1;
                  y -= height;
                }

                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Render the actual wave and progress lines
               *
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLines",
              value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
                this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);

                if (this.hasProgressCanvas) {
                  this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
                }
              }
              /**
               * Render the actual waveform line on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLineToContext",
              value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
                if (!ctx) {
                  return;
                }

                var length = peaks.length / 2;
                var first = Math.round(length * this.start); // use one more peak value to make sure we join peaks at ends -- unless,
                // of course, this is the last canvas

                var last = Math.round(length * this.end) + 1;
                var canvasStart = first;
                var canvasEnd = last;
                var scale = this.wave.width / (canvasEnd - canvasStart - 1); // optimization

                var halfOffset = halfH + offsetY;
                var absmaxHalf = absmax / halfH;
                ctx.beginPath();
                ctx.moveTo((canvasStart - first) * scale, halfOffset);
                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
                var i, peak, h;

                for (i = canvasStart; i < canvasEnd; i++) {
                  peak = peaks[2 * i] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
                } // draw the bottom edge going backwards, to make a single
                // closed hull to fill


                var j = canvasEnd - 1;

                for (j; j >= canvasStart; j--) {
                  peak = peaks[2 * j + 1] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
                }

                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Destroys this entry
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.waveCtx = null;
                this.wave = null;
                this.progressCtx = null;
                this.progress = null;
              }
              /**
               * Return image data of the wave `canvas` element
               *
               * When using a `type` of `'blob'`, this will return a `Promise` that
               * resolves with a `Blob` instance.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|Promise} When using the default `'dataURL'` `type` this
               * returns a data URL. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with a `Blob` instance.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                var _this = this;

                if (type === 'blob') {
                  return new Promise(function (resolve) {
                    _this.wave.toBlob(resolve, format, quality);
                  });
                } else if (type === 'dataURL') {
                  return this.wave.toDataURL(format, quality);
                }
              }
            }]);

            return CanvasEntry;
          }();

          exports.default = CanvasEntry;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.js":
        /*!***********************!*\
          !*** ./src/drawer.js ***!
          \***********************/
        /***/function srcDrawerJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * Parent class for renderers
           *
           * @extends {Observer}
           */
          var Drawer = /*#__PURE__*/function (_util$Observer) {
            _inherits(Drawer, _util$Observer);

            var _super = _createSuper(Drawer);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function Drawer(container, params) {
              var _this;

              _classCallCheck(this, Drawer);

              _this = _super.call(this);
              _this.container = util.withOrientation(container, params.vertical);
              /**
               * @type {WavesurferParams}
               */

              _this.params = params;
              /**
               * The width of the renderer
               * @type {number}
               */

              _this.width = 0;
              /**
               * The height of the renderer
               * @type {number}
               */

              _this.height = params.height * _this.params.pixelRatio;
              _this.lastPos = 0;
              /**
               * The `<wave>` element which is added to the container
               * @type {HTMLElement}
               */

              _this.wrapper = null;
              return _this;
            }
            /**
             * Alias of `util.style`
             *
             * @param {HTMLElement} el The element that the styles will be applied to
             * @param {Object} styles The map of propName: attribute, both are used as-is
             * @return {HTMLElement} el
             */

            _createClass(Drawer, [{
              key: "style",
              value: function style(el, styles) {
                return util.style(el, styles);
              }
              /**
               * Create the wrapper `<wave>` element, style it and set up the events for
               * interaction
               */

            }, {
              key: "createWrapper",
              value: function createWrapper() {
                this.wrapper = util.withOrientation(this.container.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.wrapper, {
                  display: 'block',
                  position: 'relative',
                  userSelect: 'none',
                  webkitUserSelect: 'none',
                  height: this.params.height + 'px'
                });

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: '100%',
                    overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
                    overflowY: 'hidden'
                  });
                }

                this.setupWrapperEvents();
              }
              /**
               * Handle click event
               *
               * @param {Event} e Click event
               * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
               * @return {number} Playback position from 0 to 1
               */

            }, {
              key: "handleEvent",
              value: function handleEvent(e, noPrevent) {
                !noPrevent && e.preventDefault();
                var clientX = util.withOrientation(e.targetTouches ? e.targetTouches[0] : e, this.params.vertical).clientX;
                var bbox = this.wrapper.getBoundingClientRect();
                var nominalWidth = this.width;
                var parentWidth = this.getWidth();
                var progressPixels = this.getProgressPixels(bbox, clientX);
                var progress;

                if (!this.params.fillParent && nominalWidth < parentWidth) {
                  progress = progressPixels * (this.params.pixelRatio / nominalWidth) || 0;
                } else {
                  progress = (progressPixels + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
                }

                return util.clamp(progress, 0, 1);
              }
            }, {
              key: "getProgressPixels",
              value: function getProgressPixels(wrapperBbox, clientX) {
                if (this.params.rtl) {
                  return wrapperBbox.right - clientX;
                } else {
                  return clientX - wrapperBbox.left;
                }
              }
            }, {
              key: "setupWrapperEvents",
              value: function setupWrapperEvents() {
                var _this2 = this;

                this.wrapper.addEventListener('click', function (e) {
                  var orientedEvent = util.withOrientation(e, _this2.params.vertical);
                  var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

                  if (scrollbarHeight !== 0) {
                    // scrollbar is visible.  Check if click was on it
                    var bbox = _this2.wrapper.getBoundingClientRect();

                    if (orientedEvent.clientY >= bbox.bottom - scrollbarHeight) {
                      // ignore mousedown as it was on the scrollbar
                      return;
                    }
                  }

                  if (_this2.params.interact) {
                    _this2.fireEvent('click', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('dblclick', function (e) {
                  if (_this2.params.interact) {
                    _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('scroll', function (e) {
                  return _this2.fireEvent('scroll', e);
                });
              }
              /**
               * Draw peaks on the canvas
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} length The width of the area that should be drawn
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawPeaks",
              value: function drawPeaks(peaks, length, start, end) {
                if (!this.setWidth(length)) {
                  this.clearWave();
                }

                this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
              }
              /**
               * Scroll to the beginning
               */

            }, {
              key: "resetScroll",
              value: function resetScroll() {
                if (this.wrapper !== null) {
                  this.wrapper.scrollLeft = 0;
                }
              }
              /**
               * Recenter the view-port at a certain percent of the waveform
               *
               * @param {number} percent Value from 0 to 1 on the waveform
               */

            }, {
              key: "recenter",
              value: function recenter(percent) {
                var position = this.wrapper.scrollWidth * percent;
                this.recenterOnPosition(position, true);
              }
              /**
               * Recenter the view-port on a position, either scroll there immediately or
               * in steps of 5 pixels
               *
               * @param {number} position X-offset in pixels
               * @param {boolean} immediate Set to true to immediately scroll somewhere
               */

            }, {
              key: "recenterOnPosition",
              value: function recenterOnPosition(position, immediate) {
                var scrollLeft = this.wrapper.scrollLeft;
                var half = ~~(this.wrapper.clientWidth / 2);
                var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
                var target = position - half;
                var offset = target - scrollLeft;

                if (maxScroll == 0) {
                  // no need to continue if scrollbar is not there
                  return;
                } // if the cursor is currently visible...


                if (!immediate && -half <= offset && offset < half) {
                  // set rate at which waveform is centered
                  var rate = this.params.autoCenterRate; // make rate depend on width of view and length of waveform

                  rate /= half;
                  rate *= maxScroll;
                  offset = Math.max(-rate, Math.min(rate, offset));
                  target = scrollLeft + offset;
                } // limit target to valid range (0 to maxScroll)


                target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

                if (target != scrollLeft) {
                  this.wrapper.scrollLeft = target;
                }
              }
              /**
               * Get the current scroll position in pixels
               *
               * @return {number} Horizontal scroll position in pixels
               */

            }, {
              key: "getScrollX",
              value: function getScrollX() {
                var x = 0;

                if (this.wrapper) {
                  var pixelRatio = this.params.pixelRatio;
                  x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
                  // scroll beyond the limits of the container
                  // Calculate and floor the scrollable extent to make sure an out
                  // of bounds value is not returned
                  // Ticket #1312

                  if (this.params.scrollParent) {
                    var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
                    x = Math.min(maxScroll, Math.max(0, x));
                  }
                }

                return x;
              }
              /**
               * Get the width of the container
               *
               * @return {number} The width of the container
               */

            }, {
              key: "getWidth",
              value: function getWidth() {
                return Math.round(this.container.clientWidth * this.params.pixelRatio);
              }
              /**
               * Set the width of the container
               *
               * @param {number} width The new width of the container
               * @return {boolean} Whether the width of the container was updated or not
               */

            }, {
              key: "setWidth",
              value: function setWidth(width) {
                if (this.width == width) {
                  return false;
                }

                this.width = width;

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: ''
                  });
                } else {
                  var newWidth = ~~(this.width / this.params.pixelRatio) + 'px';
                  this.style(this.wrapper, {
                    width: newWidth
                  });
                }

                this.updateSize();
                return true;
              }
              /**
               * Set the height of the container
               *
               * @param {number} height The new height of the container.
               * @return {boolean} Whether the height of the container was updated or not
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                if (height == this.height) {
                  return false;
                }

                this.height = height;
                this.style(this.wrapper, {
                  height: ~~(this.height / this.params.pixelRatio) + 'px'
                });
                this.updateSize();
                return true;
              }
              /**
               * Called by wavesurfer when progress should be rendered
               *
               * @param {number} progress From 0 to 1
               */

            }, {
              key: "progress",
              value: function progress(_progress) {
                var minPxDelta = 1 / this.params.pixelRatio;
                var pos = Math.round(_progress * this.width) * minPxDelta;

                if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
                  this.lastPos = pos;

                  if (this.params.scrollParent && this.params.autoCenter) {
                    var newPos = ~~(this.wrapper.scrollWidth * _progress);
                    this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
                  }

                  this.updateProgress(pos);
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.unAll();

                if (this.wrapper) {
                  if (this.wrapper.parentNode == this.container.domElement) {
                    this.container.removeChild(this.wrapper.domElement);
                  }

                  this.wrapper = null;
                }
              }
              /* Renderer-specific methods */

              /**
               * Called after cursor related params have changed.
               *
               * @abstract
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {}
              /**
               * Called when the size of the container changes so the renderer can adjust
               *
               * @abstract
               */

            }, {
              key: "updateSize",
              value: function updateSize() {}
              /**
               * Draw a waveform with bars
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {}
              /**
               * Draw a waveform
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {}
              /**
               * Clear the waveform
               *
               * @abstract
               */

            }, {
              key: "clearWave",
              value: function clearWave() {}
              /**
               * Render the new progress
               *
               * @abstract
               * @param {number} position X-Offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {}
            }]);

            return Drawer;
          }(util.Observer);

          exports.default = Drawer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.multicanvas.js":
        /*!***********************************!*\
          !*** ./src/drawer.multicanvas.js ***!
          \***********************************/
        /***/function srcDrawerMulticanvasJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer */"./src/drawer.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer2 = _interopRequireDefault(__webpack_require__( /*! ./drawer.canvasentry */"./src/drawer.canvasentry.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MultiCanvas renderer for wavesurfer. Is currently the default and sole
           * builtin renderer.
           *
           * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
           * on the zoom level.
           */
          var MultiCanvas = /*#__PURE__*/function (_Drawer) {
            _inherits(MultiCanvas, _Drawer);

            var _super = _createSuper(MultiCanvas);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function MultiCanvas(container, params) {
              var _this;

              _classCallCheck(this, MultiCanvas);

              _this = _super.call(this, container, params);
              /**
               * @type {number}
               */

              _this.maxCanvasWidth = params.maxCanvasWidth;
              /**
               * @type {number}
               */

              _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
              /**
               * Whether or not the progress wave is rendered. If the `waveColor`
               * and `progressColor` are the same color it is not.
               *
               * @type {boolean}
               */

              _this.hasProgressCanvas = params.waveColor != params.progressColor;
              /**
               * @type {number}
               */

              _this.halfPixel = 0.5 / params.pixelRatio;
              /**
               * List of `CanvasEntry` instances.
               *
               * @type {Array}
               */

              _this.canvases = [];
              /**
               * @type {HTMLElement}
               */

              _this.progressWave = null;
              /**
               * Class used to generate entries.
               *
               * @type {function}
               */

              _this.EntryClass = _drawer2.default;
              /**
               * Canvas 2d context attributes.
               *
               * @type {object}
               */

              _this.canvasContextAttributes = params.drawingContextAttributes;
              /**
               * Overlap added between entries to prevent vertical white stripes
               * between `canvas` elements.
               *
               * @type {number}
               */

              _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
              /**
               * The radius of the wave bars. Makes bars rounded
               *
               * @type {number}
               */

              _this.barRadius = params.barRadius || 0;
              /**
               * Whether to render the waveform vertically. Defaults to false.
               *
               * @type {boolean}
               */

              _this.vertical = params.vertical;
              return _this;
            }
            /**
             * Initialize the drawer
             */

            _createClass(MultiCanvas, [{
              key: "init",
              value: function init() {
                this.createWrapper();
                this.createElements();
              }
              /**
               * Create the canvas elements and style them
               *
               */

            }, {
              key: "createElements",
              value: function createElements() {
                this.progressWave = util.withOrientation(this.wrapper.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.progressWave, {
                  position: 'absolute',
                  zIndex: 3,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  overflow: 'hidden',
                  width: '0',
                  display: 'none',
                  boxSizing: 'border-box',
                  borderRightStyle: 'solid',
                  pointerEvents: 'none'
                });
                this.addCanvas();
                this.updateCursor();
              }
              /**
               * Update cursor style
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {
                this.style(this.progressWave, {
                  borderRightWidth: this.params.cursorWidth + 'px',
                  borderRightColor: this.params.cursorColor
                });
              }
              /**
               * Adjust to the updated size by adding or removing canvases
               */

            }, {
              key: "updateSize",
              value: function updateSize() {
                var _this2 = this;

                var totalWidth = Math.round(this.width / this.params.pixelRatio);
                var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap)); // add required canvases

                while (this.canvases.length < requiredCanvases) {
                  this.addCanvas();
                } // remove older existing canvases, if any


                while (this.canvases.length > requiredCanvases) {
                  this.removeCanvas();
                }

                var canvasWidth = this.maxCanvasWidth + this.overlap;
                var lastCanvas = this.canvases.length - 1;
                this.canvases.forEach(function (entry, i) {
                  if (i == lastCanvas) {
                    canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
                  }

                  _this2.updateDimensions(entry, canvasWidth, _this2.height);

                  entry.clearWave();
                });
              }
              /**
               * Add a canvas to the canvas list
               *
               */

            }, {
              key: "addCanvas",
              value: function addCanvas() {
                var entry = new this.EntryClass();
                entry.canvasContextAttributes = this.canvasContextAttributes;
                entry.hasProgressCanvas = this.hasProgressCanvas;
                entry.halfPixel = this.halfPixel;
                var leftOffset = this.maxCanvasElementWidth * this.canvases.length; // wave

                var wave = util.withOrientation(this.wrapper.appendChild(document.createElement('canvas')), this.params.vertical);
                this.style(wave, {
                  position: 'absolute',
                  zIndex: 2,
                  left: leftOffset + 'px',
                  top: 0,
                  bottom: 0,
                  height: '100%',
                  pointerEvents: 'none'
                });
                entry.initWave(wave); // progress

                if (this.hasProgressCanvas) {
                  var progress = util.withOrientation(this.progressWave.appendChild(document.createElement('canvas')), this.params.vertical);
                  this.style(progress, {
                    position: 'absolute',
                    left: leftOffset + 'px',
                    top: 0,
                    bottom: 0,
                    height: '100%'
                  });
                  entry.initProgress(progress);
                }

                this.canvases.push(entry);
              }
              /**
               * Pop single canvas from the list
               *
               */

            }, {
              key: "removeCanvas",
              value: function removeCanvas() {
                var lastEntry = this.canvases[this.canvases.length - 1]; // wave

                lastEntry.wave.parentElement.removeChild(lastEntry.wave.domElement); // progress

                if (this.hasProgressCanvas) {
                  lastEntry.progress.parentElement.removeChild(lastEntry.progress.domElement);
                } // cleanup


                if (lastEntry) {
                  lastEntry.destroy();
                  lastEntry = null;
                }

                this.canvases.pop();
              }
              /**
               * Update the dimensions of a canvas element
               *
               * @param {CanvasEntry} entry Target entry
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(entry, width, height) {
                var elementWidth = Math.round(width / this.params.pixelRatio);
                var totalWidth = Math.round(this.width / this.params.pixelRatio); // update canvas dimensions

                entry.updateDimensions(elementWidth, totalWidth, width, height); // style element

                this.style(this.progressWave, {
                  display: 'block'
                });
              }
              /**
               * Clear the whole multi-canvas
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                var _this3 = this;

                util.frame(function () {
                  _this3.canvases.forEach(function (entry) {
                    return entry.clearWave();
                  });
                })();
              }
              /**
               * Draw a waveform with bars
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0. Must be an integer.
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {
                var _this4 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
                  var absmax = _ref.absmax,
                      hasMinVals = _ref.hasMinVals,
                      height = _ref.height,
                      offsetY = _ref.offsetY,
                      halfH = _ref.halfH,
                      peaks = _ref.peaks,
                      ch = _ref.channelIndex;

                  // if drawBars was called within ws.empty we don't pass a start and
                  // don't want anything to happen
                  if (start === undefined) {
                    return;
                  } // Skip every other value if there are negatives.


                  var peakIndexScale = hasMinVals ? 2 : 1;
                  var length = peaks.length / peakIndexScale;
                  var bar = _this4.params.barWidth * _this4.params.pixelRatio;
                  var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
                  var step = bar + gap;
                  var scale = length / _this4.width;
                  var first = start;
                  var last = end;
                  var i = first;

                  for (i; i < last; i += step) {
                    var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
                    var h = Math.round(peak / absmax * halfH);
                    /* in case of silences, allow the user to specify that we
                     * always draw *something* (normally a 1px high bar) */

                    if (h == 0 && _this4.params.barMinHeight) {
                      h = _this4.params.barMinHeight;
                    }

                    _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius, ch);
                  }
                });
              }
              /**
               * Draw a waveform
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered (If this isn't set only a flat line is rendered)
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {
                var _this5 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
                  var absmax = _ref2.absmax,
                      hasMinVals = _ref2.hasMinVals,
                      height = _ref2.height,
                      offsetY = _ref2.offsetY,
                      halfH = _ref2.halfH,
                      peaks = _ref2.peaks,
                      channelIndex = _ref2.channelIndex;

                  if (!hasMinVals) {
                    var reflectedPeaks = [];
                    var len = peaks.length;
                    var i = 0;

                    for (i; i < len; i++) {
                      reflectedPeaks[2 * i] = peaks[i];
                      reflectedPeaks[2 * i + 1] = -peaks[i];
                    }

                    peaks = reflectedPeaks;
                  } // if drawWave was called within ws.empty we don't pass a start and
                  // end and simply want a flat line


                  if (start !== undefined) {
                    _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
                  } // always draw a median line


                  _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius, channelIndex);
                });
              }
              /**
               * Tell the canvas entries to render their portion of the waveform
               *
               * @param {number[]} peaks Peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               * @param {channelIndex} channelIndex The channel index of the line drawn
               */

            }, {
              key: "drawLine",
              value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
                var _this6 = this;

                var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                    waveColor = _ref3.waveColor,
                    progressColor = _ref3.progressColor;

                this.canvases.forEach(function (entry, i) {
                  _this6.setFillStyles(entry, waveColor, progressColor);

                  _this6.applyCanvasTransforms(entry, _this6.params.vertical);

                  entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
                });
              }
              /**
               * Draw a rectangle on the multi-canvas
               *
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               * @param {channelIndex} channelIndex The channel index of the bar drawn
               */

            }, {
              key: "fillRect",
              value: function fillRect(x, y, width, height, radius, channelIndex) {
                var startCanvas = Math.floor(x / this.maxCanvasWidth);
                var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
                var i = startCanvas;

                for (i; i < endCanvas; i++) {
                  var entry = this.canvases[i];
                  var leftOffset = i * this.maxCanvasWidth;
                  var intersection = {
                    x1: Math.max(x, i * this.maxCanvasWidth),
                    y1: y,
                    x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
                    y2: y + height
                  };

                  if (intersection.x1 < intersection.x2) {
                    var _ref4 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                        waveColor = _ref4.waveColor,
                        progressColor = _ref4.progressColor;

                    this.setFillStyles(entry, waveColor, progressColor);
                    this.applyCanvasTransforms(entry, this.params.vertical);
                    entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
                  }
                }
              }
              /**
               * Returns whether to hide the channel from being drawn based on params.
               *
               * @param {number} channelIndex The index of the current channel.
               * @returns {bool} True to hide the channel, false to draw.
               */

            }, {
              key: "hideChannel",
              value: function hideChannel(channelIndex) {
                return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
              }
              /**
               * Performs preparation tasks and calculations which are shared by `drawBars`
               * and `drawWave`
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
               * split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered. If this isn't set only a flat line is rendered
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @param {function} fn The render function to call, e.g. `drawWave`
               * @param {number} drawIndex The index of the current channel after filtering.
               * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
               * @returns {void}
               */

            }, {
              key: "prepareDraw",
              value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
                var _this7 = this;

                return util.frame(function () {
                  // Split channels and call this function with the channelIndex set
                  if (peaks[0] instanceof Array) {
                    var channels = peaks;

                    if (_this7.params.splitChannels) {
                      var filteredChannels = channels.filter(function (c, i) {
                        return !_this7.hideChannel(i);
                      });

                      if (!_this7.params.splitChannelsOptions.overlay) {
                        _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
                      }

                      var overallAbsMax;

                      if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
                        // calculate maximum peak across channels to use for normalization
                        overallAbsMax = util.max(channels.map(function (channelPeaks) {
                          return util.absMax(channelPeaks);
                        }));
                      }

                      return channels.forEach(function (channelPeaks, i) {
                        return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
                      });
                    }

                    peaks = channels[0];
                  } // Return and do not draw channel peaks if hidden.


                  if (_this7.hideChannel(channelIndex)) {
                    return;
                  } // calculate maximum modulation value, either from the barHeight
                  // parameter or if normalize=true from the largest value in the peak
                  // set


                  var absmax = 1 / _this7.params.barHeight;

                  if (_this7.params.normalize) {
                    absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
                  } // Bar wave draws the bottom only as a reflection of the top,
                  // so we don't need negative values


                  var hasMinVals = [].some.call(peaks, function (val) {
                    return val < 0;
                  });
                  var height = _this7.params.height * _this7.params.pixelRatio;
                  var halfH = height / 2;
                  var offsetY = height * drawIndex || 0; // Override offsetY if overlay is true

                  if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.overlay) {
                    offsetY = 0;
                  }

                  return fn({
                    absmax: absmax,
                    hasMinVals: hasMinVals,
                    height: height,
                    offsetY: offsetY,
                    halfH: halfH,
                    peaks: peaks,
                    channelIndex: channelIndex
                  });
                })();
              }
              /**
               * Set the fill styles for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {string} waveColor Wave color to draw this entry
               * @param {string} progressColor Progress color to draw this entry
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(entry) {
                var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
                var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
                entry.setFillStyles(waveColor, progressColor);
              }
              /**
               * Set the canvas transforms for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {boolean} vertical Whether to render the waveform vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(entry) {
                var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                entry.applyCanvasTransforms(vertical);
              }
              /**
               * Return image data of the multi-canvas
               *
               * When using a `type` of `'blob'`, this will return a `Promise`.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|string[]|Promise} When using the default `'dataURL'`
               * `type` this returns a single data URL or an array of data URLs,
               * one for each canvas. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with an array of `Blob` instances, one for each
               * canvas.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                if (type === 'blob') {
                  return Promise.all(this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  }));
                } else if (type === 'dataURL') {
                  var images = this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  });
                  return images.length > 1 ? images : images[0];
                }
              }
              /**
               * Render the new progress
               *
               * @param {number} position X-offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {
                this.style(this.progressWave, {
                  width: position + 'px'
                });
              }
            }]);

            return MultiCanvas;
          }(_drawer.default);

          exports.default = MultiCanvas;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement-webaudio.js":
        /*!**************************************!*\
          !*** ./src/mediaelement-webaudio.js ***!
          \**************************************/
        /***/function srcMediaelementWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
           * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
           * buffer the entire file in one request, and you still get the filtering and scripting functionality
           * of the webaudio API.
           * Note that in order to use range requests and prevent buffering, you must provide peak data.
           *
           * @since 3.2.0
           */
          var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
            _inherits(MediaElementWebAudio, _MediaElement);

            var _super = _createSuper(MediaElementWebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElementWebAudio(params) {
              var _this;

              _classCallCheck(this, MediaElementWebAudio);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /** @private */

              _this.sourceMediaElement = null;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElementWebAudio, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
              }
              /**
               * Private method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);

                this.createMediaElementSource(media);
              }
              /**
               * Create MediaElementSource node
               *
               * @since 3.2.0
               * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
               */

            }, {
              key: "createMediaElementSource",
              value: function createMediaElementSource(mediaElement) {
                this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
                this.sourceMediaElement.connect(this.analyser);
              }
            }, {
              key: "play",
              value: function play(start, end) {
                this.resumeAudioContext();
                return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);

                this.destroyWebAudio();
              }
            }]);

            return MediaElementWebAudio;
          }(_mediaelement.default);

          exports.default = MediaElementWebAudio;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement.js":
        /*!*****************************!*\
          !*** ./src/mediaelement.js ***!
          \*****************************/
        /***/function srcMediaelementJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElement backend
           */
          var MediaElement = /*#__PURE__*/function (_WebAudio) {
            _inherits(MediaElement, _WebAudio);

            var _super = _createSuper(MediaElement);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElement(params) {
              var _this;

              _classCallCheck(this, MediaElement);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /**
               * Initially a dummy media element to catch errors. Once `_load` is
               * called, this will contain the actual `HTMLMediaElement`.
               * @private
               */

              _this.media = {
                currentTime: 0,
                duration: 0,
                paused: true,
                playbackRate: 1,
                play: function play() {},
                pause: function pause() {},
                volume: 0
              };
              /** @private */

              _this.mediaType = params.mediaType.toLowerCase();
              /** @private */

              _this.elementPosition = params.elementPosition;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** @private */

              _this.volume = 1;
              /** @private */

              _this.isMuted = false;
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.onPlayEnd = null;
              /** @private */

              _this.mediaListeners = {};
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElement, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
              }
              /**
               * Attach event listeners to media element.
               */

            }, {
              key: "_setupMediaListeners",
              value: function _setupMediaListeners() {
                var _this2 = this;

                this.mediaListeners.error = function () {
                  _this2.fireEvent('error', 'Error loading media element');
                };

                this.mediaListeners.canplay = function () {
                  _this2.fireEvent('canplay');
                };

                this.mediaListeners.ended = function () {
                  _this2.fireEvent('finish');
                }; // listen to and relay play, pause and seeked events to enable
                // playback control from the external media element


                this.mediaListeners.play = function () {
                  _this2.fireEvent('play');
                };

                this.mediaListeners.pause = function () {
                  _this2.fireEvent('pause');
                };

                this.mediaListeners.seeked = function (event) {
                  _this2.fireEvent('seek');
                };

                this.mediaListeners.volumechange = function (event) {
                  _this2.isMuted = _this2.media.muted;

                  if (_this2.isMuted) {
                    _this2.volume = 0;
                  } else {
                    _this2.volume = _this2.media.volume;
                  }

                  _this2.fireEvent('volume');
                }; // reset event listeners


                Object.keys(this.mediaListeners).forEach(function (id) {
                  _this2.media.removeEventListener(id, _this2.mediaListeners[id]);

                  _this2.media.addEventListener(id, _this2.mediaListeners[id]);
                });
              }
              /**
               * Create a timer to provide a more precise `audioprocess` event.
               */

            }, {
              key: "createTimer",
              value: function createTimer() {
                var _this3 = this;

                var onAudioProcess = function onAudioProcess() {
                  if (_this3.isPaused()) {
                    return;
                  }

                  _this3.fireEvent('audioprocess', _this3.getCurrentTime()); // Call again in the next frame


                  util.frame(onAudioProcess)();
                };

                this.on('play', onAudioProcess); // Update the progress one more time to prevent it from being stuck in
                // case of lower framerates

                this.on('pause', function () {
                  _this3.fireEvent('audioprocess', _this3.getCurrentTime());
                });
              }
              /**
               * Create media element with url as its source,
               * and append to container element.
               *
               * @param {string} url Path to media file
               * @param {HTMLElement} container HTML element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `url` argument is not a valid media
               * element.
               */

            }, {
              key: "load",
              value: function load(url, container, peaks, preload) {
                var media = document.createElement(this.mediaType);
                media.controls = this.params.mediaControls;
                media.autoplay = this.params.autoplay || false;
                media.preload = preload == null ? 'auto' : preload;
                media.src = url;
                media.style.width = '100%';
                var prevMedia = container.querySelector(this.mediaType);

                if (prevMedia) {
                  container.removeChild(prevMedia);
                }

                container.appendChild(media);

                this._load(media, peaks, preload);
              }
              /**
               * Load existing media element.
               *
               * @param {HTMLMediaElement} elt HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               */

            }, {
              key: "loadElt",
              value: function loadElt(elt, peaks) {
                elt.controls = this.params.mediaControls;
                elt.autoplay = this.params.autoplay || false;

                this._load(elt, peaks, elt.preload);
              }
              /**
               * Method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `media` argument is not a valid media
               * element.
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                // verify media element is valid
                if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
                  throw new Error('media parameter is not a valid media element');
                } // load must be called manually on iOS, otherwise peaks won't draw
                // until a user interaction triggers load --> 'ready' event
                //
                // note that we avoid calling media.load here when given peaks and preload == 'none'
                // as this almost always triggers some browser fetch of the media.


                if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
                  // Resets the media element and restarts the media resource. Any
                  // pending events are discarded. How much media data is fetched is
                  // still affected by the preload attribute.
                  media.load();
                }

                this.media = media;

                this._setupMediaListeners();

                this.peaks = peaks;
                this.onPlayEnd = null;
                this.buffer = null;
                this.isMuted = media.muted;
                this.setPlaybackRate(this.playbackRate);
                this.setVolume(this.volume);
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Media paused or not
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return !this.media || this.media.paused;
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                var duration = (this.buffer || this.media).duration;

                if (duration >= Infinity) {
                  // streaming audio
                  duration = this.media.seekable.end(0);
                }

                return duration;
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} Current time
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.media && this.media.currentTime;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Current position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.getCurrentTime() / this.getDuration() || 0;
              }
              /**
               * Get the audio source playback rate.
               *
               * @return {number} Playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate || this.media.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value Playback rate
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.media.playbackRate = this.playbackRate;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               */

            }, {
              key: "seekTo",
              value: function seekTo(start) {
                if (start != null) {
                  this.media.currentTime = start;
                }

                this.clearPlayEnd();
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop, relative to the beginning of a clip.
               * @emits MediaElement#play
               * @return {Promise} Result
               */

            }, {
              key: "play",
              value: function play(start, end) {
                this.seekTo(start);
                var promise = this.media.play();
                end && this.setPlayEnd(end);
                return promise;
              }
              /**
               * Pauses the loaded audio.
               *
               * @emits MediaElement#pause
               * @return {Promise} Result
               */

            }, {
              key: "pause",
              value: function pause() {
                var promise;

                if (this.media) {
                  promise = this.media.pause();
                }

                this.clearPlayEnd();
                return promise;
              }
              /**
               * Set the play end
               *
               * @param {number} end Where to end
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                var _this4 = this;

                this.clearPlayEnd();

                this._onPlayEnd = function (time) {
                  if (time >= end) {
                    _this4.pause();

                    _this4.seekTo(end);
                  }
                };

                this.on('audioprocess', this._onPlayEnd);
              }
              /** @private */

            }, {
              key: "clearPlayEnd",
              value: function clearPlayEnd() {
                if (this._onPlayEnd) {
                  this.un('audioprocess', this._onPlayEnd);
                  this._onPlayEnd = null;
                }
              }
              /**
               * Compute the max and min value of the waveform when broken into
               * <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
               * arrays of peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.buffer) {
                  return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
                }

                return this.peaks || [];
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  if (!this.media.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  return this.media.setSinkId(deviceId);
                }

                return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.volume;
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.volume = value; // no need to change when it's already at that volume

                if (this.media.volume !== this.volume) {
                  this.media.volume = this.volume;
                }
              }
              /**
               * Enable or disable muted audio
               *
               * @since 4.0.0
               * @param {boolean} muted Specify `true` to mute audio.
               */

            }, {
              key: "setMute",
              value: function setMute(muted) {
                // This causes a volume change to be emitted too through the
                // volumechange event listener.
                this.isMuted = this.media.muted = muted;
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                var _this5 = this;

                this.pause();
                this.unAll();
                this.destroyed = true; // cleanup media event listeners

                Object.keys(this.mediaListeners).forEach(function (id) {
                  if (_this5.media) {
                    _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
                  }
                });

                if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
                  this.media.parentNode.removeChild(this.media);
                }

                this.media = null;
              }
            }]);

            return MediaElement;
          }(_webaudio.default);

          exports.default = MediaElement;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/peakcache.js":
        /*!**************************!*\
          !*** ./src/peakcache.js ***!
          \**************************/
        /***/function srcPeakcacheJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Caches the decoded peaks data to improve rendering speed for large audio
           *
           * Is used if the option parameter `partialRender` is set to `true`
           */
          var PeakCache = /*#__PURE__*/function () {
            /**
             * Instantiate cache
             */
            function PeakCache() {
              _classCallCheck(this, PeakCache);

              this.clearPeakCache();
            }
            /**
             * Empty the cache
             */

            _createClass(PeakCache, [{
              key: "clearPeakCache",
              value: function clearPeakCache() {
                /**
                 * Flat array with entries that are always in pairs to mark the
                 * beginning and end of each subrange.  This is a convenience so we can
                 * iterate over the pairs for easy set difference operations.
                 * @private
                 */
                this.peakCacheRanges = [];
                /**
                 * Length of the entire cachable region, used for resetting the cache
                 * when this changes (zoom events, for instance).
                 * @private
                 */

                this.peakCacheLength = -1;
              }
              /**
               * Add a range of peaks to the cache
               *
               * @param {number} length The length of the range
               * @param {number} start The x offset of the start of the range
               * @param {number} end The x offset of the end of the range
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "addRangeToPeakCache",
              value: function addRangeToPeakCache(length, start, end) {
                if (length != this.peakCacheLength) {
                  this.clearPeakCache();
                  this.peakCacheLength = length;
                } // Return ranges that weren't in the cache before the call.


                var uncachedRanges = [];
                var i = 0; // Skip ranges before the current start.

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
                  i++;
                } // If |i| is even, |start| falls after an existing range.  Otherwise,
                // |start| falls between an existing range, and the uncached region
                // starts when we encounter the next node in |peakCacheRanges| or
                // |end|, whichever comes first.


                if (i % 2 == 0) {
                  uncachedRanges.push(start);
                }

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
                  uncachedRanges.push(this.peakCacheRanges[i]);
                  i++;
                } // If |i| is even, |end| is after all existing ranges.


                if (i % 2 == 0) {
                  uncachedRanges.push(end);
                } // Filter out the 0-length ranges.


                uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Merge the two ranges together, uncachedRanges will either contain
                // wholly new points, or duplicates of points in peakCacheRanges.  If
                // duplicates are detected, remove both and extend the range.

                this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
                this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
                  return a - b;
                }).filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Push the uncached ranges into an array of arrays for ease of
                // iteration in the functions that call this.

                var uncachedRangePairs = [];

                for (i = 0; i < uncachedRanges.length; i += 2) {
                  uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
                }

                return uncachedRangePairs;
              }
              /**
               * For testing
               *
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "getCacheRanges",
              value: function getCacheRanges() {
                var peakCacheRangePairs = [];
                var i;

                for (i = 0; i < this.peakCacheRanges.length; i += 2) {
                  peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
                }

                return peakCacheRangePairs;
              }
            }]);

            return PeakCache;
          }();

          exports.default = PeakCache;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/absMax.js":
        /*!****************************!*\
          !*** ./src/util/absMax.js ***!
          \****************************/
        /***/function srcUtilAbsMaxJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = absMax;

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Get the largest absolute value in an array
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
           * @since 4.3.0
           */
          function absMax(values) {
            var max = (0, _max.default)(values);
            var min = (0, _min.default)(values);
            return -min > max ? -min : max;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/clamp.js":
        /*!***************************!*\
          !*** ./src/util/clamp.js ***!
          \***************************/
        /***/function srcUtilClampJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = clamp;

          /**
           * Returns a number limited to the given range.
           *
           * @param {number} val The number to be limited to a range
           * @param {number} min The lower boundary of the limit range
           * @param {number} max The upper boundary of the limit range
           * @returns {number} A number in the range [min, max]
           */
          function clamp(val, min, max) {
            return Math.min(Math.max(min, val), max);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/fetch.js":
        /*!***************************!*\
          !*** ./src/util/fetch.js ***!
          \***************************/
        /***/function srcUtilFetchJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = fetchFile;

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          var ProgressHandler = /*#__PURE__*/function () {
            /**
             * Instantiate ProgressHandler
             *
             * @param {Observer} instance The `fetchFile` observer instance.
             * @param {Number} contentLength Content length.
             * @param {Response} response Response object.
             */
            function ProgressHandler(instance, contentLength, response) {
              _classCallCheck(this, ProgressHandler);

              this.instance = instance;
              this.instance._reader = response.body.getReader();
              this.total = parseInt(contentLength, 10);
              this.loaded = 0;
            }
            /**
             * A method that is called once, immediately after the `ReadableStream``
             * is constructed.
             *
             * @param {ReadableStreamDefaultController} controller Controller instance
             *     used to control the stream.
             */

            _createClass(ProgressHandler, [{
              key: "start",
              value: function start(controller) {
                var _this = this;

                var read = function read() {
                  // instance._reader.read() returns a promise that resolves
                  // when a value has been received
                  _this.instance._reader.read().then(function (_ref) {
                    var done = _ref.done,
                        value = _ref.value;

                    // result objects contain two properties:
                    // done  - true if the stream has already given you all its data.
                    // value - some data. Always undefined when done is true.
                    if (done) {
                      // ensure onProgress called when content-length=0
                      if (_this.total === 0) {
                        _this.instance.onProgress.call(_this.instance, {
                          loaded: _this.loaded,
                          total: _this.total,
                          lengthComputable: false
                        });
                      } // no more data needs to be consumed, close the stream


                      controller.close();
                      return;
                    }

                    _this.loaded += value.byteLength;

                    _this.instance.onProgress.call(_this.instance, {
                      loaded: _this.loaded,
                      total: _this.total,
                      lengthComputable: !(_this.total === 0)
                    }); // enqueue the next data chunk into our target stream


                    controller.enqueue(value);
                    read();
                  }).catch(function (error) {
                    controller.error(error);
                  });
                };

                read();
              }
            }]);

            return ProgressHandler;
          }();
          /**
           * Load a file using `fetch`.
           *
           * @param {object} options Request options to use. See example below.
           * @returns {Observer} Observer instance
           * @example
           * // default options
           * let options = {
           *     url: undefined,
           *     method: 'GET',
           *     mode: 'cors',
           *     credentials: 'same-origin',
           *     cache: 'default',
           *     responseType: 'json',
           *     requestHeaders: [],
           *     redirect: 'follow',
           *     referrer: 'client'
           * };
           *
           * // override some options
           * options.url = '../media/demo.wav';
          
           * // available types: 'arraybuffer', 'blob', 'json' or 'text'
           * options.responseType = 'arraybuffer';
           *
           * // make fetch call
           * let request = util.fetchFile(options);
           *
           * // listen for events
           * request.on('progress', e => {
           *     console.log('progress', e);
           * });
           *
           * request.on('success', data => {
           *     console.log('success!', data);
           * });
           *
           * request.on('error', e => {
           *     console.warn('fetchFile error: ', e);
           * });
           */

          function fetchFile(options) {
            if (!options) {
              throw new Error('fetch options missing');
            } else if (!options.url) {
              throw new Error('fetch url missing');
            }

            var instance = new _observer.default();
            var fetchHeaders = new Headers();
            var fetchRequest = new Request(options.url); // add ability to abort

            instance.controller = new AbortController(); // check if headers have to be added

            if (options && options.requestHeaders) {
              // add custom request headers
              options.requestHeaders.forEach(function (header) {
                fetchHeaders.append(header.key, header.value);
              });
            } // parse fetch options


            var responseType = options.responseType || 'json';
            var fetchOptions = {
              method: options.method || 'GET',
              headers: fetchHeaders,
              mode: options.mode || 'cors',
              credentials: options.credentials || 'same-origin',
              cache: options.cache || 'default',
              redirect: options.redirect || 'follow',
              referrer: options.referrer || 'client',
              signal: instance.controller.signal
            };
            fetch(fetchRequest, fetchOptions).then(function (response) {
              // store response reference
              instance.response = response;
              var progressAvailable = true;

              if (!response.body) {
                // ReadableStream is not yet supported in this browser
                // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
                progressAvailable = false;
              } // Server must send CORS header "Access-Control-Expose-Headers: content-length"


              var contentLength = response.headers.get('content-length');

              if (contentLength === null) {
                // Content-Length server response header missing.
                // Don't evaluate download progress if we can't compare against a total size
                // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
                progressAvailable = false;
              }

              if (!progressAvailable) {
                // not able to check download progress so skip it
                return response;
              } // fire progress event when during load


              instance.onProgress = function (e) {
                instance.fireEvent('progress', e);
              };

              return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
            }).then(function (response) {
              var errMsg;

              if (response.ok) {
                switch (responseType) {
                  case 'arraybuffer':
                    return response.arrayBuffer();

                  case 'json':
                    return response.json();

                  case 'blob':
                    return response.blob();

                  case 'text':
                    return response.text();

                  default:
                    errMsg = 'Unknown responseType: ' + responseType;
                    break;
                }
              }

              if (!errMsg) {
                errMsg = 'HTTP error status: ' + response.status;
              }

              throw new Error(errMsg);
            }).then(function (response) {
              instance.fireEvent('success', response);
            }).catch(function (error) {
              instance.fireEvent('error', error);
            }); // return the fetch request

            instance.fetchRequest = fetchRequest;
            return instance;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/frame.js":
        /*!***************************!*\
          !*** ./src/util/frame.js ***!
          \***************************/
        /***/function srcUtilFrameJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = frame;

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Create a function which will be called at the next requestAnimationFrame
           * cycle
           *
           * @param {function} func The function to call
           *
           * @return {func} The function wrapped within a requestAnimationFrame
           */
          function frame(func) {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return (0, _requestAnimationFrame.default)(function () {
                return func.apply(void 0, args);
              });
            };
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/get-id.js":
        /*!****************************!*\
          !*** ./src/util/get-id.js ***!
          \****************************/
        /***/function srcUtilGetIdJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = getId;

          /**
           * Get a random prefixed ID
           *
           * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
           * @returns {String} Random prefixed ID
           * @example
           * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
           *
           * let prefix = 'foo-';
           * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
           */
          function getId(prefix) {
            if (prefix === undefined) {
              prefix = 'wavesurfer_';
            }

            return prefix + Math.random().toString(32).substring(2);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/index.js":
        /*!***************************!*\
          !*** ./src/util/index.js ***!
          \***************************/
        /***/function srcUtilIndexJs(__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          Object.defineProperty(exports, "getId", {
            enumerable: true,
            get: function get() {
              return _getId.default;
            }
          });
          Object.defineProperty(exports, "max", {
            enumerable: true,
            get: function get() {
              return _max.default;
            }
          });
          Object.defineProperty(exports, "min", {
            enumerable: true,
            get: function get() {
              return _min.default;
            }
          });
          Object.defineProperty(exports, "absMax", {
            enumerable: true,
            get: function get() {
              return _absMax.default;
            }
          });
          Object.defineProperty(exports, "Observer", {
            enumerable: true,
            get: function get() {
              return _observer.default;
            }
          });
          Object.defineProperty(exports, "style", {
            enumerable: true,
            get: function get() {
              return _style.default;
            }
          });
          Object.defineProperty(exports, "requestAnimationFrame", {
            enumerable: true,
            get: function get() {
              return _requestAnimationFrame.default;
            }
          });
          Object.defineProperty(exports, "frame", {
            enumerable: true,
            get: function get() {
              return _frame.default;
            }
          });
          Object.defineProperty(exports, "debounce", {
            enumerable: true,
            get: function get() {
              return _debounce.default;
            }
          });
          Object.defineProperty(exports, "preventClick", {
            enumerable: true,
            get: function get() {
              return _preventClick.default;
            }
          });
          Object.defineProperty(exports, "fetchFile", {
            enumerable: true,
            get: function get() {
              return _fetch.default;
            }
          });
          Object.defineProperty(exports, "clamp", {
            enumerable: true,
            get: function get() {
              return _clamp.default;
            }
          });
          Object.defineProperty(exports, "withOrientation", {
            enumerable: true,
            get: function get() {
              return _orientation.default;
            }
          });

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./get-id */"./src/util/get-id.js"));

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          var _absMax = _interopRequireDefault(__webpack_require__( /*! ./absMax */"./src/util/absMax.js"));

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          var _style = _interopRequireDefault(__webpack_require__( /*! ./style */"./src/util/style.js"));

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          var _frame = _interopRequireDefault(__webpack_require__( /*! ./frame */"./src/util/frame.js"));

          var _debounce = _interopRequireDefault(__webpack_require__( /*! debounce */"./node_modules/debounce/index.js"));

          var _preventClick = _interopRequireDefault(__webpack_require__( /*! ./prevent-click */"./src/util/prevent-click.js"));

          var _fetch = _interopRequireDefault(__webpack_require__( /*! ./fetch */"./src/util/fetch.js"));

          var _clamp = _interopRequireDefault(__webpack_require__( /*! ./clamp */"./src/util/clamp.js"));

          var _orientation = _interopRequireDefault(__webpack_require__( /*! ./orientation */"./src/util/orientation.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /***/
        },

        /***/"./src/util/max.js":
        /*!*************************!*\
          !*** ./src/util/max.js ***!
          \*************************/
        /***/function srcUtilMaxJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = max;

          /**
           * Get the largest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([1, 2, 3])); // logs 3
           */
          function max(values) {
            var largest = -Infinity;
            Object.keys(values).forEach(function (i) {
              if (values[i] > largest) {
                largest = values[i];
              }
            });
            return largest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/min.js":
        /*!*************************!*\
          !*** ./src/util/min.js ***!
          \*************************/
        /***/function srcUtilMinJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = min;

          /**
           * Get the smallest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Smallest number found
           * @example console.log(min([1, 2, 3])); // logs 1
           */
          function min(values) {
            var smallest = Number(Infinity);
            Object.keys(values).forEach(function (i) {
              if (values[i] < smallest) {
                smallest = values[i];
              }
            });
            return smallest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/observer.js":
        /*!******************************!*\
          !*** ./src/util/observer.js ***!
          \******************************/
        /***/function srcUtilObserverJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} ListenerDescriptor
           * @property {string} name The name of the event
           * @property {function} callback The callback
           * @property {function} un The function to call to remove the listener
           */

          /**
           * Observer class
           */
          var Observer = /*#__PURE__*/function () {
            /**
             * Instantiate Observer
             */
            function Observer() {
              _classCallCheck(this, Observer);

              /**
               * @private
               * @todo Initialise the handlers here already and remove the conditional
               * assignment in `on()`
               */
              this._disabledEventEmissions = [];
              this.handlers = null;
            }
            /**
             * Attach a handler function for an event.
             *
             * @param {string} event Name of the event to listen to
             * @param {function} fn The callback to trigger when the event is fired
             * @return {ListenerDescriptor} The event descriptor
             */

            _createClass(Observer, [{
              key: "on",
              value: function on(event, fn) {
                var _this = this;

                if (!this.handlers) {
                  this.handlers = {};
                }

                var handlers = this.handlers[event];

                if (!handlers) {
                  handlers = this.handlers[event] = [];
                }

                handlers.push(fn); // Return an event descriptor

                return {
                  name: event,
                  callback: fn,
                  un: function un(e, fn) {
                    return _this.un(e, fn);
                  }
                };
              }
              /**
               * Remove an event handler.
               *
               * @param {string} event Name of the event the listener that should be
               * removed listens to
               * @param {function} fn The callback that should be removed
               */

            }, {
              key: "un",
              value: function un(event, fn) {
                if (!this.handlers) {
                  return;
                }

                var handlers = this.handlers[event];
                var i;

                if (handlers) {
                  if (fn) {
                    for (i = handlers.length - 1; i >= 0; i--) {
                      if (handlers[i] == fn) {
                        handlers.splice(i, 1);
                      }
                    }
                  } else {
                    handlers.length = 0;
                  }
                }
              }
              /**
               * Remove all event handlers.
               */

            }, {
              key: "unAll",
              value: function unAll() {
                this.handlers = null;
              }
              /**
               * Attach a handler to an event. The handler is executed at most once per
               * event type.
               *
               * @param {string} event The event to listen to
               * @param {function} handler The callback that is only to be called once
               * @return {ListenerDescriptor} The event descriptor
               */

            }, {
              key: "once",
              value: function once(event, handler) {
                var _this2 = this;

                var fn = function fn() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  /*  eslint-disable no-invalid-this */
                  handler.apply(_this2, args);
                  /*  eslint-enable no-invalid-this */

                  setTimeout(function () {
                    _this2.un(event, fn);
                  }, 0);
                };

                return this.on(event, fn);
              }
              /**
               * Disable firing a list of events by name. When specified, event handlers for any event type
               * passed in here will not be called.
               *
               * @since 4.0.0
               * @param {string[]} eventNames an array of event names to disable emissions for
               * @example
               * // disable seek and interaction events
               * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
               */

            }, {
              key: "setDisabledEventEmissions",
              value: function setDisabledEventEmissions(eventNames) {
                this._disabledEventEmissions = eventNames;
              }
              /**
               * plugins borrow part of this class without calling the constructor,
               * so we have to be careful about _disabledEventEmissions
               */

            }, {
              key: "_isDisabledEventEmission",
              value: function _isDisabledEventEmission(event) {
                return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
              }
              /**
               * Manually fire an event
               *
               * @param {string} event The event to fire manually
               * @param {...any} args The arguments with which to call the listeners
               */

            }, {
              key: "fireEvent",
              value: function fireEvent(event) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }

                if (!this.handlers || this._isDisabledEventEmission(event)) {
                  return;
                }

                var handlers = this.handlers[event];
                handlers && handlers.forEach(function (fn) {
                  fn.apply(void 0, args);
                });
              }
            }]);

            return Observer;
          }();

          exports.default = Observer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/orientation.js":
        /*!*********************************!*\
          !*** ./src/util/orientation.js ***!
          \*********************************/
        /***/function srcUtilOrientationJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = withOrientation;
          var verticalPropMap = {
            width: 'height',
            height: 'width',
            overflowX: 'overflowY',
            overflowY: 'overflowX',
            clientWidth: 'clientHeight',
            clientHeight: 'clientWidth',
            clientX: 'clientY',
            clientY: 'clientX',
            scrollWidth: 'scrollHeight',
            scrollLeft: 'scrollTop',
            offsetLeft: 'offsetTop',
            offsetTop: 'offsetLeft',
            offsetHeight: 'offsetWidth',
            offsetWidth: 'offsetHeight',
            left: 'top',
            right: 'bottom',
            top: 'left',
            bottom: 'right',
            borderRightStyle: 'borderBottomStyle',
            borderRightWidth: 'borderBottomWidth',
            borderRightColor: 'borderBottomColor'
          };
          /**
           * Convert a horizontally-oriented property name to a vertical one.
           *
           * @param {string} prop A property name
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {string} prop, converted appropriately
           */

          function mapProp(prop, vertical) {
            if (Object.prototype.hasOwnProperty.call(verticalPropMap, prop)) {
              return vertical ? verticalPropMap[prop] : prop;
            } else {
              return prop;
            }
          }

          var isProxy = Symbol("isProxy");
          /**
           * Returns an appropriately oriented object based on vertical.
           * If vertical is true, attribute getting and setting will be mapped through
           * verticalPropMap, so that e.g. getting the object's .width will give its
           * .height instead.
           * Certain methods of an oriented object will return oriented objects as well.
           * Oriented objects can't be added to the DOM directly since they are Proxy objects
           * and thus fail typechecks. Use domElement to get the actual element for this.
           *
           * @param {object} target The object to be wrapped and oriented
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {Proxy} An oriented object with attr translation via verticalAttrMap
           * @since 5.0.0
           */

          function withOrientation(target, vertical) {
            if (target[isProxy]) {
              return target;
            } else {
              return new Proxy(target, {
                get: function get(obj, prop, receiver) {
                  if (prop === isProxy) {
                    return true;
                  } else if (prop === 'domElement') {
                    return obj;
                  } else if (prop === 'style') {
                    return withOrientation(obj.style, vertical);
                  } else if (prop === 'canvas') {
                    return withOrientation(obj.canvas, vertical);
                  } else if (prop === 'getBoundingClientRect') {
                    return function () {
                      return withOrientation(obj.getBoundingClientRect.apply(obj, arguments), vertical);
                    };
                  } else if (prop === 'getContext') {
                    return function () {
                      return withOrientation(obj.getContext.apply(obj, arguments), vertical);
                    };
                  } else {
                    var value = obj[mapProp(prop, vertical)];
                    return typeof value == 'function' ? value.bind(obj) : value;
                  }
                },
                set: function set(obj, prop, value) {
                  obj[mapProp(prop, vertical)] = value;
                  return true;
                }
              });
            }
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/prevent-click.js":
        /*!***********************************!*\
          !*** ./src/util/prevent-click.js ***!
          \***********************************/
        /***/function srcUtilPreventClickJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = preventClick;

          /**
           * Stops propagation of click event and removes event listener
           *
           * @private
           * @param {object} event The click event
           */
          function preventClickHandler(event) {
            event.stopPropagation();
            document.body.removeEventListener('click', preventClickHandler, true);
          }
          /**
           * Starts listening for click event and prevent propagation
           *
           * @param {object} values Values
           */

          function preventClick(values) {
            document.body.addEventListener('click', preventClickHandler, true);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/request-animation-frame.js":
        /*!*********************************************!*\
          !*** ./src/util/request-animation-frame.js ***!
          \*********************************************/
        /***/function srcUtilRequestAnimationFrameJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          /* eslint-disable valid-jsdoc */

          /**
           * Returns the `requestAnimationFrame` function for the browser, or a shim with
           * `setTimeout` if the function is not found
           *
           * @return {function} Available `requestAnimationFrame` function for the browser
           */
          var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
            return setTimeout(callback, 1000 / 60);
          }).bind(window);

          exports.default = _default;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/style.js":
        /*!***************************!*\
          !*** ./src/util/style.js ***!
          \***************************/
        /***/function srcUtilStyleJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = style;

          /**
           * Apply a map of styles to an element
           *
           * @param {HTMLElement} el The element that the styles will be applied to
           * @param {Object} styles The map of propName: attribute, both are used as-is
           *
           * @return {HTMLElement} el
           */
          function style(el, styles) {
            Object.keys(styles).forEach(function (prop) {
              if (el.style[prop] !== styles[prop]) {
                el.style[prop] = styles[prop];
              }
            });
            return el;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/wavesurfer.js":
        /*!***************************!*\
          !*** ./src/wavesurfer.js ***!
          \***************************/
        /***/function srcWavesurferJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer.multicanvas */"./src/drawer.multicanvas.js"));

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          var _peakcache = _interopRequireDefault(__webpack_require__( /*! ./peakcache */"./src/peakcache.js"));

          var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__( /*! ./mediaelement-webaudio */"./src/mediaelement-webaudio.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /*
           * This work is licensed under a BSD-3-Clause License.
           */

          /** @external {HTMLElement} https://developer.mozilla.org/en/docs/Web/API/HTMLElement */

          /** @external {OfflineAudioContext} https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext */

          /** @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File */

          /** @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob */

          /** @external {CanvasRenderingContext2D} https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D */

          /** @external {MediaStreamConstraints} https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints */

          /** @external {AudioNode} https://developer.mozilla.org/de/docs/Web/API/AudioNode */

          /**
           * @typedef {Object} WavesurferParams
           * @property {AudioContext} audioContext=null Use your own previously
           * initialized AudioContext or leave blank.
           * @property {number} audioRate=1 Speed at which to play audio. Lower number is
           * slower.
           * @property {ScriptProcessorNode} audioScriptProcessor=null Use your own previously
           * initialized ScriptProcessorNode or leave blank.
           * @property {boolean} autoCenter=true If a scrollbar is present, center the
           * waveform on current progress
           * @property {number} autoCenterRate=5 If autoCenter is active, rate at which the
           * waveform is centered
           * @property {boolean} autoCenterImmediately=false If autoCenter is active, immediately
           * center waveform on current progress
           * @property {string} backend='WebAudio' `'WebAudio'|'MediaElement'|'MediaElementWebAudio'` In most cases
           * you don't have to set this manually. MediaElement is a fallback for unsupported browsers.
           * MediaElementWebAudio allows to use WebAudio API also with big audio files, loading audio like with
           * MediaElement backend (HTML5 audio tag). You have to use the same methods of MediaElement backend for loading and
           * playback, giving also peaks, so the audio data are not decoded. In this way you can use WebAudio features, like filters,
           * also with audio with big duration. For example:
           * ` wavesurfer.load(url | HTMLMediaElement, peaks, preload, duration);
           *   wavesurfer.play();
           *   wavesurfer.setFilter(customFilter);
           * `
           * @property {string} backgroundColor=null Change background color of the
           * waveform container.
           * @property {number} barHeight=1 The height of the wave bars.
           * @property {number} barRadius=0 The radius of the wave bars. Makes bars rounded
           * @property {number} barGap=null The optional spacing between bars of the wave,
           * if not provided will be calculated in legacy format.
           * @property {number} barWidth=null Draw the waveform using bars.
           * @property {number} barMinHeight=null If specified, draw at least a bar of this height,
           * eliminating waveform gaps
           * @property {boolean} closeAudioContext=false Close and nullify all audio
           * contexts when the destroy method is called.
           * @property {!string|HTMLElement} container CSS selector or HTML element where
           * the waveform should be drawn. This is the only required parameter.
           * @property {string} cursorColor='#333' The fill color of the cursor indicating
           * the playhead position.
           * @property {number} cursorWidth=1 Measured in pixels.
           * @property {object} drawingContextAttributes={desynchronized: false} Drawing context
           * attributes.
           * @property {number} duration=null Optional audio length so pre-rendered peaks
           * can be display immediately for example.
           * @property {boolean} fillParent=true Whether to fill the entire container or
           * draw only according to `minPxPerSec`.
           * @property {boolean} forceDecode=false Force decoding of audio using web audio
           * when zooming to get a more detailed waveform.
           * @property {number} height=128 The height of the waveform. Measured in
           * pixels.
           * @property {boolean} hideScrollbar=false Whether to hide the horizontal
           * scrollbar when one would normally be shown.
           * @property {boolean} interact=true Whether the mouse interaction will be
           * enabled at initialization. You can switch this parameter at any time later
           * on.
           * @property {boolean} loopSelection=true (Use with regions plugin) Enable
           * looping of selected regions
           * @property {number} maxCanvasWidth=4000 Maximum width of a single canvas in
           * pixels, excluding a small overlap (2 * `pixelRatio`, rounded up to the next
           * even integer). If the waveform is longer than this value, additional canvases
           * will be used to render the waveform, which is useful for very large waveforms
           * that may be too wide for browsers to draw on a single canvas.
           * @property {boolean} mediaControls=false (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * this enables the native controls for the media element
           * @property {string} mediaType='audio' (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * `'audio'|'video'` ('video' only for `MediaElement`)
           * @property {number} minPxPerSec=20 Minimum number of pixels per second of
           * audio.
           * @property {boolean} normalize=false If true, normalize by the maximum peak
           * instead of 1.0.
           * @property {boolean} partialRender=false Use the PeakCache to improve
           * rendering speed of large waveforms
           * @property {number} pixelRatio=window.devicePixelRatio The pixel ratio used to
           * calculate display
           * @property {PluginDefinition[]} plugins=[] An array of plugin definitions to
           * register during instantiation, they will be directly initialised unless they
           * are added with the `deferInit` property set to true.
           * @property {string} progressColor='#555' The fill color of the part of the
           * waveform behind the cursor. When `progressColor` and `waveColor` are the same
           * the progress wave is not rendered at all.
           * @property {boolean} removeMediaElementOnDestroy=true Set to false to keep the
           * media element in the DOM when the player is destroyed. This is useful when
           * reusing an existing media element via the `loadMediaElement` method.
           * @property {Object} renderer=MultiCanvas Can be used to inject a custom
           * renderer.
           * @property {boolean|number} responsive=false If set to `true` resize the
           * waveform, when the window is resized. This is debounced with a `100ms`
           * timeout by default. If this parameter is a number it represents that timeout.
           * @property {boolean} rtl=false If set to `true`, renders waveform from
           * right-to-left.
           * @property {boolean} scrollParent=false Whether to scroll the container with a
           * lengthy waveform. Otherwise the waveform is shrunk to the container width
           * (see fillParent).
           * @property {number} skipLength=2 Number of seconds to skip with the
           * skipForward() and skipBackward() methods.
           * @property {boolean} splitChannels=false Render with separate waveforms for
           * the channels of the audio
           * @property {SplitChannelOptions} splitChannelsOptions={} Options for splitChannel rendering
           * @property {boolean} vertical=false Render the waveform vertically instead of horizontally.
           * @property {string} waveColor='#999' The fill color of the waveform after the
           * cursor.
           * @property {object} xhr={} XHR options. For example:
           * `let xhr = {
           *     cache: 'default',
           *     mode: 'cors',
           *     method: 'GET',
           *     credentials: 'same-origin',
           *     redirect: 'follow',
           *     referrer: 'client',
           *     requestHeaders: [
           *         {
           *             key: 'Authorization',
           *             value: 'my-token'
           *         }
           *     ]
           * };`
           */

          /**
           * @typedef {Object} PluginDefinition
           * @desc The Object used to describe a plugin
           * @example wavesurfer.addPlugin(pluginDefinition);
           * @property {string} name The name of the plugin, the plugin instance will be
           * added as a property to the wavesurfer instance under this name
           * @property {?Object} staticProps The properties that should be added to the
           * wavesurfer instance as static properties
           * @property {?boolean} deferInit Don't initialise plugin
           * automatically
           * @property {Object} params={} The plugin parameters, they are the first parameter
           * passed to the plugin class constructor function
           * @property {PluginClass} instance The plugin instance factory, is called with
           * the dependency specified in extends. Returns the plugin class.
           */

          /**
           * @typedef {Object} SplitChannelOptions
           * @desc parameters applied when splitChannels option is true
           * @property {boolean} overlay=false determines whether channels are rendered on top of each other or on separate tracks
           * @property {object} channelColors={} object describing color for each channel. Example:
           * {
           *     0: {
           *         progressColor: 'green',
           *         waveColor: 'pink'
           *     },
           *     1: {
           *         progressColor: 'orange',
           *         waveColor: 'purple'
           *     }
           * }
           * @property {number[]} filterChannels=[] indexes of channels to be hidden from rendering
           * @property {boolean} relativeNormalization=false determines whether
           * normalization is done per channel or maintains proportionality between
           * channels. Only applied when normalize and splitChannels are both true.
           * @since 4.3.0
           */

          /**
           * @interface PluginClass
           *
           * @desc This is the interface which is implemented by all plugin classes. Note
           * that this only turns into an observer after being passed through
           * `wavesurfer.addPlugin`.
           *
           * @extends {Observer}
           */
          var PluginClass = /*#__PURE__*/function () {
            /**
             * Construct the plugin
             *
             * @param {Object} params={} The plugin params (specific to the plugin)
             * @param {Object} ws The wavesurfer instance
             */
            function PluginClass(params, ws) {
              _classCallCheck(this, PluginClass);
            }
            /**
             * Initialise the plugin
             *
             * Start doing something. This is called by
             * `wavesurfer.initPlugin(pluginName)`
             */

            _createClass(PluginClass, [{
              key: "create",
              value:
              /**
               * Plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * It returns a `PluginDefinition` object representing the plugin.
               *
               * @param {Object} params={} The plugin params (specific to the plugin)
               */
              function create(params) {}
            }, {
              key: "init",
              value: function init() {}
              /**
               * Destroy the plugin instance
               *
               * Stop doing something. This is called by
               * `wavesurfer.destroyPlugin(pluginName)`
               */

            }, {
              key: "destroy",
              value: function destroy() {}
            }]);

            return PluginClass;
          }();
          /**
           * WaveSurfer core library class
           *
           * @extends {Observer}
           * @example
           * const params = {
           *   container: '#waveform',
           *   waveColor: 'violet',
           *   progressColor: 'purple'
           * };
           *
           * // initialise like this
           * const wavesurfer = WaveSurfer.create(params);
           *
           * // or like this ...
           * const wavesurfer = new WaveSurfer(params);
           * wavesurfer.init();
           *
           * // load audio file
           * wavesurfer.load('example/media/demo.wav');
           */

          var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
            _inherits(WaveSurfer, _util$Observer);

            var _super = _createSuper(WaveSurfer);

            /**
             * Initialise wavesurfer instance
             *
             * @param {WavesurferParams} params Instantiation options for wavesurfer
             * @example
             * const wavesurfer = new WaveSurfer(params);
             * @returns {this} Wavesurfer instance
             */
            function WaveSurfer(params) {
              var _this;

              _classCallCheck(this, WaveSurfer);

              _this = _super.call(this);
              /**
               * Extract relevant parameters (or defaults)
               * @private
               */

              _this.defaultParams = {
                audioContext: null,
                audioScriptProcessor: null,
                audioRate: 1,
                autoCenter: true,
                autoCenterRate: 5,
                autoCenterImmediately: false,
                backend: 'WebAudio',
                backgroundColor: null,
                barHeight: 1,
                barRadius: 0,
                barGap: null,
                barMinHeight: null,
                container: null,
                cursorColor: '#333',
                cursorWidth: 1,
                dragSelection: true,
                drawingContextAttributes: {
                  // Boolean that hints the user agent to reduce the latency
                  // by desynchronizing the canvas paint cycle from the event
                  // loop
                  desynchronized: false
                },
                duration: null,
                fillParent: true,
                forceDecode: false,
                height: 128,
                hideScrollbar: false,
                interact: true,
                loopSelection: true,
                maxCanvasWidth: 4000,
                mediaContainer: null,
                mediaControls: false,
                mediaType: 'audio',
                minPxPerSec: 20,
                normalize: false,
                partialRender: false,
                pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
                plugins: [],
                progressColor: '#555',
                removeMediaElementOnDestroy: true,
                renderer: _drawer.default,
                responsive: false,
                rtl: false,
                scrollParent: false,
                skipLength: 2,
                splitChannels: false,
                splitChannelsOptions: {
                  overlay: false,
                  channelColors: {},
                  filterChannels: [],
                  relativeNormalization: false
                },
                vertical: false,
                waveColor: '#999',
                xhr: {}
              };
              _this.backends = {
                MediaElement: _mediaelement.default,
                WebAudio: _webaudio.default,
                MediaElementWebAudio: _mediaelementWebaudio.default
              };
              _this.util = util;
              _this.params = _extends({}, _this.defaultParams, params);
              _this.params.splitChannelsOptions = _extends({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
              /** @private */

              _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;

              if (!_this.container) {
                throw new Error('Container element not found');
              }

              if (_this.params.mediaContainer == null) {
                /** @private */
                _this.mediaContainer = _this.container;
              } else if (typeof _this.params.mediaContainer == 'string') {
                /** @private */
                _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
              } else {
                /** @private */
                _this.mediaContainer = _this.params.mediaContainer;
              }

              if (!_this.mediaContainer) {
                throw new Error('Media Container element not found');
              }

              if (_this.params.maxCanvasWidth <= 1) {
                throw new Error('maxCanvasWidth must be greater than 1');
              } else if (_this.params.maxCanvasWidth % 2 == 1) {
                throw new Error('maxCanvasWidth must be an even number');
              }

              if (_this.params.rtl === true) {
                if (_this.params.vertical === true) {
                  util.style(_this.container, {
                    transform: 'rotateX(180deg)'
                  });
                } else {
                  util.style(_this.container, {
                    transform: 'rotateY(180deg)'
                  });
                }
              }

              if (_this.params.backgroundColor) {
                _this.setBackgroundColor(_this.params.backgroundColor);
              }
              /**
               * @private Used to save the current volume when muting so we can
               * restore once unmuted
               * @type {number}
               */

              _this.savedVolume = 0;
              /**
               * @private The current muted state
               * @type {boolean}
               */

              _this.isMuted = false;
              /**
               * @private Will hold a list of event descriptors that need to be
               * canceled on subsequent loads of audio
               * @type {Object[]}
               */

              _this.tmpEvents = [];
              /**
               * @private Holds any running audio downloads
               * @type {Observer}
               */

              _this.currentRequest = null;
              /** @private */

              _this.arraybuffer = null;
              /** @private */

              _this.drawer = null;
              /** @private */

              _this.backend = null;
              /** @private */

              _this.peakCache = null; // cache constructor objects

              if (typeof _this.params.renderer !== 'function') {
                throw new Error('Renderer parameter is invalid');
              }
              /**
               * @private The uninitialised Drawer class
               */

              _this.Drawer = _this.params.renderer;
              /**
               * @private The uninitialised Backend class
               */
              // Back compat

              if (_this.params.backend == 'AudioElement') {
                _this.params.backend = 'MediaElement';
              }

              if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
                _this.params.backend = 'MediaElement';
              }

              _this.Backend = _this.backends[_this.params.backend];
              /**
               * @private map of plugin names that are currently initialised
               */

              _this.initialisedPluginList = {};
              /** @private */

              _this.isDestroyed = false;
              /**
               * Get the current ready status.
               *
               * @example const isReady = wavesurfer.isReady;
               * @return {boolean}
               */

              _this.isReady = false; // responsive debounced event listener. If this.params.responsive is not
              // set, this is never called. Use 100ms or this.params.responsive as
              // timeout for the debounce function.

              var prevWidth = 0;
              _this._onResize = util.debounce(function () {
                if (prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
                  prevWidth = _this.drawer.wrapper.clientWidth;

                  _this.drawer.fireEvent('redraw');
                }
              }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
              return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
            }
            /**
             * Initialise the wave
             *
             * @example
             * var wavesurfer = new WaveSurfer(params);
             * wavesurfer.init();
             * @return {this} The wavesurfer instance
             */

            _createClass(WaveSurfer, [{
              key: "init",
              value: function init() {
                this.registerPlugins(this.params.plugins);
                this.createDrawer();
                this.createBackend();
                this.createPeakCache();
                return this;
              }
              /**
               * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
               * this function is called in the init function of wavesurfer
               *
               * @param {PluginDefinition[]} plugins An array of plugin definitions
               * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "registerPlugins",
              value: function registerPlugins(plugins) {
                var _this2 = this;

                // first instantiate all the plugins
                plugins.forEach(function (plugin) {
                  return _this2.addPlugin(plugin);
                }); // now run the init functions

                plugins.forEach(function (plugin) {
                  // call init function of the plugin if deferInit is falsey
                  // in that case you would manually use initPlugins()
                  if (!plugin.deferInit) {
                    _this2.initPlugin(plugin.name);
                  }
                });
                this.fireEvent('plugins-registered', plugins);
                return this;
              }
              /**
               * Get a map of plugin names that are currently initialised
               *
               * @example wavesurfer.getPlugins();
               * @return {Object} Object with plugin names
               */

            }, {
              key: "getActivePlugins",
              value: function getActivePlugins() {
                return this.initialisedPluginList;
              }
              /**
               * Add a plugin object to wavesurfer
               *
               * @param {PluginDefinition} plugin A plugin definition
               * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
               * @example wavesurfer.addPlugin(WaveSurfer.minimap());
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "addPlugin",
              value: function addPlugin(plugin) {
                var _this3 = this;

                if (!plugin.name) {
                  throw new Error('Plugin does not have a name!');
                }

                if (!plugin.instance) {
                  throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
                } // staticProps properties are applied to wavesurfer instance


                if (plugin.staticProps) {
                  Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
                    /**
                     * Properties defined in a plugin definition's `staticProps` property are added as
                     * staticProps properties of the WaveSurfer instance
                     */
                    _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
                  });
                }

                var Instance = plugin.instance; // turn the plugin instance into an observer

                var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
                observerPrototypeKeys.forEach(function (key) {
                  Instance.prototype[key] = util.Observer.prototype[key];
                });
                /**
                 * Instantiated plugin classes are added as a property of the wavesurfer
                 * instance
                 * @type {Object}
                 */

                this[plugin.name] = new Instance(plugin.params || {}, this);
                this.fireEvent('plugin-added', plugin.name);
                return this;
              }
              /**
               * Initialise a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-initialised
               * @example wavesurfer.initPlugin('minimap');
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "initPlugin",
              value: function initPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet!"));
                }

                if (this.initialisedPluginList[name]) {
                  // destroy any already initialised plugins
                  this.destroyPlugin(name);
                }

                this[name].init();
                this.initialisedPluginList[name] = true;
                this.fireEvent('plugin-initialised', name);
                return this;
              }
              /**
               * Destroy a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-destroyed
               * @example wavesurfer.destroyPlugin('minimap');
               * @returns {this} The wavesurfer instance
               */

            }, {
              key: "destroyPlugin",
              value: function destroyPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
                }

                if (!this.initialisedPluginList[name]) {
                  throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
                }

                if (typeof this[name].destroy !== 'function') {
                  throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
                }

                this[name].destroy();
                delete this.initialisedPluginList[name];
                this.fireEvent('plugin-destroyed', name);
                return this;
              }
              /**
               * Destroy all initialised plugins. Convenience function to use when
               * wavesurfer is removed
               *
               * @private
               */

            }, {
              key: "destroyAllPlugins",
              value: function destroyAllPlugins() {
                var _this4 = this;

                Object.keys(this.initialisedPluginList).forEach(function (name) {
                  return _this4.destroyPlugin(name);
                });
              }
              /**
               * Create the drawer and draw the waveform
               *
               * @private
               * @emits WaveSurfer#drawer-created
               */

            }, {
              key: "createDrawer",
              value: function createDrawer() {
                var _this5 = this;

                this.drawer = new this.Drawer(this.container, this.params);
                this.drawer.init();
                this.fireEvent('drawer-created', this.drawer);

                if (this.params.responsive !== false) {
                  window.addEventListener('resize', this._onResize, true);
                  window.addEventListener('orientationchange', this._onResize, true);
                }

                this.drawer.on('redraw', function () {
                  _this5.drawBuffer();

                  _this5.drawer.progress(_this5.backend.getPlayedPercents());
                }); // Click-to-seek

                this.drawer.on('click', function (e, progress) {
                  setTimeout(function () {
                    return _this5.seekTo(progress);
                  }, 0);
                }); // Relay the scroll event from the drawer

                this.drawer.on('scroll', function (e) {
                  if (_this5.params.partialRender) {
                    _this5.drawBuffer();
                  }

                  _this5.fireEvent('scroll', e);
                });
              }
              /**
               * Create the backend
               *
               * @private
               * @emits WaveSurfer#backend-created
               */

            }, {
              key: "createBackend",
              value: function createBackend() {
                var _this6 = this;

                if (this.backend) {
                  this.backend.destroy();
                }

                this.backend = new this.Backend(this.params);
                this.backend.init();
                this.fireEvent('backend-created', this.backend);
                this.backend.on('finish', function () {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('finish');
                });
                this.backend.on('play', function () {
                  return _this6.fireEvent('play');
                });
                this.backend.on('pause', function () {
                  return _this6.fireEvent('pause');
                });
                this.backend.on('audioprocess', function (time) {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('audioprocess', time);
                }); // only needed for MediaElement and MediaElementWebAudio backend

                if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
                  this.backend.on('seek', function () {
                    _this6.drawer.progress(_this6.backend.getPlayedPercents());
                  });
                  this.backend.on('volume', function () {
                    var newVolume = _this6.getVolume();

                    _this6.fireEvent('volume', newVolume);

                    if (_this6.backend.isMuted !== _this6.isMuted) {
                      _this6.isMuted = _this6.backend.isMuted;

                      _this6.fireEvent('mute', _this6.isMuted);
                    }
                  });
                }
              }
              /**
               * Create the peak cache
               *
               * @private
               */

            }, {
              key: "createPeakCache",
              value: function createPeakCache() {
                if (this.params.partialRender) {
                  this.peakCache = new _peakcache.default();
                }
              }
              /**
               * Get the duration of the audio clip
               *
               * @example const duration = wavesurfer.getDuration();
               * @return {number} Duration in seconds
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                return this.backend.getDuration();
              }
              /**
               * Get the current playback position
               *
               * @example const currentTime = wavesurfer.getCurrentTime();
               * @return {number} Playback position in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.backend.getCurrentTime();
              }
              /**
               * Set the current play time in seconds.
               *
               * @param {number} seconds A positive number in seconds. E.g. 10 means 10
               * seconds, 60 means 1 minute
               */

            }, {
              key: "setCurrentTime",
              value: function setCurrentTime(seconds) {
                if (seconds >= this.getDuration()) {
                  this.seekTo(1);
                } else {
                  this.seekTo(seconds / this.getDuration());
                }
              }
              /**
               * Starts playback from the current position. Optional start and end
               * measured in seconds can be used to set the range of audio to play.
               *
               * @param {?number} start Position to start at
               * @param {?number} end Position to end at
               * @emits WaveSurfer#interaction
               * @return {Promise} Result of the backend play method
               * @example
               * // play from second 1 to 5
               * wavesurfer.play(1, 5);
               */

            }, {
              key: "play",
              value: function play(start, end) {
                var _this7 = this;

                this.fireEvent('interaction', function () {
                  return _this7.play(start, end);
                });
                return this.backend.play(start, end);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} position Position (in seconds) to stop at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(position) {
                this.backend.setPlayEnd(position);
              }
              /**
               * Stops and pauses playback
               *
               * @example wavesurfer.pause();
               * @return {Promise} Result of the backend pause method
               */

            }, {
              key: "pause",
              value: function pause() {
                if (!this.backend.isPaused()) {
                  return this.backend.pause();
                }
              }
              /**
               * Toggle playback
               *
               * @example wavesurfer.playPause();
               * @return {Promise} Result of the backend play or pause method
               */

            }, {
              key: "playPause",
              value: function playPause() {
                return this.backend.isPaused() ? this.play() : this.pause();
              }
              /**
               * Get the current playback state
               *
               * @example const isPlaying = wavesurfer.isPlaying();
               * @return {boolean} False if paused, true if playing
               */

            }, {
              key: "isPlaying",
              value: function isPlaying() {
                return !this.backend.isPaused();
              }
              /**
               * Skip backward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipBackward();
               */

            }, {
              key: "skipBackward",
              value: function skipBackward(seconds) {
                this.skip(-seconds || -this.params.skipLength);
              }
              /**
               * Skip forward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipForward();
               */

            }, {
              key: "skipForward",
              value: function skipForward(seconds) {
                this.skip(seconds || this.params.skipLength);
              }
              /**
               * Skip a number of seconds from the current position (use a negative value
               * to go backwards).
               *
               * @param {number} offset Amount to skip back or forwards
               * @example
               * // go back 2 seconds
               * wavesurfer.skip(-2);
               */

            }, {
              key: "skip",
              value: function skip(offset) {
                var duration = this.getDuration() || 1;
                var position = this.getCurrentTime() || 0;
                position = Math.max(0, Math.min(duration, position + (offset || 0)));
                this.seekAndCenter(position / duration);
              }
              /**
               * Seeks to a position and centers the view
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @example
               * // seek and go to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekAndCenter",
              value: function seekAndCenter(progress) {
                this.seekTo(progress);
                this.drawer.recenter(progress);
              }
              /**
               * Seeks to a position
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @emits WaveSurfer#interaction
               * @emits WaveSurfer#seek
               * @example
               * // seek to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekTo",
              value: function seekTo(progress) {
                var _this8 = this;

                // return an error if progress is not a number between 0 and 1
                if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
                  throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
                }

                this.fireEvent('interaction', function () {
                  return _this8.seekTo(progress);
                });
                var isWebAudioBackend = this.params.backend === 'WebAudio';
                var paused = this.backend.isPaused();

                if (isWebAudioBackend && !paused) {
                  this.backend.pause();
                } // avoid small scrolls while paused seeking


                var oldScrollParent = this.params.scrollParent;
                this.params.scrollParent = false;
                this.backend.seekTo(progress * this.getDuration());
                this.drawer.progress(progress);

                if (isWebAudioBackend && !paused) {
                  this.backend.play();
                }

                this.params.scrollParent = oldScrollParent;
                this.fireEvent('seek', progress);
              }
              /**
               * Stops and goes to the beginning.
               *
               * @example wavesurfer.stop();
               */

            }, {
              key: "stop",
              value: function stop() {
                this.pause();
                this.seekTo(0);
                this.drawer.progress(0);
              }
              /**
               * Sets the ID of the audio device to use for output and returns a Promise.
               *
               * @param {string} deviceId String value representing underlying output
               * device
               * @returns {Promise} `Promise` that resolves to `undefined` when there are
               * no errors detected.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                return this.backend.setSinkId(deviceId);
              }
              /**
               * Set the playback volume.
               *
               * @param {number} newVolume A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               * @emits WaveSurfer#volume
               */

            }, {
              key: "setVolume",
              value: function setVolume(newVolume) {
                this.backend.setVolume(newVolume);
                this.fireEvent('volume', newVolume);
              }
              /**
               * Get the playback volume.
               *
               * @return {number} A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.backend.getVolume();
              }
              /**
               * Set the playback rate.
               *
               * @param {number} rate A positive number. E.g. 0.5 means half the normal
               * speed, 2 means double speed and so on.
               * @example wavesurfer.setPlaybackRate(2);
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(rate) {
                this.backend.setPlaybackRate(rate);
              }
              /**
               * Get the playback rate.
               *
               * @return {number} The current playback rate.
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.backend.getPlaybackRate();
              }
              /**
               * Toggle the volume on and off. If not currently muted it will save the
               * current volume value and turn the volume off. If currently muted then it
               * will restore the volume to the saved value, and then rest the saved
               * value.
               *
               * @example wavesurfer.toggleMute();
               */

            }, {
              key: "toggleMute",
              value: function toggleMute() {
                this.setMute(!this.isMuted);
              }
              /**
               * Enable or disable muted audio
               *
               * @param {boolean} mute Specify `true` to mute audio.
               * @emits WaveSurfer#volume
               * @emits WaveSurfer#mute
               * @example
               * // unmute
               * wavesurfer.setMute(false);
               * console.log(wavesurfer.getMute()) // logs false
               */

            }, {
              key: "setMute",
              value: function setMute(mute) {
                // ignore all muting requests if the audio is already in that state
                if (mute === this.isMuted) {
                  this.fireEvent('mute', this.isMuted);
                  return;
                }

                if (this.backend.setMute) {
                  // Backends such as the MediaElement backend have their own handling
                  // of mute, let them handle it.
                  this.backend.setMute(mute);
                  this.isMuted = mute;
                } else {
                  if (mute) {
                    // If currently not muted then save current volume,
                    // turn off the volume and update the mute properties
                    this.savedVolume = this.backend.getVolume();
                    this.backend.setVolume(0);
                    this.isMuted = true;
                    this.fireEvent('volume', 0);
                  } else {
                    // If currently muted then restore to the saved volume
                    // and update the mute properties
                    this.backend.setVolume(this.savedVolume);
                    this.isMuted = false;
                    this.fireEvent('volume', this.savedVolume);
                  }
                }

                this.fireEvent('mute', this.isMuted);
              }
              /**
               * Get the current mute status.
               *
               * @example const isMuted = wavesurfer.getMute();
               * @return {boolean} Current mute status
               */

            }, {
              key: "getMute",
              value: function getMute() {
                return this.isMuted;
              }
              /**
               * Get the list of current set filters as an array.
               *
               * Filters must be set with setFilters method first
               *
               * @return {array} List of enabled filters
               */

            }, {
              key: "getFilters",
              value: function getFilters() {
                return this.backend.filters || [];
              }
              /**
               * Toggles `scrollParent` and redraws
               *
               * @example wavesurfer.toggleScroll();
               */

            }, {
              key: "toggleScroll",
              value: function toggleScroll() {
                this.params.scrollParent = !this.params.scrollParent;
                this.drawBuffer();
              }
              /**
               * Toggle mouse interaction
               *
               * @example wavesurfer.toggleInteraction();
               */

            }, {
              key: "toggleInteraction",
              value: function toggleInteraction() {
                this.params.interact = !this.params.interact;
              }
              /**
               * Get the fill color of the waveform after the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getWaveColor",
              value: function getWaveColor() {
                return this.params.waveColor;
              }
              /**
               * Set the fill color of the waveform after the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setWaveColor('#ddd');
               */

            }, {
              key: "setWaveColor",
              value: function setWaveColor(color) {
                this.params.waveColor = color;
                this.drawBuffer();
              }
              /**
               * Get the fill color of the waveform behind the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getProgressColor",
              value: function getProgressColor() {
                return this.params.progressColor;
              }
              /**
               * Set the fill color of the waveform behind the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setProgressColor('#400');
               */

            }, {
              key: "setProgressColor",
              value: function setProgressColor(color) {
                this.params.progressColor = color;
                this.drawBuffer();
              }
              /**
               * Get the background color of the waveform container.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getBackgroundColor",
              value: function getBackgroundColor() {
                return this.params.backgroundColor;
              }
              /**
               * Set the background color of the waveform container.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setBackgroundColor('#FF00FF');
               */

            }, {
              key: "setBackgroundColor",
              value: function setBackgroundColor(color) {
                this.params.backgroundColor = color;
                util.style(this.container, {
                  background: this.params.backgroundColor
                });
              }
              /**
               * Get the fill color of the cursor indicating the playhead
               * position.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getCursorColor",
              value: function getCursorColor() {
                return this.params.cursorColor;
              }
              /**
               * Set the fill color of the cursor indicating the playhead
               * position.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setCursorColor('#222');
               */

            }, {
              key: "setCursorColor",
              value: function setCursorColor(color) {
                this.params.cursorColor = color;
                this.drawer.updateCursor();
              }
              /**
               * Get the height of the waveform.
               *
               * @return {number} Height measured in pixels.
               */

            }, {
              key: "getHeight",
              value: function getHeight() {
                return this.params.height;
              }
              /**
               * Set the height of the waveform.
               *
               * @param {number} height Height measured in pixels.
               * @example wavesurfer.setHeight(200);
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                this.params.height = height;
                this.drawer.setHeight(height * this.params.pixelRatio);
                this.drawBuffer();
              }
              /**
               * Hide channels from being drawn on the waveform if splitting channels.
               *
               * For example, if we want to draw only the peaks for the right stereo channel:
               *
               * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
               * wavesurfer.load('stereo_audio.mp3');
               *
               * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
               *
               * @param {array} channelIndices Channels to be filtered out from drawing.
               * @version 4.0.0
               */

            }, {
              key: "setFilteredChannels",
              value: function setFilteredChannels(channelIndices) {
                this.params.splitChannelsOptions.filterChannels = channelIndices;
                this.drawBuffer();
              }
              /**
               * Get the correct peaks for current wave view-port and render wave
               *
               * @private
               * @emits WaveSurfer#redraw
               */

            }, {
              key: "drawBuffer",
              value: function drawBuffer() {
                var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
                var parentWidth = this.drawer.getWidth();
                var width = nominalWidth; // always start at 0 after zooming for scrolling : issue redraw left part

                var start = 0;
                var end = Math.max(start + parentWidth, width); // Fill container

                if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
                  width = parentWidth;
                  start = 0;
                  end = width;
                }

                var peaks;

                if (this.params.partialRender) {
                  var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
                  var i;

                  for (i = 0; i < newRanges.length; i++) {
                    peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
                    this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
                  }
                } else {
                  peaks = this.backend.getPeaks(width, start, end);
                  this.drawer.drawPeaks(peaks, width, start, end);
                }

                this.fireEvent('redraw', peaks, width);
              }
              /**
               * Horizontally zooms the waveform in and out. It also changes the parameter
               * `minPxPerSec` and enables the `scrollParent` option. Calling the function
               * with a falsey parameter will reset the zoom state.
               *
               * @param {?number} pxPerSec Number of horizontal pixels per second of
               * audio, if none is set the waveform returns to unzoomed state
               * @emits WaveSurfer#zoom
               * @example wavesurfer.zoom(20);
               */

            }, {
              key: "zoom",
              value: function zoom(pxPerSec) {
                if (!pxPerSec) {
                  this.params.minPxPerSec = this.defaultParams.minPxPerSec;
                  this.params.scrollParent = false;
                } else {
                  this.params.minPxPerSec = pxPerSec;
                  this.params.scrollParent = true;
                }

                this.drawBuffer();
                this.drawer.progress(this.backend.getPlayedPercents());
                this.drawer.recenter(this.getCurrentTime() / this.getDuration());
                this.fireEvent('zoom', pxPerSec);
              }
              /**
               * Decode buffer and load
               *
               * @private
               * @param {ArrayBuffer} arraybuffer Buffer to process
               */

            }, {
              key: "loadArrayBuffer",
              value: function loadArrayBuffer(arraybuffer) {
                var _this9 = this;

                this.decodeArrayBuffer(arraybuffer, function (data) {
                  if (!_this9.isDestroyed) {
                    _this9.loadDecodedBuffer(data);
                  }
                });
              }
              /**
               * Directly load an externally decoded AudioBuffer
               *
               * @private
               * @param {AudioBuffer} buffer Buffer to process
               * @emits WaveSurfer#ready
               */

            }, {
              key: "loadDecodedBuffer",
              value: function loadDecodedBuffer(buffer) {
                this.backend.load(buffer);
                this.drawBuffer();
                this.isReady = true;
                this.fireEvent('ready');
              }
              /**
               * Loads audio data from a Blob or File object
               *
               * @param {Blob|File} blob Audio data
               * @example
               */

            }, {
              key: "loadBlob",
              value: function loadBlob(blob) {
                var _this10 = this;

                // Create file reader
                var reader = new FileReader();
                reader.addEventListener('progress', function (e) {
                  return _this10.onProgress(e);
                });
                reader.addEventListener('load', function (e) {
                  return _this10.loadArrayBuffer(e.target.result);
                });
                reader.addEventListener('error', function () {
                  return _this10.fireEvent('error', 'Error reading file');
                });
                reader.readAsArrayBuffer(blob);
                this.empty();
              }
              /**
               * Loads audio and re-renders the waveform.
               *
               * @param {string|HTMLMediaElement} url The url of the audio file or the
               * audio element with the audio
               * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
               * the audio to render the waveform if this is specified
               * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
               * `'none'|'metadata'|'auto'` Preload attribute for the media element
               * @param {?number} duration The duration of the audio. This is used to
               * render the peaks data in the correct size for the audio duration (as
               * befits the current `minPxPerSec` and zoom value) without having to decode
               * the audio.
               * @returns {void}
               * @throws Will throw an error if the `url` argument is empty.
               * @example
               * // uses fetch or media element to load file (depending on backend)
               * wavesurfer.load('http://example.com/demo.wav');
               *
               * // setting preload attribute with media element backend and supplying
               * // peaks
               * wavesurfer.load(
               *   'http://example.com/demo.wav',
               *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
               *   true
               * );
               */

            }, {
              key: "load",
              value: function load(url, peaks, preload, duration) {
                if (!url) {
                  throw new Error('url parameter cannot be empty');
                }

                this.empty();

                if (preload) {
                  // check whether the preload attribute will be usable and if not log
                  // a warning listing the reasons why not and nullify the variable
                  var preloadIgnoreReasons = {
                    "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
                    'Peaks are not provided': !peaks,
                    "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
                    'Url is not of type string': typeof url !== 'string'
                  };
                  var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
                    return preloadIgnoreReasons[reason];
                  });

                  if (activeReasons.length) {
                    // eslint-disable-next-line no-console
                    console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- ')); // stop invalid values from being used

                    preload = null;
                  }
                } // loadBuffer(url, peaks, duration) requires that url is a string
                // but users can pass in a HTMLMediaElement to WaveSurfer


                if (this.params.backend === 'WebAudio' && url instanceof HTMLMediaElement) {
                  url = url.src;
                }

                switch (this.params.backend) {
                  case 'WebAudio':
                    return this.loadBuffer(url, peaks, duration);

                  case 'MediaElement':
                  case 'MediaElementWebAudio':
                    return this.loadMediaElement(url, peaks, preload, duration);
                }
              }
              /**
               * Loads audio using Web Audio buffer backend.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string} url URL of audio file
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Optional duration of audio file
               * @returns {void}
               */

            }, {
              key: "loadBuffer",
              value: function loadBuffer(url, peaks, duration) {
                var _this11 = this;

                var load = function load(action) {
                  if (action) {
                    _this11.tmpEvents.push(_this11.once('ready', action));
                  }

                  return _this11.getArrayBuffer(url, function (data) {
                    return _this11.loadArrayBuffer(data);
                  });
                };

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                  this.tmpEvents.push(this.once('interaction', load));
                } else {
                  return load();
                }
              }
              /**
               * Either create a media element, or load an existing media element.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
               * existing HTML5 Audio/Video Element
               * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
               * dependency
               * @param {?boolean} preload Set to true if the preload attribute of the
               * audio element should be enabled
               * @param {?number} duration Optional duration of audio file
               */

            }, {
              key: "loadMediaElement",
              value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
                var _this12 = this;

                var url = urlOrElt;

                if (typeof urlOrElt === 'string') {
                  this.backend.load(url, this.mediaContainer, peaks, preload);
                } else {
                  var elt = urlOrElt;
                  this.backend.loadElt(elt, peaks); // If peaks are not provided,
                  // url = element.src so we can get peaks with web audio

                  url = elt.src;
                }

                this.tmpEvents.push(this.backend.once('canplay', function () {
                  // ignore when backend was already destroyed
                  if (!_this12.backend.destroyed) {
                    _this12.drawBuffer();

                    _this12.isReady = true;

                    _this12.fireEvent('ready');
                  }
                }), this.backend.once('error', function (err) {
                  return _this12.fireEvent('error', err);
                })); // If peaks are provided, render them and fire the `waveform-ready` event.

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                } // If no pre-decoded peaks are provided, or are provided with
                // forceDecode flag, attempt to download the audio file and decode it
                // with Web Audio.


                if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
                  this.getArrayBuffer(url, function (arraybuffer) {
                    _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
                      _this12.backend.buffer = buffer;

                      _this12.backend.setPeaks(null);

                      _this12.drawBuffer();

                      _this12.fireEvent('waveform-ready');
                    });
                  });
                }
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {Object} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback) {
                var _this13 = this;

                this.arraybuffer = arraybuffer;
                this.backend.decodeArrayBuffer(arraybuffer, function (data) {
                  // Only use the decoded data if we haven't been destroyed or
                  // another decode started in the meantime
                  if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
                    callback(data);
                    _this13.arraybuffer = null;
                  }
                }, function () {
                  return _this13.fireEvent('error', 'Error decoding audiobuffer');
                });
              }
              /**
               * Load an array buffer using fetch and pass the result to a callback
               *
               * @param {string} url The URL of the file object
               * @param {function} callback The function to call on complete
               * @returns {util.fetchFile} fetch call
               * @private
               */

            }, {
              key: "getArrayBuffer",
              value: function getArrayBuffer(url, callback) {
                var _this14 = this;

                var options = _extends({
                  url: url,
                  responseType: 'arraybuffer'
                }, this.params.xhr);
                var request = util.fetchFile(options);
                this.currentRequest = request;
                this.tmpEvents.push(request.on('progress', function (e) {
                  _this14.onProgress(e);
                }), request.on('success', function (data) {
                  callback(data);
                  _this14.currentRequest = null;
                }), request.on('error', function (e) {
                  _this14.fireEvent('error', e);

                  _this14.currentRequest = null;
                }));
                return request;
              }
              /**
               * Called while the audio file is loading
               *
               * @private
               * @param {Event} e Progress event
               * @emits WaveSurfer#loading
               */

            }, {
              key: "onProgress",
              value: function onProgress(e) {
                var percentComplete;

                if (e.lengthComputable) {
                  percentComplete = e.loaded / e.total;
                } else {
                  // Approximate progress with an asymptotic
                  // function, and assume downloads in the 1-3 MB range.
                  percentComplete = e.loaded / (e.loaded + 1000000);
                }

                this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
              }
              /**
               * Exports PCM data into a JSON array and optionally opens in a new window
               * as valid JSON Blob instance.
               *
               * @param {number} length=1024 The scale in which to export the peaks
               * @param {number} accuracy=10000
               * @param {?boolean} noWindow Set to true to disable opening a new
               * window with the JSON
               * @param {number} start Start index
               * @param {number} end End index
               * @return {Promise} Promise that resolves with array of peaks
               */

            }, {
              key: "exportPCM",
              value: function exportPCM(length, accuracy, noWindow, start, end) {
                length = length || 1024;
                start = start || 0;
                accuracy = accuracy || 10000;
                noWindow = noWindow || false;
                var peaks = this.backend.getPeaks(length, start, end);
                var arr = [].map.call(peaks, function (val) {
                  return Math.round(val * accuracy) / accuracy;
                });
                return new Promise(function (resolve, reject) {
                  if (!noWindow) {
                    var blobJSON = new Blob([JSON.stringify(arr)], {
                      type: 'application/json;charset=utf-8'
                    });
                    var objURL = URL.createObjectURL(blobJSON);
                    window.open(objURL);
                    URL.revokeObjectURL(objURL);
                  }

                  resolve(arr);
                });
              }
              /**
               * Save waveform image as data URI.
               *
               * The default format is `'image/png'`. Other supported types are
               * `'image/jpeg'` and `'image/webp'`.
               *
               * @param {string} format='image/png' A string indicating the image format.
               * The default format type is `'image/png'`.
               * @param {number} quality=1 A number between 0 and 1 indicating the image
               * quality to use for image formats that use lossy compression such as
               * `'image/jpeg'`` and `'image/webp'`.
               * @param {string} type Image data type to return. Either 'dataURL' (default)
               * or 'blob'.
               * @return {string|string[]|Promise} When using `'dataURL'` type this returns
               * a single data URL or an array of data URLs, one for each canvas. When using
               * `'blob'` type this returns a `Promise` resolving with an array of `Blob`
               * instances, one for each canvas.
               */

            }, {
              key: "exportImage",
              value: function exportImage(format, quality, type) {
                if (!format) {
                  format = 'image/png';
                }

                if (!quality) {
                  quality = 1;
                }

                if (!type) {
                  type = 'dataURL';
                }

                return this.drawer.getImage(format, quality, type);
              }
              /**
               * Cancel any fetch request currently in progress
               */

            }, {
              key: "cancelAjax",
              value: function cancelAjax() {
                if (this.currentRequest && this.currentRequest.controller) {
                  // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
                  // See: Wavesurfer issue #2042
                  // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
                  if (this.currentRequest._reader) {
                    // Ignoring exceptions thrown by call to cancel()
                    this.currentRequest._reader.cancel().catch(function (err) {});
                  }

                  this.currentRequest.controller.abort();
                  this.currentRequest = null;
                }
              }
              /**
               * @private
               */

            }, {
              key: "clearTmpEvents",
              value: function clearTmpEvents() {
                this.tmpEvents.forEach(function (e) {
                  return e.un();
                });
              }
              /**
               * Display empty waveform.
               */

            }, {
              key: "empty",
              value: function empty() {
                if (!this.backend.isPaused()) {
                  this.stop();
                  this.backend.disconnectSource();
                }

                this.isReady = false;
                this.cancelAjax();
                this.clearTmpEvents(); // empty drawer

                this.drawer.progress(0);
                this.drawer.setWidth(0);
                this.drawer.drawPeaks({
                  length: this.drawer.getWidth()
                }, 0);
              }
              /**
               * Remove events, elements and disconnect WebAudio nodes.
               *
               * @emits WaveSurfer#destroy
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.destroyAllPlugins();
                this.fireEvent('destroy');
                this.cancelAjax();
                this.clearTmpEvents();
                this.unAll();

                if (this.params.responsive !== false) {
                  window.removeEventListener('resize', this._onResize, true);
                  window.removeEventListener('orientationchange', this._onResize, true);
                }

                if (this.backend) {
                  this.backend.destroy(); // clears memory usage

                  this.backend = null;
                }

                if (this.drawer) {
                  this.drawer.destroy();
                }

                this.isDestroyed = true;
                this.isReady = false;
                this.arraybuffer = null;
              }
            }], [{
              key: "create",
              value:
              /** @private */

              /** @private */

              /**
               * Instantiate this class, call its `init` function and returns it
               *
               * @param {WavesurferParams} params The wavesurfer parameters
               * @return {Object} WaveSurfer instance
               * @example const wavesurfer = WaveSurfer.create(params);
               */
              function create(params) {
                var wavesurfer = new WaveSurfer(params);
                return wavesurfer.init();
              }
              /**
               * The library version number is available as a static property of the
               * WaveSurfer class
               *
               * @type {String}
               * @example
               * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
               */

            }]);

            return WaveSurfer;
          }(util.Observer);

          exports.default = WaveSurfer;
          WaveSurfer.VERSION = "5.1.0";
          WaveSurfer.util = util;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/webaudio.js":
        /*!*************************!*\
          !*** ./src/webaudio.js ***!
          \*************************/
        /***/function srcWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          // using constants to prevent someone writing the string wrong
          var PLAYING = 'playing';
          var PAUSED = 'paused';
          var FINISHED = 'finished';
          /**
           * WebAudio backend
           *
           * @extends {Observer}
           */

          var WebAudio = /*#__PURE__*/function (_util$Observer) {
            _inherits(WebAudio, _util$Observer);

            var _super = _createSuper(WebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function WebAudio(params) {
              var _this$stateBehaviors, _this$states;

              var _this;

              _classCallCheck(this, WebAudio);

              _this = _super.call(this);
              /** @private */

              _this.audioContext = null;
              _this.offlineAudioContext = null;
              _this.stateBehaviors = (_this$stateBehaviors = {}, _defineProperty(_this$stateBehaviors, PLAYING, {
                init: function init() {
                  this.addOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition + this.getPlayedTime();
                }
              }), _defineProperty(_this$stateBehaviors, PAUSED, {
                init: function init() {
                  this.removeOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition;
                }
              }), _defineProperty(_this$stateBehaviors, FINISHED, {
                init: function init() {
                  this.removeOnAudioProcess();
                  this.fireEvent('finish');
                },
                getPlayedPercents: function getPlayedPercents() {
                  return 1;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.getDuration();
                }
              }), _this$stateBehaviors);
              _this.params = params;
              /** ac: Audio Context instance */

              _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
              /**@private */

              _this.lastPlay = _this.ac.currentTime;
              /** @private */

              _this.startPosition = 0;
              /** @private */

              _this.scheduledPause = null;
              /** @private */

              _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.filters = [];
              /** gainNode: allows to control audio volume */

              _this.gainNode = null;
              /** @private */

              _this.mergedPeaks = null;
              /** @private */

              _this.offlineAc = null;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** analyser: provides audio analysis information */

              _this.analyser = null;
              /** scriptNode: allows processing audio */

              _this.scriptNode = null;
              /** @private */

              _this.source = null;
              /** @private */

              _this.splitPeaks = [];
              /** @private */

              _this.state = null;
              /** @private */

              _this.explicitDuration = params.duration;
              /**
               * Boolean indicating if the backend was destroyed.
               */

              _this.destroyed = false;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(WebAudio, [{
              key: "supportsWebAudio",
              value:
              /** scriptBufferSize: size of the processing buffer */

              /** audioContext: allows to process audio with WebAudio API */

              /** @private */

              /** @private */

              /**
               * Does the browser support this backend
               *
               * @return {boolean} Whether or not this browser supports this backend
               */
              function supportsWebAudio() {
                return !!(window.AudioContext || window.webkitAudioContext);
              }
              /**
               * Get the audio context used by this backend or create one
               *
               * @return {AudioContext} Existing audio context, or creates a new one
               */

            }, {
              key: "getAudioContext",
              value: function getAudioContext() {
                if (!window.WaveSurferAudioContext) {
                  window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                return window.WaveSurferAudioContext;
              }
              /**
               * Get the offline audio context used by this backend or create one
               *
               * @param {number} sampleRate The sample rate to use
               * @return {OfflineAudioContext} Existing offline audio context, or creates
               * a new one
               */

            }, {
              key: "getOfflineAudioContext",
              value: function getOfflineAudioContext(sampleRate) {
                if (!window.WaveSurferOfflineAudioContext) {
                  window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
                }

                return window.WaveSurferOfflineAudioContext;
              }
            }, {
              key: "init",
              value: function init() {
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
                this.setState(PAUSED);
                this.setPlaybackRate(this.params.audioRate);
                this.setLength(0);
              }
              /** @private */

            }, {
              key: "disconnectFilters",
              value: function disconnectFilters() {
                if (this.filters) {
                  this.filters.forEach(function (filter) {
                    filter && filter.disconnect();
                  });
                  this.filters = null; // Reconnect direct path

                  this.analyser.connect(this.gainNode);
                }
              }
              /**
               * @private
               *
               * @param {string} state The new state
               */

            }, {
              key: "setState",
              value: function setState(state) {
                if (this.state !== this.states[state]) {
                  this.state = this.states[state];
                  this.state.init.call(this);
                }
              }
              /**
               * Unpacked `setFilters()`
               *
               * @param {...AudioNode} filters One or more filters to set
               */

            }, {
              key: "setFilter",
              value: function setFilter() {
                for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
                  filters[_key] = arguments[_key];
                }

                this.setFilters(filters);
              }
              /**
               * Insert custom Web Audio nodes into the graph
               *
               * @param {AudioNode[]} filters Packed filters array
               * @example
               * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
               * wavesurfer.backend.setFilter(lowpass);
               */

            }, {
              key: "setFilters",
              value: function setFilters(filters) {
                // Remove existing filters
                this.disconnectFilters(); // Insert filters if filter array not empty

                if (filters && filters.length) {
                  this.filters = filters; // Disconnect direct path before inserting filters

                  this.analyser.disconnect(); // Connect each filter in turn

                  filters.reduce(function (prev, curr) {
                    prev.connect(curr);
                    return curr;
                  }, this.analyser).connect(this.gainNode);
                }
              }
              /** Create ScriptProcessorNode to process audio */

            }, {
              key: "createScriptNode",
              value: function createScriptNode() {
                if (this.params.audioScriptProcessor) {
                  this.scriptNode = this.params.audioScriptProcessor;
                } else {
                  if (this.ac.createScriptProcessor) {
                    this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
                  } else {
                    this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
                  }
                }

                this.scriptNode.connect(this.ac.destination);
              }
              /** @private */

            }, {
              key: "addOnAudioProcess",
              value: function addOnAudioProcess() {
                var _this2 = this;

                this.scriptNode.onaudioprocess = function () {
                  var time = _this2.getCurrentTime();

                  if (time >= _this2.getDuration()) {
                    _this2.setState(FINISHED);

                    _this2.fireEvent('pause');
                  } else if (time >= _this2.scheduledPause) {
                    _this2.pause();
                  } else if (_this2.state === _this2.states[PLAYING]) {
                    _this2.fireEvent('audioprocess', time);
                  }
                };
              }
              /** @private */

            }, {
              key: "removeOnAudioProcess",
              value: function removeOnAudioProcess() {
                this.scriptNode.onaudioprocess = null;
              }
              /** Create analyser node to perform audio analysis */

            }, {
              key: "createAnalyserNode",
              value: function createAnalyserNode() {
                this.analyser = this.ac.createAnalyser();
                this.analyser.connect(this.gainNode);
              }
              /**
               * Create the gain node needed to control the playback volume.
               *
               */

            }, {
              key: "createVolumeNode",
              value: function createVolumeNode() {
                // Create gain node using the AudioContext
                if (this.ac.createGain) {
                  this.gainNode = this.ac.createGain();
                } else {
                  this.gainNode = this.ac.createGainNode();
                } // Add the gain node to the graph


                this.gainNode.connect(this.ac.destination);
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  /**
                   * The webaudio API doesn't currently support setting the device
                   * output. Here we create an HTMLAudioElement, connect the
                   * webaudio stream to that element and setSinkId there.
                   */
                  var audio = new window.Audio();

                  if (!audio.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  audio.autoplay = true;
                  var dest = this.ac.createMediaStreamDestination();
                  this.gainNode.disconnect();
                  this.gainNode.connect(dest);
                  audio.srcObject = dest.stream;
                  return audio.setSinkId(deviceId);
                } else {
                  return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
                }
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.gainNode.gain.value;
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {ArrayBuffer} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete.
               * @param {function} errback The function to call on error.
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback, errback) {
                if (!this.offlineAc) {
                  this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
                }

                if ('webkitAudioContext' in window) {
                  // Safari: no support for Promise-based decodeAudioData enabled
                  // Enable it in Safari using the Experimental Features > Modern WebAudio API option
                  this.offlineAc.decodeAudioData(arraybuffer, function (data) {
                    return callback(data);
                  }, errback);
                } else {
                  this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
                    return callback(data);
                  }).catch(function (err) {
                    return errback(err);
                  });
                }
              }
              /**
               * Set pre-decoded peaks
               *
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Explicit duration
               */

            }, {
              key: "setPeaks",
              value: function setPeaks(peaks, duration) {
                if (duration != null) {
                  this.explicitDuration = duration;
                }

                this.peaks = peaks;
              }
              /**
               * Set the rendered length (different from the length of the audio)
               *
               * @param {number} length The rendered length
               */

            }, {
              key: "setLength",
              value: function setLength(length) {
                // No resize, we can preserve the cached peaks.
                if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
                  return;
                }

                this.splitPeaks = [];
                this.mergedPeaks = []; // Set the last element of the sparse array so the peak arrays are
                // appropriately sized for other calculations.

                var channels = this.buffer ? this.buffer.numberOfChannels : 1;
                var c;

                for (c = 0; c < channels; c++) {
                  this.splitPeaks[c] = [];
                  this.splitPeaks[c][2 * (length - 1)] = 0;
                  this.splitPeaks[c][2 * (length - 1) + 1] = 0;
                }

                this.mergedPeaks[2 * (length - 1)] = 0;
                this.mergedPeaks[2 * (length - 1) + 1] = 0;
              }
              /**
               * Compute the max and min value of the waveform when broken into <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
               * peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.peaks) {
                  return this.peaks;
                }

                if (!this.buffer) {
                  return [];
                }

                first = first || 0;
                last = last || length - 1;
                this.setLength(length);

                if (!this.buffer) {
                  return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
                }
                /**
                 * The following snippet fixes a buffering data issue on the Safari
                 * browser which returned undefined It creates the missing buffer based
                 * on 1 channel, 4096 samples and the sampleRate from the current
                 * webaudio context 4096 samples seemed to be the best fit for rendering
                 * will review this code once a stable version of Safari TP is out
                 */

                if (!this.buffer.length) {
                  var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
                  this.buffer = newBuffer.buffer;
                }

                var sampleSize = this.buffer.length / length;
                var sampleStep = ~~(sampleSize / 10) || 1;
                var channels = this.buffer.numberOfChannels;
                var c;

                for (c = 0; c < channels; c++) {
                  var peaks = this.splitPeaks[c];
                  var chan = this.buffer.getChannelData(c);
                  var i = void 0;

                  for (i = first; i <= last; i++) {
                    var start = ~~(i * sampleSize);
                    var end = ~~(start + sampleSize);
                    /**
                     * Initialize the max and min to the first sample of this
                     * subrange, so that even if the samples are entirely
                     * on one side of zero, we still return the true max and
                     * min values in the subrange.
                     */

                    var min = chan[start];
                    var max = min;
                    var j = void 0;

                    for (j = start; j < end; j += sampleStep) {
                      var value = chan[j];

                      if (value > max) {
                        max = value;
                      }

                      if (value < min) {
                        min = value;
                      }
                    }

                    peaks[2 * i] = max;
                    peaks[2 * i + 1] = min;

                    if (c == 0 || max > this.mergedPeaks[2 * i]) {
                      this.mergedPeaks[2 * i] = max;
                    }

                    if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
                      this.mergedPeaks[2 * i + 1] = min;
                    }
                  }
                }

                return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.state.getPlayedPercents.call(this);
              }
              /** @private */

            }, {
              key: "disconnectSource",
              value: function disconnectSource() {
                if (this.source) {
                  this.source.disconnect();
                }
              }
              /**
               * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
               */

            }, {
              key: "destroyWebAudio",
              value: function destroyWebAudio() {
                this.disconnectFilters();
                this.disconnectSource();
                this.gainNode.disconnect();
                this.scriptNode.disconnect();
                this.analyser.disconnect(); // close the audioContext if closeAudioContext option is set to true

                if (this.params.closeAudioContext) {
                  // check if browser supports AudioContext.close()
                  if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
                    this.ac.close();
                  } // clear the reference to the audiocontext


                  this.ac = null; // clear the actual audiocontext, either passed as param or the
                  // global singleton

                  if (!this.params.audioContext) {
                    window.WaveSurferAudioContext = null;
                  } else {
                    this.params.audioContext = null;
                  } // clear the offlineAudioContext


                  window.WaveSurferOfflineAudioContext = null;
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (!this.isPaused()) {
                  this.pause();
                }

                this.unAll();
                this.buffer = null;
                this.destroyed = true;
                this.destroyWebAudio();
              }
              /**
               * Loaded a decoded audio buffer
               *
               * @param {Object} buffer Decoded audio buffer to load
               */

            }, {
              key: "load",
              value: function load(buffer) {
                this.startPosition = 0;
                this.lastPlay = this.ac.currentTime;
                this.buffer = buffer;
                this.createSource();
              }
              /** @private */

            }, {
              key: "createSource",
              value: function createSource() {
                this.disconnectSource();
                this.source = this.ac.createBufferSource(); // adjust for old browsers

                this.source.start = this.source.start || this.source.noteGrainOn;
                this.source.stop = this.source.stop || this.source.noteOff;
                this.setPlaybackRate(this.playbackRate);
                this.source.buffer = this.buffer;
                this.source.connect(this.analyser);
              }
              /**
               * @private
               *
               * some browsers require an explicit call to #resume before they will play back audio
               */

            }, {
              key: "resumeAudioContext",
              value: function resumeAudioContext() {
                if (this.ac.state == 'suspended') {
                  this.ac.resume && this.ac.resume();
                }
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Whether or not this backend is currently paused
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return this.state !== this.states[PLAYING];
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration of loaded buffer
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                if (!this.buffer) {
                  return 0;
                }

                return this.buffer.duration;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               * @param {number} end Position to end at in seconds
               * @return {{start: number, end: number}} Object containing start and end
               * positions
               */

            }, {
              key: "seekTo",
              value: function seekTo(start, end) {
                if (!this.buffer) {
                  return;
                }

                this.scheduledPause = null;

                if (start == null) {
                  start = this.getCurrentTime();

                  if (start >= this.getDuration()) {
                    start = 0;
                  }
                }

                if (end == null) {
                  end = this.getDuration();
                }

                this.startPosition = start;
                this.lastPlay = this.ac.currentTime;

                if (this.state === this.states[FINISHED]) {
                  this.setState(PAUSED);
                }

                return {
                  start: start,
                  end: end
                };
              }
              /**
               * Get the playback position in seconds
               *
               * @return {number} The playback position in seconds
               */

            }, {
              key: "getPlayedTime",
              value: function getPlayedTime() {
                return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop relative to the beginning of a clip.
               */

            }, {
              key: "play",
              value: function play(start, end) {
                if (!this.buffer) {
                  return;
                } // need to re-create source on each playback


                this.createSource();
                var adjustedTime = this.seekTo(start, end);
                start = adjustedTime.start;
                end = adjustedTime.end;
                this.scheduledPause = end;
                this.source.start(0, start);
                this.resumeAudioContext();
                this.setState(PLAYING);
                this.fireEvent('play');
              }
              /**
               * Pauses the loaded audio.
               */

            }, {
              key: "pause",
              value: function pause() {
                this.scheduledPause = null;
                this.startPosition += this.getPlayedTime();
                this.source && this.source.stop(0);
                this.setState(PAUSED);
                this.fireEvent('pause');
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} The current time in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.state.getCurrentTime.call(this);
              }
              /**
               * Returns the current playback rate. (0=no playback, 1=normal playback)
               *
               * @return {number} The current playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value The playback rate to use
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} end Position to end at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                this.scheduledPause = end;
              }
            }]);

            return WebAudio;
          }(util.Observer);

          exports.default = WebAudio;
          WebAudio.scriptBufferSize = 256;
          module.exports = exports.default;

          /***/
        },

        /***/"./node_modules/debounce/index.js":
        /*!****************************************!*\
          !*** ./node_modules/debounce/index.js ***!
          \****************************************/
        /***/function node_modulesDebounceIndexJs(module) {

          /**
           * Returns a function, that, as long as it continues to be invoked, will not
           * be triggered. The function will be called after it stops being called for
           * N milliseconds. If `immediate` is passed, trigger the function on the
           * leading edge, instead of the trailing. The function also has a property 'clear' 
           * that is a function which will clear the timer to prevent previously scheduled executions. 
           *
           * @source underscore.js
           * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
           * @param {Function} function to wrap
           * @param {Number} timeout in ms (`100`)
           * @param {Boolean} whether to execute at the beginning (`false`)
           * @api public
           */
          function debounce(func, wait, immediate) {
            var timeout, args, context, timestamp, result;
            if (null == wait) wait = 100;

            function later() {
              var last = Date.now() - timestamp;

              if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
              } else {
                timeout = null;
                if (!immediate) {
                  result = func.apply(context, args);
                  context = args = null;
                }
              }
            };

            var debounced = function debounced() {
              context = this;
              args = arguments;
              timestamp = Date.now();
              var callNow = immediate && !timeout;
              if (!timeout) timeout = setTimeout(later, wait);
              if (callNow) {
                result = func.apply(context, args);
                context = args = null;
              }

              return result;
            };

            debounced.clear = function () {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
            };

            debounced.flush = function () {
              if (timeout) {
                result = func.apply(context, args);
                context = args = null;

                clearTimeout(timeout);
                timeout = null;
              }
            };

            return debounced;
          };

          // Adds compatibility for ES modules
          debounce.debounce = debounce;

          module.exports = debounce;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/wavesurfer.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js cursor plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["cursor"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/cursor/index.js":
        /*!************************************!*\
          !*** ./src/plugin/cursor/index.js ***!
          \************************************/
        /***/function srcPluginCursorIndexJs(module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} CursorPluginParams
           * @property {?boolean} deferInit Set to true to stop auto init in `addPlugin()`
           * @property {boolean} hideOnBlur=true Hide the cursor when the mouse leaves the
           * waveform
           * @property {string} width='1px' The width of the cursor
           * @property {string} color='black' The color of the cursor
           * @property {string} opacity='0.25' The opacity of the cursor
           * @property {string} style='solid' The border style of the cursor
           * @property {number} zIndex=3 The z-index of the cursor element
           * @property {object} customStyle An object with custom styles which are applied
           * to the cursor element
           * @property {boolean} showTime=false Show the time on the cursor.
           * @property {object} customShowTimeStyle An object with custom styles which are
           * applied to the cursor time element.
           * @property {string} followCursorY=false Use `true` to make the time on
           * the cursor follow the x and the y-position of the mouse. Use `false` to make the
           * it only follow the x-position of the mouse.
           * @property {function} formatTimeCallback Formats the timestamp on the cursor.
           */

          /**
           * Displays a thin line at the position of the cursor on the waveform.
           *
           * @implements {PluginClass}
           * @extends {Observer}
           * @example
           * // es6
           * import CursorPlugin from 'wavesurfer.cursor.js';
           *
           * // commonjs
           * var CursorPlugin = require('wavesurfer.cursor.js');
           *
           * // if you are using <script> tags
           * var CursorPlugin = window.WaveSurfer.cursor;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     CursorPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var CursorPlugin = /*#__PURE__*/function () {
            /**
             * Construct the plugin class. You probably want to use `CursorPlugin.create`
             * instead.
             *
             * @param {CursorPluginParams} params Plugin parameters
             * @param {object} ws Wavesurfer instance
             */
            function CursorPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, CursorPlugin);

              this.defaultParams = {
                hideOnBlur: true,
                width: '1px',
                color: 'black',
                opacity: '0.25',
                style: 'solid',
                zIndex: 4,
                customStyle: {},
                customShowTimeStyle: {},
                showTime: false,
                followCursorY: false,
                formatTimeCallback: null
              };

              this._onMousemove = function (e) {
                var bbox = _this.wavesurfer.container.getBoundingClientRect();

                var y = 0;
                var x = e.clientX - bbox.left;

                var flip = bbox.right < e.clientX + _this.outerWidth(_this.displayTime);

                if (_this.params.showTime && _this.params.followCursorY) {
                  // follow y-position of the mouse
                  y = e.clientY - (bbox.top + bbox.height / 2);
                }

                _this.updateCursorPosition(x, y, flip);
              };

              this._onMouseenter = function () {
                return _this.showCursor();
              };

              this._onMouseleave = function () {
                return _this.hideCursor();
              };

              this.wavesurfer = ws;
              this.style = ws.util.style;
              /**
               * The cursor HTML element
               *
               * @type {?HTMLElement}
               */

              this.cursor = null;
              /**
               * displays the time next to the cursor
               *
               * @type {?HTMLElement}
               */

              this.showTime = null;
              /**
               * The html container that will display the time
               *
               * @type {?HTMLElement}
               */

              this.displayTime = null;
              this.params = _extends({}, this.defaultParams, params);
            }
            /**
             * Initialise the plugin (used by the Plugin API)
             */

            _createClass(CursorPlugin, [{
              key: "init",
              value: function init() {
                this.wrapper = this.wavesurfer.container;
                this.cursor = this.wrapper.appendChild(this.style(document.createElement('cursor'), _extends({
                  position: 'absolute',
                  zIndex: this.params.zIndex,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  width: '0',
                  display: 'flex',
                  borderRightStyle: this.params.style,
                  borderRightWidth: this.params.width,
                  borderRightColor: this.params.color,
                  opacity: this.params.opacity,
                  pointerEvents: 'none'
                }, this.params.customStyle)));

                if (this.params.showTime) {
                  this.showTime = this.wrapper.appendChild(this.style(document.createElement('showTitle'), _extends({
                    position: 'absolute',
                    zIndex: this.params.zIndex,
                    left: 0,
                    top: 0,
                    bottom: 0,
                    width: 'auto',
                    display: 'flex',
                    opacity: this.params.opacity,
                    pointerEvents: 'none',
                    height: '100%'
                  }, this.params.customStyle)));
                  this.displayTime = this.showTime.appendChild(this.style(document.createElement('div'), _extends({
                    display: 'inline',
                    pointerEvents: 'none',
                    margin: 'auto',
                    visibility: 'hidden' // initial value will be hidden just for measuring purpose

                  }, this.params.customShowTimeStyle))); // initial value to measure display width

                  this.displayTime.innerHTML = this.formatTime(0);
                }

                this.wrapper.addEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  // ensure elements are hidden initially
                  this.hideCursor();
                  this.wrapper.addEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.addEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Destroy the plugin (used by the Plugin API)
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (this.params.showTime) {
                  this.cursor.parentNode.removeChild(this.showTime);
                }

                this.cursor.parentNode.removeChild(this.cursor);
                this.wrapper.removeEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  this.wrapper.removeEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.removeEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Update the cursor position
               *
               * @param {number} xpos The x offset of the cursor in pixels
               * @param {number} ypos The y offset of the cursor in pixels
               * @param {boolean} flip Flag to flip duration text from right to left
               */

            }, {
              key: "updateCursorPosition",
              value: function updateCursorPosition(xpos, ypos) {
                var flip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                this.style(this.cursor, {
                  left: "".concat(xpos, "px")
                });

                if (this.params.showTime) {
                  var duration = this.wavesurfer.getDuration();
                  var elementWidth = this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
                  var scrollWidth = this.wavesurfer.drawer.getScrollX();
                  var scrollTime = duration / this.wavesurfer.drawer.width * scrollWidth;
                  var timeValue = Math.max(0, xpos / elementWidth * duration) + scrollTime;
                  var formatValue = this.formatTime(timeValue);

                  if (flip) {
                    var textOffset = this.outerWidth(this.displayTime);
                    xpos -= textOffset;
                  }

                  this.style(this.showTime, {
                    left: "".concat(xpos, "px"),
                    top: "".concat(ypos, "px")
                  });
                  this.style(this.displayTime, {
                    visibility: 'visible'
                  });
                  this.displayTime.innerHTML = "".concat(formatValue);
                }
              }
              /**
               * Show the cursor
               */

            }, {
              key: "showCursor",
              value: function showCursor() {
                this.style(this.cursor, {
                  display: 'flex'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'flex'
                  });
                }
              }
              /**
               * Hide the cursor
               */

            }, {
              key: "hideCursor",
              value: function hideCursor() {
                this.style(this.cursor, {
                  display: 'none'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'none'
                  });
                }
              }
              /**
               * Format the timestamp for `cursorTime`.
               *
               * @param {number} cursorTime Time in seconds
               * @returns {string} Formatted timestamp
               */

            }, {
              key: "formatTime",
              value: function formatTime(cursorTime) {
                cursorTime = isNaN(cursorTime) ? 0 : cursorTime;

                if (this.params.formatTimeCallback) {
                  return this.params.formatTimeCallback(cursorTime);
                }

                return [cursorTime].map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2), // seconds
                  ('000' + Math.floor(time % 1 * 1000)).slice(-3) // milliseconds
                  ].join(':');
                });
              }
              /**
               * Get outer width of given element.
               *
               * @param {DOM} element DOM Element
               * @returns {number} outer width
               */

            }, {
              key: "outerWidth",
              value: function outerWidth(element) {
                if (!element) {
                  return 0;
                }

                var width = element.offsetWidth;
                var style = getComputedStyle(element);
                width += parseInt(style.marginLeft + style.marginRight);
                return width;
              }
            }], [{
              key: "create",
              value:
              /**
               * Cursor plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param  {CursorPluginParams} params parameters use to initialise the
               * plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'cursor',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {},
                  instance: CursorPlugin
                };
              }
              /**
               * @type {CursorPluginParams}
               */

            }]);

            return CursorPlugin;
          }();

          exports.default = CursorPlugin;
          module.exports = exports.default;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/cursor/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.cursor.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js regions plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["regions"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/regions/index.js":
        /*!*************************************!*\
          !*** ./src/plugin/regions/index.js ***!
          \*************************************/
        /***/function srcPluginRegionsIndexJs(module, exports, __webpack_require__) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _region = __webpack_require__( /*! ./region.js */"./src/plugin/regions/region.js");

          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {
                symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              }keys.push.apply(keys, symbols);
            }return keys;
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Regions are visual overlays on waveform that can be used to play and loop
           * portions of audio. Regions can be dragged and resized.
           *
           * Visual customization is possible via CSS (using the selectors
           * `.wavesurfer-region` and `.wavesurfer-handle`).
           *
           * @implements {PluginClass}
           * @extends {Observer}
           *
           * @example
           * // es6
           * import RegionsPlugin from 'wavesurfer.regions.js';
           *
           * // commonjs
           * var RegionsPlugin = require('wavesurfer.regions.js');
           *
           * // if you are using <script> tags
           * var RegionsPlugin = window.WaveSurfer.regions;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     RegionsPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var RegionsPlugin = /*#__PURE__*/function () {
            function RegionsPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, RegionsPlugin);

              this.params = params;
              this.wavesurfer = ws;
              this.util = _objectSpread(_objectSpread({}, ws.util), {}, {
                getRegionSnapToGridValue: function getRegionSnapToGridValue(value) {
                  return _this.getRegionSnapToGridValue(value, params);
                }
              });
              this.maxRegions = params.maxRegions;
              this.regionsMinLength = params.regionsMinLength || null; // turn the plugin instance into an observer

              var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
              observerPrototypeKeys.forEach(function (key) {
                _region.Region.prototype[key] = _this.util.Observer.prototype[key];
              });
              this.wavesurfer.Region = _region.Region; // By default, scroll the container if the user drags a region
              // within 5% of its edge

              var scrollWidthProportion = 0.05;

              this._onBackendCreated = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.orientation = _this.wavesurfer.drawer.orientation;

                if (_this.params.regions) {
                  _this.params.regions.forEach(function (region) {
                    region.edgeScrollWidth = _this.params.edgeScrollWidth || _this.wrapper.clientWidth * scrollWidthProportion;

                    _this.add(region);
                  });
                }
              }; // Id-based hash of regions


              this.list = {};

              this._onReady = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.vertical = _this.wavesurfer.drawer.params.vertical;

                if (_this.params.dragSelection) {
                  _this.enableDragSelection(_this.params);
                }

                Object.keys(_this.list).forEach(function (id) {
                  _this.list[id].updateRender();
                });
              };
            }

            _createClass(RegionsPlugin, [{
              key: "init",
              value: function init() {
                // Check if ws is ready
                if (this.wavesurfer.isReady) {
                  this._onBackendCreated();

                  this._onReady();
                } else {
                  this.wavesurfer.once('ready', this._onReady);
                  this.wavesurfer.once('backend-created', this._onBackendCreated);
                }
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.wavesurfer.un('ready', this._onReady);
                this.wavesurfer.un('backend-created', this._onBackendCreated);
                this.disableDragSelection();
                this.clear();
              }
              /**
               * check to see if adding a new region would exceed maxRegions
               * @return {boolean} whether we should proceed and create a region
               * @private
               */

            }, {
              key: "wouldExceedMaxRegions",
              value: function wouldExceedMaxRegions() {
                return this.maxRegions && Object.keys(this.list).length >= this.maxRegions;
              }
              /**
               * Add a region
               *
               * @param {object} params Region parameters
               * @return {Region} The created region
               */

            }, {
              key: "add",
              value: function add(params) {
                var _this2 = this;

                if (this.wouldExceedMaxRegions()) {
                  return null;
                }

                if (!params.minLength && this.regionsMinLength) {
                  params = _objectSpread(_objectSpread({}, params), {}, {
                    minLength: this.regionsMinLength
                  });
                }

                var region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);
                this.list[region.id] = region;
                region.on('remove', function () {
                  delete _this2.list[region.id];
                });
                return region;
              }
              /**
               * Remove all regions
               */

            }, {
              key: "clear",
              value: function clear() {
                var _this3 = this;

                Object.keys(this.list).forEach(function (id) {
                  _this3.list[id].remove();
                });
              }
            }, {
              key: "enableDragSelection",
              value: function enableDragSelection(params) {
                var _this4 = this;

                this.disableDragSelection();
                var slop = params.slop || 2;
                var container = this.wavesurfer.drawer.container;
                var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
                var scrollSpeed = params.scrollSpeed || 1;
                var scrollThreshold = params.scrollThreshold || 10;
                var drag;
                var duration = this.wavesurfer.getDuration();
                var maxScroll;
                var start;
                var region;
                var touchId;
                var pxMove = 0;
                var scrollDirection;
                var wrapperRect; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(e) {
                  if (!region || !scrollDirection) {
                    return;
                  } // Update scroll position


                  var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                  _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range

                  var end = _this4.wavesurfer.drawer.handleEvent(e);

                  region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                  }); // Check that there is more to scroll and repeat

                  if (scrollLeft < maxScroll && scrollLeft > 0) {
                    window.requestAnimationFrame(function () {
                      edgeScroll(e);
                    });
                  }
                };

                var eventDown = function eventDown(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  duration = _this4.wavesurfer.getDuration();
                  touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  drag = true;
                  start = _this4.wavesurfer.drawer.handleEvent(e, true);
                  region = null;
                  scrollDirection = null;
                };

                this.wrapper.addEventListener('mousedown', eventDown);
                this.wrapper.addEventListener('touchstart', eventDown);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchstart', eventDown);

                  _this4.wrapper.removeEventListener('mousedown', eventDown);
                });

                var eventUp = function eventUp(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  drag = false;
                  pxMove = 0;
                  scrollDirection = null;

                  if (region) {
                    _this4.util.preventClick();

                    region.fireEvent('update-end', e);

                    _this4.wavesurfer.fireEvent('region-update-end', region, e);
                  }

                  region = null;
                };

                this.wrapper.addEventListener('mouseleave', eventUp);
                this.wrapper.addEventListener('mouseup', eventUp);
                this.wrapper.addEventListener('touchend', eventUp);
                document.body.addEventListener('mouseup', eventUp);
                document.body.addEventListener('touchend', eventUp);
                this.on('disable-drag-selection', function () {
                  document.body.removeEventListener('mouseup', eventUp);
                  document.body.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('mouseup', eventUp);

                  _this4.wrapper.removeEventListener('mouseleave', eventUp);
                });

                var eventMove = function eventMove(event) {
                  if (!drag) {
                    return;
                  }

                  if (++pxMove <= slop) {
                    return;
                  }

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  } // auto-create a region during mouse drag, unless region-count would exceed "maxRegions"


                  if (!region) {
                    region = _this4.add(params || {});

                    if (!region) {
                      return;
                    }
                  }

                  var end = _this4.wavesurfer.drawer.handleEvent(event);

                  var startUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(start * duration);

                  var endUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(end * duration);

                  region.update({
                    start: Math.min(endUpdate, startUpdate),
                    end: Math.max(endUpdate, startUpdate)
                  });

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical); // If scrolling is enabled


                  if (scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Check threshold based on mouse
                    var x = orientedEvent.clientX - wrapperRect.left;

                    if (x <= scrollThreshold) {
                      scrollDirection = -1;
                    } else if (x >= wrapperRect.right - scrollThreshold) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    scrollDirection && edgeScroll(event);
                  }
                };

                this.wrapper.addEventListener('mousemove', eventMove);
                this.wrapper.addEventListener('touchmove', eventMove);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchmove', eventMove);

                  _this4.wrapper.removeEventListener('mousemove', eventMove);
                });
                this.wavesurfer.on('region-created', function (region) {
                  if (_this4.regionsMinLength) {
                    region.minLength = _this4.regionsMinLength;
                  }
                });
              }
            }, {
              key: "disableDragSelection",
              value: function disableDragSelection() {
                this.fireEvent('disable-drag-selection');
              }
              /**
               * Get current region
               *
               * The smallest region that contains the current time. If several such
               * regions exist, take the first. Return `null` if none exist.
               *
               * @returns {Region} The current region
               */

            }, {
              key: "getCurrentRegion",
              value: function getCurrentRegion() {
                var _this5 = this;

                var time = this.wavesurfer.getCurrentTime();
                var min = null;
                Object.keys(this.list).forEach(function (id) {
                  var cur = _this5.list[id];

                  if (cur.start <= time && cur.end >= time) {
                    if (!min || cur.end - cur.start < min.end - min.start) {
                      min = cur;
                    }
                  }
                });
                return min;
              }
              /**
               * Match the value to the grid, if required
               *
               * If the regions plugin params have a snapToGridInterval set, return the
               * value matching the nearest grid interval. If no snapToGridInterval is set,
               * the passed value will be returned without modification.
               *
               * @param {number} value the value to snap to the grid, if needed
               * @param {Object} params the regions plugin params
               * @returns {number} value
               */

            }, {
              key: "getRegionSnapToGridValue",
              value: function getRegionSnapToGridValue(value, params) {
                if (params.snapToGridInterval) {
                  // the regions should snap to a grid
                  var offset = params.snapToGridOffset || 0;
                  return Math.round((value - offset) / params.snapToGridInterval) * params.snapToGridInterval + offset;
                } // no snap-to-grid


                return value;
              }
            }], [{
              key: "create",
              value:
              /**
               * Regions plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param {RegionsPluginParams} params parameters use to initialise the plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'regions',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {
                    addRegion: function addRegion(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      return this.regions.add(options);
                    },
                    clearRegions: function clearRegions() {
                      this.regions && this.regions.clear();
                    },
                    enableDragSelection: function enableDragSelection(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      this.regions.enableDragSelection(options);
                    },
                    disableDragSelection: function disableDragSelection() {
                      this.regions.disableDragSelection();
                    }
                  },
                  instance: RegionsPlugin
                };
              }
            }]);

            return RegionsPlugin;
          }();

          exports.default = RegionsPlugin;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/plugin/regions/region.js":
        /*!**************************************!*\
          !*** ./src/plugin/regions/region.js ***!
          \**************************************/
        /***/function srcPluginRegionsRegionJs(__unused_webpack_module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Region = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           *  @since 4.0.0
           *
           * (Single) Region plugin class
           *
           * Must be turned into an observer before instantiating. This is done in
           * `RegionsPlugin` (main plugin class).
           *
           * @extends {Observer}
           */
          var Region = /*#__PURE__*/function () {
            function Region(params, regionsUtils, ws) {
              var _params$showTooltip,
                  _this = this;

              _classCallCheck(this, Region);

              this.wavesurfer = ws;
              this.wrapper = ws.drawer.wrapper;
              this.util = ws.util;
              this.style = this.util.style;
              this.regionsUtil = regionsUtils;
              this.vertical = ws.drawer.params.vertical;
              this.id = params.id == null ? ws.util.getId() : params.id;
              this.start = Number(params.start) || 0;
              this.end = params.end == null ? // small marker-like region
              this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
              this.resize = params.resize === undefined ? true : Boolean(params.resize);
              this.drag = params.drag === undefined ? true : Boolean(params.drag); // reflect resize and drag state of region for region-updated listener

              this.isResizing = false;
              this.isDragging = false;
              this.loop = Boolean(params.loop);
              this.color = params.color || 'rgba(0, 0, 0, 0.1)'; // The left and right handleStyle properties can be set to 'none' for
              // no styling or can be assigned an object containing CSS properties.

              this.handleStyle = params.handleStyle || {
                left: {},
                right: {}
              };
              this.handleLeftEl = null;
              this.handleRightEl = null;
              this.data = params.data || {};
              this.attributes = params.attributes || {};
              this.showTooltip = (_params$showTooltip = params.showTooltip) !== null && _params$showTooltip !== void 0 ? _params$showTooltip : true;
              this.maxLength = params.maxLength; // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided

              this.minLength = params.minLength;

              this._onRedraw = function () {
                return _this.updateRender();
              };

              this.scroll = params.scroll !== false && ws.params.scrollParent;
              this.scrollSpeed = params.scrollSpeed || 1;
              this.scrollThreshold = params.scrollThreshold || 10; // Determines whether the context menu is prevented from being opened.

              this.preventContextMenu = params.preventContextMenu === undefined ? false : Boolean(params.preventContextMenu); // select channel ID to set region

              var channelIdx = params.channelIdx == null ? -1 : parseInt(params.channelIdx);
              this.regionHeight = '100%';
              this.marginTop = '0px';

              if (channelIdx !== -1) {
                var channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : -1;

                if (channelCount >= 0 && channelIdx < channelCount) {
                  this.regionHeight = Math.floor(1 / channelCount * 100) + '%';
                  this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';
                }
              }

              this.formatTimeCallback = params.formatTimeCallback;
              this.edgeScrollWidth = params.edgeScrollWidth;
              this.bindInOut();
              this.render();
              this.wavesurfer.on('zoom', this._onRedraw);
              this.wavesurfer.on('redraw', this._onRedraw);
              this.wavesurfer.fireEvent('region-created', this);
            }
            /* Update region params. */

            _createClass(Region, [{
              key: "update",
              value: function update(params) {
                if (params.start != null) {
                  this.start = Number(params.start);
                }

                if (params.end != null) {
                  this.end = Number(params.end);
                }

                if (params.loop != null) {
                  this.loop = Boolean(params.loop);
                }

                if (params.color != null) {
                  this.color = params.color;
                }

                if (params.handleStyle != null) {
                  this.handleStyle = params.handleStyle;
                }

                if (params.data != null) {
                  this.data = params.data;
                }

                if (params.resize != null) {
                  this.resize = Boolean(params.resize);
                  this.updateHandlesResize(this.resize);
                }

                if (params.drag != null) {
                  this.drag = Boolean(params.drag);
                }

                if (params.maxLength != null) {
                  this.maxLength = Number(params.maxLength);
                }

                if (params.minLength != null) {
                  this.minLength = Number(params.minLength);
                }

                if (params.attributes != null) {
                  this.attributes = params.attributes;
                }

                this.updateRender();
                this.fireEvent('update');
                this.wavesurfer.fireEvent('region-updated', this);
              }
              /* Remove a single region. */

            }, {
              key: "remove",
              value: function remove() {
                if (this.element) {
                  this.wrapper.removeChild(this.element.domElement);
                  this.element = null;
                  this.fireEvent('remove');
                  this.wavesurfer.un('zoom', this._onRedraw);
                  this.wavesurfer.un('redraw', this._onRedraw);
                  this.wavesurfer.fireEvent('region-removed', this);
                }
              }
              /**
               * Play the audio region.
               * @param {number} start Optional offset to start playing at
               */

            }, {
              key: "play",
              value: function play(start) {
                var s = start || this.start;
                this.wavesurfer.play(s, this.end);
                this.fireEvent('play');
                this.wavesurfer.fireEvent('region-play', this);
              }
              /**
               * Play the audio region in a loop.
               * @param {number} start Optional offset to start playing at
               * */

            }, {
              key: "playLoop",
              value: function playLoop(start) {
                this.loop = true;
                this.play(start);
              }
              /**
               * Set looping on/off.
               * @param {boolean} loop True if should play in loop
               */

            }, {
              key: "setLoop",
              value: function setLoop(loop) {
                this.loop = loop;
              }
              /* Render a region as a DOM element. */

            }, {
              key: "render",
              value: function render() {
                this.element = this.util.withOrientation(this.wrapper.appendChild(document.createElement('region')), this.vertical);
                this.element.className = 'wavesurfer-region';

                if (this.showTooltip) {
                  this.element.title = this.formatTime(this.start, this.end);
                }

                this.element.setAttribute('data-id', this.id);

                for (var attrname in this.attributes) {
                  this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                }

                this.style(this.element, {
                  position: 'absolute',
                  zIndex: 2,
                  height: this.regionHeight,
                  top: this.marginTop
                });
                /* Resize handles */

                if (this.resize) {
                  this.handleLeftEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleRightEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';
                  this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end'; // Default CSS properties for both handles.

                  var css = {
                    cursor: this.vertical ? 'row-resize' : 'col-resize',
                    position: 'absolute',
                    top: '0px',
                    width: '2px',
                    height: '100%',
                    backgroundColor: 'rgba(0, 0, 0, 1)'
                  }; // Merge CSS properties per handle.

                  var handleLeftCss = this.handleStyle.left !== 'none' ? _extends({
                    left: '0px'
                  }, css, this.handleStyle.left) : null;
                  var handleRightCss = this.handleStyle.right !== 'none' ? _extends({
                    right: '0px'
                  }, css, this.handleStyle.right) : null;

                  if (handleLeftCss) {
                    this.style(this.handleLeftEl, handleLeftCss);
                  }

                  if (handleRightCss) {
                    this.style(this.handleRightEl, handleRightCss);
                  }
                }

                this.updateRender();
                this.bindEvents();
              }
            }, {
              key: "formatTime",
              value: function formatTime(start, end) {
                if (this.formatTimeCallback) {
                  return this.formatTimeCallback(start, end);
                }

                return (start == end ? [start] : [start, end]).map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2) // seconds
                  ].join(':');
                }).join('-');
              }
            }, {
              key: "getWidth",
              value: function getWidth() {
                return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
              }
              /* Update element's position, width, color. */

            }, {
              key: "updateRender",
              value: function updateRender() {
                // duration varies during loading process, so don't overwrite important data
                var dur = this.wavesurfer.getDuration();
                var width = this.getWidth();
                var startLimited = this.start;
                var endLimited = this.end;

                if (startLimited < 0) {
                  startLimited = 0;
                  endLimited = endLimited - startLimited;
                }

                if (endLimited > dur) {
                  endLimited = dur;
                  startLimited = dur - (endLimited - startLimited);
                }

                if (this.minLength != null) {
                  endLimited = Math.max(startLimited + this.minLength, endLimited);
                }

                if (this.maxLength != null) {
                  endLimited = Math.min(startLimited + this.maxLength, endLimited);
                }

                if (this.element != null) {
                  // Calculate the left and width values of the region such that
                  // no gaps appear between regions.
                  var left = Math.round(startLimited / dur * width);
                  var regionWidth = Math.round(endLimited / dur * width) - left;
                  this.style(this.element, {
                    left: left + 'px',
                    width: regionWidth + 'px',
                    backgroundColor: this.color,
                    cursor: this.drag ? 'move' : 'default'
                  });

                  for (var attrname in this.attributes) {
                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                  }

                  if (this.showTooltip) {
                    this.element.title = this.formatTime(this.start, this.end);
                  }
                }
              }
              /* Bind audio events. */

            }, {
              key: "bindInOut",
              value: function bindInOut() {
                var _this2 = this;

                this.firedIn = false;
                this.firedOut = false;

                var onProcess = function onProcess(time) {
                  var start = Math.round(_this2.start * 10) / 10;
                  var end = Math.round(_this2.end * 10) / 10;
                  time = Math.round(time * 10) / 10;

                  if (!_this2.firedOut && _this2.firedIn && (start > time || end <= time)) {
                    _this2.firedOut = true;
                    _this2.firedIn = false;

                    _this2.fireEvent('out');

                    _this2.wavesurfer.fireEvent('region-out', _this2);
                  }

                  if (!_this2.firedIn && start <= time && end > time) {
                    _this2.firedIn = true;
                    _this2.firedOut = false;

                    _this2.fireEvent('in');

                    _this2.wavesurfer.fireEvent('region-in', _this2);
                  }
                };

                this.wavesurfer.backend.on('audioprocess', onProcess);
                this.on('remove', function () {
                  _this2.wavesurfer.backend.un('audioprocess', onProcess);
                });
                /* Loop playback. */

                this.on('out', function () {
                  if (_this2.loop) {
                    var realTime = _this2.wavesurfer.getCurrentTime();

                    if (realTime >= _this2.start && realTime <= _this2.end) {
                      _this2.wavesurfer.play(_this2.start);
                    }
                  }
                });
              }
              /* Bind DOM events. */

            }, {
              key: "bindEvents",
              value: function bindEvents() {
                var _this3 = this;

                var preventContextMenu = this.preventContextMenu;
                this.element.addEventListener('mouseenter', function (e) {
                  _this3.fireEvent('mouseenter', e);

                  _this3.wavesurfer.fireEvent('region-mouseenter', _this3, e);
                });
                this.element.addEventListener('mouseleave', function (e) {
                  _this3.fireEvent('mouseleave', e);

                  _this3.wavesurfer.fireEvent('region-mouseleave', _this3, e);
                });
                this.element.addEventListener('click', function (e) {
                  e.preventDefault();

                  _this3.fireEvent('click', e);

                  _this3.wavesurfer.fireEvent('region-click', _this3, e);
                });
                this.element.addEventListener('dblclick', function (e) {
                  e.stopPropagation();
                  e.preventDefault();

                  _this3.fireEvent('dblclick', e);

                  _this3.wavesurfer.fireEvent('region-dblclick', _this3, e);
                });
                this.element.addEventListener('contextmenu', function (e) {
                  if (preventContextMenu) {
                    e.preventDefault();
                  }

                  _this3.fireEvent('contextmenu', e);

                  _this3.wavesurfer.fireEvent('region-contextmenu', _this3, e);
                });
                /* Drag or resize on mousemove. */

                if (this.drag || this.resize) {
                  this.bindDragEvents();
                }
              }
            }, {
              key: "bindDragEvents",
              value: function bindDragEvents() {
                var _this4 = this;

                var container = this.wavesurfer.drawer.container;
                var scrollSpeed = this.scrollSpeed;
                var scrollThreshold = this.scrollThreshold;
                var startTime;
                var touchId;
                var drag;
                var maxScroll;
                var resize;
                var updated = false;
                var scrollDirection;
                var wrapperRect;
                var regionLeftHalfTime;
                var regionRightHalfTime; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(event) {
                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  var duration = _this4.wavesurfer.getDuration();

                  if (!scrollDirection || !drag && !resize) {
                    return;
                  }

                  var x = orientedEvent.clientX;
                  var distanceBetweenCursorAndWrapperEdge = 0;
                  var regionHalfTimeWidth = 0;
                  var adjustment = 0; // Get the currently selected time according to the mouse position

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // Considering the point of contact with the region while edgescrolling
                    if (scrollDirection === -1) {
                      regionHalfTimeWidth = regionLeftHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;
                    } else {
                      regionHalfTimeWidth = regionRightHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;
                    }
                  } else {
                    // Considering minLength while edgescroll
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  } // Don't edgescroll if region has reached min or max limit


                  var wrapperScrollLeft = _this4.wrapper.scrollLeft;

                  if (scrollDirection === -1) {
                    if (Math.round(wrapperScrollLeft) === 0) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {
                      return;
                    }
                  } else {
                    if (Math.round(wrapperScrollLeft) === maxScroll) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {
                      return;
                    }
                  } // Update scroll position


                  var scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;

                  if (scrollDirection === -1) {
                    var calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedLeft;
                  } else {
                    var calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedRight;
                  }

                  var delta = time - startTime;
                  startTime = time; // Continue dragging or resizing

                  drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize); // Repeat

                  window.requestAnimationFrame(function () {
                    edgeScroll(event);
                  });
                };

                var onDown = function onDown(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  touchId = event.targetTouches ? event.targetTouches[0].identifier : null; // stop the event propagation, if this region is resizable or draggable
                  // and the event is therefore handled here.

                  if (_this4.drag || _this4.resize) {
                    event.stopPropagation();
                  } // Store the selected startTime we begun dragging or resizing


                  startTime = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event, true) * duration); // Store the selected point of contact when we begin dragging

                  regionLeftHalfTime = startTime - _this4.start;
                  regionRightHalfTime = _this4.end - startTime; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  _this4.isResizing = false;
                  _this4.isDragging = false;

                  if (event.target.tagName.toLowerCase() === 'handle') {
                    _this4.isResizing = true;
                    resize = event.target.classList.contains('wavesurfer-handle-start') ? 'start' : 'end';
                  } else {
                    _this4.isDragging = true;
                    drag = true;
                    resize = false;
                  }
                };

                var onUp = function onUp(event) {
                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (drag || resize) {
                    _this4.isDragging = false;
                    _this4.isResizing = false;
                    drag = false;
                    scrollDirection = null;
                    resize = false;
                  }

                  if (updated) {
                    updated = false;

                    _this4.util.preventClick();

                    _this4.fireEvent('update-end', event);

                    _this4.wavesurfer.fireEvent('region-update-end', _this4, event);
                  }
                };

                var onMove = function onMove(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  }

                  if (!drag && !resize) {
                    return;
                  }

                  var oldTime = startTime;

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // To maintain relative cursor start point while dragging
                    var maxEnd = _this4.wavesurfer.getDuration();

                    if (time > maxEnd - regionRightHalfTime) {
                      time = maxEnd - regionRightHalfTime;
                    }

                    if (time - regionLeftHalfTime < 0) {
                      time = regionLeftHalfTime;
                    }
                  }

                  if (resize) {
                    // To maintain relative cursor start point while resizing
                    // we have to handle for minLength
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  }

                  var delta = time - startTime;
                  startTime = time; // Drag

                  if (_this4.drag && drag) {
                    updated = updated || !!delta;

                    _this4.onDrag(delta);
                  } // Resize


                  if (_this4.resize && resize) {
                    updated = updated || !!delta;

                    _this4.onResize(delta, resize);
                  }

                  if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Triggering edgescroll from within edgeScrollWidth
                    var x = orientedEvent.clientX; // Check direction

                    if (x < wrapperRect.left + _this4.edgeScrollWidth) {
                      scrollDirection = -1;
                    } else if (x > wrapperRect.right - _this4.edgeScrollWidth) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    if (scrollDirection) {
                      edgeScroll(event);
                    }
                  }
                };

                this.element.addEventListener('mousedown', onDown);
                this.element.addEventListener('touchstart', onDown);
                document.body.addEventListener('mousemove', onMove);
                document.body.addEventListener('touchmove', onMove, {
                  passive: false
                });
                document.addEventListener('mouseup', onUp);
                document.body.addEventListener('touchend', onUp);
                this.on('remove', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                  document.body.removeEventListener('mousemove', onMove);
                  document.body.removeEventListener('touchmove', onMove);
                });
                this.wavesurfer.on('destroy', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                });
              }
            }, {
              key: "onDrag",
              value: function onDrag(delta) {
                var maxEnd = this.wavesurfer.getDuration();

                if (this.end + delta > maxEnd) {
                  delta = maxEnd - this.end;
                }

                if (this.start + delta < 0) {
                  delta = this.start * -1;
                }

                this.update({
                  start: this.start + delta,
                  end: this.end + delta
                });
              }
              /**
               * @example
               * onResize(-5, 'start') // Moves the start point 5 seconds back
               * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward
               *
               * @param {number} delta How much to add or subtract, given in seconds
               * @param {string} direction 'start 'or 'end'
               */

            }, {
              key: "onResize",
              value: function onResize(delta, direction) {
                var duration = this.wavesurfer.getDuration();

                if (direction === 'start') {
                  // Check if changing the start by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta > 0 && this.end - (this.start + delta) < this.minLength) {
                    delta = this.end - this.minLength - this.start;
                  }

                  if (delta < 0 && this.start + delta < 0) {
                    delta = this.start * -1;
                  }

                  this.update({
                    start: Math.min(this.start + delta, this.end),
                    end: Math.max(this.start + delta, this.end)
                  });
                } else {
                  // Check if changing the end by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta < 0 && this.end + delta - this.start < this.minLength) {
                    delta = this.start + this.minLength - this.end;
                  }

                  if (delta > 0 && this.end + delta > duration) {
                    delta = duration - this.end;
                  }

                  this.update({
                    start: Math.min(this.end + delta, this.start),
                    end: Math.max(this.end + delta, this.start)
                  });
                }
              }
            }, {
              key: "updateHandlesResize",
              value: function updateHandlesResize(resize) {
                var cursorStyle;

                if (resize) {
                  cursorStyle = this.vertical ? 'row-resize' : 'col-resize';
                } else {
                  cursorStyle = 'auto';
                }

                this.handleLeftEl && this.style(this.handleLeftEl, {
                  cursor: cursorStyle
                });
                this.handleRightEl && this.style(this.handleRightEl, {
                  cursor: cursorStyle
                });
              }
            }]);

            return Region;
          }();

          exports.Region = Region;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/regions/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.regions.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMjE4YTU5M2NhNTA1ZDdlNDFhZmIiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0LmpzIiwid2VicGFjazovLy8uL3N0eWxlcy93YXZlZm9ybS5jc3M/M2MzZCIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL1dhdmVmb3JtSW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaDVwLXBhcmVudC9zcmMvcGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oNXAtcGFyZW50L3NyYy9jaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJsIiwiaSIsIkg1UCIsIkg1UEVkaXRvciIsIndpZGdldHMiLCJ3YXZlZm9ybUluaXQiLCJXYXZlZm9ybUluaXQiLCJwYXJlbnQiLCJmaWVsZCIsInBhcmFtcyIsInNldFZhbHVlIiwiaWQiLCJjckF1ZGlvSW5kZXgiLCJjb250YWluZXIiLCJhdWRpb1BhcmFtcyIsInN0YXJ0VGltZSIsInN0YXJ0RHVyYXRpb24iLCJ1bmRlZmluZWQiLCJlbmRUaW1lIiwiZW5kRHVyYXRpb24iLCJhdWRpb0R1cmF0aW9uIiwicHJvdG90eXBlIiwiY3JlYXRlIiwiUGFyZW50IiwiY29uc3RydWN0b3IiLCJpbml0Iiwic2VsZiIsImxlbmd0aCIsIndhdmVzdXJmZXIiLCJXYXZlU3VyZmVyIiwid2F2ZUNvbG9yIiwicHJvZ3Jlc3NDb2xvciIsImZpbGxQYXJlbnQiLCJyZXNwb25zaXZlIiwiYmFySGVpZ2h0IiwicGx1Z2lucyIsIlJlZ2lvbnNQbHVnaW4iLCJyZWdpb25zTWluTGVuZ3RoIiwibWF4UmVnaW9ucyIsInJlZ2lvbnMiLCJzdGFydCIsImVuZCIsImxvb3AiLCJjb2xvciIsImRyYWdTZWxlY3Rpb24iLCJzbG9wIiwiY3NzIiwicmVnaW9uIiwicmVuZGVyYWJsZUNvbW1vbkZpZWxkcyIsImZpZWxkcyIsInN1YkNvbnRlbnRJZCIsInBhdGgiLCJmaWxlcyIsImZpbGUiLCJnZXRQYXRoIiwiJCIsImRvbmUiLCJzZXRUaW1lb3V0IiwibG9hZCIsImZhaWwiLCJjb250ZW50SWQiLCJvbiIsInZhbHVlcyIsImxpc3QiLCJ3aWR0aCIsImNwIiwiZ2V0RHVyYXRpb24iLCJ3YXZlZm9ybSIsIndhdmVmb3JtUGFyZW50IiwicGFyZW50RWxlbWVudCIsImNvbnNvbGUiLCJsb2ciLCJzdGFydER1cmF0aW9uRmllbGQiLCJxdWVyeVNlbGVjdG9yIiwiZW5kRHVyYXRpb25GaWVsZCIsInN0YXJ0RHVyYXRpb25GaWVsZElucHV0IiwiZW5kRHVyYXRpb25GaWVsZElucHV0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ2YWx1ZSIsInRhcmdldCIsImlzTmFOIiwicGFyc2VGbG9hdCIsImlucHV0U3RhcnRUaW1lIiwiaW5wdXRFbmRUaW1lIiwidG9GaXhlZCIsInVwZGF0ZSIsImZpbmQiLCJhcHBlbmQiLCJldmVudCIsIiRzdGFydGlucHV0IiwiJGVuZGlucHV0IiwidmFsIiwiZmluZEZpZWxkIiwicGFyZW50cyIsImZpcnN0IiwicmVnaW9uSWQiLCIkcGxheVJlZ2lvbkJ1dHRvbiIsInBsYXkiLCJhcHBlbmRUbyIsIiR3cmFwcGVyIiwibnMiLCJnZXROZXh0RmllbGRJZCIsImh0bWwiLCJjcmVhdGVGaWVsZE1hcmt1cCIsIiRpdGVtIiwic2V0SWQiLCJ3b3JkVGV4dCIsInRleHQiLCJjaGVja0JveEVsZW1lbnRGb3JXb3JkIiwiZ2V0U2VudGVuY2UiLCJzbGlkZXMiLCJjdXJySW5kZXgiLCJpcyIsImF0dHIiLCIkd29yZCIsInRyaW0iLCJyZXBsYWNlIiwidGVtcFdvcmRUZXh0IiwibmFtZSIsInZhbGlkYXRlIiwic2xpZGVJbmRleCIsInByZXZEYXRhIiwic2VudGVuY2VXb3JkcyIsInNwbGl0dGVkUHJldkRhdGEiLCJzcGxpdCIsImVsZW1lbnRzIiwiYWN0aW9uIiwibGlicmFyeSIsImNoZWNrQm94V29yZCIsImlubmVyVGV4dCIsImoiLCJkZWYiLCJpbmRleE9mIiwicmVtb3ZlIiwiQ2hpbGQiLCJyZXF1aXJlIiwiRXZlbnREaXNwYXRjaGVyIiwicGFyYW1ldGVycyIsImNhbGwiLCJ1cGRhdGVJbmRleGVzIiwiZnJvbSIsImluZGV4IiwiYWRkQ2hpbGQiLCJjaGlsZFBhcmFtZXRlcnMiLCJpbnN0YW5jZSIsInB1c2giLCJzcGxpY2UiLCJyZW1vdmVDaGlsZCIsIm1vdmVDaGlsZCIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJjaGlsZCIsImpRdWVyeSIsIkpvdWJlbFVJIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZGVmYXVsdCIsIl9zdHlsZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZ2V0SWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiQ2FudmFzRW50cnkiLCJ3YXZlIiwid2F2ZUN0eCIsInByb2dyZXNzIiwicHJvZ3Jlc3NDdHgiLCJ0b0xvd2VyQ2FzZSIsImNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzIiwiaW5pdFdhdmUiLCJlbGVtZW50IiwiZ2V0Q29udGV4dCIsImluaXRQcm9ncmVzcyIsInVwZGF0ZURpbWVuc2lvbnMiLCJlbGVtZW50V2lkdGgiLCJ0b3RhbFdpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0TGVmdCIsImVsZW1lbnRTaXplIiwiaGFzUHJvZ3Jlc3NDYW52YXMiLCJjbGVhcldhdmUiLCJjbGVhclJlY3QiLCJjYW52YXMiLCJzZXRGaWxsU3R5bGVzIiwiZmlsbFN0eWxlIiwiYXBwbHlDYW52YXNUcmFuc2Zvcm1zIiwidmVydGljYWwiLCJzZXRUcmFuc2Zvcm0iLCJmaWxsUmVjdHMiLCJ4IiwieSIsInJhZGl1cyIsImZpbGxSZWN0VG9Db250ZXh0IiwiY3R4IiwiZHJhd1JvdW5kZWRSZWN0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiY2xvc2VQYXRoIiwiZmlsbCIsImRyYXdMaW5lcyIsInBlYWtzIiwiYWJzbWF4IiwiaGFsZkgiLCJvZmZzZXRZIiwiZHJhd0xpbmVUb0NvbnRleHQiLCJNYXRoIiwicm91bmQiLCJsYXN0IiwiY2FudmFzU3RhcnQiLCJjYW52YXNFbmQiLCJzY2FsZSIsImhhbGZPZmZzZXQiLCJhYnNtYXhIYWxmIiwicGVhayIsImgiLCJoYWxmUGl4ZWwiLCJkZXN0cm95IiwiZ2V0SW1hZ2UiLCJmb3JtYXQiLCJxdWFsaXR5IiwidHlwZSIsIl90aGlzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0b0Jsb2IiLCJ0b0RhdGFVUkwiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ1dGlsIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImhhc093blByb3BlcnR5IiwiZGVzYyIsInNldCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImdldFByb3RvdHlwZU9mIiwiRHJhd2VyIiwiX3V0aWwkT2JzZXJ2ZXIiLCJfc3VwZXIiLCJ3aXRoT3JpZW50YXRpb24iLCJwaXhlbFJhdGlvIiwibGFzdFBvcyIsIndyYXBwZXIiLCJzdHlsZSIsImVsIiwic3R5bGVzIiwiY3JlYXRlV3JhcHBlciIsImFwcGVuZENoaWxkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheSIsInBvc2l0aW9uIiwidXNlclNlbGVjdCIsIndlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxQYXJlbnQiLCJvdmVyZmxvd1giLCJoaWRlU2Nyb2xsYmFyIiwib3ZlcmZsb3dZIiwic2V0dXBXcmFwcGVyRXZlbnRzIiwiaGFuZGxlRXZlbnQiLCJub1ByZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImNsaWVudFgiLCJ0YXJnZXRUb3VjaGVzIiwiYmJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm5vbWluYWxXaWR0aCIsInBhcmVudFdpZHRoIiwiZ2V0V2lkdGgiLCJwcm9ncmVzc1BpeGVscyIsImdldFByb2dyZXNzUGl4ZWxzIiwic2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwiY2xhbXAiLCJ3cmFwcGVyQmJveCIsInJ0bCIsInJpZ2h0IiwibGVmdCIsIl90aGlzMiIsIm9yaWVudGVkRXZlbnQiLCJzY3JvbGxiYXJIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRZIiwiYm90dG9tIiwiaW50ZXJhY3QiLCJmaXJlRXZlbnQiLCJkcmF3UGVha3MiLCJzZXRXaWR0aCIsImJhcldpZHRoIiwiZHJhd0JhcnMiLCJkcmF3V2F2ZSIsInJlc2V0U2Nyb2xsIiwicmVjZW50ZXIiLCJwZXJjZW50IiwicmVjZW50ZXJPblBvc2l0aW9uIiwiaW1tZWRpYXRlIiwiaGFsZiIsImNsaWVudFdpZHRoIiwibWF4U2Nyb2xsIiwib2Zmc2V0IiwicmF0ZSIsImF1dG9DZW50ZXJSYXRlIiwibWF4IiwibWluIiwiZ2V0U2Nyb2xsWCIsIm5ld1dpZHRoIiwidXBkYXRlU2l6ZSIsInNldEhlaWdodCIsIl9wcm9ncmVzcyIsIm1pblB4RGVsdGEiLCJwb3MiLCJhdXRvQ2VudGVyIiwibmV3UG9zIiwiYXV0b0NlbnRlckltbWVkaWF0ZWx5IiwidXBkYXRlUHJvZ3Jlc3MiLCJ1bkFsbCIsInBhcmVudE5vZGUiLCJkb21FbGVtZW50IiwidXBkYXRlQ3Vyc29yIiwiY2hhbm5lbEluZGV4IiwiT2JzZXJ2ZXIiLCJfZHJhd2VyIiwiX2RyYXdlcjIiLCJNdWx0aUNhbnZhcyIsIl9EcmF3ZXIiLCJtYXhDYW52YXNXaWR0aCIsIm1heENhbnZhc0VsZW1lbnRXaWR0aCIsImNhbnZhc2VzIiwicHJvZ3Jlc3NXYXZlIiwiRW50cnlDbGFzcyIsImRyYXdpbmdDb250ZXh0QXR0cmlidXRlcyIsIm92ZXJsYXAiLCJjZWlsIiwiYmFyUmFkaXVzIiwiY3JlYXRlRWxlbWVudHMiLCJ6SW5kZXgiLCJ0b3AiLCJvdmVyZmxvdyIsImJveFNpemluZyIsImJvcmRlclJpZ2h0U3R5bGUiLCJwb2ludGVyRXZlbnRzIiwiYWRkQ2FudmFzIiwiYm9yZGVyUmlnaHRXaWR0aCIsImN1cnNvcldpZHRoIiwiYm9yZGVyUmlnaHRDb2xvciIsImN1cnNvckNvbG9yIiwicmVxdWlyZWRDYW52YXNlcyIsInJlbW92ZUNhbnZhcyIsImNhbnZhc1dpZHRoIiwibGFzdENhbnZhcyIsImZvckVhY2giLCJlbnRyeSIsImxlZnRPZmZzZXQiLCJsYXN0RW50cnkiLCJwb3AiLCJfdGhpczMiLCJmcmFtZSIsIl90aGlzNCIsInByZXBhcmVEcmF3IiwiX3JlZiIsImhhc01pblZhbHMiLCJjaCIsInBlYWtJbmRleFNjYWxlIiwiYmFyIiwiZ2FwIiwiYmFyR2FwIiwic3RlcCIsImZsb29yIiwiYmFyTWluSGVpZ2h0IiwiX3RoaXM1IiwiX3JlZjIiLCJyZWZsZWN0ZWRQZWFrcyIsImxlbiIsImRyYXdMaW5lIiwiX3RoaXM2IiwiX3JlZjMiLCJzcGxpdENoYW5uZWxzT3B0aW9ucyIsImNoYW5uZWxDb2xvcnMiLCJzdGFydENhbnZhcyIsImVuZENhbnZhcyIsImludGVyc2VjdGlvbiIsIngxIiwieTEiLCJ4MiIsInkyIiwiX3JlZjQiLCJoaWRlQ2hhbm5lbCIsInNwbGl0Q2hhbm5lbHMiLCJmaWx0ZXJDaGFubmVscyIsImluY2x1ZGVzIiwiZm4iLCJkcmF3SW5kZXgiLCJub3JtYWxpemVkTWF4IiwiX3RoaXM3IiwiQXJyYXkiLCJjaGFubmVscyIsImZpbHRlcmVkQ2hhbm5lbHMiLCJmaWx0ZXIiLCJjIiwib3ZlcmxheSIsIm92ZXJhbGxBYnNNYXgiLCJyZWxhdGl2ZU5vcm1hbGl6YXRpb24iLCJtYXAiLCJjaGFubmVsUGVha3MiLCJhYnNNYXgiLCJub3JtYWxpemUiLCJzb21lIiwiYWxsIiwiaW1hZ2VzIiwiX21lZGlhZWxlbWVudCIsIl9nZXQiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiYmFzZSIsIl9zdXBlclByb3BCYXNlIiwib2JqZWN0IiwiTWVkaWFFbGVtZW50V2ViQXVkaW8iLCJfTWVkaWFFbGVtZW50Iiwic291cmNlTWVkaWFFbGVtZW50Iiwic2V0UGxheWJhY2tSYXRlIiwiYXVkaW9SYXRlIiwiY3JlYXRlVGltZXIiLCJjcmVhdGVWb2x1bWVOb2RlIiwiY3JlYXRlU2NyaXB0Tm9kZSIsImNyZWF0ZUFuYWx5c2VyTm9kZSIsIl9sb2FkIiwibWVkaWEiLCJwcmVsb2FkIiwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlIiwibWVkaWFFbGVtZW50IiwiYWMiLCJjb25uZWN0IiwiYW5hbHlzZXIiLCJyZXN1bWVBdWRpb0NvbnRleHQiLCJkZXN0cm95V2ViQXVkaW8iLCJfd2ViYXVkaW8iLCJNZWRpYUVsZW1lbnQiLCJfV2ViQXVkaW8iLCJjdXJyZW50VGltZSIsImR1cmF0aW9uIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicGF1c2UiLCJ2b2x1bWUiLCJtZWRpYVR5cGUiLCJlbGVtZW50UG9zaXRpb24iLCJpc011dGVkIiwiYnVmZmVyIiwib25QbGF5RW5kIiwibWVkaWFMaXN0ZW5lcnMiLCJfc2V0dXBNZWRpYUxpc3RlbmVycyIsImVycm9yIiwiY2FucGxheSIsImVuZGVkIiwic2Vla2VkIiwidm9sdW1lY2hhbmdlIiwibXV0ZWQiLCJrZXlzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uQXVkaW9Qcm9jZXNzIiwiaXNQYXVzZWQiLCJnZXRDdXJyZW50VGltZSIsInVybCIsImNvbnRyb2xzIiwibWVkaWFDb250cm9scyIsImF1dG9wbGF5Iiwic3JjIiwicHJldk1lZGlhIiwibG9hZEVsdCIsImVsdCIsIkhUTUxNZWRpYUVsZW1lbnQiLCJFcnJvciIsInNldFZvbHVtZSIsImV4cGxpY2l0RHVyYXRpb24iLCJJbmZpbml0eSIsInNlZWthYmxlIiwiZ2V0UGxheWVkUGVyY2VudHMiLCJnZXRQbGF5YmFja1JhdGUiLCJzZWVrVG8iLCJjbGVhclBsYXlFbmQiLCJwcm9taXNlIiwic2V0UGxheUVuZCIsIl9vblBsYXlFbmQiLCJ0aW1lIiwidW4iLCJnZXRQZWFrcyIsInNldFNpbmtJZCIsImRldmljZUlkIiwicmVqZWN0IiwiZ2V0Vm9sdW1lIiwic2V0TXV0ZSIsImRlc3Ryb3llZCIsInJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveSIsIlBlYWtDYWNoZSIsImNsZWFyUGVha0NhY2hlIiwicGVha0NhY2hlUmFuZ2VzIiwicGVha0NhY2hlTGVuZ3RoIiwiYWRkUmFuZ2VUb1BlYWtDYWNoZSIsInVuY2FjaGVkUmFuZ2VzIiwiaXRlbSIsImFyciIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsInVuY2FjaGVkUmFuZ2VQYWlycyIsImdldENhY2hlUmFuZ2VzIiwicGVha0NhY2hlUmFuZ2VQYWlycyIsIl9tYXgiLCJfbWluIiwiZmV0Y2hGaWxlIiwiX29ic2VydmVyIiwiUHJvZ3Jlc3NIYW5kbGVyIiwiY29udGVudExlbmd0aCIsInJlc3BvbnNlIiwiX3JlYWRlciIsImJvZHkiLCJnZXRSZWFkZXIiLCJ0b3RhbCIsInBhcnNlSW50IiwibG9hZGVkIiwiY29udHJvbGxlciIsInJlYWQiLCJ0aGVuIiwib25Qcm9ncmVzcyIsImxlbmd0aENvbXB1dGFibGUiLCJjbG9zZSIsImJ5dGVMZW5ndGgiLCJlbnF1ZXVlIiwiY2F0Y2giLCJvcHRpb25zIiwiZmV0Y2hIZWFkZXJzIiwiSGVhZGVycyIsImZldGNoUmVxdWVzdCIsIlJlcXVlc3QiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXF1ZXN0SGVhZGVycyIsImhlYWRlciIsInJlc3BvbnNlVHlwZSIsImZldGNoT3B0aW9ucyIsIm1ldGhvZCIsImhlYWRlcnMiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsInJlZmVycmVyIiwic2lnbmFsIiwiZmV0Y2giLCJwcm9ncmVzc0F2YWlsYWJsZSIsIlJlc3BvbnNlIiwiUmVhZGFibGVTdHJlYW0iLCJlcnJNc2ciLCJvayIsImFycmF5QnVmZmVyIiwianNvbiIsImJsb2IiLCJzdGF0dXMiLCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnVuYyIsIl9sZW4iLCJhcmdzIiwiX2tleSIsImdldElkIiwicHJlZml4IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9hYnNNYXgiLCJfZnJhbWUiLCJfZGVib3VuY2UiLCJfcHJldmVudENsaWNrIiwiX2ZldGNoIiwiX2NsYW1wIiwiX29yaWVudGF0aW9uIiwibGFyZ2VzdCIsInNtYWxsZXN0IiwiTnVtYmVyIiwiX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnMiLCJoYW5kbGVycyIsImNhbGxiYWNrIiwib25jZSIsImhhbmRsZXIiLCJzZXREaXNhYmxlZEV2ZW50RW1pc3Npb25zIiwiZXZlbnROYW1lcyIsIl9pc0Rpc2FibGVkRXZlbnRFbWlzc2lvbiIsIl9sZW4yIiwiX2tleTIiLCJ2ZXJ0aWNhbFByb3BNYXAiLCJvZmZzZXRUb3AiLCJvZmZzZXRXaWR0aCIsIm1hcFByb3AiLCJwcm9wIiwiaXNQcm94eSIsImJpbmQiLCJwcmV2ZW50Q2xpY2siLCJwcmV2ZW50Q2xpY2tIYW5kbGVyIiwic3RvcFByb3BhZ2F0aW9uIiwiX2RlZmF1bHQiLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfcGVha2NhY2hlIiwiX21lZGlhZWxlbWVudFdlYmF1ZGlvIiwiUGx1Z2luQ2xhc3MiLCJ3cyIsImRlZmF1bHRQYXJhbXMiLCJhdWRpb0NvbnRleHQiLCJhdWRpb1NjcmlwdFByb2Nlc3NvciIsImJhY2tlbmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJkZXN5bmNocm9uaXplZCIsImZvcmNlRGVjb2RlIiwibG9vcFNlbGVjdGlvbiIsIm1lZGlhQ29udGFpbmVyIiwibWluUHhQZXJTZWMiLCJwYXJ0aWFsUmVuZGVyIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNjcmVlbiIsImRldmljZVhEUEkiLCJsb2dpY2FsWERQSSIsInJlbmRlcmVyIiwic2tpcExlbmd0aCIsInhociIsImJhY2tlbmRzIiwiV2ViQXVkaW8iLCJ0cmFuc2Zvcm0iLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJzYXZlZFZvbHVtZSIsInRtcEV2ZW50cyIsImN1cnJlbnRSZXF1ZXN0IiwiYXJyYXlidWZmZXIiLCJkcmF3ZXIiLCJwZWFrQ2FjaGUiLCJzdXBwb3J0c1dlYkF1ZGlvIiwiQmFja2VuZCIsImluaXRpYWxpc2VkUGx1Z2luTGlzdCIsImlzRGVzdHJveWVkIiwiaXNSZWFkeSIsInByZXZXaWR0aCIsIl9vblJlc2l6ZSIsImRlYm91bmNlIiwicmVnaXN0ZXJQbHVnaW5zIiwiY3JlYXRlRHJhd2VyIiwiY3JlYXRlQmFja2VuZCIsImNyZWF0ZVBlYWtDYWNoZSIsInBsdWdpbiIsImFkZFBsdWdpbiIsImRlZmVySW5pdCIsImluaXRQbHVnaW4iLCJnZXRBY3RpdmVQbHVnaW5zIiwicGx1Z2luU3RhdGljUHJvcCIsIkluc3RhbmNlIiwib2JzZXJ2ZXJQcm90b3R5cGVLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImRlc3Ryb3lQbHVnaW4iLCJkZXN0cm95QWxsUGx1Z2lucyIsImRyYXdCdWZmZXIiLCJuZXdWb2x1bWUiLCJzZXRDdXJyZW50VGltZSIsInNlY29uZHMiLCJwbGF5UGF1c2UiLCJpc1BsYXlpbmciLCJza2lwQmFja3dhcmQiLCJza2lwIiwic2tpcEZvcndhcmQiLCJzZWVrQW5kQ2VudGVyIiwiX3RoaXM4IiwiaXNGaW5pdGUiLCJpc1dlYkF1ZGlvQmFja2VuZCIsIm9sZFNjcm9sbFBhcmVudCIsInN0b3AiLCJ0b2dnbGVNdXRlIiwibXV0ZSIsImdldE11dGUiLCJnZXRGaWx0ZXJzIiwiZmlsdGVycyIsInRvZ2dsZVNjcm9sbCIsInRvZ2dsZUludGVyYWN0aW9uIiwiZ2V0V2F2ZUNvbG9yIiwic2V0V2F2ZUNvbG9yIiwiZ2V0UHJvZ3Jlc3NDb2xvciIsInNldFByb2dyZXNzQ29sb3IiLCJnZXRCYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kIiwiZ2V0Q3Vyc29yQ29sb3IiLCJzZXRDdXJzb3JDb2xvciIsImdldEhlaWdodCIsInNldEZpbHRlcmVkQ2hhbm5lbHMiLCJjaGFubmVsSW5kaWNlcyIsIm5ld1JhbmdlcyIsInpvb20iLCJweFBlclNlYyIsImxvYWRBcnJheUJ1ZmZlciIsIl90aGlzOSIsImRlY29kZUFycmF5QnVmZmVyIiwiZGF0YSIsImxvYWREZWNvZGVkQnVmZmVyIiwibG9hZEJsb2IiLCJfdGhpczEwIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwiZW1wdHkiLCJwcmVsb2FkSWdub3JlUmVhc29ucyIsImFjdGl2ZVJlYXNvbnMiLCJyZWFzb24iLCJ3YXJuIiwiam9pbiIsImxvYWRCdWZmZXIiLCJsb2FkTWVkaWFFbGVtZW50IiwiX3RoaXMxMSIsImdldEFycmF5QnVmZmVyIiwic2V0UGVha3MiLCJ1cmxPckVsdCIsIl90aGlzMTIiLCJlcnIiLCJfdGhpczEzIiwiX3RoaXMxNCIsInJlcXVlc3QiLCJwZXJjZW50Q29tcGxldGUiLCJleHBvcnRQQ00iLCJhY2N1cmFjeSIsIm5vV2luZG93IiwiYmxvYkpTT04iLCJCbG9iIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9ialVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIm9wZW4iLCJyZXZva2VPYmplY3RVUkwiLCJleHBvcnRJbWFnZSIsImNhbmNlbEFqYXgiLCJjYW5jZWwiLCJhYm9ydCIsImNsZWFyVG1wRXZlbnRzIiwiZGlzY29ubmVjdFNvdXJjZSIsIlZFUlNJT04iLCJfZGVmaW5lUHJvcGVydHkiLCJQTEFZSU5HIiwiUEFVU0VEIiwiRklOSVNIRUQiLCJfdGhpcyRzdGF0ZUJlaGF2aW9ycyIsIl90aGlzJHN0YXRlcyIsIm9mZmxpbmVBdWRpb0NvbnRleHQiLCJzdGF0ZUJlaGF2aW9ycyIsImFkZE9uQXVkaW9Qcm9jZXNzIiwic3RhcnRQb3NpdGlvbiIsImdldFBsYXllZFRpbWUiLCJyZW1vdmVPbkF1ZGlvUHJvY2VzcyIsImdldEF1ZGlvQ29udGV4dCIsImxhc3RQbGF5Iiwic2NoZWR1bGVkUGF1c2UiLCJzdGF0ZXMiLCJnYWluTm9kZSIsIm1lcmdlZFBlYWtzIiwib2ZmbGluZUFjIiwic2NyaXB0Tm9kZSIsInNvdXJjZSIsInNwbGl0UGVha3MiLCJzdGF0ZSIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIldhdmVTdXJmZXJBdWRpb0NvbnRleHQiLCJnZXRPZmZsaW5lQXVkaW9Db250ZXh0Iiwic2FtcGxlUmF0ZSIsIldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0IiwiT2ZmbGluZUF1ZGlvQ29udGV4dCIsIndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQiLCJzZXRTdGF0ZSIsInNldExlbmd0aCIsImRpc2Nvbm5lY3RGaWx0ZXJzIiwiZGlzY29ubmVjdCIsInNldEZpbHRlciIsInNldEZpbHRlcnMiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsInNjcmlwdEJ1ZmZlclNpemUiLCJjcmVhdGVKYXZhU2NyaXB0Tm9kZSIsImRlc3RpbmF0aW9uIiwib25hdWRpb3Byb2Nlc3MiLCJjcmVhdGVBbmFseXNlciIsImNyZWF0ZUdhaW4iLCJjcmVhdGVHYWluTm9kZSIsImF1ZGlvIiwiQXVkaW8iLCJkZXN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsInNyY09iamVjdCIsInN0cmVhbSIsImdhaW4iLCJzZXRWYWx1ZUF0VGltZSIsImVycmJhY2siLCJkZWNvZGVBdWRpb0RhdGEiLCJudW1iZXJPZkNoYW5uZWxzIiwibmV3QnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwic2FtcGxlU2l6ZSIsInNhbXBsZVN0ZXAiLCJjaGFuIiwiZ2V0Q2hhbm5lbERhdGEiLCJjbG9zZUF1ZGlvQ29udGV4dCIsImNyZWF0ZVNvdXJjZSIsImNyZWF0ZUJ1ZmZlclNvdXJjZSIsIm5vdGVHcmFpbk9uIiwibm90ZU9mZiIsInJlc3VtZSIsImFkanVzdGVkVGltZSIsIndhaXQiLCJ0aW1lb3V0IiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwiRGF0ZSIsIm5vdyIsImRlYm91bmNlZCIsImNhbGxOb3ciLCJjbGVhciIsImNsZWFyVGltZW91dCIsImZsdXNoIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiQ3Vyc29yUGx1Z2luIiwiaGlkZU9uQmx1ciIsIm9wYWNpdHkiLCJjdXN0b21TdHlsZSIsImN1c3RvbVNob3dUaW1lU3R5bGUiLCJzaG93VGltZSIsImZvbGxvd0N1cnNvclkiLCJmb3JtYXRUaW1lQ2FsbGJhY2siLCJfb25Nb3VzZW1vdmUiLCJmbGlwIiwib3V0ZXJXaWR0aCIsImRpc3BsYXlUaW1lIiwidXBkYXRlQ3Vyc29yUG9zaXRpb24iLCJfb25Nb3VzZWVudGVyIiwic2hvd0N1cnNvciIsIl9vbk1vdXNlbGVhdmUiLCJoaWRlQ3Vyc29yIiwiY3Vyc29yIiwibWFyZ2luIiwidmlzaWJpbGl0eSIsImlubmVySFRNTCIsImZvcm1hdFRpbWUiLCJ4cG9zIiwieXBvcyIsInNjcm9sbFRpbWUiLCJ0aW1lVmFsdWUiLCJmb3JtYXRWYWx1ZSIsInRleHRPZmZzZXQiLCJjdXJzb3JUaW1lIiwic2xpY2UiLCJnZXRDb21wdXRlZFN0eWxlIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiX3JlZ2lvbiIsIm93bktleXMiLCJlbnVtZXJhYmxlT25seSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW0iLCJfb2JqZWN0U3ByZWFkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUiLCJSZWdpb24iLCJzY3JvbGxXaWR0aFByb3BvcnRpb24iLCJfb25CYWNrZW5kQ3JlYXRlZCIsIm9yaWVudGF0aW9uIiwiZWRnZVNjcm9sbFdpZHRoIiwiYWRkIiwiX29uUmVhZHkiLCJlbmFibGVEcmFnU2VsZWN0aW9uIiwidXBkYXRlUmVuZGVyIiwiZGlzYWJsZURyYWdTZWxlY3Rpb24iLCJ3b3VsZEV4Y2VlZE1heFJlZ2lvbnMiLCJtaW5MZW5ndGgiLCJzY3JvbGwiLCJzY3JvbGxTcGVlZCIsInNjcm9sbFRocmVzaG9sZCIsImRyYWciLCJ0b3VjaElkIiwicHhNb3ZlIiwic2Nyb2xsRGlyZWN0aW9uIiwid3JhcHBlclJlY3QiLCJlZGdlU2Nyb2xsIiwiZXZlbnREb3duIiwidG91Y2hlcyIsImlkZW50aWZpZXIiLCJldmVudFVwIiwiZXZlbnRNb3ZlIiwic3RhcnRVcGRhdGUiLCJlbmRVcGRhdGUiLCJnZXRDdXJyZW50UmVnaW9uIiwiY3VyIiwic25hcFRvR3JpZEludGVydmFsIiwic25hcFRvR3JpZE9mZnNldCIsImFkZFJlZ2lvbiIsImNsZWFyUmVnaW9ucyIsInJlZ2lvbnNVdGlscyIsIl9wYXJhbXMkc2hvd1Rvb2x0aXAiLCJyZWdpb25zVXRpbCIsInJlc2l6ZSIsImlzUmVzaXppbmciLCJpc0RyYWdnaW5nIiwiaGFuZGxlU3R5bGUiLCJoYW5kbGVMZWZ0RWwiLCJoYW5kbGVSaWdodEVsIiwiYXR0cmlidXRlcyIsInNob3dUb29sdGlwIiwibWF4TGVuZ3RoIiwiX29uUmVkcmF3IiwicHJldmVudENvbnRleHRNZW51IiwiY2hhbm5lbElkeCIsInJlZ2lvbkhlaWdodCIsIm1hcmdpblRvcCIsImNoYW5uZWxDb3VudCIsImJpbmRJbk91dCIsInJlbmRlciIsInVwZGF0ZUhhbmRsZXNSZXNpemUiLCJzIiwicGxheUxvb3AiLCJzZXRMb29wIiwiY2xhc3NOYW1lIiwidGl0bGUiLCJzZXRBdHRyaWJ1dGUiLCJhdHRybmFtZSIsImhhbmRsZUxlZnRDc3MiLCJoYW5kbGVSaWdodENzcyIsImJpbmRFdmVudHMiLCJkdXIiLCJzdGFydExpbWl0ZWQiLCJlbmRMaW1pdGVkIiwicmVnaW9uV2lkdGgiLCJmaXJlZEluIiwiZmlyZWRPdXQiLCJvblByb2Nlc3MiLCJyZWFsVGltZSIsImJpbmREcmFnRXZlbnRzIiwidXBkYXRlZCIsInJlZ2lvbkxlZnRIYWxmVGltZSIsInJlZ2lvblJpZ2h0SGFsZlRpbWUiLCJkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSIsInJlZ2lvbkhhbGZUaW1lV2lkdGgiLCJhZGp1c3RtZW50Iiwid3JhcHBlclNjcm9sbExlZnQiLCJjYWxjdWxhdGVkTGVmdCIsImNhbGN1bGF0ZWRSaWdodCIsImRlbHRhIiwib25EcmFnIiwib25SZXNpemUiLCJvbkRvd24iLCJ0YWdOYW1lIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJvblVwIiwib25Nb3ZlIiwib2xkVGltZSIsIm1heEVuZCIsInBhc3NpdmUiLCJkaXJlY3Rpb24iLCJjdXJzb3JTdHlsZSJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7UUFFQTtRQUNBOzs7Ozs7Ozs7O0FDN0RBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNELE1BQVQsRUFBaUI7QUFDakMsS0FBRyxDQUFDQSxPQUFPRSxlQUFYLEVBQTRCO0FBQzNCRixTQUFPRyxTQUFQLEdBQW1CLFlBQVcsQ0FBRSxDQUFoQztBQUNBSCxTQUFPSSxLQUFQLEdBQWUsRUFBZjtBQUNBO0FBQ0EsTUFBRyxDQUFDSixPQUFPSyxRQUFYLEVBQXFCTCxPQUFPSyxRQUFQLEdBQWtCLEVBQWxCO0FBQ3JCQyxTQUFPQyxjQUFQLENBQXNCUCxNQUF0QixFQUE4QixRQUE5QixFQUF3QztBQUN2Q1EsZUFBWSxJQUQyQjtBQUV2Q0MsUUFBSyxlQUFXO0FBQ2YsV0FBT1QsT0FBT1UsQ0FBZDtBQUNBO0FBSnNDLEdBQXhDO0FBTUFKLFNBQU9DLGNBQVAsQ0FBc0JQLE1BQXRCLEVBQThCLElBQTlCLEVBQW9DO0FBQ25DUSxlQUFZLElBRHVCO0FBRW5DQyxRQUFLLGVBQVc7QUFDZixXQUFPVCxPQUFPVyxDQUFkO0FBQ0E7QUFKa0MsR0FBcEM7QUFNQVgsU0FBT0UsZUFBUCxHQUF5QixDQUF6QjtBQUNBO0FBQ0QsUUFBT0YsTUFBUDtBQUNBLENBckJELEM7Ozs7Ozs7OztBQ0FBOztBQUNBOzs7Ozs7QUFFQTtBQUNBWSxNQUFNQSxPQUFPLEVBQWI7QUFDQUMsVUFBVUMsT0FBVixDQUFrQkMsWUFBbEIsR0FBaUNGLFVBQVVHLFlBQVYsR0FBeUJBLHNCQUExRCxDOzs7Ozs7QUNMQSx5Qzs7Ozs7Ozs7Ozs7OztBQ0FBOzs7O0FBQ0E7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJQSxlQUFlLFNBQWZBLFlBQWUsQ0FBVUMsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUJDLE1BQXpCLEVBQWlDQyxRQUFqQyxFQUEyQztBQUM1RCxPQUFLSCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxPQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQSxPQUFLQyxFQUFMLEdBQVUsSUFBVjtBQUNBLE9BQUtDLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQSxPQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsT0FBS0MsV0FBTCxHQUFtQixLQUFLUCxNQUFMLENBQVlBLE1BQVosQ0FBbUJBLE1BQW5CLENBQTBCRSxNQUExQixDQUFpQ0EsTUFBcEQ7QUFDQSxPQUFLTSxTQUFMLEdBQWlCLEtBQUtSLE1BQUwsQ0FBWUUsTUFBWixDQUFtQk8sYUFBbkIsSUFBb0NDLFNBQXBDLEdBQWdELEtBQUtWLE1BQUwsQ0FBWUUsTUFBWixDQUFtQk8sYUFBbkUsR0FBbUYsQ0FBcEc7QUFDQSxPQUFLRSxPQUFMLEdBQWUsS0FBS1gsTUFBTCxDQUFZRSxNQUFaLENBQW1CVSxXQUFuQixJQUFrQ0YsU0FBbEMsR0FBOEMsS0FBS1YsTUFBTCxDQUFZRSxNQUFaLENBQW1CVSxXQUFqRSxHQUErRSxHQUE5RjtBQUNBLE9BQUtDLGFBQUw7QUFDRCxDQWJEOztBQWVBZCxhQUFhZSxTQUFiLEdBQXlCekIsT0FBTzBCLE1BQVAsQ0FBY0Msb0JBQU9GLFNBQXJCLENBQXpCO0FBQ0FmLGFBQWFlLFNBQWIsQ0FBdUJHLFdBQXZCLEdBQXFDbEIsWUFBckM7O0FBRUE7Ozs7QUFJQUEsYUFBYWUsU0FBYixDQUF1QkksSUFBdkIsR0FBOEIsWUFBWTtBQUFBOztBQUN4QyxNQUFJQyxPQUFPLElBQVg7QUFDQSxNQUFJLENBQUNBLEtBQUtiLFNBQU4sSUFBb0JhLEtBQUtiLFNBQUwsSUFBa0JhLEtBQUtiLFNBQUwsQ0FBZWMsTUFBZixJQUF5QixDQUFuRSxFQUF1RTtBQUN2RSxNQUFJQyxhQUFhQyxxQkFBV1AsTUFBWCxDQUFrQjtBQUNqQ1QsZUFBV2EsS0FBS2IsU0FBTCxDQUFlLENBQWYsQ0FEc0I7QUFFakNpQixlQUFXLE9BRnNCO0FBR2pDQyxtQkFBZSxNQUhrQjtBQUlqQ0MsZ0JBQVksSUFKcUI7QUFLakNDLGdCQUFZLElBTHFCO0FBTWpDQyxlQUFXLENBTnNCO0FBT2pDQyxhQUFTLENBQ1BDLDRCQUFjZCxNQUFkLENBQXFCO0FBQ25CZSx3QkFBa0IsR0FEQztBQUVuQkMsa0JBQVksQ0FGTztBQUduQkMsZUFBUyxDQUFDO0FBQ1JDLGVBQU9kLEtBQUtYLFNBREo7QUFFUjBCLGFBQUtmLEtBQUtSLE9BRkY7QUFHUndCLGNBQU0sS0FIRTtBQUlSQyxlQUFPO0FBSkMsT0FBRCxDQUhVO0FBU25CQyxxQkFBZTtBQUNiQyxjQUFNO0FBRE87QUFUSSxLQUFyQixDQURPO0FBUHdCLEdBQWxCLENBQWpCOztBQXdCQSx1QkFBRSxvQkFBRixFQUF3QkMsR0FBeEIsQ0FBNEIsT0FBNUIsRUFBcUMsS0FBckM7QUFDQSx1QkFBRSxvQkFBRixFQUF3QkEsR0FBeEIsQ0FBNEIsa0JBQTVCLEVBQWdELFNBQWhEOztBQUVBLE1BQUlDLGVBQUo7QUFDQXJCLE9BQUtkLFlBQUwsR0FBb0JULFVBQVU2QyxzQkFBVixDQUFpQyxpQkFBakMsRUFBb0RDLE1BQXBELENBQTJEdEIsTUFBL0U7QUFDQTtBQUNBLE1BQUloQixLQUFLUixVQUFVNkMsc0JBQVYsQ0FBaUMsaUJBQWpDLEVBQW9EQyxNQUFwRCxDQUEyRCxDQUEzRCxFQUE4RDFDLE1BQTlELENBQXFFRSxNQUFyRSxDQUE0RXlDLFlBQXJGO0FBQ0EsTUFBSUMsT0FBT3pCLEtBQUtaLFdBQUwsQ0FBaUJzQyxLQUFqQixHQUF5QjFCLEtBQUtaLFdBQUwsQ0FBaUJzQyxLQUFqQixDQUF1QixDQUF2QixFQUEwQkQsSUFBbkQsR0FBMERsQyxTQUFyRTtBQUNBO0FBQ0EsTUFBSWtDLFFBQVFsQyxTQUFSLElBQXFCTixNQUFNTSxTQUEvQixFQUEwQztBQUN4QyxRQUFJb0MsT0FBT25ELElBQUlvRCxPQUFKLENBQVlILElBQVosRUFBa0J4QyxFQUFsQixDQUFYO0FBQ0E0QyxvQkFBRXhELEdBQUYsQ0FBTXNELElBQU4sRUFBWUcsSUFBWixDQUFpQixZQUFZO0FBQzNCQyxpQkFBVyxZQUFZO0FBQ3JCN0IsbUJBQVc4QixJQUFYLENBQWdCTCxJQUFoQjtBQUNELE9BRkQsRUFFRyxJQUZIO0FBR0QsS0FKRCxFQUlHTSxJQUpILENBSVEsWUFBWTtBQUNsQixVQUFJaEQsS0FBS1IsVUFBVXlELFNBQW5CO0FBQ0EsVUFBSVAsT0FBT25ELElBQUlvRCxPQUFKLENBQVlILElBQVosRUFBa0J4QyxFQUFsQixDQUFYO0FBQ0E4QyxpQkFBVyxZQUFZO0FBQ3JCN0IsbUJBQVc4QixJQUFYLENBQWdCTCxJQUFoQjtBQUNELE9BRkQsRUFFRyxJQUZIO0FBR0QsS0FWRDtBQVdEOztBQUdEekIsYUFBV2lDLEVBQVgsQ0FBYyxPQUFkLEVBQXVCLFlBQVk7QUFDakNkLGFBQVNuRCxPQUFPa0UsTUFBUCxDQUFjbEMsV0FBV1csT0FBWCxDQUFtQndCLElBQWpDLEVBQXVDLENBQXZDLENBQVQ7QUFDQSxRQUFJQyxRQUFRdEMsS0FBS25CLE1BQUwsQ0FBWUEsTUFBWixDQUFtQkEsTUFBbkIsQ0FBMEJBLE1BQTFCLENBQWlDMEQsRUFBakMsQ0FBb0NELEtBQXBDLEdBQTZDdEMsS0FBS25CLE1BQUwsQ0FBWUEsTUFBWixDQUFtQkEsTUFBbkIsQ0FBMEJBLE1BQTFCLENBQWlDMEQsRUFBakMsQ0FBb0NELEtBQXBDLEdBQTRDLElBQXJHO0FBQ0F0QyxTQUFLTixhQUFMLEdBQXFCUSxXQUFXc0MsV0FBWCxFQUFyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSUMsV0FBV3pDLEtBQUtiLFNBQUwsQ0FBZSxDQUFmLENBQWY7QUFDQSxRQUFJdUQsaUJBQWlCRCxTQUFTRSxhQUFULENBQXVCQSxhQUE1QztBQUNBQyxZQUFRQyxHQUFSLENBQVlILGNBQVo7QUFDQSxRQUFJSSxxQkFBcUJKLGVBQWVLLGFBQWYsQ0FBNkIsMkJBQTdCLENBQXpCO0FBQ0EsUUFBSUMsbUJBQW1CTixlQUFlSyxhQUFmLENBQTZCLHlCQUE3QixDQUF2Qjs7QUFFQUgsWUFBUUMsR0FBUixDQUFZQyxrQkFBWjtBQUNBRixZQUFRQyxHQUFSLENBQVlHLGdCQUFaO0FBQ0QsR0F4QkQ7O0FBMEJBSixVQUFRQyxHQUFSLENBQVksV0FBWjtBQUNBLE1BQUk3QyxLQUFLYixTQUFMLENBQWUsQ0FBZixDQUFKLEVBQXVCO0FBQ3JCLFFBQUlzRCxXQUFXekMsS0FBS2IsU0FBTCxDQUFlLENBQWYsQ0FBZjtBQUNBLFFBQUl1RCxpQkFBaUJELFNBQVNFLGFBQVQsQ0FBdUJBLGFBQTVDO0FBQ0FDLFlBQVFDLEdBQVIsQ0FBWUgsY0FBWjtBQUNBLFFBQUlJLHFCQUFxQkosZUFBZUssYUFBZixDQUE2QiwyQkFBN0IsQ0FBekI7QUFDQSxRQUFJQyxtQkFBbUJOLGVBQWVLLGFBQWYsQ0FBNkIseUJBQTdCLENBQXZCOztBQUVBLFFBQUlELHNCQUFzQkUsZ0JBQTFCLEVBQTRDO0FBQzFDLFVBQUlDLDBCQUEwQkgsbUJBQW1CQyxhQUFuQixDQUFpQyxPQUFqQyxDQUE5QjtBQUNBLFVBQUlHLHdCQUF3QkYsaUJBQWlCRCxhQUFqQixDQUErQixPQUEvQixDQUE1Qjs7QUFFQUgsY0FBUUMsR0FBUixDQUFZSSx1QkFBWjtBQUNBTCxjQUFRQyxHQUFSLENBQVlLLHFCQUFaOztBQUVBRCw4QkFBd0JFLGdCQUF4QixDQUF5QyxVQUF6QyxFQUFxRCxVQUFDQyxDQUFELEVBQU87QUFDMUQsWUFBSS9CLFVBQVU5QixTQUFkLEVBQXlCO0FBQ3ZCLGNBQUk4RCxRQUFRRCxFQUFFRSxNQUFGLENBQVNELEtBQXJCO0FBQ0EsY0FBSSxDQUFDRSxNQUFNRixLQUFOLENBQUwsRUFBbUI7QUFDakIsZ0JBQUlHLFdBQVdILEtBQVgsSUFBb0JyRCxLQUFLTixhQUE3QixFQUE0QztBQUMxQzJELHNCQUFRLEdBQVI7QUFDRDtBQUNELGdCQUFJSSxpQkFBaUJELFdBQVdILEtBQVgsQ0FBckI7QUFDQSxnQkFBSUssZUFBZXJDLE9BQU9OLEdBQVAsSUFBY3lDLFdBQVdILEtBQVgsQ0FBZCxHQUFrQ0csV0FBV0gsS0FBWCxJQUFvQixHQUF0RCxHQUE0RGhDLE9BQU9OLEdBQXRGO0FBQ0FoQyxxQkFBUztBQUNQK0IscUJBQU8yQyxlQUFlRSxPQUFmLENBQXVCLENBQXZCLENBREE7QUFFUDVDLG1CQUFLMkMsYUFBYUMsT0FBYixDQUFxQixDQUFyQjtBQUZFLGFBQVQ7QUFJQXRDLG1CQUFPdUMsTUFBUCxDQUFjN0UsTUFBZDtBQUNELFdBWEQsTUFXTztBQUNMLGlDQUFFLEtBQUYsRUFBUUYsTUFBUixHQUFpQmdGLElBQWpCLENBQXNCLGFBQXRCLEVBQXFDQyxNQUFyQyxDQUE0QyxzREFBNUM7QUFDRDtBQUNGO0FBQ0YsT0FsQkQ7O0FBb0JBWiw0QkFBc0JDLGdCQUF0QixDQUF1QyxVQUF2QyxFQUFtRCxVQUFDQyxDQUFELEVBQU87QUFDeEQsWUFBSS9CLFVBQVU5QixTQUFkLEVBQXlCO0FBQ3ZCLGNBQUk4RCxRQUFRRCxFQUFFRSxNQUFGLENBQVNELEtBQXJCO0FBQ0EsY0FBSSxDQUFDRSxNQUFNRixLQUFOLENBQUwsRUFBbUI7QUFDakIsZ0JBQUlHLFdBQVdILEtBQVgsSUFBb0JyRCxLQUFLTixhQUE3QixFQUE0QztBQUMxQzJELHNCQUFRckQsS0FBS04sYUFBTCxHQUFxQixJQUE3QjtBQUNEO0FBQ0QsZ0JBQUkrRCxpQkFBaUJELFdBQVdILEtBQVgsS0FBcUJoQyxPQUFPUCxLQUE1QixHQUFvQyxDQUFwQyxHQUF3Q08sT0FBT1AsS0FBcEU7QUFDQSxnQkFBSTRDLGVBQWVGLFdBQVdILEtBQVgsQ0FBbkI7QUFDQXRFLHFCQUFTO0FBQ1ArQixxQkFBTzJDLGVBQWVFLE9BQWYsQ0FBdUIsQ0FBdkIsQ0FEQTtBQUVQNUMsbUJBQUsyQyxhQUFhQyxPQUFiLENBQXFCLENBQXJCO0FBRkUsYUFBVDtBQUlBdEMsbUJBQU91QyxNQUFQLENBQWM3RSxNQUFkO0FBQ0QsV0FYRCxNQVdPO0FBQ0wsaUNBQUUsS0FBRixFQUFRRixNQUFSLEdBQWlCZ0YsSUFBakIsQ0FBc0IsYUFBdEIsRUFBcUNDLE1BQXJDLENBQTRDLHNEQUE1QztBQUNEO0FBQ0Y7QUFDRixPQWxCRDtBQW1CRDtBQUNGOztBQUVENUQsYUFBV2lDLEVBQVgsQ0FBYyxnQkFBZCxFQUFnQyxVQUFDNEIsS0FBRCxFQUFXO0FBQ3pDLFVBQUtqRCxLQUFMLEdBQWFpRCxNQUFNakQsS0FBbkI7QUFDQSxVQUFLQyxHQUFMLEdBQVdnRCxNQUFNaEQsR0FBakI7QUFDQSxVQUFLaUQsV0FBTCxHQUFtQixxQkFBRSxNQUFNLE1BQUsvRSxFQUFiLEVBQWlCSixNQUFqQixHQUEwQkEsTUFBMUIsR0FBbUNnRixJQUFuQyxDQUF3QywyQkFBeEMsRUFBcUVBLElBQXJFLENBQTBFLE9BQTFFLENBQW5CO0FBQ0EsVUFBS0ksU0FBTCxHQUFpQixxQkFBRSxNQUFNLE1BQUtoRixFQUFiLEVBQWlCSixNQUFqQixHQUEwQkEsTUFBMUIsR0FBbUNnRixJQUFuQyxDQUF3Qyx5QkFBeEMsRUFBbUVBLElBQW5FLENBQXdFLE9BQXhFLENBQWpCO0FBQ0EsVUFBS0csV0FBTCxDQUFpQkUsR0FBakIsQ0FBcUIsTUFBS3BELEtBQUwsQ0FBVzZDLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBckI7QUFDQSxVQUFLTSxTQUFMLENBQWVDLEdBQWYsQ0FBbUIsTUFBS25ELEdBQUwsQ0FBUzRDLE9BQVQsQ0FBaUIsQ0FBakIsQ0FBbkI7QUFDQSxVQUFLM0UsUUFBTCxDQUFjLE1BQUttRixTQUFMLENBQWUsZUFBZixFQUFnQyxNQUFLdEYsTUFBTCxDQUFZQyxLQUFaLENBQWtCeUMsTUFBbEQsQ0FBZCxFQUF5RSxLQUFLLE1BQUtULEtBQUwsQ0FBVzZDLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBOUU7QUFDQSxVQUFLM0UsUUFBTCxDQUFjLE1BQUttRixTQUFMLENBQWUsYUFBZixFQUE4QixNQUFLdEYsTUFBTCxDQUFZQyxLQUFaLENBQWtCeUMsTUFBaEQsQ0FBZCxFQUF1RSxLQUFLLE1BQUtSLEdBQUwsQ0FBUzRDLE9BQVQsQ0FBaUIsQ0FBakIsQ0FBNUU7QUFDRCxHQVREOztBQVdBLHVCQUFFM0QsS0FBS2IsU0FBUCxFQUFrQmlGLE9BQWxCLENBQTBCLHFCQUExQixFQUFpRFAsSUFBakQsQ0FBc0QsZUFBdEQsRUFBdUVRLEtBQXZFLEdBQStFeEYsTUFBL0UsR0FBd0ZnRixJQUF4RixDQUE2RixJQUE3RixFQUFtRzFCLEVBQW5HLENBQXNHLG9CQUF0RyxFQUNFLFlBQU07QUFDSjtBQUNBLFFBQUlsRCxLQUFLUixVQUFVNkMsc0JBQVYsQ0FBaUMsaUJBQWpDLEVBQW9EQyxNQUFwRCxDQUEyRHZCLEtBQUtkLFlBQUwsR0FBb0IsQ0FBL0UsRUFBa0ZMLE1BQWxGLENBQXlGRSxNQUF6RixDQUFnR3lDLFlBQXpHO0FBQ0EsUUFBSUMsT0FBT3pCLEtBQUtaLFdBQUwsQ0FBaUJzQyxLQUFqQixHQUF5QjFCLEtBQUtaLFdBQUwsQ0FBaUJzQyxLQUFqQixDQUF1QixDQUF2QixFQUEwQkQsSUFBbkQsR0FBMERsQyxTQUFyRTtBQUNBLFFBQUlrQyxRQUFRbEMsU0FBUixJQUFxQk4sTUFBTU0sU0FBL0IsRUFBMEM7QUFDeEMsVUFBSW9DLFFBQU9uRCxJQUFJb0QsT0FBSixDQUFZSCxJQUFaLEVBQWtCeEMsRUFBbEIsQ0FBWDtBQUNBNEMsc0JBQUV4RCxHQUFGLENBQU1zRCxLQUFOLEVBQVlHLElBQVosQ0FBaUIsWUFBWTtBQUMzQkMsbUJBQVcsWUFBWTtBQUNyQjdCLHFCQUFXOEIsSUFBWCxDQUFnQkwsS0FBaEI7QUFDRCxTQUZELEVBRUcsSUFGSDtBQUdELE9BSkQsRUFJR00sSUFKSCxDQUlRLFlBQVk7QUFDbEIsWUFBSWhELEtBQUtSLFVBQVV5RCxTQUFuQjtBQUNBLFlBQUlQLE9BQU9uRCxJQUFJb0QsT0FBSixDQUFZSCxJQUFaLEVBQWtCeEMsRUFBbEIsQ0FBWDtBQUNBOEMsbUJBQVcsWUFBWTtBQUNyQjdCLHFCQUFXOEIsSUFBWCxDQUFnQkwsSUFBaEI7QUFDRCxTQUZELEVBRUcsSUFGSDtBQUdELE9BVkQ7QUFXRDtBQUNELFFBQUlOLFVBQVU5QixTQUFkLEVBQXlCO0FBQ3ZCLFVBQUl5RSxjQUFjLHFCQUFFLE1BQU0sTUFBSy9FLEVBQWIsRUFBaUJKLE1BQWpCLEdBQTBCQSxNQUExQixHQUFtQ2dGLElBQW5DLENBQXdDLDJCQUF4QyxFQUFxRUEsSUFBckUsQ0FBMEUsT0FBMUUsQ0FBbEI7QUFDQSxVQUFJSSxZQUFZLHFCQUFFLE1BQU0sTUFBS2hGLEVBQWIsRUFBaUJKLE1BQWpCLEdBQTBCQSxNQUExQixHQUFtQ2dGLElBQW5DLENBQXdDLHlCQUF4QyxFQUFtRUEsSUFBbkUsQ0FBd0UsT0FBeEUsQ0FBaEI7QUFDQUcsa0JBQVlFLEdBQVosQ0FBZ0IsQ0FBaEI7QUFDQUQsZ0JBQVVDLEdBQVYsQ0FBYyxHQUFkO0FBQ0EsWUFBS2xGLFFBQUwsQ0FBYyxNQUFLbUYsU0FBTCxDQUFlLGVBQWYsRUFBZ0MsTUFBS3RGLE1BQUwsQ0FBWUMsS0FBWixDQUFrQnlDLE1BQWxELENBQWQsRUFBeUUsS0FBSyxDQUE5RTtBQUNBLFlBQUt2QyxRQUFMLENBQWMsTUFBS21GLFNBQUwsQ0FBZSxhQUFmLEVBQThCLE1BQUt0RixNQUFMLENBQVlDLEtBQVosQ0FBa0J5QyxNQUFoRCxDQUFkLEVBQXVFLEtBQUssR0FBNUU7QUFDQXhDLGVBQVM7QUFDUCtCLGVBQU8sQ0FEQTtBQUVQQyxhQUFLO0FBRkUsT0FBVDtBQUlBTSxhQUFPdUMsTUFBUCxDQUFjN0UsTUFBZDtBQUNEO0FBQ0YsR0FoQ0g7O0FBa0NBLE1BQUksS0FBS0UsRUFBTCxJQUFXLElBQWYsRUFBcUI7QUFDbkIsUUFBSXFGLFdBQVcsS0FBS3JGLEVBQUwsR0FBVSxZQUF6QjtBQUNBLFFBQUlzRixvQkFBb0IscUJBQUUsa0JBQWtCRCxRQUFsQixHQUE2QixxQ0FBL0IsQ0FBeEI7QUFDQSx5QkFBRXRFLEtBQUtiLFNBQVAsRUFBa0JOLE1BQWxCLENBQXlCLEtBQXpCLEVBQWdDaUYsTUFBaEMsQ0FBdUNTLGlCQUF2QztBQUNBLHlCQUFFQSxpQkFBRixFQUFxQnBDLEVBQXJCLENBQXdCLE9BQXhCLEVBQWlDLFlBQVk7QUFDM0MsVUFBSWQsVUFBVTlCLFNBQWQsRUFBeUI7QUFDdkI4QixlQUFPbUQsSUFBUDtBQUNEO0FBQ0YsS0FKRDtBQUtEO0FBQ0YsQ0E5TEQ7O0FBZ01BOzs7OztBQUtBNUYsYUFBYWUsU0FBYixDQUF1QjhFLFFBQXZCLEdBQWtDLFVBQVVDLFFBQVYsRUFBb0I7QUFDcEQsTUFBSTFFLE9BQU8sSUFBWDtBQUNBLE1BQU1mLEtBQUswRixHQUFHQyxjQUFILENBQWtCLEtBQUs5RixLQUF2QixDQUFYO0FBQ0EsTUFBSStGLE9BQU9wRyxVQUFVcUcsaUJBQVYsQ0FBNEIsS0FBS2hHLEtBQWpDLEVBQXdDLCtCQUErQkcsRUFBL0IsR0FBb0MsNkJBQTVFLEVBQTJHQSxFQUEzRyxDQUFYO0FBQ0FlLE9BQUsrRSxLQUFMLEdBQWF0RyxVQUFVb0QsQ0FBVixDQUFZZ0QsSUFBWixDQUFiO0FBQ0EsT0FBS0csS0FBTCxDQUFXL0YsRUFBWDtBQUNBLE1BQUlnRyxXQUFZLEtBQUtwRyxNQUFMLENBQVlFLE1BQVosQ0FBbUJtRyxJQUFuQixJQUEyQjNGLFNBQTVCLEdBQXlDLEtBQUtWLE1BQUwsQ0FBWUUsTUFBWixDQUFtQm1HLElBQTVELEdBQW1FLEVBQWxGO0FBQ0FSLFdBQVNaLE1BQVQsQ0FBZ0Isc0NBQWhCO0FBQ0E7QUFDQTtBQUNBLE1BQUlxQix5QkFBeUJULFNBQVNaLE1BQVQsQ0FBZ0IsS0FBS3NCLFdBQUwsQ0FBaUJwRixLQUFLbkIsTUFBTCxDQUFZQSxNQUFaLENBQW1CQSxNQUFuQixDQUEwQkEsTUFBMUIsQ0FBaUMwRCxFQUFqQyxDQUFvQzhDLE1BQXJELEVBQTZELEtBQUt4RyxNQUFMLENBQVlBLE1BQVosQ0FBbUJBLE1BQW5CLENBQTBCRSxNQUExQixDQUFpQ0EsTUFBakMsQ0FBd0N1RyxTQUFyRyxFQUFnSCxLQUFLekcsTUFBTCxDQUFZRSxNQUFaLENBQW1CbUcsSUFBbkksQ0FBaEIsQ0FBN0I7QUFDQWxGLE9BQUsrRSxLQUFMLENBQVdOLFFBQVgsQ0FBb0JDLFFBQXBCO0FBQ0ExRSxPQUFLYixTQUFMLEdBQWlCYSxLQUFLK0UsS0FBTCxDQUFXbEIsSUFBWCxDQUFnQixNQUFNLEtBQUs1RSxFQUEzQixDQUFqQjtBQUNBLHVCQUFFa0csc0JBQUYsRUFBMEJoRCxFQUExQixDQUE2QixRQUE3QixFQUF1QyxVQUFVNEIsS0FBVixFQUFpQjtBQUN0RCxRQUFJLHFCQUFFLE1BQU1BLE1BQU1ULE1BQU4sQ0FBYXJFLEVBQXJCLEVBQXlCc0csRUFBekIsQ0FBNEIsVUFBNUIsQ0FBSixFQUE2QztBQUMzQ04saUJBQVdBLFdBQVcsR0FBWCxHQUFpQmxCLE1BQU1ULE1BQU4sQ0FBYUQsS0FBOUIsR0FBc0MsR0FBakQ7QUFDQSwyQkFBRSxNQUFNVSxNQUFNVCxNQUFOLENBQWFyRSxFQUFyQixFQUF5QnVHLElBQXpCLENBQThCLFNBQTlCLEVBQXlDLElBQXpDO0FBQ0EsV0FBS0MsS0FBTCxHQUFhLHFCQUFFLE1BQU14RyxFQUFSLEVBQVlKLE1BQVosR0FBcUJBLE1BQXJCLEdBQThCZ0YsSUFBOUIsQ0FBbUMsa0JBQW5DLEVBQXVEQSxJQUF2RCxDQUE0RCxPQUE1RCxDQUFiO0FBQ0EsV0FBSzRCLEtBQUwsQ0FBV3ZCLEdBQVgsQ0FBZ0JlLFNBQVNTLElBQVQsRUFBRCxDQUFrQkMsT0FBbEIsQ0FBMEIsTUFBMUIsRUFBa0MsR0FBbEMsQ0FBZjtBQUNBLDJCQUFFLEtBQUtGLEtBQVAsRUFBY0QsSUFBZCxDQUFtQixTQUFuQixFQUE4QixJQUE5QjtBQUNBeEYsV0FBS2hCLFFBQUwsQ0FBY2dCLEtBQUttRSxTQUFMLENBQWUsTUFBZixFQUF1Qm5FLEtBQUtuQixNQUFMLENBQVlDLEtBQVosQ0FBa0J5QyxNQUF6QyxDQUFkLEVBQWdFLEtBQUswRCxTQUFTVSxPQUFULENBQWlCLE1BQWpCLEVBQXlCLEdBQXpCLENBQXJFO0FBQ0E7QUFDRCxLQVJELE1BUU87QUFDTCwyQkFBRSxNQUFNNUIsTUFBTVQsTUFBTixDQUFhckUsRUFBckIsRUFBeUJ1RyxJQUF6QixDQUE4QixTQUE5QixFQUF5QyxLQUF6QztBQUNBLFVBQUlJLGVBQWVYLFNBQVNVLE9BQVQsQ0FBaUI1QixNQUFNVCxNQUFOLENBQWFELEtBQTlCLEVBQXFDLEVBQXJDLENBQW5CO0FBQ0E0QixpQkFBV1csWUFBWDtBQUNBLFdBQUtILEtBQUwsR0FBYSxxQkFBRSxNQUFNeEcsRUFBUixFQUFZSixNQUFaLEdBQXFCQSxNQUFyQixHQUE4QmdGLElBQTlCLENBQW1DLGtCQUFuQyxFQUF1REEsSUFBdkQsQ0FBNEQsT0FBNUQsQ0FBYjtBQUNBN0QsV0FBS2hCLFFBQUwsQ0FBY2dCLEtBQUttRSxTQUFMLENBQWUsTUFBZixFQUF1Qm5FLEtBQUtuQixNQUFMLENBQVlDLEtBQVosQ0FBa0J5QyxNQUF6QyxDQUFkLEVBQWdFLEtBQUswRCxTQUFTVSxPQUFULENBQWlCLE1BQWpCLEVBQXlCLEdBQXpCLENBQXJFO0FBQ0EsMkJBQUUsS0FBS0YsS0FBUCxFQUFjRCxJQUFkLENBQW1CLFNBQW5CLEVBQThCLEtBQTlCO0FBQ0EsV0FBS0MsS0FBTCxDQUFXdkIsR0FBWCxDQUFnQmUsU0FBU1MsSUFBVCxFQUFELENBQWtCQyxPQUFsQixDQUEwQixNQUExQixFQUFrQyxHQUFsQyxDQUFmO0FBQ0Q7QUFDRixHQWxCRDtBQW1CQTNGLE9BQUtoQixRQUFMLENBQWNnQixLQUFLbUUsU0FBTCxDQUFlLE1BQWYsRUFBdUJuRSxLQUFLbkIsTUFBTCxDQUFZQyxLQUFaLENBQWtCeUMsTUFBekMsQ0FBZCxFQUFnRSxLQUFLLEtBQUsxQyxNQUFMLENBQVlFLE1BQVosQ0FBbUJtRyxJQUF4RjtBQUNBbEYsT0FBS0QsSUFBTDtBQUNELENBbENEOztBQW9DQW5CLGFBQWFlLFNBQWIsQ0FBdUJ3RSxTQUF2QixHQUFtQyxVQUFVMEIsSUFBVixFQUFnQnRFLE1BQWhCLEVBQXdCO0FBQ3pELE9BQUssSUFBSWhELElBQUksQ0FBYixFQUFnQkEsSUFBSWdELE9BQU90QixNQUEzQixFQUFtQzFCLEdBQW5DLEVBQXdDO0FBQ3RDLFFBQUlnRCxPQUFPaEQsQ0FBUCxFQUFVc0gsSUFBVixLQUFtQkEsSUFBdkIsRUFBNkI7QUFDM0IsYUFBT3RFLE9BQU9oRCxDQUFQLENBQVA7QUFDRDtBQUNGO0FBQ0YsQ0FORDs7QUFRQUssYUFBYWUsU0FBYixDQUF1QnFGLEtBQXZCLEdBQStCLFVBQVUvRixFQUFWLEVBQWM7QUFDM0MsT0FBS0EsRUFBTCxHQUFVQSxFQUFWO0FBQ0QsQ0FGRDs7QUFJQUwsYUFBYWUsU0FBYixDQUF1QndFLFNBQXZCLEdBQW1DLFVBQVUwQixJQUFWLEVBQWdCdEUsTUFBaEIsRUFBd0I7QUFDekQsT0FBSyxJQUFJaEQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZ0QsT0FBT3RCLE1BQTNCLEVBQW1DMUIsR0FBbkMsRUFBd0M7QUFDdEMsUUFBSWdELE9BQU9oRCxDQUFQLEVBQVVzSCxJQUFWLEtBQW1CQSxJQUF2QixFQUE2QjtBQUMzQixhQUFPdEUsT0FBT2hELENBQVAsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixDQU5EOztBQVFBSyxhQUFhZSxTQUFiLENBQXVCbUcsUUFBdkIsR0FBa0MsWUFBWTtBQUM1QztBQUNBO0FBQ0QsQ0FIRDs7QUFLQWxILGFBQWFlLFNBQWIsQ0FBdUJ5RixXQUF2QixHQUFxQyxVQUFVQyxNQUFWLEVBQWtCVSxVQUFsQixFQUE4QkMsUUFBOUIsRUFBd0M7QUFDM0UsTUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsTUFBSUMsbUJBQW9CRixZQUFZekcsU0FBYixHQUEwQnlHLFNBQVNHLEtBQVQsQ0FBZSxHQUFmLENBQTFCLEdBQWdELEVBQXZFO0FBQ0EsT0FBSyxJQUFJNUgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJOEcsT0FBT1UsVUFBUCxFQUFtQkssUUFBbkIsQ0FBNEJuRyxNQUFoRCxFQUF3RDFCLEdBQXhELEVBQTZEOztBQUUzRCxRQUFJOEcsT0FBT1UsVUFBUCxFQUFtQkssUUFBbkIsQ0FBNEI3SCxDQUE1QixFQUErQjhILE1BQS9CLENBQXNDQyxPQUF0QyxDQUE4Q0gsS0FBOUMsQ0FBb0QsR0FBcEQsRUFBeUQsQ0FBekQsS0FBK0Qsb0JBQW5FLEVBQXlGO0FBQ3ZGLFVBQUlJLGVBQWUsRUFBbkI7QUFDQU4sc0JBQWdCLHFCQUFFWixPQUFPVSxVQUFQLEVBQW1CSyxRQUFuQixDQUE0QjdILENBQTVCLEVBQStCOEgsTUFBL0IsQ0FBc0N0SCxNQUF0QyxDQUE2Q21HLElBQS9DLEVBQXFELENBQXJELEVBQXdEc0IsU0FBeEQsQ0FBa0VMLEtBQWxFLENBQXdFLEdBQXhFLENBQWhCO0FBQ0EsV0FBSyxJQUFJTSxJQUFJLENBQWIsRUFBZ0JBLElBQUlSLGNBQWNoRyxNQUFsQyxFQUEwQ3dHLEdBQTFDLEVBQStDO0FBQzdDLFlBQUlDLE1BQU9SLGlCQUFpQlMsT0FBakIsQ0FBeUJWLGNBQWNRLENBQWQsQ0FBekIsTUFBK0MsQ0FBQyxDQUFqRCxHQUFzRCxJQUF0RCxHQUE2RCxLQUF2RTtBQUNBLFlBQUlSLGNBQWNRLENBQWQsRUFBaUJkLE9BQWpCLENBQXlCLE1BQXpCLEVBQWlDLEdBQWpDLEtBQXlDLEVBQTdDLEVBQWlEO0FBQy9DLGNBQUllLEdBQUosRUFBUztBQUNQSCwyQkFBZUEsZUFBZSxvQ0FBZixHQUFzRCxLQUFLdEgsRUFBM0QsR0FBZ0V3SCxDQUFoRSxHQUFvRSxjQUFwRSxHQUFxRixLQUFLeEgsRUFBMUYsR0FBK0Z3SCxDQUEvRixHQUFtRywwQkFBbkcsR0FBZ0lSLGNBQWNRLENBQWQsQ0FBaEksR0FBbUosV0FBbkosR0FBaUtSLGNBQWNRLENBQWQsQ0FBakssR0FBb0wsVUFBbk07QUFDRCxXQUZELE1BRU87QUFDTEYsMkJBQWVBLGVBQWUsb0NBQWYsR0FBc0QsS0FBS3RILEVBQTNELEdBQWdFd0gsQ0FBaEUsR0FBb0UsY0FBcEUsR0FBcUYsS0FBS3hILEVBQTFGLEdBQStGd0gsQ0FBL0YsR0FBbUcsMEJBQW5HLEdBQWdJUixjQUFjUSxDQUFkLENBQWhJLEdBQW1KLElBQW5KLEdBQTBKUixjQUFjUSxDQUFkLENBQTFKLEdBQTZLLFVBQTVMO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjtBQUNELFNBQU9GLFlBQVA7QUFDRCxDQXJCRDs7QUF1QkEzSCxhQUFhZSxTQUFiLENBQXVCaUgsTUFBdkIsR0FBZ0MsWUFBWSxDQUFFLENBQTlDO2tCQUNlaEksWTs7Ozs7Ozs7O0FDeFRmLElBQU1pSSxRQUFRQyxtQkFBT0EsQ0FBQyxDQUFSLENBQWQ7QUFDQSxJQUFNQyxrQkFBa0J2SSxJQUFJdUksZUFBNUI7O0FBRUE7OztBQUdBLFNBQVNsSCxNQUFULENBQWdCQyxXQUFoQixFQUE2QmtILFVBQTdCLEVBQXlDO0FBQ3ZDLE1BQU1oSCxPQUFPLElBQWI7QUFDQStHLGtCQUFnQkUsSUFBaEIsQ0FBcUJqSCxJQUFyQjs7QUFFQUEsT0FBSy9CLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUE7Ozs7OztBQU1BLE1BQUlpSixnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVVDLElBQVYsRUFBZ0I7QUFDbEMsU0FBSyxJQUFJNUksSUFBSTRJLElBQWIsRUFBbUI1SSxJQUFJeUIsS0FBSy9CLFFBQUwsQ0FBY2dDLE1BQXJDLEVBQTZDMUIsR0FBN0MsRUFBa0Q7QUFDaER5QixXQUFLL0IsUUFBTCxDQUFjTSxDQUFkLEVBQWlCNkksS0FBakIsR0FBeUI3SSxDQUF6QjtBQUNEO0FBQ0YsR0FKRDs7QUFNQTs7Ozs7QUFLQXlCLE9BQUtxSCxRQUFMLEdBQWdCLFVBQVVDLGVBQVYsRUFBMkJGLEtBQTNCLEVBQWtDO0FBQ2hELFFBQUlBLFVBQVU3SCxTQUFkLEVBQXlCO0FBQ3ZCNkgsY0FBUXBILEtBQUsvQixRQUFMLENBQWNnQyxNQUF0QjtBQUNEOztBQUVEO0FBQ0EsUUFBTXNILFdBQVcsSUFBSVYsS0FBSixDQUFVTyxLQUFWLEVBQWlCcEgsSUFBakIsQ0FBakI7O0FBRUEsUUFBSW9ILFVBQVVwSCxLQUFLL0IsUUFBTCxDQUFjZ0MsTUFBNUIsRUFBb0M7QUFDbEM7QUFDQUQsV0FBSy9CLFFBQUwsQ0FBY3VKLElBQWQsQ0FBbUJELFFBQW5CO0FBQ0QsS0FIRCxNQUlLO0FBQ0g7QUFDQXZILFdBQUsvQixRQUFMLENBQWN3SixNQUFkLENBQXFCTCxLQUFyQixFQUE0QixDQUE1QixFQUErQkcsUUFBL0I7QUFDQUwsb0JBQWNFLEtBQWQ7QUFDRDs7QUFFRDtBQUNBdEgsZ0JBQVltSCxJQUFaLENBQWlCTSxRQUFqQixFQUEyQkQsZUFBM0I7O0FBRUEsV0FBT0MsUUFBUDtBQUNELEdBdEJEOztBQXdCQTs7Ozs7QUFLQXZILE9BQUswSCxXQUFMLEdBQW1CLFVBQVVOLEtBQVYsRUFBaUI7QUFDbEM7QUFDQXBILFNBQUsvQixRQUFMLENBQWN3SixNQUFkLENBQXFCTCxLQUFyQixFQUE0QixDQUE1Qjs7QUFFQTtBQUNBRixrQkFBY0UsS0FBZDtBQUNELEdBTkQ7O0FBUUE7Ozs7OztBQU1BcEgsT0FBSzJILFNBQUwsR0FBaUIsVUFBVUMsUUFBVixFQUFvQkMsUUFBcEIsRUFBOEI7QUFDN0MsUUFBTUMsUUFBUTlILEtBQUsvQixRQUFMLENBQWN3SixNQUFkLENBQXFCRyxRQUFyQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxDQUFkO0FBQ0E1SCxTQUFLL0IsUUFBTCxDQUFjd0osTUFBZCxDQUFxQkksUUFBckIsRUFBK0IsQ0FBL0IsRUFBa0NDLEtBQWxDOztBQUVBWixrQkFBY1csV0FBV0QsUUFBWCxHQUFzQkMsUUFBdEIsR0FBaUNELFFBQS9DO0FBQ0QsR0FMRDs7QUFPQSxNQUFJWixVQUFKLEVBQWdCO0FBQ2QsU0FBSyxJQUFJekksSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUksV0FBVy9HLE1BQS9CLEVBQXVDMUIsR0FBdkMsRUFBNEM7QUFDMUN5QixXQUFLcUgsUUFBTCxDQUFjTCxXQUFXekksQ0FBWCxDQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVEc0IsT0FBT0YsU0FBUCxHQUFtQnpCLE9BQU8wQixNQUFQLENBQWNtSCxnQkFBZ0JwSCxTQUE5QixDQUFuQjtBQUNBRSxPQUFPRixTQUFQLENBQWlCRyxXQUFqQixHQUErQkQsTUFBL0I7O0FBRUFqQyxPQUFPQyxPQUFQLEdBQWlCZ0MsTUFBakIsQzs7Ozs7Ozs7O0FDekZBOzs7QUFHQSxTQUFTZ0gsS0FBVCxDQUFlTyxLQUFmLEVBQXNCdkksTUFBdEIsRUFBOEI7QUFDNUIsTUFBTW1CLE9BQU8sSUFBYjs7QUFFQUEsT0FBS29ILEtBQUwsR0FBYUEsS0FBYjtBQUNBcEgsT0FBS25CLE1BQUwsR0FBY0EsTUFBZDtBQUNEOztBQUVEakIsT0FBT0MsT0FBUCxHQUFpQmdKLEtBQWpCLEM7Ozs7Ozs7Ozs7OztBQ1ZPLElBQU1rQiwwQkFBU3ZKLElBQUl1SixNQUFuQjtBQUNBLElBQU1oQiw0Q0FBa0J2SSxJQUFJdUksZUFBNUI7QUFDQSxJQUFNaUIsOEJBQVd4SixJQUFJd0osUUFBckIsQzs7Ozs7Ozs7Ozs7OztBQ0ZQOzs7OztBQUtBLENBQUMsU0FBU0MsZ0NBQVQsQ0FBMENDLElBQTFDLEVBQWdEQyxPQUFoRCxFQUF5RDtBQUN6RCxNQUFHLGlDQUFPdEssT0FBUCxPQUFtQixRQUFuQixJQUErQixpQ0FBT0QsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxPQUFPQyxPQUFQLEdBQWlCc0ssU0FBakIsQ0FERCxLQUVLLElBQUcsSUFBSCxFQUNKQyxpQ0FBcUIsRUFBckIsb0NBQXlCRCxPQUF6QjtBQUFBO0FBQUE7QUFBQSxxR0FESSxLQUVBLElBQUcsUUFBT3RLLE9BQVAsMENBQU9BLE9BQVAsT0FBbUIsUUFBdEIsRUFDSkEsUUFBUSxZQUFSLElBQXdCc0ssU0FBeEIsQ0FESSxLQUdKRCxLQUFLLFlBQUwsSUFBcUJDLFNBQXJCO0FBQ0QsQ0FURCxhQVNTLFlBQVc7QUFDcEIsU0FBTyxTQUFVLFlBQU07QUFBRTtBQUN6QixjQUFVLElBQUlFLHNCQUF1Qjs7QUFFckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLGdDQUFDekssTUFBRCxFQUFTQyxPQUFULEVBQWtCeUssbUJBQWxCLEVBQTBDOztBQUVqRDs7QUFHQXBLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0IsS0FBSyxDQUF2Qjs7QUFFQSxjQUFJQyxTQUFTQyx1QkFBdUJILHFCQUFvQixtQkFBb0IscUJBQXhDLENBQXZCLENBQWI7O0FBRUEsY0FBSUksU0FBU0QsdUJBQXVCSCxxQkFBb0Isb0JBQXFCLHNCQUF6QyxDQUF2QixDQUFiOztBQUVBLG1CQUFTRyxzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7QUFBRSxtQkFBT0EsT0FBT0EsSUFBSUMsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEIsRUFBRUosU0FBU0ksR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsbUJBQVNFLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOOzs7Ozs7O0FBT0EsY0FBSVcsY0FBYyxhQUFhLFlBQVk7QUFDekMscUJBQVNBLFdBQVQsR0FBdUI7QUFDckJaLDhCQUFnQixJQUFoQixFQUFzQlksV0FBdEI7O0FBRUE7Ozs7O0FBS0EsbUJBQUtDLElBQUwsR0FBWSxJQUFaO0FBQ0E7Ozs7OztBQU1BLG1CQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUNBOzs7Ozs7QUFNQSxtQkFBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBOzs7Ozs7QUFNQSxtQkFBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBOzs7Ozs7QUFNQSxtQkFBSy9JLEtBQUwsR0FBYSxDQUFiO0FBQ0E7Ozs7OztBQU1BLG1CQUFLQyxHQUFMLEdBQVcsQ0FBWDtBQUNBOzs7Ozs7QUFNQSxtQkFBSzlCLEVBQUwsR0FBVSxDQUFDLEdBQUd5SixPQUFPSCxPQUFYLEVBQW9CLE9BQU8sS0FBS3pJLFdBQUwsQ0FBaUIrRixJQUF4QixLQUFpQyxXQUFqQyxHQUErQyxLQUFLL0YsV0FBTCxDQUFpQitGLElBQWpCLENBQXNCaUUsV0FBdEIsS0FBc0MsR0FBckYsR0FBMkYsY0FBL0csQ0FBVjtBQUNBOzs7Ozs7QUFNQSxtQkFBS0MsdUJBQUwsR0FBK0IsRUFBL0I7QUFDRDtBQUNEOzs7Ozs7QUFPQVQseUJBQWFHLFdBQWIsRUFBMEIsQ0FBQztBQUN6QkosbUJBQUssVUFEb0I7QUFFekJoRyxxQkFBTyxTQUFTMkcsUUFBVCxDQUFrQkMsT0FBbEIsRUFBMkI7QUFDaEMscUJBQUtQLElBQUwsR0FBWU8sT0FBWjtBQUNBLHFCQUFLTixPQUFMLEdBQWUsS0FBS0QsSUFBTCxDQUFVUSxVQUFWLENBQXFCLElBQXJCLEVBQTJCLEtBQUtILHVCQUFoQyxDQUFmO0FBQ0Q7QUFDRDs7Ozs7OztBQU55QixhQUFELEVBYXZCO0FBQ0RWLG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVM4RyxZQUFULENBQXNCRixPQUF0QixFQUErQjtBQUNwQyxxQkFBS0wsUUFBTCxHQUFnQkssT0FBaEI7QUFDQSxxQkFBS0osV0FBTCxHQUFtQixLQUFLRCxRQUFMLENBQWNNLFVBQWQsQ0FBeUIsSUFBekIsRUFBK0IsS0FBS0gsdUJBQXBDLENBQW5CO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBTkMsYUFidUIsRUE0QnZCO0FBQ0RWLG1CQUFLLGtCQURKO0FBRURoRyxxQkFBTyxTQUFTK0csZ0JBQVQsQ0FBMEJDLFlBQTFCLEVBQXdDQyxVQUF4QyxFQUFvRGhJLEtBQXBELEVBQTJEaUksTUFBM0QsRUFBbUU7QUFDeEU7QUFDQTtBQUNBLHFCQUFLekosS0FBTCxHQUFhLEtBQUs0SSxJQUFMLENBQVVjLFVBQVYsR0FBdUJGLFVBQXZCLElBQXFDLENBQWxEO0FBQ0EscUJBQUt2SixHQUFMLEdBQVcsS0FBS0QsS0FBTCxHQUFhdUosZUFBZUMsVUFBdkMsQ0FKd0UsQ0FJckI7O0FBRW5ELHFCQUFLWixJQUFMLENBQVVwSCxLQUFWLEdBQWtCQSxLQUFsQjtBQUNBLHFCQUFLb0gsSUFBTCxDQUFVYSxNQUFWLEdBQW1CQSxNQUFuQjtBQUNBLG9CQUFJRSxjQUFjO0FBQ2hCbkkseUJBQU8rSCxlQUFlO0FBRE4saUJBQWxCO0FBR0EsaUJBQUMsR0FBRzdCLE9BQU9ELE9BQVgsRUFBb0IsS0FBS21CLElBQXpCLEVBQStCZSxXQUEvQjs7QUFFQSxvQkFBSSxLQUFLQyxpQkFBVCxFQUE0QjtBQUMxQjtBQUNBLHVCQUFLZCxRQUFMLENBQWN0SCxLQUFkLEdBQXNCQSxLQUF0QjtBQUNBLHVCQUFLc0gsUUFBTCxDQUFjVyxNQUFkLEdBQXVCQSxNQUF2QjtBQUNBLG1CQUFDLEdBQUcvQixPQUFPRCxPQUFYLEVBQW9CLEtBQUtxQixRQUF6QixFQUFtQ2EsV0FBbkM7QUFDRDtBQUNGO0FBQ0Q7Ozs7QUF0QkMsYUE1QnVCLEVBc0R2QjtBQUNEcEIsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU3NILFNBQVQsR0FBcUI7QUFDMUI7QUFDQSxxQkFBS2hCLE9BQUwsQ0FBYWlCLFNBQWIsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsS0FBS2pCLE9BQUwsQ0FBYWtCLE1BQWIsQ0FBb0J2SSxLQUFqRCxFQUF3RCxLQUFLcUgsT0FBTCxDQUFha0IsTUFBYixDQUFvQk4sTUFBNUUsRUFGMEIsQ0FFMkQ7O0FBRXJGLG9CQUFJLEtBQUtHLGlCQUFULEVBQTRCO0FBQzFCLHVCQUFLYixXQUFMLENBQWlCZSxTQUFqQixDQUEyQixDQUEzQixFQUE4QixDQUE5QixFQUFpQyxLQUFLZixXQUFMLENBQWlCZ0IsTUFBakIsQ0FBd0J2SSxLQUF6RCxFQUFnRSxLQUFLdUgsV0FBTCxDQUFpQmdCLE1BQWpCLENBQXdCTixNQUF4RjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7OztBQVZDLGFBdER1QixFQXVFdkI7QUFDRGxCLG1CQUFLLGVBREo7QUFFRGhHLHFCQUFPLFNBQVN5SCxhQUFULENBQXVCMUssU0FBdkIsRUFBa0NDLGFBQWxDLEVBQWlEO0FBQ3RELHFCQUFLc0osT0FBTCxDQUFhb0IsU0FBYixHQUF5QjNLLFNBQXpCOztBQUVBLG9CQUFJLEtBQUtzSyxpQkFBVCxFQUE0QjtBQUMxQix1QkFBS2IsV0FBTCxDQUFpQmtCLFNBQWpCLEdBQTZCMUssYUFBN0I7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQVRDLGFBdkV1QixFQXNGdkI7QUFDRGdKLG1CQUFLLHVCQURKO0FBRURoRyxxQkFBTyxTQUFTMkgscUJBQVQsQ0FBK0JDLFFBQS9CLEVBQXlDO0FBQzlDLG9CQUFJQSxRQUFKLEVBQWM7QUFDWjtBQUNBLHVCQUFLdEIsT0FBTCxDQUFhdUIsWUFBYixDQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6Qzs7QUFFQSxzQkFBSSxLQUFLUixpQkFBVCxFQUE0QjtBQUMxQix5QkFBS2IsV0FBTCxDQUFpQnFCLFlBQWpCLENBQThCLENBQTlCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDLEVBQXVDLENBQXZDLEVBQTBDLENBQTFDLEVBQTZDLENBQTdDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7Ozs7Ozs7Ozs7QUFaQyxhQXRGdUIsRUE0R3ZCO0FBQ0Q3QixtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTOEgsU0FBVCxDQUFtQkMsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCL0ksS0FBekIsRUFBZ0NpSSxNQUFoQyxFQUF3Q2UsTUFBeEMsRUFBZ0Q7QUFDckQscUJBQUtDLGlCQUFMLENBQXVCLEtBQUs1QixPQUE1QixFQUFxQ3lCLENBQXJDLEVBQXdDQyxDQUF4QyxFQUEyQy9JLEtBQTNDLEVBQWtEaUksTUFBbEQsRUFBMERlLE1BQTFEOztBQUVBLG9CQUFJLEtBQUtaLGlCQUFULEVBQTRCO0FBQzFCLHVCQUFLYSxpQkFBTCxDQUF1QixLQUFLMUIsV0FBNUIsRUFBeUN1QixDQUF6QyxFQUE0Q0MsQ0FBNUMsRUFBK0MvSSxLQUEvQyxFQUFzRGlJLE1BQXRELEVBQThEZSxNQUE5RDtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7Ozs7QUFUQyxhQTVHdUIsRUFnSXZCO0FBQ0RqQyxtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU2tJLGlCQUFULENBQTJCQyxHQUEzQixFQUFnQ0osQ0FBaEMsRUFBbUNDLENBQW5DLEVBQXNDL0ksS0FBdEMsRUFBNkNpSSxNQUE3QyxFQUFxRGUsTUFBckQsRUFBNkQ7QUFDbEUsb0JBQUksQ0FBQ0UsR0FBTCxFQUFVO0FBQ1I7QUFDRDs7QUFFRCxvQkFBSUYsTUFBSixFQUFZO0FBQ1YsdUJBQUtHLGVBQUwsQ0FBcUJELEdBQXJCLEVBQTBCSixDQUExQixFQUE2QkMsQ0FBN0IsRUFBZ0MvSSxLQUFoQyxFQUF1Q2lJLE1BQXZDLEVBQStDZSxNQUEvQztBQUNELGlCQUZELE1BRU87QUFDTEUsc0JBQUlFLFFBQUosQ0FBYU4sQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUIvSSxLQUFuQixFQUEwQmlJLE1BQTFCO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7Ozs7Ozs7OztBQWJDLGFBaEl1QixFQTJKdkI7QUFDRGxCLG1CQUFLLGlCQURKO0FBRURoRyxxQkFBTyxTQUFTb0ksZUFBVCxDQUF5QkQsR0FBekIsRUFBOEJKLENBQTlCLEVBQWlDQyxDQUFqQyxFQUFvQy9JLEtBQXBDLEVBQTJDaUksTUFBM0MsRUFBbURlLE1BQW5ELEVBQTJEO0FBQ2hFLG9CQUFJZixXQUFXLENBQWYsRUFBa0I7QUFDaEI7QUFDRCxpQkFIK0QsQ0FHOUQ7QUFDRjs7O0FBR0Esb0JBQUlBLFNBQVMsQ0FBYixFQUFnQjtBQUNkQSw0QkFBVSxDQUFDLENBQVg7QUFDQWMsdUJBQUtkLE1BQUw7QUFDRDs7QUFFRGlCLG9CQUFJRyxTQUFKO0FBQ0FILG9CQUFJSSxNQUFKLENBQVdSLElBQUlFLE1BQWYsRUFBdUJELENBQXZCO0FBQ0FHLG9CQUFJSyxNQUFKLENBQVdULElBQUk5SSxLQUFKLEdBQVlnSixNQUF2QixFQUErQkQsQ0FBL0I7QUFDQUcsb0JBQUlNLGdCQUFKLENBQXFCVixJQUFJOUksS0FBekIsRUFBZ0MrSSxDQUFoQyxFQUFtQ0QsSUFBSTlJLEtBQXZDLEVBQThDK0ksSUFBSUMsTUFBbEQ7QUFDQUUsb0JBQUlLLE1BQUosQ0FBV1QsSUFBSTlJLEtBQWYsRUFBc0IrSSxJQUFJZCxNQUFKLEdBQWFlLE1BQW5DO0FBQ0FFLG9CQUFJTSxnQkFBSixDQUFxQlYsSUFBSTlJLEtBQXpCLEVBQWdDK0ksSUFBSWQsTUFBcEMsRUFBNENhLElBQUk5SSxLQUFKLEdBQVlnSixNQUF4RCxFQUFnRUQsSUFBSWQsTUFBcEU7QUFDQWlCLG9CQUFJSyxNQUFKLENBQVdULElBQUlFLE1BQWYsRUFBdUJELElBQUlkLE1BQTNCO0FBQ0FpQixvQkFBSU0sZ0JBQUosQ0FBcUJWLENBQXJCLEVBQXdCQyxJQUFJZCxNQUE1QixFQUFvQ2EsQ0FBcEMsRUFBdUNDLElBQUlkLE1BQUosR0FBYWUsTUFBcEQ7QUFDQUUsb0JBQUlLLE1BQUosQ0FBV1QsQ0FBWCxFQUFjQyxJQUFJQyxNQUFsQjtBQUNBRSxvQkFBSU0sZ0JBQUosQ0FBcUJWLENBQXJCLEVBQXdCQyxDQUF4QixFQUEyQkQsSUFBSUUsTUFBL0IsRUFBdUNELENBQXZDO0FBQ0FHLG9CQUFJTyxTQUFKO0FBQ0FQLG9CQUFJUSxJQUFKO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7OztBQTNCQyxhQTNKdUIsRUFtTXZCO0FBQ0QzQyxtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTNEksU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEJDLE1BQTFCLEVBQWtDQyxLQUFsQyxFQUF5Q0MsT0FBekMsRUFBa0R2TCxLQUFsRCxFQUF5REMsR0FBekQsRUFBOEQ7QUFDbkUscUJBQUt1TCxpQkFBTCxDQUF1QixLQUFLM0MsT0FBNUIsRUFBcUN1QyxLQUFyQyxFQUE0Q0MsTUFBNUMsRUFBb0RDLEtBQXBELEVBQTJEQyxPQUEzRCxFQUFvRXZMLEtBQXBFLEVBQTJFQyxHQUEzRTs7QUFFQSxvQkFBSSxLQUFLMkosaUJBQVQsRUFBNEI7QUFDMUIsdUJBQUs0QixpQkFBTCxDQUF1QixLQUFLekMsV0FBNUIsRUFBeUNxQyxLQUF6QyxFQUFnREMsTUFBaEQsRUFBd0RDLEtBQXhELEVBQStEQyxPQUEvRCxFQUF3RXZMLEtBQXhFLEVBQStFQyxHQUEvRTtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUFUQyxhQW5NdUIsRUEwTnZCO0FBQ0RzSSxtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU2lKLGlCQUFULENBQTJCZCxHQUEzQixFQUFnQ1UsS0FBaEMsRUFBdUNDLE1BQXZDLEVBQStDQyxLQUEvQyxFQUFzREMsT0FBdEQsRUFBK0R2TCxLQUEvRCxFQUFzRUMsR0FBdEUsRUFBMkU7QUFDaEYsb0JBQUksQ0FBQ3lLLEdBQUwsRUFBVTtBQUNSO0FBQ0Q7O0FBRUQsb0JBQUl2TCxTQUFTaU0sTUFBTWpNLE1BQU4sR0FBZSxDQUE1QjtBQUNBLG9CQUFJb0UsUUFBUWtJLEtBQUtDLEtBQUwsQ0FBV3ZNLFNBQVMsS0FBS2EsS0FBekIsQ0FBWixDQU5nRixDQU1uQztBQUM3Qzs7QUFFQSxvQkFBSTJMLE9BQU9GLEtBQUtDLEtBQUwsQ0FBV3ZNLFNBQVMsS0FBS2MsR0FBekIsSUFBZ0MsQ0FBM0M7QUFDQSxvQkFBSTJMLGNBQWNySSxLQUFsQjtBQUNBLG9CQUFJc0ksWUFBWUYsSUFBaEI7QUFDQSxvQkFBSUcsUUFBUSxLQUFLbEQsSUFBTCxDQUFVcEgsS0FBVixJQUFtQnFLLFlBQVlELFdBQVosR0FBMEIsQ0FBN0MsQ0FBWixDQVpnRixDQVluQjs7QUFFN0Qsb0JBQUlHLGFBQWFULFFBQVFDLE9BQXpCO0FBQ0Esb0JBQUlTLGFBQWFYLFNBQVNDLEtBQTFCO0FBQ0FaLG9CQUFJRyxTQUFKO0FBQ0FILG9CQUFJSSxNQUFKLENBQVcsQ0FBQ2MsY0FBY3JJLEtBQWYsSUFBd0J1SSxLQUFuQyxFQUEwQ0MsVUFBMUM7QUFDQXJCLG9CQUFJSyxNQUFKLENBQVcsQ0FBQ2EsY0FBY3JJLEtBQWYsSUFBd0J1SSxLQUFuQyxFQUEwQ0MsYUFBYU4sS0FBS0MsS0FBTCxDQUFXLENBQUNOLE1BQU0sSUFBSVEsV0FBVixLQUEwQixDQUEzQixJQUFnQ0ksVUFBM0MsQ0FBdkQ7QUFDQSxvQkFBSXZPLENBQUosRUFBT3dPLElBQVAsRUFBYUMsQ0FBYjs7QUFFQSxxQkFBS3pPLElBQUltTyxXQUFULEVBQXNCbk8sSUFBSW9PLFNBQTFCLEVBQXFDcE8sR0FBckMsRUFBMEM7QUFDeEN3Tyx5QkFBT2IsTUFBTSxJQUFJM04sQ0FBVixLQUFnQixDQUF2QjtBQUNBeU8sc0JBQUlULEtBQUtDLEtBQUwsQ0FBV08sT0FBT0QsVUFBbEIsQ0FBSjtBQUNBdEIsc0JBQUlLLE1BQUosQ0FBVyxDQUFDdE4sSUFBSThGLEtBQUwsSUFBY3VJLEtBQWQsR0FBc0IsS0FBS0ssU0FBdEMsRUFBaURKLGFBQWFHLENBQTlEO0FBQ0QsaUJBekIrRSxDQXlCOUU7QUFDRjs7O0FBR0Esb0JBQUl2RyxJQUFJa0csWUFBWSxDQUFwQjs7QUFFQSxxQkFBS2xHLENBQUwsRUFBUUEsS0FBS2lHLFdBQWIsRUFBMEJqRyxHQUExQixFQUErQjtBQUM3QnNHLHlCQUFPYixNQUFNLElBQUl6RixDQUFKLEdBQVEsQ0FBZCxLQUFvQixDQUEzQjtBQUNBdUcsc0JBQUlULEtBQUtDLEtBQUwsQ0FBV08sT0FBT0QsVUFBbEIsQ0FBSjtBQUNBdEIsc0JBQUlLLE1BQUosQ0FBVyxDQUFDcEYsSUFBSXBDLEtBQUwsSUFBY3VJLEtBQWQsR0FBc0IsS0FBS0ssU0FBdEMsRUFBaURKLGFBQWFHLENBQTlEO0FBQ0Q7O0FBRUR4QixvQkFBSUssTUFBSixDQUFXLENBQUNhLGNBQWNySSxLQUFmLElBQXdCdUksS0FBbkMsRUFBMENDLGFBQWFOLEtBQUtDLEtBQUwsQ0FBVyxDQUFDTixNQUFNLElBQUlRLFdBQUosR0FBa0IsQ0FBeEIsS0FBOEIsQ0FBL0IsSUFBb0NJLFVBQS9DLENBQXZEO0FBQ0F0QixvQkFBSU8sU0FBSjtBQUNBUCxvQkFBSVEsSUFBSjtBQUNEO0FBQ0Q7Ozs7QUEzQ0MsYUExTnVCLEVBeVF2QjtBQUNEM0MsbUJBQUssU0FESjtBQUVEaEcscUJBQU8sU0FBUzZKLE9BQVQsR0FBbUI7QUFDeEIscUJBQUt2RCxPQUFMLEdBQWUsSUFBZjtBQUNBLHFCQUFLRCxJQUFMLEdBQVksSUFBWjtBQUNBLHFCQUFLRyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EscUJBQUtELFFBQUwsR0FBZ0IsSUFBaEI7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7OztBQVJDLGFBelF1QixFQStSdkI7QUFDRFAsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzhKLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxPQUExQixFQUFtQ0MsSUFBbkMsRUFBeUM7QUFDOUMsb0JBQUlDLFFBQVEsSUFBWjs7QUFFQSxvQkFBSUQsU0FBUyxNQUFiLEVBQXFCO0FBQ25CLHlCQUFPLElBQUlFLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CO0FBQ3BDRiwwQkFBTTdELElBQU4sQ0FBV2dFLE1BQVgsQ0FBa0JELE9BQWxCLEVBQTJCTCxNQUEzQixFQUFtQ0MsT0FBbkM7QUFDRCxtQkFGTSxDQUFQO0FBR0QsaUJBSkQsTUFJTyxJQUFJQyxTQUFTLFNBQWIsRUFBd0I7QUFDN0IseUJBQU8sS0FBSzVELElBQUwsQ0FBVWlFLFNBQVYsQ0FBb0JQLE1BQXBCLEVBQTRCQyxPQUE1QixDQUFQO0FBQ0Q7QUFDRjtBQVpBLGFBL1J1QixDQUExQjs7QUE4U0EsbUJBQU81RCxXQUFQO0FBQ0QsV0FsWDhCLEVBQS9COztBQW9YQTVMLGtCQUFRMEssT0FBUixHQUFrQmtCLFdBQWxCO0FBQ0E3TCxpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0ExWjhCOztBQTRackMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLHFCQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQWtCeUssbUJBQWxCLEVBQTBDOztBQUVqRDs7QUFHQSxtQkFBU3NGLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFO0FBQTJCLGdCQUFJLE9BQU9rRixNQUFQLEtBQWtCLFVBQWxCLElBQWdDLFNBQU9BLE9BQU9DLFFBQWQsTUFBMkIsUUFBL0QsRUFBeUU7QUFBRUYsd0JBQVUsU0FBU0EsT0FBVCxDQUFpQmpGLEdBQWpCLEVBQXNCO0FBQUUsOEJBQWNBLEdBQWQsMENBQWNBLEdBQWQ7QUFBb0IsZUFBdEQ7QUFBeUQsYUFBcEksTUFBMEk7QUFBRWlGLHdCQUFVLFNBQVNBLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFLHVCQUFPQSxPQUFPLE9BQU9rRixNQUFQLEtBQWtCLFVBQXpCLElBQXVDbEYsSUFBSTdJLFdBQUosS0FBb0IrTixNQUEzRCxJQUFxRWxGLFFBQVFrRixPQUFPbE8sU0FBcEYsR0FBZ0csUUFBaEcsVUFBa0hnSixHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsZUFBaks7QUFBb0ssYUFBQyxPQUFPaUYsUUFBUWpGLEdBQVIsQ0FBUDtBQUFzQjs7QUFFMVh6SyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsY0FBSXdGLE9BQU9DLHdCQUF3QjFGLHFCQUFvQixhQUFjLHFCQUFsQyxDQUF4QixDQUFYOztBQUVBLG1CQUFTMkYsd0JBQVQsQ0FBa0NDLFdBQWxDLEVBQStDO0FBQUUsZ0JBQUksT0FBT0MsT0FBUCxLQUFtQixVQUF2QixFQUFtQyxPQUFPLElBQVAsQ0FBYSxJQUFJQyxvQkFBb0IsSUFBSUQsT0FBSixFQUF4QixDQUF1QyxJQUFJRSxtQkFBbUIsSUFBSUYsT0FBSixFQUF2QixDQUFzQyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx3QkFBVCxDQUFrQ0MsV0FBbEMsRUFBK0M7QUFBRSxxQkFBT0EsY0FBY0csZ0JBQWQsR0FBaUNELGlCQUF4QztBQUE0RCxhQUF6SSxFQUEySUYsV0FBM0ksQ0FBUDtBQUFpSzs7QUFFL1UsbUJBQVNGLHVCQUFULENBQWlDckYsR0FBakMsRUFBc0N1RixXQUF0QyxFQUFtRDtBQUFFLGdCQUFJLENBQUNBLFdBQUQsSUFBZ0J2RixHQUFoQixJQUF1QkEsSUFBSUMsVUFBL0IsRUFBMkM7QUFBRSxxQkFBT0QsR0FBUDtBQUFhLGFBQUMsSUFBSUEsUUFBUSxJQUFSLElBQWdCaUYsUUFBUWpGLEdBQVIsTUFBaUIsUUFBakIsSUFBNkIsT0FBT0EsR0FBUCxLQUFlLFVBQWhFLEVBQTRFO0FBQUUscUJBQU8sRUFBRUosU0FBU0ksR0FBWCxFQUFQO0FBQTBCLGFBQUMsSUFBSTJGLFFBQVFMLHlCQUF5QkMsV0FBekIsQ0FBWixDQUFtRCxJQUFJSSxTQUFTQSxNQUFNQyxHQUFOLENBQVU1RixHQUFWLENBQWIsRUFBNkI7QUFBRSxxQkFBTzJGLE1BQU1qUSxHQUFOLENBQVVzSyxHQUFWLENBQVA7QUFBd0IsYUFBQyxJQUFJNkYsU0FBUyxFQUFiLENBQWlCLElBQUlDLHdCQUF3QnZRLE9BQU9DLGNBQVAsSUFBeUJELE9BQU93USx3QkFBNUQsQ0FBc0YsS0FBSyxJQUFJckYsR0FBVCxJQUFnQlYsR0FBaEIsRUFBcUI7QUFBRSxrQkFBSVUsUUFBUSxTQUFSLElBQXFCbkwsT0FBT3lCLFNBQVAsQ0FBaUJnUCxjQUFqQixDQUFnQzFILElBQWhDLENBQXFDMEIsR0FBckMsRUFBMENVLEdBQTFDLENBQXpCLEVBQXlFO0FBQUUsb0JBQUl1RixPQUFPSCx3QkFBd0J2USxPQUFPd1Esd0JBQVAsQ0FBZ0MvRixHQUFoQyxFQUFxQ1UsR0FBckMsQ0FBeEIsR0FBb0UsSUFBL0UsQ0FBcUYsSUFBSXVGLFNBQVNBLEtBQUt2USxHQUFMLElBQVl1USxLQUFLQyxHQUExQixDQUFKLEVBQW9DO0FBQUUzUSx5QkFBT0MsY0FBUCxDQUFzQnFRLE1BQXRCLEVBQThCbkYsR0FBOUIsRUFBbUN1RixJQUFuQztBQUEyQyxpQkFBakYsTUFBdUY7QUFBRUoseUJBQU9uRixHQUFQLElBQWNWLElBQUlVLEdBQUosQ0FBZDtBQUF5QjtBQUFFO0FBQUUsYUFBQ21GLE9BQU9qRyxPQUFQLEdBQWlCSSxHQUFqQixDQUFzQixJQUFJMkYsS0FBSixFQUFXO0FBQUVBLG9CQUFNTyxHQUFOLENBQVVsRyxHQUFWLEVBQWU2RixNQUFmO0FBQXlCLGFBQUMsT0FBT0EsTUFBUDtBQUFnQjs7QUFFdHlCLG1CQUFTM0YsZUFBVCxDQUF5QnRCLFFBQXpCLEVBQW1DdUIsV0FBbkMsRUFBZ0Q7QUFBRSxnQkFBSSxFQUFFdkIsb0JBQW9CdUIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLG9CQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLG1CQUFTQyxpQkFBVCxDQUEyQjFGLE1BQTNCLEVBQW1DMkYsS0FBbkMsRUFBMEM7QUFBRSxpQkFBSyxJQUFJMUssSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEssTUFBTWhKLE1BQTFCLEVBQWtDMUIsR0FBbEMsRUFBdUM7QUFBRSxrQkFBSTJLLGFBQWFELE1BQU0xSyxDQUFOLENBQWpCLENBQTJCMkssV0FBVzlLLFVBQVgsR0FBd0I4SyxXQUFXOUssVUFBWCxJQUF5QixLQUFqRCxDQUF3RDhLLFdBQVdDLFlBQVgsR0FBMEIsSUFBMUIsQ0FBZ0MsSUFBSSxXQUFXRCxVQUFmLEVBQTJCQSxXQUFXRSxRQUFYLEdBQXNCLElBQXRCLENBQTRCbEwsT0FBT0MsY0FBUCxDQUFzQm1GLE1BQXRCLEVBQThCNEYsV0FBV0csR0FBekMsRUFBOENILFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULG1CQUFTSSxZQUFULENBQXNCUixXQUF0QixFQUFtQ1MsVUFBbkMsRUFBK0NDLFdBQS9DLEVBQTREO0FBQUUsZ0JBQUlELFVBQUosRUFBZ0JQLGtCQUFrQkYsWUFBWW5KLFNBQTlCLEVBQXlDNEosVUFBekMsRUFBc0QsSUFBSUMsV0FBSixFQUFpQlIsa0JBQWtCRixXQUFsQixFQUErQlUsV0FBL0IsRUFBNkMsT0FBT1YsV0FBUDtBQUFxQjs7QUFFdk4sbUJBQVNnRyxTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxnQkFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXRCLElBQW9DQSxlQUFlLElBQXZELEVBQTZEO0FBQUUsb0JBQU0sSUFBSWpHLFNBQUosQ0FBYyxvREFBZCxDQUFOO0FBQTRFLGFBQUNnRyxTQUFTcFAsU0FBVCxHQUFxQnpCLE9BQU8wQixNQUFQLENBQWNvUCxjQUFjQSxXQUFXclAsU0FBdkMsRUFBa0QsRUFBRUcsYUFBYSxFQUFFdUQsT0FBTzBMLFFBQVQsRUFBbUIzRixVQUFVLElBQTdCLEVBQW1DRCxjQUFjLElBQWpELEVBQWYsRUFBbEQsQ0FBckIsQ0FBa0osSUFBSTZGLFVBQUosRUFBZ0JDLGdCQUFnQkYsUUFBaEIsRUFBMEJDLFVBQTFCO0FBQXdDOztBQUVqWSxtQkFBU0MsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0FBQUVGLDhCQUFrQi9RLE9BQU9rUixjQUFQLElBQXlCLFNBQVNILGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjtBQUFFRCxnQkFBRUcsU0FBRixHQUFjRixDQUFkLENBQWlCLE9BQU9ELENBQVA7QUFBVyxhQUF4RyxDQUEwRyxPQUFPRCxnQkFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixDQUFQO0FBQStCOztBQUUxSyxtQkFBU0csWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0I7QUFBRSxnQkFBSUMsNEJBQTRCQywyQkFBaEMsQ0FBNkQsT0FBTyxTQUFTQyxvQkFBVCxHQUFnQztBQUFFLGtCQUFJQyxRQUFRQyxnQkFBZ0JMLE9BQWhCLENBQVo7QUFBQSxrQkFBc0NNLE1BQXRDLENBQThDLElBQUlMLHlCQUFKLEVBQStCO0FBQUUsb0JBQUlNLFlBQVlGLGdCQUFnQixJQUFoQixFQUFzQjlQLFdBQXRDLENBQW1EK1AsU0FBU0UsUUFBUUMsU0FBUixDQUFrQkwsS0FBbEIsRUFBeUJNLFNBQXpCLEVBQW9DSCxTQUFwQyxDQUFUO0FBQTBELGVBQTlJLE1BQW9KO0FBQUVELHlCQUFTRixNQUFNTyxLQUFOLENBQVksSUFBWixFQUFrQkQsU0FBbEIsQ0FBVDtBQUF3QyxlQUFDLE9BQU9FLDJCQUEyQixJQUEzQixFQUFpQ04sTUFBakMsQ0FBUDtBQUFrRCxhQUF4VTtBQUEyVTs7QUFFemEsbUJBQVNNLDBCQUFULENBQW9DblEsSUFBcEMsRUFBMENpSCxJQUExQyxFQUFnRDtBQUFFLGdCQUFJQSxTQUFTMkcsUUFBUTNHLElBQVIsTUFBa0IsUUFBbEIsSUFBOEIsT0FBT0EsSUFBUCxLQUFnQixVQUF2RCxDQUFKLEVBQXdFO0FBQUUscUJBQU9BLElBQVA7QUFBYyxhQUFDLE9BQU9tSix1QkFBdUJwUSxJQUF2QixDQUFQO0FBQXNDOztBQUVqTCxtQkFBU29RLHNCQUFULENBQWdDcFEsSUFBaEMsRUFBc0M7QUFBRSxnQkFBSUEsU0FBUyxLQUFLLENBQWxCLEVBQXFCO0FBQUUsb0JBQU0sSUFBSXFRLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsYUFBQyxPQUFPclEsSUFBUDtBQUFjOztBQUV0SyxtQkFBU3lQLHlCQUFULEdBQXFDO0FBQUUsZ0JBQUksT0FBT00sT0FBUCxLQUFtQixXQUFuQixJQUFrQyxDQUFDQSxRQUFRQyxTQUEvQyxFQUEwRCxPQUFPLEtBQVAsQ0FBYyxJQUFJRCxRQUFRQyxTQUFSLENBQWtCTSxJQUF0QixFQUE0QixPQUFPLEtBQVAsQ0FBYyxJQUFJLE9BQU9DLEtBQVAsS0FBaUIsVUFBckIsRUFBaUMsT0FBTyxJQUFQLENBQWEsSUFBSTtBQUFFQyxzQkFBUTdRLFNBQVIsQ0FBa0I4USxPQUFsQixDQUEwQnhKLElBQTFCLENBQStCOEksUUFBUUMsU0FBUixDQUFrQlEsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CLEVBQWdGLE9BQU8sSUFBUDtBQUFjLGFBQXBHLENBQXFHLE9BQU9wTixDQUFQLEVBQVU7QUFBRSxxQkFBTyxLQUFQO0FBQWU7QUFBRTs7QUFFelUsbUJBQVN3TSxlQUFULENBQXlCVixDQUF6QixFQUE0QjtBQUFFVSw4QkFBa0IxUixPQUFPa1IsY0FBUCxHQUF3QmxSLE9BQU93UyxjQUEvQixHQUFnRCxTQUFTZCxlQUFULENBQXlCVixDQUF6QixFQUE0QjtBQUFFLHFCQUFPQSxFQUFFRyxTQUFGLElBQWVuUixPQUFPd1MsY0FBUCxDQUFzQnhCLENBQXRCLENBQXRCO0FBQWlELGFBQWpKLENBQW1KLE9BQU9VLGdCQUFnQlYsQ0FBaEIsQ0FBUDtBQUE0Qjs7QUFFN007Ozs7O0FBS0EsY0FBSXlCLFNBQVMsYUFBYSxVQUFVQyxjQUFWLEVBQTBCO0FBQ2xEOUIsc0JBQVU2QixNQUFWLEVBQWtCQyxjQUFsQjs7QUFFQSxnQkFBSUMsU0FBU3ZCLGFBQWFxQixNQUFiLENBQWI7O0FBRUE7Ozs7QUFJQSxxQkFBU0EsTUFBVCxDQUFnQnhSLFNBQWhCLEVBQTJCSixNQUEzQixFQUFtQztBQUNqQyxrQkFBSXdPLEtBQUo7O0FBRUExRSw4QkFBZ0IsSUFBaEIsRUFBc0I4SCxNQUF0Qjs7QUFFQXBELHNCQUFRc0QsT0FBTzVKLElBQVAsQ0FBWSxJQUFaLENBQVI7QUFDQXNHLG9CQUFNcE8sU0FBTixHQUFrQjRPLEtBQUsrQyxlQUFMLENBQXFCM1IsU0FBckIsRUFBZ0NKLE9BQU9rTSxRQUF2QyxDQUFsQjtBQUNBOzs7O0FBSUFzQyxvQkFBTXhPLE1BQU4sR0FBZUEsTUFBZjtBQUNBOzs7OztBQUtBd08sb0JBQU1qTCxLQUFOLEdBQWMsQ0FBZDtBQUNBOzs7OztBQUtBaUwsb0JBQU1oRCxNQUFOLEdBQWV4TCxPQUFPd0wsTUFBUCxHQUFnQmdELE1BQU14TyxNQUFOLENBQWFnUyxVQUE1QztBQUNBeEQsb0JBQU15RCxPQUFOLEdBQWdCLENBQWhCO0FBQ0E7Ozs7O0FBS0F6RCxvQkFBTTBELE9BQU4sR0FBZ0IsSUFBaEI7QUFDQSxxQkFBTzFELEtBQVA7QUFDRDtBQUNEOzs7Ozs7OztBQVNBakUseUJBQWFxSCxNQUFiLEVBQXFCLENBQUM7QUFDcEJ0SCxtQkFBSyxPQURlO0FBRXBCaEcscUJBQU8sU0FBUzZOLEtBQVQsQ0FBZUMsRUFBZixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDaEMsdUJBQU9yRCxLQUFLbUQsS0FBTCxDQUFXQyxFQUFYLEVBQWVDLE1BQWYsQ0FBUDtBQUNEO0FBQ0Q7Ozs7O0FBTG9CLGFBQUQsRUFVbEI7QUFDRC9ILG1CQUFLLGVBREo7QUFFRGhHLHFCQUFPLFNBQVNnTyxhQUFULEdBQXlCO0FBQzlCLHFCQUFLSixPQUFMLEdBQWVsRCxLQUFLK0MsZUFBTCxDQUFxQixLQUFLM1IsU0FBTCxDQUFlbVMsV0FBZixDQUEyQkMsU0FBU0MsYUFBVCxDQUF1QixNQUF2QixDQUEzQixDQUFyQixFQUFpRixLQUFLelMsTUFBTCxDQUFZa00sUUFBN0YsQ0FBZjtBQUNBLHFCQUFLaUcsS0FBTCxDQUFXLEtBQUtELE9BQWhCLEVBQXlCO0FBQ3ZCUSwyQkFBUyxPQURjO0FBRXZCQyw0QkFBVSxVQUZhO0FBR3ZCQyw4QkFBWSxNQUhXO0FBSXZCQyxvQ0FBa0IsTUFKSztBQUt2QnJILDBCQUFRLEtBQUt4TCxNQUFMLENBQVl3TCxNQUFaLEdBQXFCO0FBTE4saUJBQXpCOztBQVFBLG9CQUFJLEtBQUt4TCxNQUFMLENBQVl1QixVQUFaLElBQTBCLEtBQUt2QixNQUFMLENBQVk4UyxZQUExQyxFQUF3RDtBQUN0RCx1QkFBS1gsS0FBTCxDQUFXLEtBQUtELE9BQWhCLEVBQXlCO0FBQ3ZCM08sMkJBQU8sTUFEZ0I7QUFFdkJ3UCwrQkFBVyxLQUFLL1MsTUFBTCxDQUFZZ1QsYUFBWixHQUE0QixRQUE1QixHQUF1QyxNQUYzQjtBQUd2QkMsK0JBQVc7QUFIWSxtQkFBekI7QUFLRDs7QUFFRCxxQkFBS0Msa0JBQUw7QUFDRDtBQUNEOzs7Ozs7OztBQXRCQyxhQVZrQixFQXdDbEI7QUFDRDVJLG1CQUFLLGFBREo7QUFFRGhHLHFCQUFPLFNBQVM2TyxXQUFULENBQXFCOU8sQ0FBckIsRUFBd0IrTyxTQUF4QixFQUFtQztBQUN4QyxpQkFBQ0EsU0FBRCxJQUFjL08sRUFBRWdQLGNBQUYsRUFBZDtBQUNBLG9CQUFJQyxVQUFVdEUsS0FBSytDLGVBQUwsQ0FBcUIxTixFQUFFa1AsYUFBRixHQUFrQmxQLEVBQUVrUCxhQUFGLENBQWdCLENBQWhCLENBQWxCLEdBQXVDbFAsQ0FBNUQsRUFBK0QsS0FBS3JFLE1BQUwsQ0FBWWtNLFFBQTNFLEVBQXFGb0gsT0FBbkc7QUFDQSxvQkFBSUUsT0FBTyxLQUFLdEIsT0FBTCxDQUFhdUIscUJBQWIsRUFBWDtBQUNBLG9CQUFJQyxlQUFlLEtBQUtuUSxLQUF4QjtBQUNBLG9CQUFJb1EsY0FBYyxLQUFLQyxRQUFMLEVBQWxCO0FBQ0Esb0JBQUlDLGlCQUFpQixLQUFLQyxpQkFBTCxDQUF1Qk4sSUFBdkIsRUFBNkJGLE9BQTdCLENBQXJCO0FBQ0Esb0JBQUl6SSxRQUFKOztBQUVBLG9CQUFJLENBQUMsS0FBSzdLLE1BQUwsQ0FBWXVCLFVBQWIsSUFBMkJtUyxlQUFlQyxXQUE5QyxFQUEyRDtBQUN6RDlJLDZCQUFXZ0osa0JBQWtCLEtBQUs3VCxNQUFMLENBQVlnUyxVQUFaLEdBQXlCMEIsWUFBM0MsS0FBNEQsQ0FBdkU7QUFDRCxpQkFGRCxNQUVPO0FBQ0w3SSw2QkFBVyxDQUFDZ0osaUJBQWlCLEtBQUszQixPQUFMLENBQWE2QixVQUEvQixJQUE2QyxLQUFLN0IsT0FBTCxDQUFhOEIsV0FBMUQsSUFBeUUsQ0FBcEY7QUFDRDs7QUFFRCx1QkFBT2hGLEtBQUtpRixLQUFMLENBQVdwSixRQUFYLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQVA7QUFDRDtBQWxCQSxhQXhDa0IsRUEyRGxCO0FBQ0RQLG1CQUFLLG1CQURKO0FBRURoRyxxQkFBTyxTQUFTd1AsaUJBQVQsQ0FBMkJJLFdBQTNCLEVBQXdDWixPQUF4QyxFQUFpRDtBQUN0RCxvQkFBSSxLQUFLdFQsTUFBTCxDQUFZbVUsR0FBaEIsRUFBcUI7QUFDbkIseUJBQU9ELFlBQVlFLEtBQVosR0FBb0JkLE9BQTNCO0FBQ0QsaUJBRkQsTUFFTztBQUNMLHlCQUFPQSxVQUFVWSxZQUFZRyxJQUE3QjtBQUNEO0FBQ0Y7QUFSQSxhQTNEa0IsRUFvRWxCO0FBQ0QvSixtQkFBSyxvQkFESjtBQUVEaEcscUJBQU8sU0FBUzRPLGtCQUFULEdBQThCO0FBQ25DLG9CQUFJb0IsU0FBUyxJQUFiOztBQUVBLHFCQUFLcEMsT0FBTCxDQUFhOU4sZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBVUMsQ0FBVixFQUFhO0FBQ2xELHNCQUFJa1EsZ0JBQWdCdkYsS0FBSytDLGVBQUwsQ0FBcUIxTixDQUFyQixFQUF3QmlRLE9BQU90VSxNQUFQLENBQWNrTSxRQUF0QyxDQUFwQjtBQUNBLHNCQUFJc0ksa0JBQWtCRixPQUFPcEMsT0FBUCxDQUFldUMsWUFBZixHQUE4QkgsT0FBT3BDLE9BQVAsQ0FBZXdDLFlBQW5FOztBQUVBLHNCQUFJRixvQkFBb0IsQ0FBeEIsRUFBMkI7QUFDekI7QUFDQSx3QkFBSWhCLE9BQU9jLE9BQU9wQyxPQUFQLENBQWV1QixxQkFBZixFQUFYOztBQUVBLHdCQUFJYyxjQUFjSSxPQUFkLElBQXlCbkIsS0FBS29CLE1BQUwsR0FBY0osZUFBM0MsRUFBNEQ7QUFDMUQ7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsc0JBQUlGLE9BQU90VSxNQUFQLENBQWM2VSxRQUFsQixFQUE0QjtBQUMxQlAsMkJBQU9RLFNBQVAsQ0FBaUIsT0FBakIsRUFBMEJ6USxDQUExQixFQUE2QmlRLE9BQU9uQixXQUFQLENBQW1COU8sQ0FBbkIsQ0FBN0I7QUFDRDtBQUNGLGlCQWpCRDtBQWtCQSxxQkFBSzZOLE9BQUwsQ0FBYTlOLGdCQUFiLENBQThCLFVBQTlCLEVBQTBDLFVBQVVDLENBQVYsRUFBYTtBQUNyRCxzQkFBSWlRLE9BQU90VSxNQUFQLENBQWM2VSxRQUFsQixFQUE0QjtBQUMxQlAsMkJBQU9RLFNBQVAsQ0FBaUIsVUFBakIsRUFBNkJ6USxDQUE3QixFQUFnQ2lRLE9BQU9uQixXQUFQLENBQW1COU8sQ0FBbkIsQ0FBaEM7QUFDRDtBQUNGLGlCQUpEO0FBS0EscUJBQUs2TixPQUFMLENBQWE5TixnQkFBYixDQUE4QixRQUE5QixFQUF3QyxVQUFVQyxDQUFWLEVBQWE7QUFDbkQseUJBQU9pUSxPQUFPUSxTQUFQLENBQWlCLFFBQWpCLEVBQTJCelEsQ0FBM0IsQ0FBUDtBQUNELGlCQUZEO0FBR0Q7QUFDRDs7Ozs7Ozs7Ozs7O0FBaENDLGFBcEVrQixFQWdIbEI7QUFDRGlHLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVN5USxTQUFULENBQW1CNUgsS0FBbkIsRUFBMEJqTSxNQUExQixFQUFrQ2EsS0FBbEMsRUFBeUNDLEdBQXpDLEVBQThDO0FBQ25ELG9CQUFJLENBQUMsS0FBS2dULFFBQUwsQ0FBYzlULE1BQWQsQ0FBTCxFQUE0QjtBQUMxQix1QkFBSzBLLFNBQUw7QUFDRDs7QUFFRCxxQkFBSzVMLE1BQUwsQ0FBWWlWLFFBQVosR0FBdUIsS0FBS0MsUUFBTCxDQUFjL0gsS0FBZCxFQUFxQixDQUFyQixFQUF3QnBMLEtBQXhCLEVBQStCQyxHQUEvQixDQUF2QixHQUE2RCxLQUFLbVQsUUFBTCxDQUFjaEksS0FBZCxFQUFxQixDQUFyQixFQUF3QnBMLEtBQXhCLEVBQStCQyxHQUEvQixDQUE3RDtBQUNEO0FBQ0Q7Ozs7QUFUQyxhQWhIa0IsRUE2SGxCO0FBQ0RzSSxtQkFBSyxhQURKO0FBRURoRyxxQkFBTyxTQUFTOFEsV0FBVCxHQUF1QjtBQUM1QixvQkFBSSxLQUFLbEQsT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN6Qix1QkFBS0EsT0FBTCxDQUFhNkIsVUFBYixHQUEwQixDQUExQjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7O0FBUEMsYUE3SGtCLEVBMElsQjtBQUNEekosbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUytRLFFBQVQsQ0FBa0JDLE9BQWxCLEVBQTJCO0FBQ2hDLG9CQUFJM0MsV0FBVyxLQUFLVCxPQUFMLENBQWE4QixXQUFiLEdBQTJCc0IsT0FBMUM7QUFDQSxxQkFBS0Msa0JBQUwsQ0FBd0I1QyxRQUF4QixFQUFrQyxJQUFsQztBQUNEO0FBQ0Q7Ozs7Ozs7O0FBTkMsYUExSWtCLEVBd0psQjtBQUNEckksbUJBQUssb0JBREo7QUFFRGhHLHFCQUFPLFNBQVNpUixrQkFBVCxDQUE0QjVDLFFBQTVCLEVBQXNDNkMsU0FBdEMsRUFBaUQ7QUFDdEQsb0JBQUl6QixhQUFhLEtBQUs3QixPQUFMLENBQWE2QixVQUE5QjtBQUNBLG9CQUFJMEIsT0FBTyxDQUFDLEVBQUUsS0FBS3ZELE9BQUwsQ0FBYXdELFdBQWIsR0FBMkIsQ0FBN0IsQ0FBWjtBQUNBLG9CQUFJQyxZQUFZLEtBQUt6RCxPQUFMLENBQWE4QixXQUFiLEdBQTJCLEtBQUs5QixPQUFMLENBQWF3RCxXQUF4RDtBQUNBLG9CQUFJblIsU0FBU29PLFdBQVc4QyxJQUF4QjtBQUNBLG9CQUFJRyxTQUFTclIsU0FBU3dQLFVBQXRCOztBQUVBLG9CQUFJNEIsYUFBYSxDQUFqQixFQUFvQjtBQUNsQjtBQUNBO0FBQ0QsaUJBVnFELENBVXBEOzs7QUFHRixvQkFBSSxDQUFDSCxTQUFELElBQWMsQ0FBQ0MsSUFBRCxJQUFTRyxNQUF2QixJQUFpQ0EsU0FBU0gsSUFBOUMsRUFBb0Q7QUFDbEQ7QUFDQSxzQkFBSUksT0FBTyxLQUFLN1YsTUFBTCxDQUFZOFYsY0FBdkIsQ0FGa0QsQ0FFWDs7QUFFdkNELDBCQUFRSixJQUFSO0FBQ0FJLDBCQUFRRixTQUFSO0FBQ0FDLDJCQUFTcEksS0FBS3VJLEdBQUwsQ0FBUyxDQUFDRixJQUFWLEVBQWdCckksS0FBS3dJLEdBQUwsQ0FBU0gsSUFBVCxFQUFlRCxNQUFmLENBQWhCLENBQVQ7QUFDQXJSLDJCQUFTd1AsYUFBYTZCLE1BQXRCO0FBQ0QsaUJBckJxRCxDQXFCcEQ7OztBQUdGclIseUJBQVNpSixLQUFLdUksR0FBTCxDQUFTLENBQVQsRUFBWXZJLEtBQUt3SSxHQUFMLENBQVNMLFNBQVQsRUFBb0JwUixNQUFwQixDQUFaLENBQVQsQ0F4QnNELENBd0JIOztBQUVuRCxvQkFBSUEsVUFBVXdQLFVBQWQsRUFBMEI7QUFDeEIsdUJBQUs3QixPQUFMLENBQWE2QixVQUFiLEdBQTBCeFAsTUFBMUI7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQWhDQyxhQXhKa0IsRUE4TGxCO0FBQ0QrRixtQkFBSyxZQURKO0FBRURoRyxxQkFBTyxTQUFTMlIsVUFBVCxHQUFzQjtBQUMzQixvQkFBSTVKLElBQUksQ0FBUjs7QUFFQSxvQkFBSSxLQUFLNkYsT0FBVCxFQUFrQjtBQUNoQixzQkFBSUYsYUFBYSxLQUFLaFMsTUFBTCxDQUFZZ1MsVUFBN0I7QUFDQTNGLHNCQUFJbUIsS0FBS0MsS0FBTCxDQUFXLEtBQUt5RSxPQUFMLENBQWE2QixVQUFiLEdBQTBCL0IsVUFBckMsQ0FBSixDQUZnQixDQUVzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBSSxLQUFLaFMsTUFBTCxDQUFZOFMsWUFBaEIsRUFBOEI7QUFDNUIsd0JBQUk2QyxZQUFZLENBQUMsRUFBRSxLQUFLekQsT0FBTCxDQUFhOEIsV0FBYixHQUEyQmhDLFVBQTNCLEdBQXdDLEtBQUs0QixRQUFMLEVBQTFDLENBQWpCO0FBQ0F2SCx3QkFBSW1CLEtBQUt3SSxHQUFMLENBQVNMLFNBQVQsRUFBb0JuSSxLQUFLdUksR0FBTCxDQUFTLENBQVQsRUFBWTFKLENBQVosQ0FBcEIsQ0FBSjtBQUNEO0FBQ0Y7O0FBRUQsdUJBQU9BLENBQVA7QUFDRDtBQUNEOzs7Ozs7QUFyQkMsYUE5TGtCLEVBeU5sQjtBQUNEL0IsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBU3NQLFFBQVQsR0FBb0I7QUFDekIsdUJBQU9wRyxLQUFLQyxLQUFMLENBQVcsS0FBS3JOLFNBQUwsQ0FBZXNWLFdBQWYsR0FBNkIsS0FBSzFWLE1BQUwsQ0FBWWdTLFVBQXBELENBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUF6TmtCLEVBcU9sQjtBQUNEMUgsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzBRLFFBQVQsQ0FBa0J6UixLQUFsQixFQUF5QjtBQUM5QixvQkFBSSxLQUFLQSxLQUFMLElBQWNBLEtBQWxCLEVBQXlCO0FBQ3ZCLHlCQUFPLEtBQVA7QUFDRDs7QUFFRCxxQkFBS0EsS0FBTCxHQUFhQSxLQUFiOztBQUVBLG9CQUFJLEtBQUt2RCxNQUFMLENBQVl1QixVQUFaLElBQTBCLEtBQUt2QixNQUFMLENBQVk4UyxZQUExQyxFQUF3RDtBQUN0RCx1QkFBS1gsS0FBTCxDQUFXLEtBQUtELE9BQWhCLEVBQXlCO0FBQ3ZCM08sMkJBQU87QUFEZ0IsbUJBQXpCO0FBR0QsaUJBSkQsTUFJTztBQUNMLHNCQUFJMlMsV0FBVyxDQUFDLEVBQUUsS0FBSzNTLEtBQUwsR0FBYSxLQUFLdkQsTUFBTCxDQUFZZ1MsVUFBM0IsQ0FBRCxHQUEwQyxJQUF6RDtBQUNBLHVCQUFLRyxLQUFMLENBQVcsS0FBS0QsT0FBaEIsRUFBeUI7QUFDdkIzTywyQkFBTzJTO0FBRGdCLG1CQUF6QjtBQUdEOztBQUVELHFCQUFLQyxVQUFMO0FBQ0EsdUJBQU8sSUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUF2QkMsYUFyT2tCLEVBbVFsQjtBQUNEN0wsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBUzhSLFNBQVQsQ0FBbUI1SyxNQUFuQixFQUEyQjtBQUNoQyxvQkFBSUEsVUFBVSxLQUFLQSxNQUFuQixFQUEyQjtBQUN6Qix5QkFBTyxLQUFQO0FBQ0Q7O0FBRUQscUJBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBLHFCQUFLMkcsS0FBTCxDQUFXLEtBQUtELE9BQWhCLEVBQXlCO0FBQ3ZCMUcsMEJBQVEsQ0FBQyxFQUFFLEtBQUtBLE1BQUwsR0FBYyxLQUFLeEwsTUFBTCxDQUFZZ1MsVUFBNUIsQ0FBRCxHQUEyQztBQUQ1QixpQkFBekI7QUFHQSxxQkFBS21FLFVBQUw7QUFDQSx1QkFBTyxJQUFQO0FBQ0Q7QUFDRDs7Ozs7O0FBZEMsYUFuUWtCLEVBdVJsQjtBQUNEN0wsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBU3VHLFFBQVQsQ0FBa0J3TCxTQUFsQixFQUE2QjtBQUNsQyxvQkFBSUMsYUFBYSxJQUFJLEtBQUt0VyxNQUFMLENBQVlnUyxVQUFqQztBQUNBLG9CQUFJdUUsTUFBTS9JLEtBQUtDLEtBQUwsQ0FBVzRJLFlBQVksS0FBSzlTLEtBQTVCLElBQXFDK1MsVUFBL0M7O0FBRUEsb0JBQUlDLE1BQU0sS0FBS3RFLE9BQVgsSUFBc0JzRSxNQUFNLEtBQUt0RSxPQUFYLElBQXNCcUUsVUFBaEQsRUFBNEQ7QUFDMUQsdUJBQUtyRSxPQUFMLEdBQWVzRSxHQUFmOztBQUVBLHNCQUFJLEtBQUt2VyxNQUFMLENBQVk4UyxZQUFaLElBQTRCLEtBQUs5UyxNQUFMLENBQVl3VyxVQUE1QyxFQUF3RDtBQUN0RCx3QkFBSUMsU0FBUyxDQUFDLEVBQUUsS0FBS3ZFLE9BQUwsQ0FBYThCLFdBQWIsR0FBMkJxQyxTQUE3QixDQUFkO0FBQ0EseUJBQUtkLGtCQUFMLENBQXdCa0IsTUFBeEIsRUFBZ0MsS0FBS3pXLE1BQUwsQ0FBWTBXLHFCQUE1QztBQUNEOztBQUVELHVCQUFLQyxjQUFMLENBQW9CSixHQUFwQjtBQUNEO0FBQ0Y7QUFDRDs7OztBQWpCQyxhQXZSa0IsRUE0U2xCO0FBQ0RqTSxtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTNkosT0FBVCxHQUFtQjtBQUN4QixxQkFBS3lJLEtBQUw7O0FBRUEsb0JBQUksS0FBSzFFLE9BQVQsRUFBa0I7QUFDaEIsc0JBQUksS0FBS0EsT0FBTCxDQUFhMkUsVUFBYixJQUEyQixLQUFLelcsU0FBTCxDQUFlMFcsVUFBOUMsRUFBMEQ7QUFDeEQseUJBQUsxVyxTQUFMLENBQWV1SSxXQUFmLENBQTJCLEtBQUt1SixPQUFMLENBQWE0RSxVQUF4QztBQUNEOztBQUVELHVCQUFLNUUsT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNGO0FBQ0Q7O0FBRUE7Ozs7OztBQWZDLGFBNVNrQixFQWlVbEI7QUFDRDVILG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVN5UyxZQUFULEdBQXdCLENBQUU7QUFDakM7Ozs7OztBQUhDLGFBalVrQixFQTBVbEI7QUFDRHpNLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVM2UixVQUFULEdBQXNCLENBQUU7QUFDL0I7Ozs7Ozs7Ozs7Ozs7O0FBSEMsYUExVWtCLEVBMlZsQjtBQUNEN0wsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzRRLFFBQVQsQ0FBa0IvSCxLQUFsQixFQUF5QjZKLFlBQXpCLEVBQXVDalYsS0FBdkMsRUFBOENDLEdBQTlDLEVBQW1ELENBQUU7QUFDNUQ7Ozs7Ozs7Ozs7Ozs7O0FBSEMsYUEzVmtCLEVBNFdsQjtBQUNEc0ksbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzZRLFFBQVQsQ0FBa0JoSSxLQUFsQixFQUF5QjZKLFlBQXpCLEVBQXVDalYsS0FBdkMsRUFBOENDLEdBQTlDLEVBQW1ELENBQUU7QUFDNUQ7Ozs7OztBQUhDLGFBNVdrQixFQXFYbEI7QUFDRHNJLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVNzSCxTQUFULEdBQXFCLENBQUU7QUFDOUI7Ozs7Ozs7QUFIQyxhQXJYa0IsRUErWGxCO0FBQ0R0QixtQkFBSyxnQkFESjtBQUVEaEcscUJBQU8sU0FBU3FTLGNBQVQsQ0FBd0JoRSxRQUF4QixFQUFrQyxDQUFFO0FBRjFDLGFBL1hrQixDQUFyQjs7QUFvWUEsbUJBQU9mLE1BQVA7QUFDRCxXQXhieUIsQ0F3YnhCNUMsS0FBS2lJLFFBeGJtQixDQUExQjs7QUEwYkFuWSxrQkFBUTBLLE9BQVIsR0FBa0JvSSxNQUFsQjtBQUNBL1MsaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBeDRCOEI7O0FBMDRCckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLGdDQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQWtCeUssbUJBQWxCLEVBQTBDOztBQUVqRDs7QUFHQSxtQkFBU3NGLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFO0FBQTJCLGdCQUFJLE9BQU9rRixNQUFQLEtBQWtCLFVBQWxCLElBQWdDLFNBQU9BLE9BQU9DLFFBQWQsTUFBMkIsUUFBL0QsRUFBeUU7QUFBRUYsd0JBQVUsU0FBU0EsT0FBVCxDQUFpQmpGLEdBQWpCLEVBQXNCO0FBQUUsOEJBQWNBLEdBQWQsMENBQWNBLEdBQWQ7QUFBb0IsZUFBdEQ7QUFBeUQsYUFBcEksTUFBMEk7QUFBRWlGLHdCQUFVLFNBQVNBLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFLHVCQUFPQSxPQUFPLE9BQU9rRixNQUFQLEtBQWtCLFVBQXpCLElBQXVDbEYsSUFBSTdJLFdBQUosS0FBb0IrTixNQUEzRCxJQUFxRWxGLFFBQVFrRixPQUFPbE8sU0FBcEYsR0FBZ0csUUFBaEcsVUFBa0hnSixHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsZUFBaks7QUFBb0ssYUFBQyxPQUFPaUYsUUFBUWpGLEdBQVIsQ0FBUDtBQUFzQjs7QUFFMVh6SyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsY0FBSTBOLFVBQVV4Tix1QkFBdUJILHFCQUFvQixlQUFnQixpQkFBcEMsQ0FBdkIsQ0FBZDs7QUFFQSxjQUFJeUYsT0FBT0Msd0JBQXdCMUYscUJBQW9CLGFBQWMscUJBQWxDLENBQXhCLENBQVg7O0FBRUEsY0FBSTROLFdBQVd6Tix1QkFBdUJILHFCQUFvQiwyQkFBNEIsNkJBQWhELENBQXZCLENBQWY7O0FBRUEsbUJBQVMyRix3QkFBVCxDQUFrQ0MsV0FBbEMsRUFBK0M7QUFBRSxnQkFBSSxPQUFPQyxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DLE9BQU8sSUFBUCxDQUFhLElBQUlDLG9CQUFvQixJQUFJRCxPQUFKLEVBQXhCLENBQXVDLElBQUlFLG1CQUFtQixJQUFJRixPQUFKLEVBQXZCLENBQXNDLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHdCQUFULENBQWtDQyxXQUFsQyxFQUErQztBQUFFLHFCQUFPQSxjQUFjRyxnQkFBZCxHQUFpQ0QsaUJBQXhDO0FBQTRELGFBQXpJLEVBQTJJRixXQUEzSSxDQUFQO0FBQWlLOztBQUUvVSxtQkFBU0YsdUJBQVQsQ0FBaUNyRixHQUFqQyxFQUFzQ3VGLFdBQXRDLEVBQW1EO0FBQUUsZ0JBQUksQ0FBQ0EsV0FBRCxJQUFnQnZGLEdBQWhCLElBQXVCQSxJQUFJQyxVQUEvQixFQUEyQztBQUFFLHFCQUFPRCxHQUFQO0FBQWEsYUFBQyxJQUFJQSxRQUFRLElBQVIsSUFBZ0JpRixRQUFRakYsR0FBUixNQUFpQixRQUFqQixJQUE2QixPQUFPQSxHQUFQLEtBQWUsVUFBaEUsRUFBNEU7QUFBRSxxQkFBTyxFQUFFSixTQUFTSSxHQUFYLEVBQVA7QUFBMEIsYUFBQyxJQUFJMkYsUUFBUUwseUJBQXlCQyxXQUF6QixDQUFaLENBQW1ELElBQUlJLFNBQVNBLE1BQU1DLEdBQU4sQ0FBVTVGLEdBQVYsQ0FBYixFQUE2QjtBQUFFLHFCQUFPMkYsTUFBTWpRLEdBQU4sQ0FBVXNLLEdBQVYsQ0FBUDtBQUF3QixhQUFDLElBQUk2RixTQUFTLEVBQWIsQ0FBaUIsSUFBSUMsd0JBQXdCdlEsT0FBT0MsY0FBUCxJQUF5QkQsT0FBT3dRLHdCQUE1RCxDQUFzRixLQUFLLElBQUlyRixHQUFULElBQWdCVixHQUFoQixFQUFxQjtBQUFFLGtCQUFJVSxRQUFRLFNBQVIsSUFBcUJuTCxPQUFPeUIsU0FBUCxDQUFpQmdQLGNBQWpCLENBQWdDMUgsSUFBaEMsQ0FBcUMwQixHQUFyQyxFQUEwQ1UsR0FBMUMsQ0FBekIsRUFBeUU7QUFBRSxvQkFBSXVGLE9BQU9ILHdCQUF3QnZRLE9BQU93USx3QkFBUCxDQUFnQy9GLEdBQWhDLEVBQXFDVSxHQUFyQyxDQUF4QixHQUFvRSxJQUEvRSxDQUFxRixJQUFJdUYsU0FBU0EsS0FBS3ZRLEdBQUwsSUFBWXVRLEtBQUtDLEdBQTFCLENBQUosRUFBb0M7QUFBRTNRLHlCQUFPQyxjQUFQLENBQXNCcVEsTUFBdEIsRUFBOEJuRixHQUE5QixFQUFtQ3VGLElBQW5DO0FBQTJDLGlCQUFqRixNQUF1RjtBQUFFSix5QkFBT25GLEdBQVAsSUFBY1YsSUFBSVUsR0FBSixDQUFkO0FBQXlCO0FBQUU7QUFBRSxhQUFDbUYsT0FBT2pHLE9BQVAsR0FBaUJJLEdBQWpCLENBQXNCLElBQUkyRixLQUFKLEVBQVc7QUFBRUEsb0JBQU1PLEdBQU4sQ0FBVWxHLEdBQVYsRUFBZTZGLE1BQWY7QUFBeUIsYUFBQyxPQUFPQSxNQUFQO0FBQWdCOztBQUV0eUIsbUJBQVMvRixzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7QUFBRSxtQkFBT0EsT0FBT0EsSUFBSUMsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEIsRUFBRUosU0FBU0ksR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsbUJBQVNFLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOLG1CQUFTZ0csU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQUUsZ0JBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLG9CQUFNLElBQUlqRyxTQUFKLENBQWMsb0RBQWQsQ0FBTjtBQUE0RSxhQUFDZ0csU0FBU3BQLFNBQVQsR0FBcUJ6QixPQUFPMEIsTUFBUCxDQUFjb1AsY0FBY0EsV0FBV3JQLFNBQXZDLEVBQWtELEVBQUVHLGFBQWEsRUFBRXVELE9BQU8wTCxRQUFULEVBQW1CM0YsVUFBVSxJQUE3QixFQUFtQ0QsY0FBYyxJQUFqRCxFQUFmLEVBQWxELENBQXJCLENBQWtKLElBQUk2RixVQUFKLEVBQWdCQyxnQkFBZ0JGLFFBQWhCLEVBQTBCQyxVQUExQjtBQUF3Qzs7QUFFalksbUJBQVNDLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjtBQUFFRiw4QkFBa0IvUSxPQUFPa1IsY0FBUCxJQUF5QixTQUFTSCxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7QUFBRUQsZ0JBQUVHLFNBQUYsR0FBY0YsQ0FBZCxDQUFpQixPQUFPRCxDQUFQO0FBQVcsYUFBeEcsQ0FBMEcsT0FBT0QsZ0JBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsQ0FBUDtBQUErQjs7QUFFMUssbUJBQVNHLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCO0FBQUUsZ0JBQUlDLDRCQUE0QkMsMkJBQWhDLENBQTZELE9BQU8sU0FBU0Msb0JBQVQsR0FBZ0M7QUFBRSxrQkFBSUMsUUFBUUMsZ0JBQWdCTCxPQUFoQixDQUFaO0FBQUEsa0JBQXNDTSxNQUF0QyxDQUE4QyxJQUFJTCx5QkFBSixFQUErQjtBQUFFLG9CQUFJTSxZQUFZRixnQkFBZ0IsSUFBaEIsRUFBc0I5UCxXQUF0QyxDQUFtRCtQLFNBQVNFLFFBQVFDLFNBQVIsQ0FBa0JMLEtBQWxCLEVBQXlCTSxTQUF6QixFQUFvQ0gsU0FBcEMsQ0FBVDtBQUEwRCxlQUE5SSxNQUFvSjtBQUFFRCx5QkFBU0YsTUFBTU8sS0FBTixDQUFZLElBQVosRUFBa0JELFNBQWxCLENBQVQ7QUFBd0MsZUFBQyxPQUFPRSwyQkFBMkIsSUFBM0IsRUFBaUNOLE1BQWpDLENBQVA7QUFBa0QsYUFBeFU7QUFBMlU7O0FBRXphLG1CQUFTTSwwQkFBVCxDQUFvQ25RLElBQXBDLEVBQTBDaUgsSUFBMUMsRUFBZ0Q7QUFBRSxnQkFBSUEsU0FBUzJHLFFBQVEzRyxJQUFSLE1BQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBdkQsQ0FBSixFQUF3RTtBQUFFLHFCQUFPQSxJQUFQO0FBQWMsYUFBQyxPQUFPbUosdUJBQXVCcFEsSUFBdkIsQ0FBUDtBQUFzQzs7QUFFakwsbUJBQVNvUSxzQkFBVCxDQUFnQ3BRLElBQWhDLEVBQXNDO0FBQUUsZ0JBQUlBLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUFFLG9CQUFNLElBQUlxUSxjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLGFBQUMsT0FBT3JRLElBQVA7QUFBYzs7QUFFdEssbUJBQVN5UCx5QkFBVCxHQUFxQztBQUFFLGdCQUFJLE9BQU9NLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0MsQ0FBQ0EsUUFBUUMsU0FBL0MsRUFBMEQsT0FBTyxLQUFQLENBQWMsSUFBSUQsUUFBUUMsU0FBUixDQUFrQk0sSUFBdEIsRUFBNEIsT0FBTyxLQUFQLENBQWMsSUFBSSxPQUFPQyxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDLE9BQU8sSUFBUCxDQUFhLElBQUk7QUFBRUMsc0JBQVE3USxTQUFSLENBQWtCOFEsT0FBbEIsQ0FBMEJ4SixJQUExQixDQUErQjhJLFFBQVFDLFNBQVIsQ0FBa0JRLE9BQWxCLEVBQTJCLEVBQTNCLEVBQStCLFlBQVksQ0FBRSxDQUE3QyxDQUEvQixFQUFnRixPQUFPLElBQVA7QUFBYyxhQUFwRyxDQUFxRyxPQUFPcE4sQ0FBUCxFQUFVO0FBQUUscUJBQU8sS0FBUDtBQUFlO0FBQUU7O0FBRXpVLG1CQUFTd00sZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRVUsOEJBQWtCMVIsT0FBT2tSLGNBQVAsR0FBd0JsUixPQUFPd1MsY0FBL0IsR0FBZ0QsU0FBU2QsZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRSxxQkFBT0EsRUFBRUcsU0FBRixJQUFlblIsT0FBT3dTLGNBQVAsQ0FBc0J4QixDQUF0QixDQUF0QjtBQUFpRCxhQUFqSixDQUFtSixPQUFPVSxnQkFBZ0JWLENBQWhCLENBQVA7QUFBNEI7O0FBRTdNOzs7Ozs7O0FBT0EsY0FBSWlILGNBQWMsYUFBYSxVQUFVQyxPQUFWLEVBQW1CO0FBQ2hEdEgsc0JBQVVxSCxXQUFWLEVBQXVCQyxPQUF2Qjs7QUFFQSxnQkFBSXZGLFNBQVN2QixhQUFhNkcsV0FBYixDQUFiOztBQUVBOzs7O0FBSUEscUJBQVNBLFdBQVQsQ0FBcUJoWCxTQUFyQixFQUFnQ0osTUFBaEMsRUFBd0M7QUFDdEMsa0JBQUl3TyxLQUFKOztBQUVBMUUsOEJBQWdCLElBQWhCLEVBQXNCc04sV0FBdEI7O0FBRUE1SSxzQkFBUXNELE9BQU81SixJQUFQLENBQVksSUFBWixFQUFrQjlILFNBQWxCLEVBQTZCSixNQUE3QixDQUFSO0FBQ0E7Ozs7QUFJQXdPLG9CQUFNOEksY0FBTixHQUF1QnRYLE9BQU9zWCxjQUE5QjtBQUNBOzs7O0FBSUE5SSxvQkFBTStJLHFCQUFOLEdBQThCL0osS0FBS0MsS0FBTCxDQUFXek4sT0FBT3NYLGNBQVAsR0FBd0J0WCxPQUFPZ1MsVUFBMUMsQ0FBOUI7QUFDQTs7Ozs7OztBQU9BeEQsb0JBQU03QyxpQkFBTixHQUEwQjNMLE9BQU9xQixTQUFQLElBQW9CckIsT0FBT3NCLGFBQXJEO0FBQ0E7Ozs7QUFJQWtOLG9CQUFNTixTQUFOLEdBQWtCLE1BQU1sTyxPQUFPZ1MsVUFBL0I7QUFDQTs7Ozs7O0FBTUF4RCxvQkFBTWdKLFFBQU4sR0FBaUIsRUFBakI7QUFDQTs7OztBQUlBaEosb0JBQU1pSixZQUFOLEdBQXFCLElBQXJCO0FBQ0E7Ozs7OztBQU1Bakosb0JBQU1rSixVQUFOLEdBQW1CUCxTQUFTM04sT0FBNUI7QUFDQTs7Ozs7O0FBTUFnRixvQkFBTXhELHVCQUFOLEdBQWdDaEwsT0FBTzJYLHdCQUF2QztBQUNBOzs7Ozs7O0FBT0FuSixvQkFBTW9KLE9BQU4sR0FBZ0IsSUFBSXBLLEtBQUtxSyxJQUFMLENBQVU3WCxPQUFPZ1MsVUFBUCxHQUFvQixDQUE5QixDQUFwQjtBQUNBOzs7Ozs7QUFNQXhELG9CQUFNc0osU0FBTixHQUFrQjlYLE9BQU84WCxTQUFQLElBQW9CLENBQXRDO0FBQ0E7Ozs7OztBQU1BdEosb0JBQU10QyxRQUFOLEdBQWlCbE0sT0FBT2tNLFFBQXhCO0FBQ0EscUJBQU9zQyxLQUFQO0FBQ0Q7QUFDRDs7OztBQUtBakUseUJBQWE2TSxXQUFiLEVBQTBCLENBQUM7QUFDekI5TSxtQkFBSyxNQURvQjtBQUV6QmhHLHFCQUFPLFNBQVN0RCxJQUFULEdBQWdCO0FBQ3JCLHFCQUFLc1IsYUFBTDtBQUNBLHFCQUFLeUYsY0FBTDtBQUNEO0FBQ0Q7Ozs7O0FBTnlCLGFBQUQsRUFXdkI7QUFDRHpOLG1CQUFLLGdCQURKO0FBRURoRyxxQkFBTyxTQUFTeVQsY0FBVCxHQUEwQjtBQUMvQixxQkFBS04sWUFBTCxHQUFvQnpJLEtBQUsrQyxlQUFMLENBQXFCLEtBQUtHLE9BQUwsQ0FBYUssV0FBYixDQUF5QkMsU0FBU0MsYUFBVCxDQUF1QixNQUF2QixDQUF6QixDQUFyQixFQUErRSxLQUFLelMsTUFBTCxDQUFZa00sUUFBM0YsQ0FBcEI7QUFDQSxxQkFBS2lHLEtBQUwsQ0FBVyxLQUFLc0YsWUFBaEIsRUFBOEI7QUFDNUI5RSw0QkFBVSxVQURrQjtBQUU1QnFGLDBCQUFRLENBRm9CO0FBRzVCM0Qsd0JBQU0sQ0FIc0I7QUFJNUI0RCx1QkFBSyxDQUp1QjtBQUs1QnJELDBCQUFRLENBTG9CO0FBTTVCc0QsNEJBQVUsUUFOa0I7QUFPNUIzVSx5QkFBTyxHQVBxQjtBQVE1Qm1QLDJCQUFTLE1BUm1CO0FBUzVCeUYsNkJBQVcsWUFUaUI7QUFVNUJDLG9DQUFrQixPQVZVO0FBVzVCQyxpQ0FBZTtBQVhhLGlCQUE5QjtBQWFBLHFCQUFLQyxTQUFMO0FBQ0EscUJBQUt2QixZQUFMO0FBQ0Q7QUFDRDs7OztBQXBCQyxhQVh1QixFQW1DdkI7QUFDRHpNLG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVN5UyxZQUFULEdBQXdCO0FBQzdCLHFCQUFLNUUsS0FBTCxDQUFXLEtBQUtzRixZQUFoQixFQUE4QjtBQUM1QmMsb0NBQWtCLEtBQUt2WSxNQUFMLENBQVl3WSxXQUFaLEdBQTBCLElBRGhCO0FBRTVCQyxvQ0FBa0IsS0FBS3pZLE1BQUwsQ0FBWTBZO0FBRkYsaUJBQTlCO0FBSUQ7QUFDRDs7OztBQVJDLGFBbkN1QixFQStDdkI7QUFDRHBPLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVM2UixVQUFULEdBQXNCO0FBQzNCLG9CQUFJN0IsU0FBUyxJQUFiOztBQUVBLG9CQUFJL0ksYUFBYWlDLEtBQUtDLEtBQUwsQ0FBVyxLQUFLbEssS0FBTCxHQUFhLEtBQUt2RCxNQUFMLENBQVlnUyxVQUFwQyxDQUFqQjtBQUNBLG9CQUFJMkcsbUJBQW1CbkwsS0FBS3FLLElBQUwsQ0FBVXRNLGNBQWMsS0FBS2dNLHFCQUFMLEdBQTZCLEtBQUtLLE9BQWhELENBQVYsQ0FBdkIsQ0FKMkIsQ0FJaUU7O0FBRTVGLHVCQUFPLEtBQUtKLFFBQUwsQ0FBY3RXLE1BQWQsR0FBdUJ5WCxnQkFBOUIsRUFBZ0Q7QUFDOUMsdUJBQUtMLFNBQUw7QUFDRCxpQkFSMEIsQ0FRekI7OztBQUdGLHVCQUFPLEtBQUtkLFFBQUwsQ0FBY3RXLE1BQWQsR0FBdUJ5WCxnQkFBOUIsRUFBZ0Q7QUFDOUMsdUJBQUtDLFlBQUw7QUFDRDs7QUFFRCxvQkFBSUMsY0FBYyxLQUFLdkIsY0FBTCxHQUFzQixLQUFLTSxPQUE3QztBQUNBLG9CQUFJa0IsYUFBYSxLQUFLdEIsUUFBTCxDQUFjdFcsTUFBZCxHQUF1QixDQUF4QztBQUNBLHFCQUFLc1csUUFBTCxDQUFjdUIsT0FBZCxDQUFzQixVQUFVQyxLQUFWLEVBQWlCeFosQ0FBakIsRUFBb0I7QUFDeEMsc0JBQUlBLEtBQUtzWixVQUFULEVBQXFCO0FBQ25CRCxrQ0FBY3ZFLE9BQU8vUSxLQUFQLEdBQWUrUSxPQUFPZ0QsY0FBUCxHQUF3QndCLFVBQXJEO0FBQ0Q7O0FBRUR4RSx5QkFBT2pKLGdCQUFQLENBQXdCMk4sS0FBeEIsRUFBK0JILFdBQS9CLEVBQTRDdkUsT0FBTzlJLE1BQW5EOztBQUVBd04sd0JBQU1wTixTQUFOO0FBQ0QsaUJBUkQ7QUFTRDtBQUNEOzs7OztBQTdCQyxhQS9DdUIsRUFpRnZCO0FBQ0R0QixtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTZ1UsU0FBVCxHQUFxQjtBQUMxQixvQkFBSVUsUUFBUSxJQUFJLEtBQUt0QixVQUFULEVBQVo7QUFDQXNCLHNCQUFNaE8sdUJBQU4sR0FBZ0MsS0FBS0EsdUJBQXJDO0FBQ0FnTyxzQkFBTXJOLGlCQUFOLEdBQTBCLEtBQUtBLGlCQUEvQjtBQUNBcU4sc0JBQU05SyxTQUFOLEdBQWtCLEtBQUtBLFNBQXZCO0FBQ0Esb0JBQUkrSyxhQUFhLEtBQUsxQixxQkFBTCxHQUE2QixLQUFLQyxRQUFMLENBQWN0VyxNQUE1RCxDQUwwQixDQUswQzs7QUFFcEUsb0JBQUl5SixPQUFPcUUsS0FBSytDLGVBQUwsQ0FBcUIsS0FBS0csT0FBTCxDQUFhSyxXQUFiLENBQXlCQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQXpCLENBQXJCLEVBQWlGLEtBQUt6UyxNQUFMLENBQVlrTSxRQUE3RixDQUFYO0FBQ0EscUJBQUtpRyxLQUFMLENBQVd4SCxJQUFYLEVBQWlCO0FBQ2ZnSSw0QkFBVSxVQURLO0FBRWZxRiwwQkFBUSxDQUZPO0FBR2YzRCx3QkFBTTRFLGFBQWEsSUFISjtBQUlmaEIsdUJBQUssQ0FKVTtBQUtmckQsMEJBQVEsQ0FMTztBQU1mcEosMEJBQVEsTUFOTztBQU9mNk0saUNBQWU7QUFQQSxpQkFBakI7QUFTQVcsc0JBQU0vTixRQUFOLENBQWVOLElBQWYsRUFqQjBCLENBaUJKOztBQUV0QixvQkFBSSxLQUFLZ0IsaUJBQVQsRUFBNEI7QUFDMUIsc0JBQUlkLFdBQVdtRSxLQUFLK0MsZUFBTCxDQUFxQixLQUFLMEYsWUFBTCxDQUFrQmxGLFdBQWxCLENBQThCQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQTlCLENBQXJCLEVBQXNGLEtBQUt6UyxNQUFMLENBQVlrTSxRQUFsRyxDQUFmO0FBQ0EsdUJBQUtpRyxLQUFMLENBQVd0SCxRQUFYLEVBQXFCO0FBQ25COEgsOEJBQVUsVUFEUztBQUVuQjBCLDBCQUFNNEUsYUFBYSxJQUZBO0FBR25CaEIseUJBQUssQ0FIYztBQUluQnJELDRCQUFRLENBSlc7QUFLbkJwSiw0QkFBUTtBQUxXLG1CQUFyQjtBQU9Bd04sd0JBQU01TixZQUFOLENBQW1CUCxRQUFuQjtBQUNEOztBQUVELHFCQUFLMk0sUUFBTCxDQUFjL08sSUFBZCxDQUFtQnVRLEtBQW5CO0FBQ0Q7QUFDRDs7Ozs7QUFuQ0MsYUFqRnVCLEVBeUh2QjtBQUNEMU8sbUJBQUssY0FESjtBQUVEaEcscUJBQU8sU0FBU3NVLFlBQVQsR0FBd0I7QUFDN0Isb0JBQUlNLFlBQVksS0FBSzFCLFFBQUwsQ0FBYyxLQUFLQSxRQUFMLENBQWN0VyxNQUFkLEdBQXVCLENBQXJDLENBQWhCLENBRDZCLENBQzRCOztBQUV6RGdZLDBCQUFVdk8sSUFBVixDQUFlL0csYUFBZixDQUE2QitFLFdBQTdCLENBQXlDdVEsVUFBVXZPLElBQVYsQ0FBZW1NLFVBQXhELEVBSDZCLENBR3dDOztBQUVyRSxvQkFBSSxLQUFLbkwsaUJBQVQsRUFBNEI7QUFDMUJ1Tiw0QkFBVXJPLFFBQVYsQ0FBbUJqSCxhQUFuQixDQUFpQytFLFdBQWpDLENBQTZDdVEsVUFBVXJPLFFBQVYsQ0FBbUJpTSxVQUFoRTtBQUNELGlCQVA0QixDQU8zQjs7O0FBR0Ysb0JBQUlvQyxTQUFKLEVBQWU7QUFDYkEsNEJBQVUvSyxPQUFWO0FBQ0ErSyw4QkFBWSxJQUFaO0FBQ0Q7O0FBRUQscUJBQUsxQixRQUFMLENBQWMyQixHQUFkO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFuQkMsYUF6SHVCLEVBb0p2QjtBQUNEN08sbUJBQUssa0JBREo7QUFFRGhHLHFCQUFPLFNBQVMrRyxnQkFBVCxDQUEwQjJOLEtBQTFCLEVBQWlDelYsS0FBakMsRUFBd0NpSSxNQUF4QyxFQUFnRDtBQUNyRCxvQkFBSUYsZUFBZWtDLEtBQUtDLEtBQUwsQ0FBV2xLLFFBQVEsS0FBS3ZELE1BQUwsQ0FBWWdTLFVBQS9CLENBQW5CO0FBQ0Esb0JBQUl6RyxhQUFhaUMsS0FBS0MsS0FBTCxDQUFXLEtBQUtsSyxLQUFMLEdBQWEsS0FBS3ZELE1BQUwsQ0FBWWdTLFVBQXBDLENBQWpCLENBRnFELENBRWE7O0FBRWxFZ0gsc0JBQU0zTixnQkFBTixDQUF1QkMsWUFBdkIsRUFBcUNDLFVBQXJDLEVBQWlEaEksS0FBakQsRUFBd0RpSSxNQUF4RCxFQUpxRCxDQUlZOztBQUVqRSxxQkFBSzJHLEtBQUwsQ0FBVyxLQUFLc0YsWUFBaEIsRUFBOEI7QUFDNUIvRSwyQkFBUztBQURtQixpQkFBOUI7QUFHRDtBQUNEOzs7O0FBWkMsYUFwSnVCLEVBb0t2QjtBQUNEcEksbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU3NILFNBQVQsR0FBcUI7QUFDMUIsb0JBQUl3TixTQUFTLElBQWI7O0FBRUFwSyxxQkFBS3FLLEtBQUwsQ0FBVyxZQUFZO0FBQ3JCRCx5QkFBTzVCLFFBQVAsQ0FBZ0J1QixPQUFoQixDQUF3QixVQUFVQyxLQUFWLEVBQWlCO0FBQ3ZDLDJCQUFPQSxNQUFNcE4sU0FBTixFQUFQO0FBQ0QsbUJBRkQ7QUFHRCxpQkFKRDtBQUtEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7O0FBWEMsYUFwS3VCLEVBNkx2QjtBQUNEdEIsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzRRLFFBQVQsQ0FBa0IvSCxLQUFsQixFQUF5QjZKLFlBQXpCLEVBQXVDalYsS0FBdkMsRUFBOENDLEdBQTlDLEVBQW1EO0FBQ3hELG9CQUFJc1gsU0FBUyxJQUFiOztBQUVBLHVCQUFPLEtBQUtDLFdBQUwsQ0FBaUJwTSxLQUFqQixFQUF3QjZKLFlBQXhCLEVBQXNDalYsS0FBdEMsRUFBNkNDLEdBQTdDLEVBQWtELFVBQVV3WCxJQUFWLEVBQWdCO0FBQ3ZFLHNCQUFJcE0sU0FBU29NLEtBQUtwTSxNQUFsQjtBQUFBLHNCQUNJcU0sYUFBYUQsS0FBS0MsVUFEdEI7QUFBQSxzQkFFSWpPLFNBQVNnTyxLQUFLaE8sTUFGbEI7QUFBQSxzQkFHSThCLFVBQVVrTSxLQUFLbE0sT0FIbkI7QUFBQSxzQkFJSUQsUUFBUW1NLEtBQUtuTSxLQUpqQjtBQUFBLHNCQUtJRixRQUFRcU0sS0FBS3JNLEtBTGpCO0FBQUEsc0JBTUl1TSxLQUFLRixLQUFLeEMsWUFOZDs7QUFRQTtBQUNBO0FBQ0Esc0JBQUlqVixVQUFVdkIsU0FBZCxFQUF5QjtBQUN2QjtBQUNELG1CQWJzRSxDQWFyRTs7O0FBR0Ysc0JBQUltWixpQkFBaUJGLGFBQWEsQ0FBYixHQUFpQixDQUF0QztBQUNBLHNCQUFJdlksU0FBU2lNLE1BQU1qTSxNQUFOLEdBQWV5WSxjQUE1QjtBQUNBLHNCQUFJQyxNQUFNTixPQUFPdFosTUFBUCxDQUFjaVYsUUFBZCxHQUF5QnFFLE9BQU90WixNQUFQLENBQWNnUyxVQUFqRDtBQUNBLHNCQUFJNkgsTUFBTVAsT0FBT3RaLE1BQVAsQ0FBYzhaLE1BQWQsS0FBeUIsSUFBekIsR0FBZ0N0TSxLQUFLdUksR0FBTCxDQUFTdUQsT0FBT3RaLE1BQVAsQ0FBY2dTLFVBQXZCLEVBQW1DLENBQUMsRUFBRTRILE1BQU0sQ0FBUixDQUFwQyxDQUFoQyxHQUFrRnBNLEtBQUt1SSxHQUFMLENBQVN1RCxPQUFPdFosTUFBUCxDQUFjZ1MsVUFBdkIsRUFBbUNzSCxPQUFPdFosTUFBUCxDQUFjOFosTUFBZCxHQUF1QlIsT0FBT3RaLE1BQVAsQ0FBY2dTLFVBQXhFLENBQTVGO0FBQ0Esc0JBQUkrSCxPQUFPSCxNQUFNQyxHQUFqQjtBQUNBLHNCQUFJaE0sUUFBUTNNLFNBQVNvWSxPQUFPL1YsS0FBNUI7QUFDQSxzQkFBSStCLFFBQVF2RCxLQUFaO0FBQ0Esc0JBQUkyTCxPQUFPMUwsR0FBWDtBQUNBLHNCQUFJeEMsSUFBSThGLEtBQVI7O0FBRUEsdUJBQUs5RixDQUFMLEVBQVFBLElBQUlrTyxJQUFaLEVBQWtCbE8sS0FBS3VhLElBQXZCLEVBQTZCO0FBQzNCLHdCQUFJL0wsT0FBT2IsTUFBTUssS0FBS3dNLEtBQUwsQ0FBV3hhLElBQUlxTyxLQUFKLEdBQVk4TCxjQUF2QixDQUFOLEtBQWlELENBQTVEO0FBQ0Esd0JBQUkxTCxJQUFJVCxLQUFLQyxLQUFMLENBQVdPLE9BQU9aLE1BQVAsR0FBZ0JDLEtBQTNCLENBQVI7QUFDQTs7O0FBR0Esd0JBQUlZLEtBQUssQ0FBTCxJQUFVcUwsT0FBT3RaLE1BQVAsQ0FBY2lhLFlBQTVCLEVBQTBDO0FBQ3hDaE0sMEJBQUlxTCxPQUFPdFosTUFBUCxDQUFjaWEsWUFBbEI7QUFDRDs7QUFFRFgsMkJBQU8zTSxRQUFQLENBQWdCbk4sSUFBSThaLE9BQU9wTCxTQUEzQixFQUFzQ2IsUUFBUVksQ0FBUixHQUFZWCxPQUFsRCxFQUEyRHNNLE1BQU1OLE9BQU9wTCxTQUF4RSxFQUFtRkQsSUFBSSxDQUF2RixFQUEwRnFMLE9BQU94QixTQUFqRyxFQUE0RzRCLEVBQTVHO0FBQ0Q7QUFDRixpQkF0Q00sQ0FBUDtBQXVDRDtBQUNEOzs7Ozs7Ozs7Ozs7OztBQTdDQyxhQTdMdUIsRUF3UHZCO0FBQ0RwUCxtQkFBSyxVQURKO0FBRURoRyxxQkFBTyxTQUFTNlEsUUFBVCxDQUFrQmhJLEtBQWxCLEVBQXlCNkosWUFBekIsRUFBdUNqVixLQUF2QyxFQUE4Q0MsR0FBOUMsRUFBbUQ7QUFDeEQsb0JBQUlrWSxTQUFTLElBQWI7O0FBRUEsdUJBQU8sS0FBS1gsV0FBTCxDQUFpQnBNLEtBQWpCLEVBQXdCNkosWUFBeEIsRUFBc0NqVixLQUF0QyxFQUE2Q0MsR0FBN0MsRUFBa0QsVUFBVW1ZLEtBQVYsRUFBaUI7QUFDeEUsc0JBQUkvTSxTQUFTK00sTUFBTS9NLE1BQW5CO0FBQUEsc0JBQ0lxTSxhQUFhVSxNQUFNVixVQUR2QjtBQUFBLHNCQUVJak8sU0FBUzJPLE1BQU0zTyxNQUZuQjtBQUFBLHNCQUdJOEIsVUFBVTZNLE1BQU03TSxPQUhwQjtBQUFBLHNCQUlJRCxRQUFROE0sTUFBTTlNLEtBSmxCO0FBQUEsc0JBS0lGLFFBQVFnTixNQUFNaE4sS0FMbEI7QUFBQSxzQkFNSTZKLGVBQWVtRCxNQUFNbkQsWUFOekI7O0FBUUEsc0JBQUksQ0FBQ3lDLFVBQUwsRUFBaUI7QUFDZix3QkFBSVcsaUJBQWlCLEVBQXJCO0FBQ0Esd0JBQUlDLE1BQU1sTixNQUFNak0sTUFBaEI7QUFDQSx3QkFBSTFCLElBQUksQ0FBUjs7QUFFQSx5QkFBS0EsQ0FBTCxFQUFRQSxJQUFJNmEsR0FBWixFQUFpQjdhLEdBQWpCLEVBQXNCO0FBQ3BCNGEscUNBQWUsSUFBSTVhLENBQW5CLElBQXdCMk4sTUFBTTNOLENBQU4sQ0FBeEI7QUFDQTRhLHFDQUFlLElBQUk1YSxDQUFKLEdBQVEsQ0FBdkIsSUFBNEIsQ0FBQzJOLE1BQU0zTixDQUFOLENBQTdCO0FBQ0Q7O0FBRUQyTiw0QkFBUWlOLGNBQVI7QUFDRCxtQkFwQnVFLENBb0J0RTtBQUNGOzs7QUFHQSxzQkFBSXJZLFVBQVV2QixTQUFkLEVBQXlCO0FBQ3ZCMFosMkJBQU9JLFFBQVAsQ0FBZ0JuTixLQUFoQixFQUF1QkMsTUFBdkIsRUFBK0JDLEtBQS9CLEVBQXNDQyxPQUF0QyxFQUErQ3ZMLEtBQS9DLEVBQXNEQyxHQUF0RCxFQUEyRGdWLFlBQTNEO0FBQ0QsbUJBMUJ1RSxDQTBCdEU7OztBQUdGa0QseUJBQU92TixRQUFQLENBQWdCLENBQWhCLEVBQW1CVSxRQUFRQyxPQUFSLEdBQWtCNE0sT0FBT2hNLFNBQTVDLEVBQXVEZ00sT0FBTzNXLEtBQTlELEVBQXFFMlcsT0FBT2hNLFNBQTVFLEVBQXVGZ00sT0FBT3BDLFNBQTlGLEVBQXlHZCxZQUF6RztBQUNELGlCQTlCTSxDQUFQO0FBK0JEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7O0FBckNDLGFBeFB1QixFQTJTdkI7QUFDRDFNLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVNnVyxRQUFULENBQWtCbk4sS0FBbEIsRUFBeUJDLE1BQXpCLEVBQWlDQyxLQUFqQyxFQUF3Q0MsT0FBeEMsRUFBaUR2TCxLQUFqRCxFQUF3REMsR0FBeEQsRUFBNkRnVixZQUE3RCxFQUEyRTtBQUNoRixvQkFBSXVELFNBQVMsSUFBYjs7QUFFQSxvQkFBSUMsUUFBUSxLQUFLeGEsTUFBTCxDQUFZeWEsb0JBQVosQ0FBaUNDLGFBQWpDLENBQStDMUQsWUFBL0MsS0FBZ0UsRUFBNUU7QUFBQSxvQkFDSTNWLFlBQVltWixNQUFNblosU0FEdEI7QUFBQSxvQkFFSUMsZ0JBQWdCa1osTUFBTWxaLGFBRjFCOztBQUlBLHFCQUFLa1csUUFBTCxDQUFjdUIsT0FBZCxDQUFzQixVQUFVQyxLQUFWLEVBQWlCeFosQ0FBakIsRUFBb0I7QUFDeEMrYSx5QkFBT3hPLGFBQVAsQ0FBcUJpTixLQUFyQixFQUE0QjNYLFNBQTVCLEVBQXVDQyxhQUF2Qzs7QUFFQWlaLHlCQUFPdE8scUJBQVAsQ0FBNkIrTSxLQUE3QixFQUFvQ3VCLE9BQU92YSxNQUFQLENBQWNrTSxRQUFsRDs7QUFFQThNLHdCQUFNOUwsU0FBTixDQUFnQkMsS0FBaEIsRUFBdUJDLE1BQXZCLEVBQStCQyxLQUEvQixFQUFzQ0MsT0FBdEMsRUFBK0N2TCxLQUEvQyxFQUFzREMsR0FBdEQ7QUFDRCxpQkFORDtBQU9EO0FBQ0Q7Ozs7Ozs7Ozs7O0FBakJDLGFBM1N1QixFQXVVdkI7QUFDRHNJLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVNxSSxRQUFULENBQWtCTixDQUFsQixFQUFxQkMsQ0FBckIsRUFBd0IvSSxLQUF4QixFQUErQmlJLE1BQS9CLEVBQXVDZSxNQUF2QyxFQUErQ3lLLFlBQS9DLEVBQTZEO0FBQ2xFLG9CQUFJMkQsY0FBY25OLEtBQUt3TSxLQUFMLENBQVczTixJQUFJLEtBQUtpTCxjQUFwQixDQUFsQjtBQUNBLG9CQUFJc0QsWUFBWXBOLEtBQUt3SSxHQUFMLENBQVN4SSxLQUFLcUssSUFBTCxDQUFVLENBQUN4TCxJQUFJOUksS0FBTCxJQUFjLEtBQUsrVCxjQUE3QixJQUErQyxDQUF4RCxFQUEyRCxLQUFLRSxRQUFMLENBQWN0VyxNQUF6RSxDQUFoQjtBQUNBLG9CQUFJMUIsSUFBSW1iLFdBQVI7O0FBRUEscUJBQUtuYixDQUFMLEVBQVFBLElBQUlvYixTQUFaLEVBQXVCcGIsR0FBdkIsRUFBNEI7QUFDMUIsc0JBQUl3WixRQUFRLEtBQUt4QixRQUFMLENBQWNoWSxDQUFkLENBQVo7QUFDQSxzQkFBSXlaLGFBQWF6WixJQUFJLEtBQUs4WCxjQUExQjtBQUNBLHNCQUFJdUQsZUFBZTtBQUNqQkMsd0JBQUl0TixLQUFLdUksR0FBTCxDQUFTMUosQ0FBVCxFQUFZN00sSUFBSSxLQUFLOFgsY0FBckIsQ0FEYTtBQUVqQnlELHdCQUFJek8sQ0FGYTtBQUdqQjBPLHdCQUFJeE4sS0FBS3dJLEdBQUwsQ0FBUzNKLElBQUk5SSxLQUFiLEVBQW9CL0QsSUFBSSxLQUFLOFgsY0FBVCxHQUEwQjBCLE1BQU1yTyxJQUFOLENBQVdwSCxLQUF6RCxDQUhhO0FBSWpCMFgsd0JBQUkzTyxJQUFJZDtBQUpTLG1CQUFuQjs7QUFPQSxzQkFBSXFQLGFBQWFDLEVBQWIsR0FBa0JELGFBQWFHLEVBQW5DLEVBQXVDO0FBQ3JDLHdCQUFJRSxRQUFRLEtBQUtsYixNQUFMLENBQVl5YSxvQkFBWixDQUFpQ0MsYUFBakMsQ0FBK0MxRCxZQUEvQyxLQUFnRSxFQUE1RTtBQUFBLHdCQUNJM1YsWUFBWTZaLE1BQU03WixTQUR0QjtBQUFBLHdCQUVJQyxnQkFBZ0I0WixNQUFNNVosYUFGMUI7O0FBSUEseUJBQUt5SyxhQUFMLENBQW1CaU4sS0FBbkIsRUFBMEIzWCxTQUExQixFQUFxQ0MsYUFBckM7QUFDQSx5QkFBSzJLLHFCQUFMLENBQTJCK00sS0FBM0IsRUFBa0MsS0FBS2haLE1BQUwsQ0FBWWtNLFFBQTlDO0FBQ0E4TSwwQkFBTTVNLFNBQU4sQ0FBZ0J5TyxhQUFhQyxFQUFiLEdBQWtCN0IsVUFBbEMsRUFBOEM0QixhQUFhRSxFQUEzRCxFQUErREYsYUFBYUcsRUFBYixHQUFrQkgsYUFBYUMsRUFBOUYsRUFBa0dELGFBQWFJLEVBQWIsR0FBa0JKLGFBQWFFLEVBQWpJLEVBQXFJeE8sTUFBckk7QUFDRDtBQUNGO0FBQ0Y7QUFDRDs7Ozs7OztBQTVCQyxhQXZVdUIsRUEwV3ZCO0FBQ0RqQyxtQkFBSyxhQURKO0FBRURoRyxxQkFBTyxTQUFTNlcsV0FBVCxDQUFxQm5FLFlBQXJCLEVBQW1DO0FBQ3hDLHVCQUFPLEtBQUtoWCxNQUFMLENBQVlvYixhQUFaLElBQTZCLEtBQUtwYixNQUFMLENBQVl5YSxvQkFBWixDQUFpQ1ksY0FBakMsQ0FBZ0RDLFFBQWhELENBQXlEdEUsWUFBekQsQ0FBcEM7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFMQyxhQTFXdUIsRUFpWXZCO0FBQ0QxTSxtQkFBSyxhQURKO0FBRURoRyxxQkFBTyxTQUFTaVYsV0FBVCxDQUFxQnBNLEtBQXJCLEVBQTRCNkosWUFBNUIsRUFBMENqVixLQUExQyxFQUFpREMsR0FBakQsRUFBc0R1WixFQUF0RCxFQUEwREMsU0FBMUQsRUFBcUVDLGFBQXJFLEVBQW9GO0FBQ3pGLG9CQUFJQyxTQUFTLElBQWI7O0FBRUEsdUJBQU8xTSxLQUFLcUssS0FBTCxDQUFXLFlBQVk7QUFDNUI7QUFDQSxzQkFBSWxNLE1BQU0sQ0FBTixhQUFvQndPLEtBQXhCLEVBQStCO0FBQzdCLHdCQUFJQyxXQUFXek8sS0FBZjs7QUFFQSx3QkFBSXVPLE9BQU8xYixNQUFQLENBQWNvYixhQUFsQixFQUFpQztBQUMvQiwwQkFBSVMsbUJBQW1CRCxTQUFTRSxNQUFULENBQWdCLFVBQVVDLENBQVYsRUFBYXZjLENBQWIsRUFBZ0I7QUFDckQsK0JBQU8sQ0FBQ2tjLE9BQU9QLFdBQVAsQ0FBbUIzYixDQUFuQixDQUFSO0FBQ0QsdUJBRnNCLENBQXZCOztBQUlBLDBCQUFJLENBQUNrYyxPQUFPMWIsTUFBUCxDQUFjeWEsb0JBQWQsQ0FBbUN1QixPQUF4QyxFQUFpRDtBQUMvQ04sK0JBQU90RixTQUFQLENBQWlCNUksS0FBS3VJLEdBQUwsQ0FBUzhGLGlCQUFpQjNhLE1BQTFCLEVBQWtDLENBQWxDLElBQXVDd2EsT0FBTzFiLE1BQVAsQ0FBY3dMLE1BQXJELEdBQThEa1EsT0FBTzFiLE1BQVAsQ0FBY2dTLFVBQTdGO0FBQ0Q7O0FBRUQsMEJBQUlpSyxhQUFKOztBQUVBLDBCQUFJUCxPQUFPMWIsTUFBUCxDQUFjeWEsb0JBQWQsSUFBc0NpQixPQUFPMWIsTUFBUCxDQUFjeWEsb0JBQWQsQ0FBbUN5QixxQkFBN0UsRUFBb0c7QUFDbEc7QUFDQUQsd0NBQWdCak4sS0FBSytHLEdBQUwsQ0FBUzZGLFNBQVNPLEdBQVQsQ0FBYSxVQUFVQyxZQUFWLEVBQXdCO0FBQzVELGlDQUFPcE4sS0FBS3FOLE1BQUwsQ0FBWUQsWUFBWixDQUFQO0FBQ0QseUJBRndCLENBQVQsQ0FBaEI7QUFHRDs7QUFFRCw2QkFBT1IsU0FBUzdDLE9BQVQsQ0FBaUIsVUFBVXFELFlBQVYsRUFBd0I1YyxDQUF4QixFQUEyQjtBQUNqRCwrQkFBT2tjLE9BQU9uQyxXQUFQLENBQW1CNkMsWUFBbkIsRUFBaUM1YyxDQUFqQyxFQUFvQ3VDLEtBQXBDLEVBQTJDQyxHQUEzQyxFQUFnRHVaLEVBQWhELEVBQW9ETSxpQkFBaUJqVSxPQUFqQixDQUF5QndVLFlBQXpCLENBQXBELEVBQTRGSCxhQUE1RixDQUFQO0FBQ0QsdUJBRk0sQ0FBUDtBQUdEOztBQUVEOU8sNEJBQVF5TyxTQUFTLENBQVQsQ0FBUjtBQUNELG1CQTdCMkIsQ0E2QjFCOzs7QUFHRixzQkFBSUYsT0FBT1AsV0FBUCxDQUFtQm5FLFlBQW5CLENBQUosRUFBc0M7QUFDcEM7QUFDRCxtQkFsQzJCLENBa0MxQjtBQUNGO0FBQ0E7OztBQUdBLHNCQUFJNUosU0FBUyxJQUFJc08sT0FBTzFiLE1BQVAsQ0FBY3lCLFNBQS9COztBQUVBLHNCQUFJaWEsT0FBTzFiLE1BQVAsQ0FBY3NjLFNBQWxCLEVBQTZCO0FBQzNCbFAsNkJBQVNxTyxrQkFBa0JqYixTQUFsQixHQUE4QndPLEtBQUtxTixNQUFMLENBQVlsUCxLQUFaLENBQTlCLEdBQW1Ec08sYUFBNUQ7QUFDRCxtQkEzQzJCLENBMkMxQjtBQUNGOzs7QUFHQSxzQkFBSWhDLGFBQWEsR0FBRzhDLElBQUgsQ0FBUXJVLElBQVIsQ0FBYWlGLEtBQWIsRUFBb0IsVUFBVWhJLEdBQVYsRUFBZTtBQUNsRCwyQkFBT0EsTUFBTSxDQUFiO0FBQ0QsbUJBRmdCLENBQWpCO0FBR0Esc0JBQUlxRyxTQUFTa1EsT0FBTzFiLE1BQVAsQ0FBY3dMLE1BQWQsR0FBdUJrUSxPQUFPMWIsTUFBUCxDQUFjZ1MsVUFBbEQ7QUFDQSxzQkFBSTNFLFFBQVE3QixTQUFTLENBQXJCO0FBQ0Esc0JBQUk4QixVQUFVOUIsU0FBU2dRLFNBQVQsSUFBc0IsQ0FBcEMsQ0FwRDRCLENBb0RXOztBQUV2QyxzQkFBSUUsT0FBTzFiLE1BQVAsQ0FBY3lhLG9CQUFkLElBQXNDaUIsT0FBTzFiLE1BQVAsQ0FBY3lhLG9CQUFkLENBQW1DdUIsT0FBN0UsRUFBc0Y7QUFDcEYxTyw4QkFBVSxDQUFWO0FBQ0Q7O0FBRUQseUJBQU9pTyxHQUFHO0FBQ1JuTyw0QkFBUUEsTUFEQTtBQUVScU0sZ0NBQVlBLFVBRko7QUFHUmpPLDRCQUFRQSxNQUhBO0FBSVI4Qiw2QkFBU0EsT0FKRDtBQUtSRCwyQkFBT0EsS0FMQztBQU1SRiwyQkFBT0EsS0FOQztBQU9SNkosa0NBQWNBO0FBUE4sbUJBQUgsQ0FBUDtBQVNELGlCQW5FTSxHQUFQO0FBb0VEO0FBQ0Q7Ozs7Ozs7O0FBMUVDLGFBall1QixFQW1kdkI7QUFDRDFNLG1CQUFLLGVBREo7QUFFRGhHLHFCQUFPLFNBQVN5SCxhQUFULENBQXVCaU4sS0FBdkIsRUFBOEI7QUFDbkMsb0JBQUkzWCxZQUFZNlAsVUFBVWhRLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JnUSxVQUFVLENBQVYsTUFBaUIxUSxTQUF6QyxHQUFxRDBRLFVBQVUsQ0FBVixDQUFyRCxHQUFvRSxLQUFLbFIsTUFBTCxDQUFZcUIsU0FBaEc7QUFDQSxvQkFBSUMsZ0JBQWdCNFAsVUFBVWhRLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JnUSxVQUFVLENBQVYsTUFBaUIxUSxTQUF6QyxHQUFxRDBRLFVBQVUsQ0FBVixDQUFyRCxHQUFvRSxLQUFLbFIsTUFBTCxDQUFZc0IsYUFBcEc7QUFDQTBYLHNCQUFNak4sYUFBTixDQUFvQjFLLFNBQXBCLEVBQStCQyxhQUEvQjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFQQyxhQW5kdUIsRUFpZXZCO0FBQ0RnSixtQkFBSyx1QkFESjtBQUVEaEcscUJBQU8sU0FBUzJILHFCQUFULENBQStCK00sS0FBL0IsRUFBc0M7QUFDM0Msb0JBQUk5TSxXQUFXZ0YsVUFBVWhRLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JnUSxVQUFVLENBQVYsTUFBaUIxUSxTQUF6QyxHQUFxRDBRLFVBQVUsQ0FBVixDQUFyRCxHQUFvRSxLQUFuRjtBQUNBOEgsc0JBQU0vTSxxQkFBTixDQUE0QkMsUUFBNUI7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7QUFOQyxhQWpldUIsRUFzZnZCO0FBQ0Q1QixtQkFBSyxVQURKO0FBRURoRyxxQkFBTyxTQUFTOEosUUFBVCxDQUFrQkMsTUFBbEIsRUFBMEJDLE9BQTFCLEVBQW1DQyxJQUFuQyxFQUF5QztBQUM5QyxvQkFBSUEsU0FBUyxNQUFiLEVBQXFCO0FBQ25CLHlCQUFPRSxRQUFRK04sR0FBUixDQUFZLEtBQUtoRixRQUFMLENBQWMyRSxHQUFkLENBQWtCLFVBQVVuRCxLQUFWLEVBQWlCO0FBQ3BELDJCQUFPQSxNQUFNNUssUUFBTixDQUFlQyxNQUFmLEVBQXVCQyxPQUF2QixFQUFnQ0MsSUFBaEMsQ0FBUDtBQUNELG1CQUZrQixDQUFaLENBQVA7QUFHRCxpQkFKRCxNQUlPLElBQUlBLFNBQVMsU0FBYixFQUF3QjtBQUM3QixzQkFBSWtPLFNBQVMsS0FBS2pGLFFBQUwsQ0FBYzJFLEdBQWQsQ0FBa0IsVUFBVW5ELEtBQVYsRUFBaUI7QUFDOUMsMkJBQU9BLE1BQU01SyxRQUFOLENBQWVDLE1BQWYsRUFBdUJDLE9BQXZCLEVBQWdDQyxJQUFoQyxDQUFQO0FBQ0QsbUJBRlksQ0FBYjtBQUdBLHlCQUFPa08sT0FBT3ZiLE1BQVAsR0FBZ0IsQ0FBaEIsR0FBb0J1YixNQUFwQixHQUE2QkEsT0FBTyxDQUFQLENBQXBDO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7QUFkQyxhQXRmdUIsRUEwZ0J2QjtBQUNEblMsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVNxUyxjQUFULENBQXdCaEUsUUFBeEIsRUFBa0M7QUFDdkMscUJBQUtSLEtBQUwsQ0FBVyxLQUFLc0YsWUFBaEIsRUFBOEI7QUFDNUJsVSx5QkFBT29QLFdBQVc7QUFEVSxpQkFBOUI7QUFHRDtBQU5BLGFBMWdCdUIsQ0FBMUI7O0FBbWhCQSxtQkFBT3lFLFdBQVA7QUFDRCxXQWpuQjhCLENBaW5CN0JGLFFBQVExTixPQWpuQnFCLENBQS9COztBQW1uQkExSyxrQkFBUTBLLE9BQVIsR0FBa0I0TixXQUFsQjtBQUNBdlksaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBdmpEOEI7O0FBeWpEckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLG1DQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQWtCeUssbUJBQWxCLEVBQTBDOztBQUVqRDs7QUFHQSxtQkFBU3NGLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFO0FBQTJCLGdCQUFJLE9BQU9rRixNQUFQLEtBQWtCLFVBQWxCLElBQWdDLFNBQU9BLE9BQU9DLFFBQWQsTUFBMkIsUUFBL0QsRUFBeUU7QUFBRUYsd0JBQVUsU0FBU0EsT0FBVCxDQUFpQmpGLEdBQWpCLEVBQXNCO0FBQUUsOEJBQWNBLEdBQWQsMENBQWNBLEdBQWQ7QUFBb0IsZUFBdEQ7QUFBeUQsYUFBcEksTUFBMEk7QUFBRWlGLHdCQUFVLFNBQVNBLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFLHVCQUFPQSxPQUFPLE9BQU9rRixNQUFQLEtBQWtCLFVBQXpCLElBQXVDbEYsSUFBSTdJLFdBQUosS0FBb0IrTixNQUEzRCxJQUFxRWxGLFFBQVFrRixPQUFPbE8sU0FBcEYsR0FBZ0csUUFBaEcsVUFBa0hnSixHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsZUFBaks7QUFBb0ssYUFBQyxPQUFPaUYsUUFBUWpGLEdBQVIsQ0FBUDtBQUFzQjs7QUFFMVh6SyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsY0FBSWtULGdCQUFnQmhULHVCQUF1QkgscUJBQW9CLHFCQUFzQix1QkFBMUMsQ0FBdkIsQ0FBcEI7O0FBRUEsbUJBQVNHLHNCQUFULENBQWdDRSxHQUFoQyxFQUFxQztBQUFFLG1CQUFPQSxPQUFPQSxJQUFJQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QixFQUFFSixTQUFTSSxHQUFYLEVBQXJDO0FBQXdEOztBQUUvRixtQkFBU0UsZUFBVCxDQUF5QnRCLFFBQXpCLEVBQW1DdUIsV0FBbkMsRUFBZ0Q7QUFBRSxnQkFBSSxFQUFFdkIsb0JBQW9CdUIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLG9CQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLG1CQUFTQyxpQkFBVCxDQUEyQjFGLE1BQTNCLEVBQW1DMkYsS0FBbkMsRUFBMEM7QUFBRSxpQkFBSyxJQUFJMUssSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEssTUFBTWhKLE1BQTFCLEVBQWtDMUIsR0FBbEMsRUFBdUM7QUFBRSxrQkFBSTJLLGFBQWFELE1BQU0xSyxDQUFOLENBQWpCLENBQTJCMkssV0FBVzlLLFVBQVgsR0FBd0I4SyxXQUFXOUssVUFBWCxJQUF5QixLQUFqRCxDQUF3RDhLLFdBQVdDLFlBQVgsR0FBMEIsSUFBMUIsQ0FBZ0MsSUFBSSxXQUFXRCxVQUFmLEVBQTJCQSxXQUFXRSxRQUFYLEdBQXNCLElBQXRCLENBQTRCbEwsT0FBT0MsY0FBUCxDQUFzQm1GLE1BQXRCLEVBQThCNEYsV0FBV0csR0FBekMsRUFBOENILFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULG1CQUFTSSxZQUFULENBQXNCUixXQUF0QixFQUFtQ1MsVUFBbkMsRUFBK0NDLFdBQS9DLEVBQTREO0FBQUUsZ0JBQUlELFVBQUosRUFBZ0JQLGtCQUFrQkYsWUFBWW5KLFNBQTlCLEVBQXlDNEosVUFBekMsRUFBc0QsSUFBSUMsV0FBSixFQUFpQlIsa0JBQWtCRixXQUFsQixFQUErQlUsV0FBL0IsRUFBNkMsT0FBT1YsV0FBUDtBQUFxQjs7QUFFdk4sbUJBQVM0UyxJQUFULENBQWNwWSxNQUFkLEVBQXNCcVksUUFBdEIsRUFBZ0NDLFFBQWhDLEVBQTBDO0FBQUUsZ0JBQUksT0FBTzdMLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVExUixHQUE5QyxFQUFtRDtBQUFFcWQscUJBQU8zTCxRQUFRMVIsR0FBZjtBQUFxQixhQUExRSxNQUFnRjtBQUFFcWQscUJBQU8sU0FBU0EsSUFBVCxDQUFjcFksTUFBZCxFQUFzQnFZLFFBQXRCLEVBQWdDQyxRQUFoQyxFQUEwQztBQUFFLG9CQUFJQyxPQUFPQyxlQUFleFksTUFBZixFQUF1QnFZLFFBQXZCLENBQVgsQ0FBNkMsSUFBSSxDQUFDRSxJQUFMLEVBQVcsT0FBUSxJQUFJak4sT0FBTzFRLE9BQU93USx3QkFBUCxDQUFnQ21OLElBQWhDLEVBQXNDRixRQUF0QyxDQUFYLENBQTRELElBQUkvTSxLQUFLdlEsR0FBVCxFQUFjO0FBQUUseUJBQU91USxLQUFLdlEsR0FBTCxDQUFTNEksSUFBVCxDQUFjMlUsUUFBZCxDQUFQO0FBQWlDLGlCQUFDLE9BQU9oTixLQUFLdkwsS0FBWjtBQUFvQixlQUFyUDtBQUF3UCxhQUFDLE9BQU9xWSxLQUFLcFksTUFBTCxFQUFhcVksUUFBYixFQUF1QkMsWUFBWXRZLE1BQW5DLENBQVA7QUFBb0Q7O0FBRTNhLG1CQUFTd1ksY0FBVCxDQUF3QkMsTUFBeEIsRUFBZ0NKLFFBQWhDLEVBQTBDO0FBQUUsbUJBQU8sQ0FBQ3pkLE9BQU95QixTQUFQLENBQWlCZ1AsY0FBakIsQ0FBZ0MxSCxJQUFoQyxDQUFxQzhVLE1BQXJDLEVBQTZDSixRQUE3QyxDQUFSLEVBQWdFO0FBQUVJLHVCQUFTbk0sZ0JBQWdCbU0sTUFBaEIsQ0FBVCxDQUFrQyxJQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFBUSxhQUFDLE9BQU9BLE1BQVA7QUFBZ0I7O0FBRTlMLG1CQUFTak4sU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQUUsZ0JBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLG9CQUFNLElBQUlqRyxTQUFKLENBQWMsb0RBQWQsQ0FBTjtBQUE0RSxhQUFDZ0csU0FBU3BQLFNBQVQsR0FBcUJ6QixPQUFPMEIsTUFBUCxDQUFjb1AsY0FBY0EsV0FBV3JQLFNBQXZDLEVBQWtELEVBQUVHLGFBQWEsRUFBRXVELE9BQU8wTCxRQUFULEVBQW1CM0YsVUFBVSxJQUE3QixFQUFtQ0QsY0FBYyxJQUFqRCxFQUFmLEVBQWxELENBQXJCLENBQWtKLElBQUk2RixVQUFKLEVBQWdCQyxnQkFBZ0JGLFFBQWhCLEVBQTBCQyxVQUExQjtBQUF3Qzs7QUFFalksbUJBQVNDLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjtBQUFFRiw4QkFBa0IvUSxPQUFPa1IsY0FBUCxJQUF5QixTQUFTSCxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7QUFBRUQsZ0JBQUVHLFNBQUYsR0FBY0YsQ0FBZCxDQUFpQixPQUFPRCxDQUFQO0FBQVcsYUFBeEcsQ0FBMEcsT0FBT0QsZ0JBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsQ0FBUDtBQUErQjs7QUFFMUssbUJBQVNHLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCO0FBQUUsZ0JBQUlDLDRCQUE0QkMsMkJBQWhDLENBQTZELE9BQU8sU0FBU0Msb0JBQVQsR0FBZ0M7QUFBRSxrQkFBSUMsUUFBUUMsZ0JBQWdCTCxPQUFoQixDQUFaO0FBQUEsa0JBQXNDTSxNQUF0QyxDQUE4QyxJQUFJTCx5QkFBSixFQUErQjtBQUFFLG9CQUFJTSxZQUFZRixnQkFBZ0IsSUFBaEIsRUFBc0I5UCxXQUF0QyxDQUFtRCtQLFNBQVNFLFFBQVFDLFNBQVIsQ0FBa0JMLEtBQWxCLEVBQXlCTSxTQUF6QixFQUFvQ0gsU0FBcEMsQ0FBVDtBQUEwRCxlQUE5SSxNQUFvSjtBQUFFRCx5QkFBU0YsTUFBTU8sS0FBTixDQUFZLElBQVosRUFBa0JELFNBQWxCLENBQVQ7QUFBd0MsZUFBQyxPQUFPRSwyQkFBMkIsSUFBM0IsRUFBaUNOLE1BQWpDLENBQVA7QUFBa0QsYUFBeFU7QUFBMlU7O0FBRXphLG1CQUFTTSwwQkFBVCxDQUFvQ25RLElBQXBDLEVBQTBDaUgsSUFBMUMsRUFBZ0Q7QUFBRSxnQkFBSUEsU0FBUzJHLFFBQVEzRyxJQUFSLE1BQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBdkQsQ0FBSixFQUF3RTtBQUFFLHFCQUFPQSxJQUFQO0FBQWMsYUFBQyxPQUFPbUosdUJBQXVCcFEsSUFBdkIsQ0FBUDtBQUFzQzs7QUFFakwsbUJBQVNvUSxzQkFBVCxDQUFnQ3BRLElBQWhDLEVBQXNDO0FBQUUsZ0JBQUlBLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUFFLG9CQUFNLElBQUlxUSxjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLGFBQUMsT0FBT3JRLElBQVA7QUFBYzs7QUFFdEssbUJBQVN5UCx5QkFBVCxHQUFxQztBQUFFLGdCQUFJLE9BQU9NLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0MsQ0FBQ0EsUUFBUUMsU0FBL0MsRUFBMEQsT0FBTyxLQUFQLENBQWMsSUFBSUQsUUFBUUMsU0FBUixDQUFrQk0sSUFBdEIsRUFBNEIsT0FBTyxLQUFQLENBQWMsSUFBSSxPQUFPQyxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDLE9BQU8sSUFBUCxDQUFhLElBQUk7QUFBRUMsc0JBQVE3USxTQUFSLENBQWtCOFEsT0FBbEIsQ0FBMEJ4SixJQUExQixDQUErQjhJLFFBQVFDLFNBQVIsQ0FBa0JRLE9BQWxCLEVBQTJCLEVBQTNCLEVBQStCLFlBQVksQ0FBRSxDQUE3QyxDQUEvQixFQUFnRixPQUFPLElBQVA7QUFBYyxhQUFwRyxDQUFxRyxPQUFPcE4sQ0FBUCxFQUFVO0FBQUUscUJBQU8sS0FBUDtBQUFlO0FBQUU7O0FBRXpVLG1CQUFTd00sZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRVUsOEJBQWtCMVIsT0FBT2tSLGNBQVAsR0FBd0JsUixPQUFPd1MsY0FBL0IsR0FBZ0QsU0FBU2QsZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRSxxQkFBT0EsRUFBRUcsU0FBRixJQUFlblIsT0FBT3dTLGNBQVAsQ0FBc0J4QixDQUF0QixDQUF0QjtBQUFpRCxhQUFqSixDQUFtSixPQUFPVSxnQkFBZ0JWLENBQWhCLENBQVA7QUFBNEI7O0FBRTdNOzs7Ozs7Ozs7QUFTQSxjQUFJOE0sdUJBQXVCLGFBQWEsVUFBVUMsYUFBVixFQUF5QjtBQUMvRG5OLHNCQUFVa04sb0JBQVYsRUFBZ0NDLGFBQWhDOztBQUVBLGdCQUFJcEwsU0FBU3ZCLGFBQWEwTSxvQkFBYixDQUFiOztBQUVBOzs7OztBQUtBLHFCQUFTQSxvQkFBVCxDQUE4QmpkLE1BQTlCLEVBQXNDO0FBQ3BDLGtCQUFJd08sS0FBSjs7QUFFQTFFLDhCQUFnQixJQUFoQixFQUFzQm1ULG9CQUF0Qjs7QUFFQXpPLHNCQUFRc0QsT0FBTzVKLElBQVAsQ0FBWSxJQUFaLEVBQWtCbEksTUFBbEIsQ0FBUjtBQUNBOztBQUVBd08sb0JBQU14TyxNQUFOLEdBQWVBLE1BQWY7QUFDQTs7QUFFQXdPLG9CQUFNMk8sa0JBQU4sR0FBMkIsSUFBM0I7QUFDQSxxQkFBTzNPLEtBQVA7QUFDRDtBQUNEOzs7O0FBS0FqRSx5QkFBYTBTLG9CQUFiLEVBQW1DLENBQUM7QUFDbEMzUyxtQkFBSyxNQUQ2QjtBQUVsQ2hHLHFCQUFPLFNBQVN0RCxJQUFULEdBQWdCO0FBQ3JCLHFCQUFLb2MsZUFBTCxDQUFxQixLQUFLcGQsTUFBTCxDQUFZcWQsU0FBakM7QUFDQSxxQkFBS0MsV0FBTDtBQUNBLHFCQUFLQyxnQkFBTDtBQUNBLHFCQUFLQyxnQkFBTDtBQUNBLHFCQUFLQyxrQkFBTDtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7QUFUa0MsYUFBRCxFQW1CaEM7QUFDRG5ULG1CQUFLLE9BREo7QUFFRGhHLHFCQUFPLFNBQVNvWixLQUFULENBQWVDLEtBQWYsRUFBc0J4USxLQUF0QixFQUE2QnlRLE9BQTdCLEVBQXNDO0FBQzNDakIscUJBQUs5TCxnQkFBZ0JvTSxxQkFBcUJyYyxTQUFyQyxDQUFMLEVBQXNELE9BQXRELEVBQStELElBQS9ELEVBQXFFc0gsSUFBckUsQ0FBMEUsSUFBMUUsRUFBZ0Z5VixLQUFoRixFQUF1RnhRLEtBQXZGLEVBQThGeVEsT0FBOUY7O0FBRUEscUJBQUtDLHdCQUFMLENBQThCRixLQUE5QjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFQQyxhQW5CZ0MsRUFpQ2hDO0FBQ0RyVCxtQkFBSywwQkFESjtBQUVEaEcscUJBQU8sU0FBU3VaLHdCQUFULENBQWtDQyxZQUFsQyxFQUFnRDtBQUNyRCxxQkFBS1gsa0JBQUwsR0FBMEIsS0FBS1ksRUFBTCxDQUFRRix3QkFBUixDQUFpQ0MsWUFBakMsQ0FBMUI7QUFDQSxxQkFBS1gsa0JBQUwsQ0FBd0JhLE9BQXhCLENBQWdDLEtBQUtDLFFBQXJDO0FBQ0Q7QUFMQSxhQWpDZ0MsRUF1Q2hDO0FBQ0QzVCxtQkFBSyxNQURKO0FBRURoRyxxQkFBTyxTQUFTbUIsSUFBVCxDQUFjMUQsS0FBZCxFQUFxQkMsR0FBckIsRUFBMEI7QUFDL0IscUJBQUtrYyxrQkFBTDtBQUNBLHVCQUFPdkIsS0FBSzlMLGdCQUFnQm9NLHFCQUFxQnJjLFNBQXJDLENBQUwsRUFBc0QsTUFBdEQsRUFBOEQsSUFBOUQsRUFBb0VzSCxJQUFwRSxDQUF5RSxJQUF6RSxFQUErRW5HLEtBQS9FLEVBQXNGQyxHQUF0RixDQUFQO0FBQ0Q7QUFDRDs7Ozs7QUFOQyxhQXZDZ0MsRUFrRGhDO0FBQ0RzSSxtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTNkosT0FBVCxHQUFtQjtBQUN4QndPLHFCQUFLOUwsZ0JBQWdCb00scUJBQXFCcmMsU0FBckMsQ0FBTCxFQUFzRCxTQUF0RCxFQUFpRSxJQUFqRSxFQUF1RXNILElBQXZFLENBQTRFLElBQTVFOztBQUVBLHFCQUFLaVcsZUFBTDtBQUNEO0FBTkEsYUFsRGdDLENBQW5DOztBQTJEQSxtQkFBT2xCLG9CQUFQO0FBQ0QsV0F6RnVDLENBeUZ0Q1AsY0FBY2xULE9BekZ3QixDQUF4Qzs7QUEyRkExSyxrQkFBUTBLLE9BQVIsR0FBa0J5VCxvQkFBbEI7QUFDQXBlLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQTVzRDhCOztBQThzRHJDLGFBQU07QUFDTjs7O0FBR0EsYUFBTywyQkFBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFrQnlLLG1CQUFsQixFQUEwQzs7QUFFakQ7O0FBR0EsbUJBQVNzRixPQUFULENBQWlCakYsR0FBakIsRUFBc0I7QUFBRTtBQUEyQixnQkFBSSxPQUFPa0YsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxTQUFPQSxPQUFPQyxRQUFkLE1BQTJCLFFBQS9ELEVBQXlFO0FBQUVGLHdCQUFVLFNBQVNBLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFLDhCQUFjQSxHQUFkLDBDQUFjQSxHQUFkO0FBQW9CLGVBQXREO0FBQXlELGFBQXBJLE1BQTBJO0FBQUVpRix3QkFBVSxTQUFTQSxPQUFULENBQWlCakYsR0FBakIsRUFBc0I7QUFBRSx1QkFBT0EsT0FBTyxPQUFPa0YsTUFBUCxLQUFrQixVQUF6QixJQUF1Q2xGLElBQUk3SSxXQUFKLEtBQW9CK04sTUFBM0QsSUFBcUVsRixRQUFRa0YsT0FBT2xPLFNBQXBGLEdBQWdHLFFBQWhHLFVBQWtIZ0osR0FBbEgsMENBQWtIQSxHQUFsSCxDQUFQO0FBQStILGVBQWpLO0FBQW9LLGFBQUMsT0FBT2lGLFFBQVFqRixHQUFSLENBQVA7QUFBc0I7O0FBRTFYekssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLGNBQUk0VSxZQUFZMVUsdUJBQXVCSCxxQkFBb0IsaUJBQWtCLG1CQUF0QyxDQUF2QixDQUFoQjs7QUFFQSxjQUFJeUYsT0FBT0Msd0JBQXdCMUYscUJBQW9CLGFBQWMscUJBQWxDLENBQXhCLENBQVg7O0FBRUEsbUJBQVMyRix3QkFBVCxDQUFrQ0MsV0FBbEMsRUFBK0M7QUFBRSxnQkFBSSxPQUFPQyxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DLE9BQU8sSUFBUCxDQUFhLElBQUlDLG9CQUFvQixJQUFJRCxPQUFKLEVBQXhCLENBQXVDLElBQUlFLG1CQUFtQixJQUFJRixPQUFKLEVBQXZCLENBQXNDLE9BQU8sQ0FBQ0YsMkJBQTJCLFNBQVNBLHdCQUFULENBQWtDQyxXQUFsQyxFQUErQztBQUFFLHFCQUFPQSxjQUFjRyxnQkFBZCxHQUFpQ0QsaUJBQXhDO0FBQTRELGFBQXpJLEVBQTJJRixXQUEzSSxDQUFQO0FBQWlLOztBQUUvVSxtQkFBU0YsdUJBQVQsQ0FBaUNyRixHQUFqQyxFQUFzQ3VGLFdBQXRDLEVBQW1EO0FBQUUsZ0JBQUksQ0FBQ0EsV0FBRCxJQUFnQnZGLEdBQWhCLElBQXVCQSxJQUFJQyxVQUEvQixFQUEyQztBQUFFLHFCQUFPRCxHQUFQO0FBQWEsYUFBQyxJQUFJQSxRQUFRLElBQVIsSUFBZ0JpRixRQUFRakYsR0FBUixNQUFpQixRQUFqQixJQUE2QixPQUFPQSxHQUFQLEtBQWUsVUFBaEUsRUFBNEU7QUFBRSxxQkFBTyxFQUFFSixTQUFTSSxHQUFYLEVBQVA7QUFBMEIsYUFBQyxJQUFJMkYsUUFBUUwseUJBQXlCQyxXQUF6QixDQUFaLENBQW1ELElBQUlJLFNBQVNBLE1BQU1DLEdBQU4sQ0FBVTVGLEdBQVYsQ0FBYixFQUE2QjtBQUFFLHFCQUFPMkYsTUFBTWpRLEdBQU4sQ0FBVXNLLEdBQVYsQ0FBUDtBQUF3QixhQUFDLElBQUk2RixTQUFTLEVBQWIsQ0FBaUIsSUFBSUMsd0JBQXdCdlEsT0FBT0MsY0FBUCxJQUF5QkQsT0FBT3dRLHdCQUE1RCxDQUFzRixLQUFLLElBQUlyRixHQUFULElBQWdCVixHQUFoQixFQUFxQjtBQUFFLGtCQUFJVSxRQUFRLFNBQVIsSUFBcUJuTCxPQUFPeUIsU0FBUCxDQUFpQmdQLGNBQWpCLENBQWdDMUgsSUFBaEMsQ0FBcUMwQixHQUFyQyxFQUEwQ1UsR0FBMUMsQ0FBekIsRUFBeUU7QUFBRSxvQkFBSXVGLE9BQU9ILHdCQUF3QnZRLE9BQU93USx3QkFBUCxDQUFnQy9GLEdBQWhDLEVBQXFDVSxHQUFyQyxDQUF4QixHQUFvRSxJQUEvRSxDQUFxRixJQUFJdUYsU0FBU0EsS0FBS3ZRLEdBQUwsSUFBWXVRLEtBQUtDLEdBQTFCLENBQUosRUFBb0M7QUFBRTNRLHlCQUFPQyxjQUFQLENBQXNCcVEsTUFBdEIsRUFBOEJuRixHQUE5QixFQUFtQ3VGLElBQW5DO0FBQTJDLGlCQUFqRixNQUF1RjtBQUFFSix5QkFBT25GLEdBQVAsSUFBY1YsSUFBSVUsR0FBSixDQUFkO0FBQXlCO0FBQUU7QUFBRSxhQUFDbUYsT0FBT2pHLE9BQVAsR0FBaUJJLEdBQWpCLENBQXNCLElBQUkyRixLQUFKLEVBQVc7QUFBRUEsb0JBQU1PLEdBQU4sQ0FBVWxHLEdBQVYsRUFBZTZGLE1BQWY7QUFBeUIsYUFBQyxPQUFPQSxNQUFQO0FBQWdCOztBQUV0eUIsbUJBQVMvRixzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7QUFBRSxtQkFBT0EsT0FBT0EsSUFBSUMsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEIsRUFBRUosU0FBU0ksR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsbUJBQVNFLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOLG1CQUFTNFMsSUFBVCxDQUFjcFksTUFBZCxFQUFzQnFZLFFBQXRCLEVBQWdDQyxRQUFoQyxFQUEwQztBQUFFLGdCQUFJLE9BQU83TCxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRMVIsR0FBOUMsRUFBbUQ7QUFBRXFkLHFCQUFPM0wsUUFBUTFSLEdBQWY7QUFBcUIsYUFBMUUsTUFBZ0Y7QUFBRXFkLHFCQUFPLFNBQVNBLElBQVQsQ0FBY3BZLE1BQWQsRUFBc0JxWSxRQUF0QixFQUFnQ0MsUUFBaEMsRUFBMEM7QUFBRSxvQkFBSUMsT0FBT0MsZUFBZXhZLE1BQWYsRUFBdUJxWSxRQUF2QixDQUFYLENBQTZDLElBQUksQ0FBQ0UsSUFBTCxFQUFXLE9BQVEsSUFBSWpOLE9BQU8xUSxPQUFPd1Esd0JBQVAsQ0FBZ0NtTixJQUFoQyxFQUFzQ0YsUUFBdEMsQ0FBWCxDQUE0RCxJQUFJL00sS0FBS3ZRLEdBQVQsRUFBYztBQUFFLHlCQUFPdVEsS0FBS3ZRLEdBQUwsQ0FBUzRJLElBQVQsQ0FBYzJVLFFBQWQsQ0FBUDtBQUFpQyxpQkFBQyxPQUFPaE4sS0FBS3ZMLEtBQVo7QUFBb0IsZUFBclA7QUFBd1AsYUFBQyxPQUFPcVksS0FBS3BZLE1BQUwsRUFBYXFZLFFBQWIsRUFBdUJDLFlBQVl0WSxNQUFuQyxDQUFQO0FBQW9EOztBQUUzYSxtQkFBU3dZLGNBQVQsQ0FBd0JDLE1BQXhCLEVBQWdDSixRQUFoQyxFQUEwQztBQUFFLG1CQUFPLENBQUN6ZCxPQUFPeUIsU0FBUCxDQUFpQmdQLGNBQWpCLENBQWdDMUgsSUFBaEMsQ0FBcUM4VSxNQUFyQyxFQUE2Q0osUUFBN0MsQ0FBUixFQUFnRTtBQUFFSSx1QkFBU25NLGdCQUFnQm1NLE1BQWhCLENBQVQsQ0FBa0MsSUFBSUEsV0FBVyxJQUFmLEVBQXFCO0FBQVEsYUFBQyxPQUFPQSxNQUFQO0FBQWdCOztBQUU5TCxtQkFBU2pOLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxVQUE3QixFQUF5QztBQUFFLGdCQUFJLE9BQU9BLFVBQVAsS0FBc0IsVUFBdEIsSUFBb0NBLGVBQWUsSUFBdkQsRUFBNkQ7QUFBRSxvQkFBTSxJQUFJakcsU0FBSixDQUFjLG9EQUFkLENBQU47QUFBNEUsYUFBQ2dHLFNBQVNwUCxTQUFULEdBQXFCekIsT0FBTzBCLE1BQVAsQ0FBY29QLGNBQWNBLFdBQVdyUCxTQUF2QyxFQUFrRCxFQUFFRyxhQUFhLEVBQUV1RCxPQUFPMEwsUUFBVCxFQUFtQjNGLFVBQVUsSUFBN0IsRUFBbUNELGNBQWMsSUFBakQsRUFBZixFQUFsRCxDQUFyQixDQUFrSixJQUFJNkYsVUFBSixFQUFnQkMsZ0JBQWdCRixRQUFoQixFQUEwQkMsVUFBMUI7QUFBd0M7O0FBRWpZLG1CQUFTQyxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7QUFBRUYsOEJBQWtCL1EsT0FBT2tSLGNBQVAsSUFBeUIsU0FBU0gsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0FBQUVELGdCQUFFRyxTQUFGLEdBQWNGLENBQWQsQ0FBaUIsT0FBT0QsQ0FBUDtBQUFXLGFBQXhHLENBQTBHLE9BQU9ELGdCQUFnQkMsQ0FBaEIsRUFBbUJDLENBQW5CLENBQVA7QUFBK0I7O0FBRTFLLG1CQUFTRyxZQUFULENBQXNCQyxPQUF0QixFQUErQjtBQUFFLGdCQUFJQyw0QkFBNEJDLDJCQUFoQyxDQUE2RCxPQUFPLFNBQVNDLG9CQUFULEdBQWdDO0FBQUUsa0JBQUlDLFFBQVFDLGdCQUFnQkwsT0FBaEIsQ0FBWjtBQUFBLGtCQUFzQ00sTUFBdEMsQ0FBOEMsSUFBSUwseUJBQUosRUFBK0I7QUFBRSxvQkFBSU0sWUFBWUYsZ0JBQWdCLElBQWhCLEVBQXNCOVAsV0FBdEMsQ0FBbUQrUCxTQUFTRSxRQUFRQyxTQUFSLENBQWtCTCxLQUFsQixFQUF5Qk0sU0FBekIsRUFBb0NILFNBQXBDLENBQVQ7QUFBMEQsZUFBOUksTUFBb0o7QUFBRUQseUJBQVNGLE1BQU1PLEtBQU4sQ0FBWSxJQUFaLEVBQWtCRCxTQUFsQixDQUFUO0FBQXdDLGVBQUMsT0FBT0UsMkJBQTJCLElBQTNCLEVBQWlDTixNQUFqQyxDQUFQO0FBQWtELGFBQXhVO0FBQTJVOztBQUV6YSxtQkFBU00sMEJBQVQsQ0FBb0NuUSxJQUFwQyxFQUEwQ2lILElBQTFDLEVBQWdEO0FBQUUsZ0JBQUlBLFNBQVMyRyxRQUFRM0csSUFBUixNQUFrQixRQUFsQixJQUE4QixPQUFPQSxJQUFQLEtBQWdCLFVBQXZELENBQUosRUFBd0U7QUFBRSxxQkFBT0EsSUFBUDtBQUFjLGFBQUMsT0FBT21KLHVCQUF1QnBRLElBQXZCLENBQVA7QUFBc0M7O0FBRWpMLG1CQUFTb1Esc0JBQVQsQ0FBZ0NwUSxJQUFoQyxFQUFzQztBQUFFLGdCQUFJQSxTQUFTLEtBQUssQ0FBbEIsRUFBcUI7QUFBRSxvQkFBTSxJQUFJcVEsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUF3RixhQUFDLE9BQU9yUSxJQUFQO0FBQWM7O0FBRXRLLG1CQUFTeVAseUJBQVQsR0FBcUM7QUFBRSxnQkFBSSxPQUFPTSxPQUFQLEtBQW1CLFdBQW5CLElBQWtDLENBQUNBLFFBQVFDLFNBQS9DLEVBQTBELE9BQU8sS0FBUCxDQUFjLElBQUlELFFBQVFDLFNBQVIsQ0FBa0JNLElBQXRCLEVBQTRCLE9BQU8sS0FBUCxDQUFjLElBQUksT0FBT0MsS0FBUCxLQUFpQixVQUFyQixFQUFpQyxPQUFPLElBQVAsQ0FBYSxJQUFJO0FBQUVDLHNCQUFRN1EsU0FBUixDQUFrQjhRLE9BQWxCLENBQTBCeEosSUFBMUIsQ0FBK0I4SSxRQUFRQyxTQUFSLENBQWtCUSxPQUFsQixFQUEyQixFQUEzQixFQUErQixZQUFZLENBQUUsQ0FBN0MsQ0FBL0IsRUFBZ0YsT0FBTyxJQUFQO0FBQWMsYUFBcEcsQ0FBcUcsT0FBT3BOLENBQVAsRUFBVTtBQUFFLHFCQUFPLEtBQVA7QUFBZTtBQUFFOztBQUV6VSxtQkFBU3dNLGVBQVQsQ0FBeUJWLENBQXpCLEVBQTRCO0FBQUVVLDhCQUFrQjFSLE9BQU9rUixjQUFQLEdBQXdCbFIsT0FBT3dTLGNBQS9CLEdBQWdELFNBQVNkLGVBQVQsQ0FBeUJWLENBQXpCLEVBQTRCO0FBQUUscUJBQU9BLEVBQUVHLFNBQUYsSUFBZW5SLE9BQU93UyxjQUFQLENBQXNCeEIsQ0FBdEIsQ0FBdEI7QUFBaUQsYUFBakosQ0FBbUosT0FBT1UsZ0JBQWdCVixDQUFoQixDQUFQO0FBQTRCOztBQUU3TTs7O0FBR0EsY0FBSWtPLGVBQWUsYUFBYSxVQUFVQyxTQUFWLEVBQXFCO0FBQ25Edk8sc0JBQVVzTyxZQUFWLEVBQXdCQyxTQUF4Qjs7QUFFQSxnQkFBSXhNLFNBQVN2QixhQUFhOE4sWUFBYixDQUFiOztBQUVBOzs7OztBQUtBLHFCQUFTQSxZQUFULENBQXNCcmUsTUFBdEIsRUFBOEI7QUFDNUIsa0JBQUl3TyxLQUFKOztBQUVBMUUsOEJBQWdCLElBQWhCLEVBQXNCdVUsWUFBdEI7O0FBRUE3UCxzQkFBUXNELE9BQU81SixJQUFQLENBQVksSUFBWixFQUFrQmxJLE1BQWxCLENBQVI7QUFDQTs7QUFFQXdPLG9CQUFNeE8sTUFBTixHQUFlQSxNQUFmO0FBQ0E7Ozs7OztBQU1Bd08sb0JBQU1tUCxLQUFOLEdBQWM7QUFDWlksNkJBQWEsQ0FERDtBQUVaQywwQkFBVSxDQUZFO0FBR1pDLHdCQUFRLElBSEk7QUFJWkMsOEJBQWMsQ0FKRjtBQUtaalosc0JBQU0sU0FBU0EsSUFBVCxHQUFnQixDQUFFLENBTFo7QUFNWmtaLHVCQUFPLFNBQVNBLEtBQVQsR0FBaUIsQ0FBRSxDQU5kO0FBT1pDLHdCQUFRO0FBUEksZUFBZDtBQVNBOztBQUVBcFEsb0JBQU1xUSxTQUFOLEdBQWtCN2UsT0FBTzZlLFNBQVAsQ0FBaUI5VCxXQUFqQixFQUFsQjtBQUNBOztBQUVBeUQsb0JBQU1zUSxlQUFOLEdBQXdCOWUsT0FBTzhlLGVBQS9CO0FBQ0E7O0FBRUF0USxvQkFBTXJCLEtBQU4sR0FBYyxJQUFkO0FBQ0E7O0FBRUFxQixvQkFBTWtRLFlBQU4sR0FBcUIsQ0FBckI7QUFDQTs7QUFFQWxRLG9CQUFNb1EsTUFBTixHQUFlLENBQWY7QUFDQTs7QUFFQXBRLG9CQUFNdVEsT0FBTixHQUFnQixLQUFoQjtBQUNBOztBQUVBdlEsb0JBQU13USxNQUFOLEdBQWUsSUFBZjtBQUNBOztBQUVBeFEsb0JBQU15USxTQUFOLEdBQWtCLElBQWxCO0FBQ0E7O0FBRUF6USxvQkFBTTBRLGNBQU4sR0FBdUIsRUFBdkI7QUFDQSxxQkFBTzFRLEtBQVA7QUFDRDtBQUNEOzs7O0FBS0FqRSx5QkFBYThULFlBQWIsRUFBMkIsQ0FBQztBQUMxQi9ULG1CQUFLLE1BRHFCO0FBRTFCaEcscUJBQU8sU0FBU3RELElBQVQsR0FBZ0I7QUFDckIscUJBQUtvYyxlQUFMLENBQXFCLEtBQUtwZCxNQUFMLENBQVlxZCxTQUFqQztBQUNBLHFCQUFLQyxXQUFMO0FBQ0Q7QUFDRDs7OztBQU4wQixhQUFELEVBVXhCO0FBQ0RoVCxtQkFBSyxzQkFESjtBQUVEaEcscUJBQU8sU0FBUzZhLG9CQUFULEdBQWdDO0FBQ3JDLG9CQUFJN0ssU0FBUyxJQUFiOztBQUVBLHFCQUFLNEssY0FBTCxDQUFvQkUsS0FBcEIsR0FBNEIsWUFBWTtBQUN0QzlLLHlCQUFPUSxTQUFQLENBQWlCLE9BQWpCLEVBQTBCLDZCQUExQjtBQUNELGlCQUZEOztBQUlBLHFCQUFLb0ssY0FBTCxDQUFvQkcsT0FBcEIsR0FBOEIsWUFBWTtBQUN4Qy9LLHlCQUFPUSxTQUFQLENBQWlCLFNBQWpCO0FBQ0QsaUJBRkQ7O0FBSUEscUJBQUtvSyxjQUFMLENBQW9CSSxLQUFwQixHQUE0QixZQUFZO0FBQ3RDaEwseUJBQU9RLFNBQVAsQ0FBaUIsUUFBakI7QUFDRCxpQkFGRCxDQVhxQyxDQWFsQztBQUNIOzs7QUFHQSxxQkFBS29LLGNBQUwsQ0FBb0J6WixJQUFwQixHQUEyQixZQUFZO0FBQ3JDNk8seUJBQU9RLFNBQVAsQ0FBaUIsTUFBakI7QUFDRCxpQkFGRDs7QUFJQSxxQkFBS29LLGNBQUwsQ0FBb0JQLEtBQXBCLEdBQTRCLFlBQVk7QUFDdENySyx5QkFBT1EsU0FBUCxDQUFpQixPQUFqQjtBQUNELGlCQUZEOztBQUlBLHFCQUFLb0ssY0FBTCxDQUFvQkssTUFBcEIsR0FBNkIsVUFBVXZhLEtBQVYsRUFBaUI7QUFDNUNzUCx5QkFBT1EsU0FBUCxDQUFpQixNQUFqQjtBQUNELGlCQUZEOztBQUlBLHFCQUFLb0ssY0FBTCxDQUFvQk0sWUFBcEIsR0FBbUMsVUFBVXhhLEtBQVYsRUFBaUI7QUFDbERzUCx5QkFBT3lLLE9BQVAsR0FBaUJ6SyxPQUFPcUosS0FBUCxDQUFhOEIsS0FBOUI7O0FBRUEsc0JBQUluTCxPQUFPeUssT0FBWCxFQUFvQjtBQUNsQnpLLDJCQUFPc0ssTUFBUCxHQUFnQixDQUFoQjtBQUNELG1CQUZELE1BRU87QUFDTHRLLDJCQUFPc0ssTUFBUCxHQUFnQnRLLE9BQU9xSixLQUFQLENBQWFpQixNQUE3QjtBQUNEOztBQUVEdEsseUJBQU9RLFNBQVAsQ0FBaUIsUUFBakI7QUFDRCxpQkFWRCxDQTdCcUMsQ0F1Q2xDOzs7QUFHSDNWLHVCQUFPdWdCLElBQVAsQ0FBWSxLQUFLUixjQUFqQixFQUFpQ25HLE9BQWpDLENBQXlDLFVBQVU3WSxFQUFWLEVBQWM7QUFDckRvVSx5QkFBT3FKLEtBQVAsQ0FBYWdDLG1CQUFiLENBQWlDemYsRUFBakMsRUFBcUNvVSxPQUFPNEssY0FBUCxDQUFzQmhmLEVBQXRCLENBQXJDOztBQUVBb1UseUJBQU9xSixLQUFQLENBQWF2WixnQkFBYixDQUE4QmxFLEVBQTlCLEVBQWtDb1UsT0FBTzRLLGNBQVAsQ0FBc0JoZixFQUF0QixDQUFsQztBQUNELGlCQUpEO0FBS0Q7QUFDRDs7OztBQWxEQyxhQVZ3QixFQWdFeEI7QUFDRG9LLG1CQUFLLGFBREo7QUFFRGhHLHFCQUFPLFNBQVNnWixXQUFULEdBQXVCO0FBQzVCLG9CQUFJbEUsU0FBUyxJQUFiOztBQUVBLG9CQUFJd0csaUJBQWlCLFNBQVNBLGNBQVQsR0FBMEI7QUFDN0Msc0JBQUl4RyxPQUFPeUcsUUFBUCxFQUFKLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRUR6Ryx5QkFBT3RFLFNBQVAsQ0FBaUIsY0FBakIsRUFBaUNzRSxPQUFPMEcsY0FBUCxFQUFqQyxFQUw2QyxDQUtjOzs7QUFHM0Q5USx1QkFBS3FLLEtBQUwsQ0FBV3VHLGNBQVg7QUFDRCxpQkFURDs7QUFXQSxxQkFBS3hjLEVBQUwsQ0FBUSxNQUFSLEVBQWdCd2MsY0FBaEIsRUFkNEIsQ0FjSztBQUNqQzs7QUFFQSxxQkFBS3hjLEVBQUwsQ0FBUSxPQUFSLEVBQWlCLFlBQVk7QUFDM0JnVyx5QkFBT3RFLFNBQVAsQ0FBaUIsY0FBakIsRUFBaUNzRSxPQUFPMEcsY0FBUCxFQUFqQztBQUNELGlCQUZEO0FBR0Q7QUFDRDs7Ozs7Ozs7Ozs7O0FBdkJDLGFBaEV3QixFQW1HeEI7QUFDRHhWLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVNyQixJQUFULENBQWM4YyxHQUFkLEVBQW1CM2YsU0FBbkIsRUFBOEIrTSxLQUE5QixFQUFxQ3lRLE9BQXJDLEVBQThDO0FBQ25ELG9CQUFJRCxRQUFRbkwsU0FBU0MsYUFBVCxDQUF1QixLQUFLb00sU0FBNUIsQ0FBWjtBQUNBbEIsc0JBQU1xQyxRQUFOLEdBQWlCLEtBQUtoZ0IsTUFBTCxDQUFZaWdCLGFBQTdCO0FBQ0F0QyxzQkFBTXVDLFFBQU4sR0FBaUIsS0FBS2xnQixNQUFMLENBQVlrZ0IsUUFBWixJQUF3QixLQUF6QztBQUNBdkMsc0JBQU1DLE9BQU4sR0FBZ0JBLFdBQVcsSUFBWCxHQUFrQixNQUFsQixHQUEyQkEsT0FBM0M7QUFDQUQsc0JBQU13QyxHQUFOLEdBQVlKLEdBQVo7QUFDQXBDLHNCQUFNeEwsS0FBTixDQUFZNU8sS0FBWixHQUFvQixNQUFwQjtBQUNBLG9CQUFJNmMsWUFBWWhnQixVQUFVNEQsYUFBVixDQUF3QixLQUFLNmEsU0FBN0IsQ0FBaEI7O0FBRUEsb0JBQUl1QixTQUFKLEVBQWU7QUFDYmhnQiw0QkFBVXVJLFdBQVYsQ0FBc0J5WCxTQUF0QjtBQUNEOztBQUVEaGdCLDBCQUFVbVMsV0FBVixDQUFzQm9MLEtBQXRCOztBQUVBLHFCQUFLRCxLQUFMLENBQVdDLEtBQVgsRUFBa0J4USxLQUFsQixFQUF5QnlRLE9BQXpCO0FBQ0Q7QUFDRDs7Ozs7OztBQW5CQyxhQW5Hd0IsRUE2SHhCO0FBQ0R0VCxtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTK2IsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0JuVCxLQUF0QixFQUE2QjtBQUNsQ21ULG9CQUFJTixRQUFKLEdBQWUsS0FBS2hnQixNQUFMLENBQVlpZ0IsYUFBM0I7QUFDQUssb0JBQUlKLFFBQUosR0FBZSxLQUFLbGdCLE1BQUwsQ0FBWWtnQixRQUFaLElBQXdCLEtBQXZDOztBQUVBLHFCQUFLeEMsS0FBTCxDQUFXNEMsR0FBWCxFQUFnQm5ULEtBQWhCLEVBQXVCbVQsSUFBSTFDLE9BQTNCO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7O0FBUkMsYUE3SHdCLEVBaUp4QjtBQUNEdFQsbUJBQUssT0FESjtBQUVEaEcscUJBQU8sU0FBU29aLEtBQVQsQ0FBZUMsS0FBZixFQUFzQnhRLEtBQXRCLEVBQTZCeVEsT0FBN0IsRUFBc0M7QUFDM0M7QUFDQSxvQkFBSSxFQUFFRCxpQkFBaUI0QyxnQkFBbkIsS0FBd0MsT0FBTzVDLE1BQU12WixnQkFBYixLQUFrQyxXQUE5RSxFQUEyRjtBQUN6Rix3QkFBTSxJQUFJb2MsS0FBSixDQUFVLDhDQUFWLENBQU47QUFDRCxpQkFKMEMsQ0FJekM7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0JBQUksT0FBTzdDLE1BQU0xYSxJQUFiLElBQXFCLFVBQXJCLElBQW1DLEVBQUVrSyxTQUFTeVEsV0FBVyxNQUF0QixDQUF2QyxFQUFzRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQUQsd0JBQU0xYSxJQUFOO0FBQ0Q7O0FBRUQscUJBQUswYSxLQUFMLEdBQWFBLEtBQWI7O0FBRUEscUJBQUt3QixvQkFBTDs7QUFFQSxxQkFBS2hTLEtBQUwsR0FBYUEsS0FBYjtBQUNBLHFCQUFLOFIsU0FBTCxHQUFpQixJQUFqQjtBQUNBLHFCQUFLRCxNQUFMLEdBQWMsSUFBZDtBQUNBLHFCQUFLRCxPQUFMLEdBQWVwQixNQUFNOEIsS0FBckI7QUFDQSxxQkFBS3JDLGVBQUwsQ0FBcUIsS0FBS3NCLFlBQTFCO0FBQ0EscUJBQUsrQixTQUFMLENBQWUsS0FBSzdCLE1BQXBCO0FBQ0Q7QUFDRDs7Ozs7O0FBL0JDLGFBakp3QixFQXNMeEI7QUFDRHRVLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVN1YixRQUFULEdBQW9CO0FBQ3pCLHVCQUFPLENBQUMsS0FBS2xDLEtBQU4sSUFBZSxLQUFLQSxLQUFMLENBQVdjLE1BQWpDO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUF0THdCLEVBaU14QjtBQUNEblUsbUJBQUssYUFESjtBQUVEaEcscUJBQU8sU0FBU2IsV0FBVCxHQUF1QjtBQUM1QixvQkFBSSxLQUFLaWQsZ0JBQVQsRUFBMkI7QUFDekIseUJBQU8sS0FBS0EsZ0JBQVo7QUFDRDs7QUFFRCxvQkFBSWxDLFdBQVcsQ0FBQyxLQUFLUSxNQUFMLElBQWUsS0FBS3JCLEtBQXJCLEVBQTRCYSxRQUEzQzs7QUFFQSxvQkFBSUEsWUFBWW1DLFFBQWhCLEVBQTBCO0FBQ3hCO0FBQ0FuQyw2QkFBVyxLQUFLYixLQUFMLENBQVdpRCxRQUFYLENBQW9CNWUsR0FBcEIsQ0FBd0IsQ0FBeEIsQ0FBWDtBQUNEOztBQUVELHVCQUFPd2MsUUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFoQkMsYUFqTXdCLEVBd054QjtBQUNEbFUsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVN3YixjQUFULEdBQTBCO0FBQy9CLHVCQUFPLEtBQUtuQyxLQUFMLElBQWMsS0FBS0EsS0FBTCxDQUFXWSxXQUFoQztBQUNEO0FBQ0Q7Ozs7OztBQUxDLGFBeE53QixFQW1PeEI7QUFDRGpVLG1CQUFLLG1CQURKO0FBRURoRyxxQkFBTyxTQUFTdWMsaUJBQVQsR0FBNkI7QUFDbEMsdUJBQU8sS0FBS2YsY0FBTCxLQUF3QixLQUFLcmMsV0FBTCxFQUF4QixJQUE4QyxDQUFyRDtBQUNEO0FBQ0Q7Ozs7OztBQUxDLGFBbk93QixFQThPeEI7QUFDRDZHLG1CQUFLLGlCQURKO0FBRURoRyxxQkFBTyxTQUFTd2MsZUFBVCxHQUEyQjtBQUNoQyx1QkFBTyxLQUFLcEMsWUFBTCxJQUFxQixLQUFLZixLQUFMLENBQVdlLFlBQXZDO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUE5T3dCLEVBeVB4QjtBQUNEcFUsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVM4WSxlQUFULENBQXlCOVksS0FBekIsRUFBZ0M7QUFDckMscUJBQUtvYSxZQUFMLEdBQW9CcGEsU0FBUyxDQUE3QjtBQUNBLHFCQUFLcVosS0FBTCxDQUFXZSxZQUFYLEdBQTBCLEtBQUtBLFlBQS9CO0FBQ0Q7QUFDRDs7Ozs7O0FBTkMsYUF6UHdCLEVBcVF4QjtBQUNEcFUsbUJBQUssUUFESjtBQUVEaEcscUJBQU8sU0FBU3ljLE1BQVQsQ0FBZ0JoZixLQUFoQixFQUF1QjtBQUM1QixvQkFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLHVCQUFLNGIsS0FBTCxDQUFXWSxXQUFYLEdBQXlCeGMsS0FBekI7QUFDRDs7QUFFRCxxQkFBS2lmLFlBQUw7QUFDRDtBQUNEOzs7Ozs7Ozs7O0FBVEMsYUFyUXdCLEVBd1J4QjtBQUNEMVcsbUJBQUssTUFESjtBQUVEaEcscUJBQU8sU0FBU21CLElBQVQsQ0FBYzFELEtBQWQsRUFBcUJDLEdBQXJCLEVBQTBCO0FBQy9CLHFCQUFLK2UsTUFBTCxDQUFZaGYsS0FBWjtBQUNBLG9CQUFJa2YsVUFBVSxLQUFLdEQsS0FBTCxDQUFXbFksSUFBWCxFQUFkO0FBQ0F6RCx1QkFBTyxLQUFLa2YsVUFBTCxDQUFnQmxmLEdBQWhCLENBQVA7QUFDQSx1QkFBT2lmLE9BQVA7QUFDRDtBQUNEOzs7Ozs7O0FBUkMsYUF4UndCLEVBdVN4QjtBQUNEM1csbUJBQUssT0FESjtBQUVEaEcscUJBQU8sU0FBU3FhLEtBQVQsR0FBaUI7QUFDdEIsb0JBQUlzQyxPQUFKOztBQUVBLG9CQUFJLEtBQUt0RCxLQUFULEVBQWdCO0FBQ2RzRCw0QkFBVSxLQUFLdEQsS0FBTCxDQUFXZ0IsS0FBWCxFQUFWO0FBQ0Q7O0FBRUQscUJBQUtxQyxZQUFMO0FBQ0EsdUJBQU9DLE9BQVA7QUFDRDtBQUNEOzs7Ozs7QUFaQyxhQXZTd0IsRUF5VHhCO0FBQ0QzVyxtQkFBSyxZQURKO0FBRURoRyxxQkFBTyxTQUFTNGMsVUFBVCxDQUFvQmxmLEdBQXBCLEVBQXlCO0FBQzlCLG9CQUFJc1gsU0FBUyxJQUFiOztBQUVBLHFCQUFLMEgsWUFBTDs7QUFFQSxxQkFBS0csVUFBTCxHQUFrQixVQUFVQyxJQUFWLEVBQWdCO0FBQ2hDLHNCQUFJQSxRQUFRcGYsR0FBWixFQUFpQjtBQUNmc1gsMkJBQU9xRixLQUFQOztBQUVBckYsMkJBQU95SCxNQUFQLENBQWMvZSxHQUFkO0FBQ0Q7QUFDRixpQkFORDs7QUFRQSxxQkFBS29CLEVBQUwsQ0FBUSxjQUFSLEVBQXdCLEtBQUsrZCxVQUE3QjtBQUNEO0FBQ0Q7O0FBakJDLGFBelR3QixFQTRVeEI7QUFDRDdXLG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVMwYyxZQUFULEdBQXdCO0FBQzdCLG9CQUFJLEtBQUtHLFVBQVQsRUFBcUI7QUFDbkIsdUJBQUtFLEVBQUwsQ0FBUSxjQUFSLEVBQXdCLEtBQUtGLFVBQTdCO0FBQ0EsdUJBQUtBLFVBQUwsR0FBa0IsSUFBbEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7Ozs7Ozs7O0FBUkMsYUE1VXdCLEVBK1Z4QjtBQUNEN1csbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBU2dkLFFBQVQsQ0FBa0JwZ0IsTUFBbEIsRUFBMEJvRSxLQUExQixFQUFpQ29JLElBQWpDLEVBQXVDO0FBQzVDLG9CQUFJLEtBQUtzUixNQUFULEVBQWlCO0FBQ2YseUJBQU9yQyxLQUFLOUwsZ0JBQWdCd04sYUFBYXpkLFNBQTdCLENBQUwsRUFBOEMsVUFBOUMsRUFBMEQsSUFBMUQsRUFBZ0VzSCxJQUFoRSxDQUFxRSxJQUFyRSxFQUEyRWhILE1BQTNFLEVBQW1Gb0UsS0FBbkYsRUFBMEZvSSxJQUExRixDQUFQO0FBQ0Q7O0FBRUQsdUJBQU8sS0FBS1AsS0FBTCxJQUFjLEVBQXJCO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFUQyxhQS9Wd0IsRUFnWHhCO0FBQ0Q3QyxtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTaWQsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkI7QUFDbEMsb0JBQUlBLFFBQUosRUFBYztBQUNaLHNCQUFJLENBQUMsS0FBSzdELEtBQUwsQ0FBVzRELFNBQWhCLEVBQTJCO0FBQ3pCLDJCQUFPOVMsUUFBUWdULE1BQVIsQ0FBZSxJQUFJakIsS0FBSixDQUFVLDRDQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELHlCQUFPLEtBQUs3QyxLQUFMLENBQVc0RCxTQUFYLENBQXFCQyxRQUFyQixDQUFQO0FBQ0Q7O0FBRUQsdUJBQU8vUyxRQUFRZ1QsTUFBUixDQUFlLElBQUlqQixLQUFKLENBQVUsdUJBQXVCZ0IsUUFBakMsQ0FBZixDQUFQO0FBQ0Q7QUFDRDs7Ozs7O0FBYkMsYUFoWHdCLEVBbVl4QjtBQUNEbFgsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU29kLFNBQVQsR0FBcUI7QUFDMUIsdUJBQU8sS0FBSzlDLE1BQVo7QUFDRDtBQUNEOzs7Ozs7QUFMQyxhQW5Zd0IsRUE4WXhCO0FBQ0R0VSxtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTbWMsU0FBVCxDQUFtQm5jLEtBQW5CLEVBQTBCO0FBQy9CLHFCQUFLc2EsTUFBTCxHQUFjdGEsS0FBZCxDQUQrQixDQUNWOztBQUVyQixvQkFBSSxLQUFLcVosS0FBTCxDQUFXaUIsTUFBWCxLQUFzQixLQUFLQSxNQUEvQixFQUF1QztBQUNyQyx1QkFBS2pCLEtBQUwsQ0FBV2lCLE1BQVgsR0FBb0IsS0FBS0EsTUFBekI7QUFDRDtBQUNGO0FBQ0Q7Ozs7Ozs7QUFUQyxhQTlZd0IsRUE4WnhCO0FBQ0R0VSxtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTcWQsT0FBVCxDQUFpQmxDLEtBQWpCLEVBQXdCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBS1YsT0FBTCxHQUFlLEtBQUtwQixLQUFMLENBQVc4QixLQUFYLEdBQW1CQSxLQUFsQztBQUNEO0FBQ0Q7Ozs7O0FBUEMsYUE5WndCLEVBMGF4QjtBQUNEblYsbUJBQUssU0FESjtBQUVEaEcscUJBQU8sU0FBUzZKLE9BQVQsR0FBbUI7QUFDeEIsb0JBQUkrTCxTQUFTLElBQWI7O0FBRUEscUJBQUt5RSxLQUFMO0FBQ0EscUJBQUsvSCxLQUFMO0FBQ0EscUJBQUtnTCxTQUFMLEdBQWlCLElBQWpCLENBTHdCLENBS0Q7O0FBRXZCemlCLHVCQUFPdWdCLElBQVAsQ0FBWSxLQUFLUixjQUFqQixFQUFpQ25HLE9BQWpDLENBQXlDLFVBQVU3WSxFQUFWLEVBQWM7QUFDckQsc0JBQUlnYSxPQUFPeUQsS0FBWCxFQUFrQjtBQUNoQnpELDJCQUFPeUQsS0FBUCxDQUFhZ0MsbUJBQWIsQ0FBaUN6ZixFQUFqQyxFQUFxQ2dhLE9BQU9nRixjQUFQLENBQXNCaGYsRUFBdEIsQ0FBckM7QUFDRDtBQUNGLGlCQUpEOztBQU1BLG9CQUFJLEtBQUtGLE1BQUwsQ0FBWTZoQiwyQkFBWixJQUEyQyxLQUFLbEUsS0FBaEQsSUFBeUQsS0FBS0EsS0FBTCxDQUFXOUcsVUFBeEUsRUFBb0Y7QUFDbEYsdUJBQUs4RyxLQUFMLENBQVc5RyxVQUFYLENBQXNCbE8sV0FBdEIsQ0FBa0MsS0FBS2dWLEtBQXZDO0FBQ0Q7O0FBRUQscUJBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7QUFwQkEsYUExYXdCLENBQTNCOztBQWljQSxtQkFBT1UsWUFBUDtBQUNELFdBdGdCK0IsQ0FzZ0I5QkQsVUFBVTVVLE9BdGdCb0IsQ0FBaEM7O0FBd2dCQTFLLGtCQUFRMEssT0FBUixHQUFrQjZVLFlBQWxCO0FBQ0F4ZixpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0E5d0U4Qjs7QUFneEVyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sd0JBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBcUI7O0FBRTVCOztBQUdBSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsbUJBQVNNLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOOzs7OztBQUtBLGNBQUkrWCxZQUFZLGFBQWEsWUFBWTtBQUN2Qzs7O0FBR0EscUJBQVNBLFNBQVQsR0FBcUI7QUFDbkJoWSw4QkFBZ0IsSUFBaEIsRUFBc0JnWSxTQUF0Qjs7QUFFQSxtQkFBS0MsY0FBTDtBQUNEO0FBQ0Q7Ozs7QUFLQXhYLHlCQUFhdVgsU0FBYixFQUF3QixDQUFDO0FBQ3ZCeFgsbUJBQUssZ0JBRGtCO0FBRXZCaEcscUJBQU8sU0FBU3lkLGNBQVQsR0FBMEI7QUFDL0I7Ozs7OztBQU1BLHFCQUFLQyxlQUFMLEdBQXVCLEVBQXZCO0FBQ0E7Ozs7OztBQU1BLHFCQUFLQyxlQUFMLEdBQXVCLENBQUMsQ0FBeEI7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFsQnVCLGFBQUQsRUEyQnJCO0FBQ0QzWCxtQkFBSyxxQkFESjtBQUVEaEcscUJBQU8sU0FBUzRkLG1CQUFULENBQTZCaGhCLE1BQTdCLEVBQXFDYSxLQUFyQyxFQUE0Q0MsR0FBNUMsRUFBaUQ7QUFDdEQsb0JBQUlkLFVBQVUsS0FBSytnQixlQUFuQixFQUFvQztBQUNsQyx1QkFBS0YsY0FBTDtBQUNBLHVCQUFLRSxlQUFMLEdBQXVCL2dCLE1BQXZCO0FBQ0QsaUJBSnFELENBSXBEOzs7QUFHRixvQkFBSWloQixpQkFBaUIsRUFBckI7QUFDQSxvQkFBSTNpQixJQUFJLENBQVIsQ0FSc0QsQ0FRM0M7O0FBRVgsdUJBQU9BLElBQUksS0FBS3dpQixlQUFMLENBQXFCOWdCLE1BQXpCLElBQW1DLEtBQUs4Z0IsZUFBTCxDQUFxQnhpQixDQUFyQixJQUEwQnVDLEtBQXBFLEVBQTJFO0FBQ3pFdkM7QUFDRCxpQkFacUQsQ0FZcEQ7QUFDRjtBQUNBO0FBQ0E7OztBQUdBLG9CQUFJQSxJQUFJLENBQUosSUFBUyxDQUFiLEVBQWdCO0FBQ2QyaUIsaUNBQWUxWixJQUFmLENBQW9CMUcsS0FBcEI7QUFDRDs7QUFFRCx1QkFBT3ZDLElBQUksS0FBS3dpQixlQUFMLENBQXFCOWdCLE1BQXpCLElBQW1DLEtBQUs4Z0IsZUFBTCxDQUFxQnhpQixDQUFyQixLQUEyQndDLEdBQXJFLEVBQTBFO0FBQ3hFbWdCLGlDQUFlMVosSUFBZixDQUFvQixLQUFLdVosZUFBTCxDQUFxQnhpQixDQUFyQixDQUFwQjtBQUNBQTtBQUNELGlCQXpCcUQsQ0F5QnBEOzs7QUFHRixvQkFBSUEsSUFBSSxDQUFKLElBQVMsQ0FBYixFQUFnQjtBQUNkMmlCLGlDQUFlMVosSUFBZixDQUFvQnpHLEdBQXBCO0FBQ0QsaUJBOUJxRCxDQThCcEQ7OztBQUdGbWdCLGlDQUFpQkEsZUFBZXJHLE1BQWYsQ0FBc0IsVUFBVXNHLElBQVYsRUFBZ0I3TCxHQUFoQixFQUFxQjhMLEdBQXJCLEVBQTBCO0FBQy9ELHNCQUFJOUwsT0FBTyxDQUFYLEVBQWM7QUFDWiwyQkFBTzZMLFFBQVFDLElBQUk5TCxNQUFNLENBQVYsQ0FBZjtBQUNELG1CQUZELE1BRU8sSUFBSUEsT0FBTzhMLElBQUluaEIsTUFBSixHQUFhLENBQXhCLEVBQTJCO0FBQ2hDLDJCQUFPa2hCLFFBQVFDLElBQUk5TCxNQUFNLENBQVYsQ0FBZjtBQUNEOztBQUVELHlCQUFPNkwsUUFBUUMsSUFBSTlMLE1BQU0sQ0FBVixDQUFSLElBQXdCNkwsUUFBUUMsSUFBSTlMLE1BQU0sQ0FBVixDQUF2QztBQUNELGlCQVJnQixDQUFqQixDQWpDc0QsQ0F5Q2xEO0FBQ0o7QUFDQTs7QUFFQSxxQkFBS3lMLGVBQUwsR0FBdUIsS0FBS0EsZUFBTCxDQUFxQk0sTUFBckIsQ0FBNEJILGNBQTVCLENBQXZCO0FBQ0EscUJBQUtILGVBQUwsR0FBdUIsS0FBS0EsZUFBTCxDQUFxQk8sSUFBckIsQ0FBMEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQy9ELHlCQUFPRCxJQUFJQyxDQUFYO0FBQ0QsaUJBRnNCLEVBRXBCM0csTUFGb0IsQ0FFYixVQUFVc0csSUFBVixFQUFnQjdMLEdBQWhCLEVBQXFCOEwsR0FBckIsRUFBMEI7QUFDbEMsc0JBQUk5TCxPQUFPLENBQVgsRUFBYztBQUNaLDJCQUFPNkwsUUFBUUMsSUFBSTlMLE1BQU0sQ0FBVixDQUFmO0FBQ0QsbUJBRkQsTUFFTyxJQUFJQSxPQUFPOEwsSUFBSW5oQixNQUFKLEdBQWEsQ0FBeEIsRUFBMkI7QUFDaEMsMkJBQU9raEIsUUFBUUMsSUFBSTlMLE1BQU0sQ0FBVixDQUFmO0FBQ0Q7O0FBRUQseUJBQU82TCxRQUFRQyxJQUFJOUwsTUFBTSxDQUFWLENBQVIsSUFBd0I2TCxRQUFRQyxJQUFJOUwsTUFBTSxDQUFWLENBQXZDO0FBQ0QsaUJBVnNCLENBQXZCLENBOUNzRCxDQXdEbEQ7QUFDSjs7QUFFQSxvQkFBSW1NLHFCQUFxQixFQUF6Qjs7QUFFQSxxQkFBS2xqQixJQUFJLENBQVQsRUFBWUEsSUFBSTJpQixlQUFlamhCLE1BQS9CLEVBQXVDMUIsS0FBSyxDQUE1QyxFQUErQztBQUM3Q2tqQixxQ0FBbUJqYSxJQUFuQixDQUF3QixDQUFDMFosZUFBZTNpQixDQUFmLENBQUQsRUFBb0IyaUIsZUFBZTNpQixJQUFJLENBQW5CLENBQXBCLENBQXhCO0FBQ0Q7O0FBRUQsdUJBQU9rakIsa0JBQVA7QUFDRDtBQUNEOzs7Ozs7QUFyRUMsYUEzQnFCLEVBc0dyQjtBQUNEcFksbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVNxZSxjQUFULEdBQTBCO0FBQy9CLG9CQUFJQyxzQkFBc0IsRUFBMUI7QUFDQSxvQkFBSXBqQixDQUFKOztBQUVBLHFCQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSSxLQUFLd2lCLGVBQUwsQ0FBcUI5Z0IsTUFBckMsRUFBNkMxQixLQUFLLENBQWxELEVBQXFEO0FBQ25Eb2pCLHNDQUFvQm5hLElBQXBCLENBQXlCLENBQUMsS0FBS3VaLGVBQUwsQ0FBcUJ4aUIsQ0FBckIsQ0FBRCxFQUEwQixLQUFLd2lCLGVBQUwsQ0FBcUJ4aUIsSUFBSSxDQUF6QixDQUExQixDQUF6QjtBQUNEOztBQUVELHVCQUFPb2pCLG1CQUFQO0FBQ0Q7QUFYQSxhQXRHcUIsQ0FBeEI7O0FBb0hBLG1CQUFPZCxTQUFQO0FBQ0QsV0FuSTRCLEVBQTdCOztBQXFJQWhqQixrQkFBUTBLLE9BQVIsR0FBa0JzWSxTQUFsQjtBQUNBampCLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQWo3RThCOztBQW03RXJDLGFBQU07QUFDTjs7O0FBR0EsYUFBTyx5QkFBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFrQnlLLG1CQUFsQixFQUEwQzs7QUFFakQ7O0FBR0FwSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCNlMsTUFBbEI7O0FBRUEsY0FBSXdHLE9BQU9uWix1QkFBdUJILHFCQUFvQixZQUFhLG1CQUFqQyxDQUF2QixDQUFYOztBQUVBLGNBQUl1WixPQUFPcFosdUJBQXVCSCxxQkFBb0IsWUFBYSxtQkFBakMsQ0FBdkIsQ0FBWDs7QUFFQSxtQkFBU0csc0JBQVQsQ0FBZ0NFLEdBQWhDLEVBQXFDO0FBQUUsbUJBQU9BLE9BQU9BLElBQUlDLFVBQVgsR0FBd0JELEdBQXhCLEdBQThCLEVBQUVKLFNBQVNJLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GOzs7Ozs7OztBQVFBLG1CQUFTeVMsTUFBVCxDQUFnQmhaLE1BQWhCLEVBQXdCO0FBQ3RCLGdCQUFJMFMsTUFBTSxDQUFDLEdBQUc4TSxLQUFLclosT0FBVCxFQUFrQm5HLE1BQWxCLENBQVY7QUFDQSxnQkFBSTJTLE1BQU0sQ0FBQyxHQUFHOE0sS0FBS3RaLE9BQVQsRUFBa0JuRyxNQUFsQixDQUFWO0FBQ0EsbUJBQU8sQ0FBQzJTLEdBQUQsR0FBT0QsR0FBUCxHQUFhLENBQUNDLEdBQWQsR0FBb0JELEdBQTNCO0FBQ0Q7O0FBRURsWCxpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0F2OUU4Qjs7QUF5OUVyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sd0JBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBcUI7O0FBRTVCOztBQUdBSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCeUssS0FBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsbUJBQVNBLEtBQVQsQ0FBZTlPLEdBQWYsRUFBb0I2USxHQUFwQixFQUF5QkQsR0FBekIsRUFBOEI7QUFDNUIsbUJBQU92SSxLQUFLd0ksR0FBTCxDQUFTeEksS0FBS3VJLEdBQUwsQ0FBU0MsR0FBVCxFQUFjN1EsR0FBZCxDQUFULEVBQTZCNFEsR0FBN0IsQ0FBUDtBQUNEOztBQUVEbFgsaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBci9FOEI7O0FBdS9FckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLHdCQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQWtCeUssbUJBQWxCLEVBQTBDOztBQUVqRDs7QUFHQXBLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0J1WixTQUFsQjs7QUFFQSxjQUFJQyxZQUFZdFosdUJBQXVCSCxxQkFBb0IsaUJBQWtCLHdCQUF0QyxDQUF2QixDQUFoQjs7QUFFQSxtQkFBU0csc0JBQVQsQ0FBZ0NFLEdBQWhDLEVBQXFDO0FBQUUsbUJBQU9BLE9BQU9BLElBQUlDLFVBQVgsR0FBd0JELEdBQXhCLEdBQThCLEVBQUVKLFNBQVNJLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLG1CQUFTRSxlQUFULENBQXlCdEIsUUFBekIsRUFBbUN1QixXQUFuQyxFQUFnRDtBQUFFLGdCQUFJLEVBQUV2QixvQkFBb0J1QixXQUF0QixDQUFKLEVBQXdDO0FBQUUsb0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosbUJBQVNDLGlCQUFULENBQTJCMUYsTUFBM0IsRUFBbUMyRixLQUFuQyxFQUEwQztBQUFFLGlCQUFLLElBQUkxSyxJQUFJLENBQWIsRUFBZ0JBLElBQUkwSyxNQUFNaEosTUFBMUIsRUFBa0MxQixHQUFsQyxFQUF1QztBQUFFLGtCQUFJMkssYUFBYUQsTUFBTTFLLENBQU4sQ0FBakIsQ0FBMkIySyxXQUFXOUssVUFBWCxHQUF3QjhLLFdBQVc5SyxVQUFYLElBQXlCLEtBQWpELENBQXdEOEssV0FBV0MsWUFBWCxHQUEwQixJQUExQixDQUFnQyxJQUFJLFdBQVdELFVBQWYsRUFBMkJBLFdBQVdFLFFBQVgsR0FBc0IsSUFBdEIsQ0FBNEJsTCxPQUFPQyxjQUFQLENBQXNCbUYsTUFBdEIsRUFBOEI0RixXQUFXRyxHQUF6QyxFQUE4Q0gsVUFBOUM7QUFBNEQ7QUFBRTs7QUFFN1QsbUJBQVNJLFlBQVQsQ0FBc0JSLFdBQXRCLEVBQW1DUyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxnQkFBSUQsVUFBSixFQUFnQlAsa0JBQWtCRixZQUFZbkosU0FBOUIsRUFBeUM0SixVQUF6QyxFQUFzRCxJQUFJQyxXQUFKLEVBQWlCUixrQkFBa0JGLFdBQWxCLEVBQStCVSxXQUEvQixFQUE2QyxPQUFPVixXQUFQO0FBQXFCOztBQUV2TixjQUFJa1osa0JBQWtCLGFBQWEsWUFBWTtBQUM3Qzs7Ozs7OztBQU9BLHFCQUFTQSxlQUFULENBQXlCemEsUUFBekIsRUFBbUMwYSxhQUFuQyxFQUFrREMsUUFBbEQsRUFBNEQ7QUFDMURyWiw4QkFBZ0IsSUFBaEIsRUFBc0JtWixlQUF0Qjs7QUFFQSxtQkFBS3phLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsbUJBQUtBLFFBQUwsQ0FBYzRhLE9BQWQsR0FBd0JELFNBQVNFLElBQVQsQ0FBY0MsU0FBZCxFQUF4QjtBQUNBLG1CQUFLQyxLQUFMLEdBQWFDLFNBQVNOLGFBQVQsRUFBd0IsRUFBeEIsQ0FBYjtBQUNBLG1CQUFLTyxNQUFMLEdBQWMsQ0FBZDtBQUNEO0FBQ0Q7Ozs7Ozs7O0FBU0FsWix5QkFBYTBZLGVBQWIsRUFBOEIsQ0FBQztBQUM3QjNZLG1CQUFLLE9BRHdCO0FBRTdCaEcscUJBQU8sU0FBU3ZDLEtBQVQsQ0FBZTJoQixVQUFmLEVBQTJCO0FBQ2hDLG9CQUFJbFYsUUFBUSxJQUFaOztBQUVBLG9CQUFJbVYsT0FBTyxTQUFTQSxJQUFULEdBQWdCO0FBQ3pCO0FBQ0E7QUFDQW5WLHdCQUFNaEcsUUFBTixDQUFlNGEsT0FBZixDQUF1Qk8sSUFBdkIsR0FBOEJDLElBQTlCLENBQW1DLFVBQVVwSyxJQUFWLEVBQWdCO0FBQ2pELHdCQUFJelcsT0FBT3lXLEtBQUt6VyxJQUFoQjtBQUFBLHdCQUNJdUIsUUFBUWtWLEtBQUtsVixLQURqQjs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx3QkFBSXZCLElBQUosRUFBVTtBQUNSO0FBQ0EsMEJBQUl5TCxNQUFNK1UsS0FBTixLQUFnQixDQUFwQixFQUF1QjtBQUNyQi9VLDhCQUFNaEcsUUFBTixDQUFlcWIsVUFBZixDQUEwQjNiLElBQTFCLENBQStCc0csTUFBTWhHLFFBQXJDLEVBQStDO0FBQzdDaWIsa0NBQVFqVixNQUFNaVYsTUFEK0I7QUFFN0NGLGlDQUFPL1UsTUFBTStVLEtBRmdDO0FBRzdDTyw0Q0FBa0I7QUFIMkIseUJBQS9DO0FBS0QsdUJBUk8sQ0FRTjs7O0FBR0ZKLGlDQUFXSyxLQUFYO0FBQ0E7QUFDRDs7QUFFRHZWLDBCQUFNaVYsTUFBTixJQUFnQm5mLE1BQU0wZixVQUF0Qjs7QUFFQXhWLDBCQUFNaEcsUUFBTixDQUFlcWIsVUFBZixDQUEwQjNiLElBQTFCLENBQStCc0csTUFBTWhHLFFBQXJDLEVBQStDO0FBQzdDaWIsOEJBQVFqVixNQUFNaVYsTUFEK0I7QUFFN0NGLDZCQUFPL1UsTUFBTStVLEtBRmdDO0FBRzdDTyx3Q0FBa0IsRUFBRXRWLE1BQU0rVSxLQUFOLEtBQWdCLENBQWxCO0FBSDJCLHFCQUEvQyxFQXhCaUQsQ0E0QjdDOzs7QUFHSkcsK0JBQVdPLE9BQVgsQ0FBbUIzZixLQUFuQjtBQUNBcWY7QUFDRCxtQkFqQ0QsRUFpQ0dPLEtBakNILENBaUNTLFVBQVU5RSxLQUFWLEVBQWlCO0FBQ3hCc0UsK0JBQVd0RSxLQUFYLENBQWlCQSxLQUFqQjtBQUNELG1CQW5DRDtBQW9DRCxpQkF2Q0Q7O0FBeUNBdUU7QUFDRDtBQS9DNEIsYUFBRCxDQUE5Qjs7QUFrREEsbUJBQU9WLGVBQVA7QUFDRCxXQTVFa0MsRUFBbkM7QUE2RUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxtQkFBU0YsU0FBVCxDQUFtQm9CLE9BQW5CLEVBQTRCO0FBQzFCLGdCQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaLG9CQUFNLElBQUkzRCxLQUFKLENBQVUsdUJBQVYsQ0FBTjtBQUNELGFBRkQsTUFFTyxJQUFJLENBQUMyRCxRQUFRcEUsR0FBYixFQUFrQjtBQUN2QixvQkFBTSxJQUFJUyxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUNEOztBQUVELGdCQUFJaFksV0FBVyxJQUFJd2EsVUFBVXhaLE9BQWQsRUFBZjtBQUNBLGdCQUFJNGEsZUFBZSxJQUFJQyxPQUFKLEVBQW5CO0FBQ0EsZ0JBQUlDLGVBQWUsSUFBSUMsT0FBSixDQUFZSixRQUFRcEUsR0FBcEIsQ0FBbkIsQ0FUMEIsQ0FTbUI7O0FBRTdDdlgscUJBQVNrYixVQUFULEdBQXNCLElBQUljLGVBQUosRUFBdEIsQ0FYMEIsQ0FXbUI7O0FBRTdDLGdCQUFJTCxXQUFXQSxRQUFRTSxjQUF2QixFQUF1QztBQUNyQztBQUNBTixzQkFBUU0sY0FBUixDQUF1QjFMLE9BQXZCLENBQStCLFVBQVUyTCxNQUFWLEVBQWtCO0FBQy9DTiw2QkFBYXJmLE1BQWIsQ0FBb0IyZixPQUFPcGEsR0FBM0IsRUFBZ0NvYSxPQUFPcGdCLEtBQXZDO0FBQ0QsZUFGRDtBQUdELGFBbEJ5QixDQWtCeEI7OztBQUdGLGdCQUFJcWdCLGVBQWVSLFFBQVFRLFlBQVIsSUFBd0IsTUFBM0M7QUFDQSxnQkFBSUMsZUFBZTtBQUNqQkMsc0JBQVFWLFFBQVFVLE1BQVIsSUFBa0IsS0FEVDtBQUVqQkMsdUJBQVNWLFlBRlE7QUFHakJXLG9CQUFNWixRQUFRWSxJQUFSLElBQWdCLE1BSEw7QUFJakJDLDJCQUFhYixRQUFRYSxXQUFSLElBQXVCLGFBSm5CO0FBS2pCelYscUJBQU80VSxRQUFRNVUsS0FBUixJQUFpQixTQUxQO0FBTWpCMFYsd0JBQVVkLFFBQVFjLFFBQVIsSUFBb0IsUUFOYjtBQU9qQkMsd0JBQVVmLFFBQVFlLFFBQVIsSUFBb0IsUUFQYjtBQVFqQkMsc0JBQVEzYyxTQUFTa2IsVUFBVCxDQUFvQnlCO0FBUlgsYUFBbkI7QUFVQUMsa0JBQU1kLFlBQU4sRUFBb0JNLFlBQXBCLEVBQWtDaEIsSUFBbEMsQ0FBdUMsVUFBVVQsUUFBVixFQUFvQjtBQUN6RDtBQUNBM2EsdUJBQVMyYSxRQUFULEdBQW9CQSxRQUFwQjtBQUNBLGtCQUFJa0Msb0JBQW9CLElBQXhCOztBQUVBLGtCQUFJLENBQUNsQyxTQUFTRSxJQUFkLEVBQW9CO0FBQ2xCO0FBQ0E7QUFDQWdDLG9DQUFvQixLQUFwQjtBQUNELGVBVHdELENBU3ZEOzs7QUFHRixrQkFBSW5DLGdCQUFnQkMsU0FBUzJCLE9BQVQsQ0FBaUJ4bEIsR0FBakIsQ0FBcUIsZ0JBQXJCLENBQXBCOztBQUVBLGtCQUFJNGpCLGtCQUFrQixJQUF0QixFQUE0QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQW1DLG9DQUFvQixLQUFwQjtBQUNEOztBQUVELGtCQUFJLENBQUNBLGlCQUFMLEVBQXdCO0FBQ3RCO0FBQ0EsdUJBQU9sQyxRQUFQO0FBQ0QsZUF4QndELENBd0J2RDs7O0FBR0YzYSx1QkFBU3FiLFVBQVQsR0FBc0IsVUFBVXhmLENBQVYsRUFBYTtBQUNqQ21FLHlCQUFTc00sU0FBVCxDQUFtQixVQUFuQixFQUErQnpRLENBQS9CO0FBQ0QsZUFGRDs7QUFJQSxxQkFBTyxJQUFJaWhCLFFBQUosQ0FBYSxJQUFJQyxjQUFKLENBQW1CLElBQUl0QyxlQUFKLENBQW9CemEsUUFBcEIsRUFBOEIwYSxhQUE5QixFQUE2Q0MsUUFBN0MsQ0FBbkIsQ0FBYixFQUF5RnlCLFlBQXpGLENBQVA7QUFDRCxhQWhDRCxFQWdDR2hCLElBaENILENBZ0NRLFVBQVVULFFBQVYsRUFBb0I7QUFDMUIsa0JBQUlxQyxNQUFKOztBQUVBLGtCQUFJckMsU0FBU3NDLEVBQWIsRUFBaUI7QUFDZix3QkFBUWQsWUFBUjtBQUNFLHVCQUFLLGFBQUw7QUFDRSwyQkFBT3hCLFNBQVN1QyxXQUFULEVBQVA7O0FBRUYsdUJBQUssTUFBTDtBQUNFLDJCQUFPdkMsU0FBU3dDLElBQVQsRUFBUDs7QUFFRix1QkFBSyxNQUFMO0FBQ0UsMkJBQU94QyxTQUFTeUMsSUFBVCxFQUFQOztBQUVGLHVCQUFLLE1BQUw7QUFDRSwyQkFBT3pDLFNBQVNoZCxJQUFULEVBQVA7O0FBRUY7QUFDRXFmLDZCQUFTLDJCQUEyQmIsWUFBcEM7QUFDQTtBQWZKO0FBaUJEOztBQUVELGtCQUFJLENBQUNhLE1BQUwsRUFBYTtBQUNYQSx5QkFBUyx3QkFBd0JyQyxTQUFTMEMsTUFBMUM7QUFDRDs7QUFFRCxvQkFBTSxJQUFJckYsS0FBSixDQUFVZ0YsTUFBVixDQUFOO0FBQ0QsYUE1REQsRUE0REc1QixJQTVESCxDQTREUSxVQUFVVCxRQUFWLEVBQW9CO0FBQzFCM2EsdUJBQVNzTSxTQUFULENBQW1CLFNBQW5CLEVBQThCcU8sUUFBOUI7QUFDRCxhQTlERCxFQThER2UsS0E5REgsQ0E4RFMsVUFBVTlFLEtBQVYsRUFBaUI7QUFDeEI1Vyx1QkFBU3NNLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEJzSyxLQUE1QjtBQUNELGFBaEVELEVBaEMwQixDQWdHdEI7O0FBRUo1VyxxQkFBUzhiLFlBQVQsR0FBd0JBLFlBQXhCO0FBQ0EsbUJBQU85YixRQUFQO0FBQ0Q7O0FBRUQzSixpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0EvdUY4Qjs7QUFpdkZyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sd0JBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBa0J5SyxtQkFBbEIsRUFBMEM7O0FBRWpEOztBQUdBcEssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQjZQLEtBQWxCOztBQUVBLGNBQUl5TSx5QkFBeUJwYyx1QkFBdUJILHFCQUFvQixnQ0FBaUMsdUNBQXJELENBQXZCLENBQTdCOztBQUVBLG1CQUFTRyxzQkFBVCxDQUFnQ0UsR0FBaEMsRUFBcUM7QUFBRSxtQkFBT0EsT0FBT0EsSUFBSUMsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEIsRUFBRUosU0FBU0ksR0FBWCxFQUFyQztBQUF3RDs7QUFFL0Y7Ozs7Ozs7O0FBUUEsbUJBQVN5UCxLQUFULENBQWUwTSxJQUFmLEVBQXFCO0FBQ25CLG1CQUFPLFlBQVk7QUFDakIsbUJBQUssSUFBSUMsT0FBTzlVLFVBQVVoUSxNQUFyQixFQUE2QitrQixPQUFPLElBQUl0SyxLQUFKLENBQVVxSyxJQUFWLENBQXBDLEVBQXFERSxPQUFPLENBQWpFLEVBQW9FQSxPQUFPRixJQUEzRSxFQUFpRkUsTUFBakYsRUFBeUY7QUFDdkZELHFCQUFLQyxJQUFMLElBQWFoVixVQUFVZ1YsSUFBVixDQUFiO0FBQ0Q7O0FBRUQscUJBQU8sQ0FBQyxHQUFHSix1QkFBdUJ0YyxPQUEzQixFQUFvQyxZQUFZO0FBQ3JELHVCQUFPdWMsS0FBSzVVLEtBQUwsQ0FBVyxLQUFLLENBQWhCLEVBQW1COFUsSUFBbkIsQ0FBUDtBQUNELGVBRk0sQ0FBUDtBQUdELGFBUkQ7QUFTRDs7QUFFRHBuQixpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0F6eEY4Qjs7QUEyeEZyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sd0JBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBcUI7O0FBRTVCOztBQUdBSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCMmMsS0FBbEI7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsbUJBQVNBLEtBQVQsQ0FBZUMsTUFBZixFQUF1QjtBQUNyQixnQkFBSUEsV0FBVzVsQixTQUFmLEVBQTBCO0FBQ3hCNGxCLHVCQUFTLGFBQVQ7QUFDRDs7QUFFRCxtQkFBT0EsU0FBUzVZLEtBQUs2WSxNQUFMLEdBQWNDLFFBQWQsQ0FBdUIsRUFBdkIsRUFBMkJDLFNBQTNCLENBQXFDLENBQXJDLENBQWhCO0FBQ0Q7O0FBRUQxbkIsaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBOXpGOEI7O0FBZzBGckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLHdCQUFDZ2QsdUJBQUQsRUFBMEIxbkIsT0FBMUIsRUFBbUN5SyxtQkFBbkMsRUFBMkQ7O0FBRWxFOztBQUdBcEssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQW5GLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixPQUEvQixFQUF5QztBQUN2Q08sd0JBQVksSUFEMkI7QUFFdkNDLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixxQkFBT3FLLE9BQU9ILE9BQWQ7QUFDRDtBQUpzQyxXQUF6QztBQU1BckssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLEtBQS9CLEVBQXVDO0FBQ3JDTyx3QkFBWSxJQUR5QjtBQUVyQ0MsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLHFCQUFPdWpCLEtBQUtyWixPQUFaO0FBQ0Q7QUFKb0MsV0FBdkM7QUFNQXJLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixLQUEvQixFQUF1QztBQUNyQ08sd0JBQVksSUFEeUI7QUFFckNDLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixxQkFBT3dqQixLQUFLdFosT0FBWjtBQUNEO0FBSm9DLFdBQXZDO0FBTUFySyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsUUFBL0IsRUFBMEM7QUFDeENPLHdCQUFZLElBRDRCO0FBRXhDQyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU9tbkIsUUFBUWpkLE9BQWY7QUFDRDtBQUp1QyxXQUExQztBQU1BckssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFVBQS9CLEVBQTRDO0FBQzFDTyx3QkFBWSxJQUQ4QjtBQUUxQ0MsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLHFCQUFPMGpCLFVBQVV4WixPQUFqQjtBQUNEO0FBSnlDLFdBQTVDO0FBTUFySyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsT0FBL0IsRUFBeUM7QUFDdkNPLHdCQUFZLElBRDJCO0FBRXZDQyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU9tSyxPQUFPRCxPQUFkO0FBQ0Q7QUFKc0MsV0FBekM7QUFNQXJLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQix1QkFBL0IsRUFBeUQ7QUFDdkRPLHdCQUFZLElBRDJDO0FBRXZEQyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU93bUIsdUJBQXVCdGMsT0FBOUI7QUFDRDtBQUpzRCxXQUF6RDtBQU1BckssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLE9BQS9CLEVBQXlDO0FBQ3ZDTyx3QkFBWSxJQUQyQjtBQUV2Q0MsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLHFCQUFPb25CLE9BQU9sZCxPQUFkO0FBQ0Q7QUFKc0MsV0FBekM7QUFNQXJLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixVQUEvQixFQUE0QztBQUMxQ08sd0JBQVksSUFEOEI7QUFFMUNDLGlCQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixxQkFBT3FuQixVQUFVbmQsT0FBakI7QUFDRDtBQUp5QyxXQUE1QztBQU1BckssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLGNBQS9CLEVBQWdEO0FBQzlDTyx3QkFBWSxJQURrQztBQUU5Q0MsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLHFCQUFPc25CLGNBQWNwZCxPQUFyQjtBQUNEO0FBSjZDLFdBQWhEO0FBTUFySyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsV0FBL0IsRUFBNkM7QUFDM0NPLHdCQUFZLElBRCtCO0FBRTNDQyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU91bkIsT0FBT3JkLE9BQWQ7QUFDRDtBQUowQyxXQUE3QztBQU1BckssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLE9BQS9CLEVBQXlDO0FBQ3ZDTyx3QkFBWSxJQUQyQjtBQUV2Q0MsaUJBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLHFCQUFPd25CLE9BQU90ZCxPQUFkO0FBQ0Q7QUFKc0MsV0FBekM7QUFNQXJLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixpQkFBL0IsRUFBbUQ7QUFDakRPLHdCQUFZLElBRHFDO0FBRWpEQyxpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU95bkIsYUFBYXZkLE9BQXBCO0FBQ0Q7QUFKZ0QsV0FBbkQ7O0FBT0EsY0FBSUcsU0FBU0QsdUJBQXVCSCxxQkFBb0IsZUFBZ0Isc0JBQXBDLENBQXZCLENBQWI7O0FBRUEsY0FBSXNaLE9BQU9uWix1QkFBdUJILHFCQUFvQixZQUFhLG1CQUFqQyxDQUF2QixDQUFYOztBQUVBLGNBQUl1WixPQUFPcFosdUJBQXVCSCxxQkFBb0IsWUFBYSxtQkFBakMsQ0FBdkIsQ0FBWDs7QUFFQSxjQUFJa2QsVUFBVS9jLHVCQUF1QkgscUJBQW9CLGVBQWdCLHNCQUFwQyxDQUF2QixDQUFkOztBQUVBLGNBQUl5WixZQUFZdFosdUJBQXVCSCxxQkFBb0IsaUJBQWtCLHdCQUF0QyxDQUF2QixDQUFoQjs7QUFFQSxjQUFJRSxTQUFTQyx1QkFBdUJILHFCQUFvQixjQUFlLHFCQUFuQyxDQUF2QixDQUFiOztBQUVBLGNBQUl1Yyx5QkFBeUJwYyx1QkFBdUJILHFCQUFvQixnQ0FBaUMsdUNBQXJELENBQXZCLENBQTdCOztBQUVBLGNBQUltZCxTQUFTaGQsdUJBQXVCSCxxQkFBb0IsY0FBZSxxQkFBbkMsQ0FBdkIsQ0FBYjs7QUFFQSxjQUFJb2QsWUFBWWpkLHVCQUF1QkgscUJBQW9CLGVBQWdCLGtDQUFwQyxDQUF2QixDQUFoQjs7QUFFQSxjQUFJcWQsZ0JBQWdCbGQsdUJBQXVCSCxxQkFBb0Isc0JBQXVCLDZCQUEzQyxDQUF2QixDQUFwQjs7QUFFQSxjQUFJc2QsU0FBU25kLHVCQUF1QkgscUJBQW9CLGNBQWUscUJBQW5DLENBQXZCLENBQWI7O0FBRUEsY0FBSXVkLFNBQVNwZCx1QkFBdUJILHFCQUFvQixjQUFlLHFCQUFuQyxDQUF2QixDQUFiOztBQUVBLGNBQUl3ZCxlQUFlcmQsdUJBQXVCSCxxQkFBb0Isb0JBQXFCLDJCQUF6QyxDQUF2QixDQUFuQjs7QUFFQSxtQkFBU0csc0JBQVQsQ0FBZ0NFLEdBQWhDLEVBQXFDO0FBQUUsbUJBQU9BLE9BQU9BLElBQUlDLFVBQVgsR0FBd0JELEdBQXhCLEdBQThCLEVBQUVKLFNBQVNJLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GO0FBQU8sU0F2N0Y4Qjs7QUF5N0ZyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sc0JBQUMvSyxNQUFELEVBQVNDLE9BQVQsRUFBcUI7O0FBRTVCOztBQUdBSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCdU0sR0FBbEI7O0FBRUE7Ozs7Ozs7QUFPQSxtQkFBU0EsR0FBVCxDQUFhMVMsTUFBYixFQUFxQjtBQUNuQixnQkFBSTJqQixVQUFVLENBQUNyRyxRQUFmO0FBQ0F4aEIsbUJBQU91Z0IsSUFBUCxDQUFZcmMsTUFBWixFQUFvQjBWLE9BQXBCLENBQTRCLFVBQVV2WixDQUFWLEVBQWE7QUFDdkMsa0JBQUk2RCxPQUFPN0QsQ0FBUCxJQUFZd25CLE9BQWhCLEVBQXlCO0FBQ3ZCQSwwQkFBVTNqQixPQUFPN0QsQ0FBUCxDQUFWO0FBQ0Q7QUFDRixhQUpEO0FBS0EsbUJBQU93bkIsT0FBUDtBQUNEOztBQUVEbm9CLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQTE5RjhCOztBQTQ5RnJDLGFBQU07QUFDTjs7O0FBR0EsYUFBTyxzQkFBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFxQjs7QUFFNUI7O0FBR0FLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0J3TSxHQUFsQjs7QUFFQTs7Ozs7OztBQU9BLG1CQUFTQSxHQUFULENBQWEzUyxNQUFiLEVBQXFCO0FBQ25CLGdCQUFJNGpCLFdBQVdDLE9BQU92RyxRQUFQLENBQWY7QUFDQXhoQixtQkFBT3VnQixJQUFQLENBQVlyYyxNQUFaLEVBQW9CMFYsT0FBcEIsQ0FBNEIsVUFBVXZaLENBQVYsRUFBYTtBQUN2QyxrQkFBSTZELE9BQU83RCxDQUFQLElBQVl5bkIsUUFBaEIsRUFBMEI7QUFDeEJBLDJCQUFXNWpCLE9BQU83RCxDQUFQLENBQVg7QUFDRDtBQUNGLGFBSkQ7QUFLQSxtQkFBT3luQixRQUFQO0FBQ0Q7O0FBRURwb0IsaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBNy9GOEI7O0FBKy9GckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLDJCQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQXFCOztBQUU1Qjs7QUFHQUssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLG1CQUFTTSxlQUFULENBQXlCdEIsUUFBekIsRUFBbUN1QixXQUFuQyxFQUFnRDtBQUFFLGdCQUFJLEVBQUV2QixvQkFBb0J1QixXQUF0QixDQUFKLEVBQXdDO0FBQUUsb0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosbUJBQVNDLGlCQUFULENBQTJCMUYsTUFBM0IsRUFBbUMyRixLQUFuQyxFQUEwQztBQUFFLGlCQUFLLElBQUkxSyxJQUFJLENBQWIsRUFBZ0JBLElBQUkwSyxNQUFNaEosTUFBMUIsRUFBa0MxQixHQUFsQyxFQUF1QztBQUFFLGtCQUFJMkssYUFBYUQsTUFBTTFLLENBQU4sQ0FBakIsQ0FBMkIySyxXQUFXOUssVUFBWCxHQUF3QjhLLFdBQVc5SyxVQUFYLElBQXlCLEtBQWpELENBQXdEOEssV0FBV0MsWUFBWCxHQUEwQixJQUExQixDQUFnQyxJQUFJLFdBQVdELFVBQWYsRUFBMkJBLFdBQVdFLFFBQVgsR0FBc0IsSUFBdEIsQ0FBNEJsTCxPQUFPQyxjQUFQLENBQXNCbUYsTUFBdEIsRUFBOEI0RixXQUFXRyxHQUF6QyxFQUE4Q0gsVUFBOUM7QUFBNEQ7QUFBRTs7QUFFN1QsbUJBQVNJLFlBQVQsQ0FBc0JSLFdBQXRCLEVBQW1DUyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxnQkFBSUQsVUFBSixFQUFnQlAsa0JBQWtCRixZQUFZbkosU0FBOUIsRUFBeUM0SixVQUF6QyxFQUFzRCxJQUFJQyxXQUFKLEVBQWlCUixrQkFBa0JGLFdBQWxCLEVBQStCVSxXQUEvQixFQUE2QyxPQUFPVixXQUFQO0FBQXFCOztBQUV2Tjs7Ozs7OztBQU9BOzs7QUFHQSxjQUFJa04sV0FBVyxhQUFhLFlBQVk7QUFDdEM7OztBQUdBLHFCQUFTQSxRQUFULEdBQW9CO0FBQ2xCbk4sOEJBQWdCLElBQWhCLEVBQXNCbU4sUUFBdEI7O0FBRUE7Ozs7O0FBS0EsbUJBQUtrUSx1QkFBTCxHQUErQixFQUEvQjtBQUNBLG1CQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFTQTdjLHlCQUFhME0sUUFBYixFQUF1QixDQUFDO0FBQ3RCM00sbUJBQUssSUFEaUI7QUFFdEJoRyxxQkFBTyxTQUFTbEIsRUFBVCxDQUFZNEIsS0FBWixFQUFtQnVXLEVBQW5CLEVBQXVCO0FBQzVCLG9CQUFJL00sUUFBUSxJQUFaOztBQUVBLG9CQUFJLENBQUMsS0FBSzRZLFFBQVYsRUFBb0I7QUFDbEIsdUJBQUtBLFFBQUwsR0FBZ0IsRUFBaEI7QUFDRDs7QUFFRCxvQkFBSUEsV0FBVyxLQUFLQSxRQUFMLENBQWNwaUIsS0FBZCxDQUFmOztBQUVBLG9CQUFJLENBQUNvaUIsUUFBTCxFQUFlO0FBQ2JBLDZCQUFXLEtBQUtBLFFBQUwsQ0FBY3BpQixLQUFkLElBQXVCLEVBQWxDO0FBQ0Q7O0FBRURvaUIseUJBQVMzZSxJQUFULENBQWM4UyxFQUFkLEVBYjRCLENBYVQ7O0FBRW5CLHVCQUFPO0FBQ0x6VSx3QkFBTTlCLEtBREQ7QUFFTHFpQiw0QkFBVTlMLEVBRkw7QUFHTDhGLHNCQUFJLFNBQVNBLEVBQVQsQ0FBWWhkLENBQVosRUFBZWtYLEVBQWYsRUFBbUI7QUFDckIsMkJBQU8vTSxNQUFNNlMsRUFBTixDQUFTaGQsQ0FBVCxFQUFZa1gsRUFBWixDQUFQO0FBQ0Q7QUFMSSxpQkFBUDtBQU9EO0FBQ0Q7Ozs7Ozs7O0FBekJzQixhQUFELEVBaUNwQjtBQUNEalIsbUJBQUssSUFESjtBQUVEaEcscUJBQU8sU0FBUytjLEVBQVQsQ0FBWXJjLEtBQVosRUFBbUJ1VyxFQUFuQixFQUF1QjtBQUM1QixvQkFBSSxDQUFDLEtBQUs2TCxRQUFWLEVBQW9CO0FBQ2xCO0FBQ0Q7O0FBRUQsb0JBQUlBLFdBQVcsS0FBS0EsUUFBTCxDQUFjcGlCLEtBQWQsQ0FBZjtBQUNBLG9CQUFJeEYsQ0FBSjs7QUFFQSxvQkFBSTRuQixRQUFKLEVBQWM7QUFDWixzQkFBSTdMLEVBQUosRUFBUTtBQUNOLHlCQUFLL2IsSUFBSTRuQixTQUFTbG1CLE1BQVQsR0FBa0IsQ0FBM0IsRUFBOEIxQixLQUFLLENBQW5DLEVBQXNDQSxHQUF0QyxFQUEyQztBQUN6QywwQkFBSTRuQixTQUFTNW5CLENBQVQsS0FBZStiLEVBQW5CLEVBQXVCO0FBQ3JCNkwsaUNBQVMxZSxNQUFULENBQWdCbEosQ0FBaEIsRUFBbUIsQ0FBbkI7QUFDRDtBQUNGO0FBQ0YsbUJBTkQsTUFNTztBQUNMNG5CLDZCQUFTbG1CLE1BQVQsR0FBa0IsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRDs7OztBQXRCQyxhQWpDb0IsRUEyRHBCO0FBQ0RvSixtQkFBSyxPQURKO0FBRURoRyxxQkFBTyxTQUFTc1MsS0FBVCxHQUFpQjtBQUN0QixxQkFBS3dRLFFBQUwsR0FBZ0IsSUFBaEI7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFMQyxhQTNEb0IsRUF5RXBCO0FBQ0Q5YyxtQkFBSyxNQURKO0FBRURoRyxxQkFBTyxTQUFTZ2pCLElBQVQsQ0FBY3RpQixLQUFkLEVBQXFCdWlCLE9BQXJCLEVBQThCO0FBQ25DLG9CQUFJalQsU0FBUyxJQUFiOztBQUVBLG9CQUFJaUgsS0FBSyxTQUFTQSxFQUFULEdBQWM7QUFDckIsdUJBQUssSUFBSXlLLE9BQU85VSxVQUFVaFEsTUFBckIsRUFBNkIra0IsT0FBTyxJQUFJdEssS0FBSixDQUFVcUssSUFBVixDQUFwQyxFQUFxREUsT0FBTyxDQUFqRSxFQUFvRUEsT0FBT0YsSUFBM0UsRUFBaUZFLE1BQWpGLEVBQXlGO0FBQ3ZGRCx5QkFBS0MsSUFBTCxJQUFhaFYsVUFBVWdWLElBQVYsQ0FBYjtBQUNEOztBQUVEO0FBQ0FxQiwwQkFBUXBXLEtBQVIsQ0FBY21ELE1BQWQsRUFBc0IyUixJQUF0QjtBQUNBOztBQUVBampCLDZCQUFXLFlBQVk7QUFDckJzUiwyQkFBTytNLEVBQVAsQ0FBVXJjLEtBQVYsRUFBaUJ1VyxFQUFqQjtBQUNELG1CQUZELEVBRUcsQ0FGSDtBQUdELGlCQVpEOztBQWNBLHVCQUFPLEtBQUtuWSxFQUFMLENBQVE0QixLQUFSLEVBQWV1VyxFQUFmLENBQVA7QUFDRDtBQUNEOzs7Ozs7Ozs7OztBQXJCQyxhQXpFb0IsRUF5R3BCO0FBQ0RqUixtQkFBSywyQkFESjtBQUVEaEcscUJBQU8sU0FBU2tqQix5QkFBVCxDQUFtQ0MsVUFBbkMsRUFBK0M7QUFDcEQscUJBQUtOLHVCQUFMLEdBQStCTSxVQUEvQjtBQUNEO0FBQ0Q7Ozs7O0FBTEMsYUF6R29CLEVBbUhwQjtBQUNEbmQsbUJBQUssMEJBREo7QUFFRGhHLHFCQUFPLFNBQVNvakIsd0JBQVQsQ0FBa0MxaUIsS0FBbEMsRUFBeUM7QUFDOUMsdUJBQU8sS0FBS21pQix1QkFBTCxJQUFnQyxLQUFLQSx1QkFBTCxDQUE2QjdMLFFBQTdCLENBQXNDdFcsS0FBdEMsQ0FBdkM7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUFuSG9CLEVBK0hwQjtBQUNEc0YsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU3dRLFNBQVQsQ0FBbUI5UCxLQUFuQixFQUEwQjtBQUMvQixxQkFBSyxJQUFJMmlCLFFBQVF6VyxVQUFVaFEsTUFBdEIsRUFBOEIra0IsT0FBTyxJQUFJdEssS0FBSixDQUFVZ00sUUFBUSxDQUFSLEdBQVlBLFFBQVEsQ0FBcEIsR0FBd0IsQ0FBbEMsQ0FBckMsRUFBMkVDLFFBQVEsQ0FBeEYsRUFBMkZBLFFBQVFELEtBQW5HLEVBQTBHQyxPQUExRyxFQUFtSDtBQUNqSDNCLHVCQUFLMkIsUUFBUSxDQUFiLElBQWtCMVcsVUFBVTBXLEtBQVYsQ0FBbEI7QUFDRDs7QUFFRCxvQkFBSSxDQUFDLEtBQUtSLFFBQU4sSUFBa0IsS0FBS00sd0JBQUwsQ0FBOEIxaUIsS0FBOUIsQ0FBdEIsRUFBNEQ7QUFDMUQ7QUFDRDs7QUFFRCxvQkFBSW9pQixXQUFXLEtBQUtBLFFBQUwsQ0FBY3BpQixLQUFkLENBQWY7QUFDQW9pQiw0QkFBWUEsU0FBU3JPLE9BQVQsQ0FBaUIsVUFBVXdDLEVBQVYsRUFBYztBQUN6Q0EscUJBQUdwSyxLQUFILENBQVMsS0FBSyxDQUFkLEVBQWlCOFUsSUFBakI7QUFDRCxpQkFGVyxDQUFaO0FBR0Q7QUFmQSxhQS9Ib0IsQ0FBdkI7O0FBaUpBLG1CQUFPaFAsUUFBUDtBQUNELFdBMUsyQixFQUE1Qjs7QUE0S0FuWSxrQkFBUTBLLE9BQVIsR0FBa0J5TixRQUFsQjtBQUNBcFksaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPLFNBNXNHOEI7O0FBOHNHckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLDhCQUFDM0ssTUFBRCxFQUFTQyxPQUFULEVBQXFCOztBQUU1Qjs7QUFHQUssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQnVJLGVBQWxCO0FBQ0EsY0FBSThWLGtCQUFrQjtBQUNwQnRrQixtQkFBTyxRQURhO0FBRXBCaUksb0JBQVEsT0FGWTtBQUdwQnVILHVCQUFXLFdBSFM7QUFJcEJFLHVCQUFXLFdBSlM7QUFLcEJ5Qyx5QkFBYSxjQUxPO0FBTXBCaEIsMEJBQWMsYUFOTTtBQU9wQnBCLHFCQUFTLFNBUFc7QUFRcEJxQixxQkFBUyxTQVJXO0FBU3BCWCx5QkFBYSxjQVRPO0FBVXBCRCx3QkFBWSxXQVZRO0FBV3BCdEksd0JBQVksV0FYUTtBQVlwQnFjLHVCQUFXLFlBWlM7QUFhcEJyVCwwQkFBYyxhQWJNO0FBY3BCc1QseUJBQWEsY0FkTztBQWVwQjFULGtCQUFNLEtBZmM7QUFnQnBCRCxtQkFBTyxRQWhCYTtBQWlCcEI2RCxpQkFBSyxNQWpCZTtBQWtCcEJyRCxvQkFBUSxPQWxCWTtBQW1CcEJ3RCw4QkFBa0IsbUJBbkJFO0FBb0JwQkcsOEJBQWtCLG1CQXBCRTtBQXFCcEJFLDhCQUFrQjtBQXJCRSxXQUF0QjtBQXVCQTs7Ozs7Ozs7QUFRQSxtQkFBU3VQLE9BQVQsQ0FBaUJDLElBQWpCLEVBQXVCL2IsUUFBdkIsRUFBaUM7QUFDL0IsZ0JBQUkvTSxPQUFPeUIsU0FBUCxDQUFpQmdQLGNBQWpCLENBQWdDMUgsSUFBaEMsQ0FBcUMyZixlQUFyQyxFQUFzREksSUFBdEQsQ0FBSixFQUFpRTtBQUMvRCxxQkFBTy9iLFdBQVcyYixnQkFBZ0JJLElBQWhCLENBQVgsR0FBbUNBLElBQTFDO0FBQ0QsYUFGRCxNQUVPO0FBQ0wscUJBQU9BLElBQVA7QUFDRDtBQUNGOztBQUVELGNBQUlDLFVBQVVwWixPQUFPLFNBQVAsQ0FBZDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxtQkFBU2lELGVBQVQsQ0FBeUJ4TixNQUF6QixFQUFpQzJILFFBQWpDLEVBQTJDO0FBQ3pDLGdCQUFJM0gsT0FBTzJqQixPQUFQLENBQUosRUFBcUI7QUFDbkIscUJBQU8zakIsTUFBUDtBQUNELGFBRkQsTUFFTztBQUNMLHFCQUFPLElBQUlpTixLQUFKLENBQVVqTixNQUFWLEVBQWtCO0FBQ3ZCakYscUJBQUssU0FBU0EsR0FBVCxDQUFhc0ssR0FBYixFQUFrQnFlLElBQWxCLEVBQXdCcEwsUUFBeEIsRUFBa0M7QUFDckMsc0JBQUlvTCxTQUFTQyxPQUFiLEVBQXNCO0FBQ3BCLDJCQUFPLElBQVA7QUFDRCxtQkFGRCxNQUVPLElBQUlELFNBQVMsWUFBYixFQUEyQjtBQUNoQywyQkFBT3JlLEdBQVA7QUFDRCxtQkFGTSxNQUVBLElBQUlxZSxTQUFTLE9BQWIsRUFBc0I7QUFDM0IsMkJBQU9sVyxnQkFBZ0JuSSxJQUFJdUksS0FBcEIsRUFBMkJqRyxRQUEzQixDQUFQO0FBQ0QsbUJBRk0sTUFFQSxJQUFJK2IsU0FBUyxRQUFiLEVBQXVCO0FBQzVCLDJCQUFPbFcsZ0JBQWdCbkksSUFBSWtDLE1BQXBCLEVBQTRCSSxRQUE1QixDQUFQO0FBQ0QsbUJBRk0sTUFFQSxJQUFJK2IsU0FBUyx1QkFBYixFQUFzQztBQUMzQywyQkFBTyxZQUFZO0FBQ2pCLDZCQUFPbFcsZ0JBQWdCbkksSUFBSTZKLHFCQUFKLENBQTBCdEMsS0FBMUIsQ0FBZ0N2SCxHQUFoQyxFQUFxQ3NILFNBQXJDLENBQWhCLEVBQWlFaEYsUUFBakUsQ0FBUDtBQUNELHFCQUZEO0FBR0QsbUJBSk0sTUFJQSxJQUFJK2IsU0FBUyxZQUFiLEVBQTJCO0FBQ2hDLDJCQUFPLFlBQVk7QUFDakIsNkJBQU9sVyxnQkFBZ0JuSSxJQUFJdUIsVUFBSixDQUFlZ0csS0FBZixDQUFxQnZILEdBQXJCLEVBQTBCc0gsU0FBMUIsQ0FBaEIsRUFBc0RoRixRQUF0RCxDQUFQO0FBQ0QscUJBRkQ7QUFHRCxtQkFKTSxNQUlBO0FBQ0wsd0JBQUk1SCxRQUFRc0YsSUFBSW9lLFFBQVFDLElBQVIsRUFBYy9iLFFBQWQsQ0FBSixDQUFaO0FBQ0EsMkJBQU8sT0FBTzVILEtBQVAsSUFBZ0IsVUFBaEIsR0FBNkJBLE1BQU02akIsSUFBTixDQUFXdmUsR0FBWCxDQUE3QixHQUErQ3RGLEtBQXREO0FBQ0Q7QUFDRixpQkF0QnNCO0FBdUJ2QndMLHFCQUFLLFNBQVNBLEdBQVQsQ0FBYWxHLEdBQWIsRUFBa0JxZSxJQUFsQixFQUF3QjNqQixLQUF4QixFQUErQjtBQUNsQ3NGLHNCQUFJb2UsUUFBUUMsSUFBUixFQUFjL2IsUUFBZCxDQUFKLElBQStCNUgsS0FBL0I7QUFDQSx5QkFBTyxJQUFQO0FBQ0Q7QUExQnNCLGVBQWxCLENBQVA7QUE0QkQ7QUFDRjs7QUFFRHpGLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQXZ6RzhCOztBQXl6R3JDLGFBQU07QUFDTjs7O0FBR0EsYUFBTywrQkFBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFxQjs7QUFFNUI7O0FBR0FLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0I0ZSxZQUFsQjs7QUFFQTs7Ozs7O0FBTUEsbUJBQVNDLG1CQUFULENBQTZCcmpCLEtBQTdCLEVBQW9DO0FBQ2xDQSxrQkFBTXNqQixlQUFOO0FBQ0E5VixxQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLE9BQWxDLEVBQTJDMEksbUJBQTNDLEVBQWdFLElBQWhFO0FBQ0Q7QUFDRDs7Ozs7O0FBT0EsbUJBQVNELFlBQVQsQ0FBc0Iva0IsTUFBdEIsRUFBOEI7QUFDNUJtUCxxQkFBUzZRLElBQVQsQ0FBY2pmLGdCQUFkLENBQStCLE9BQS9CLEVBQXdDaWtCLG1CQUF4QyxFQUE2RCxJQUE3RDtBQUNEOztBQUVEeHBCLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQTkxRzhCOztBQWcyR3JDLGFBQU07QUFDTjs7O0FBR0EsYUFBTyx3Q0FBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFxQjs7QUFFNUI7O0FBR0FLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0IsS0FBSyxDQUF2Qjs7QUFFQTs7QUFFQTs7Ozs7O0FBTUEsY0FBSStlLFdBQVcsQ0FBQ0MsT0FBT0MscUJBQVAsSUFBZ0NELE9BQU9FLDJCQUF2QyxJQUFzRUYsT0FBT0csd0JBQTdFLElBQXlHSCxPQUFPSSxzQkFBaEgsSUFBMElKLE9BQU9LLHVCQUFqSixJQUE0SyxVQUFVeEIsUUFBVixFQUFvQm5jLE9BQXBCLEVBQTZCO0FBQ3ZOLG1CQUFPbEksV0FBV3FrQixRQUFYLEVBQXFCLE9BQU8sRUFBNUIsQ0FBUDtBQUNELFdBRmMsRUFFWmMsSUFGWSxDQUVQSyxNQUZPLENBQWY7O0FBSUExcEIsa0JBQVEwSyxPQUFSLEdBQWtCK2UsUUFBbEI7QUFDQTFwQixpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0E3M0c4Qjs7QUErM0dyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sd0JBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBcUI7O0FBRTVCOztBQUdBSyxpQkFBT0MsY0FBUCxDQUFzQk4sT0FBdEIsRUFBK0IsWUFBL0IsRUFBOEM7QUFDNUN3RixtQkFBTztBQURxQyxXQUE5QztBQUdBeEYsa0JBQVEwSyxPQUFSLEdBQWtCMkksS0FBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsbUJBQVNBLEtBQVQsQ0FBZUMsRUFBZixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDekJsVCxtQkFBT3VnQixJQUFQLENBQVlyTixNQUFaLEVBQW9CMEcsT0FBcEIsQ0FBNEIsVUFBVWtQLElBQVYsRUFBZ0I7QUFDMUMsa0JBQUk3VixHQUFHRCxLQUFILENBQVM4VixJQUFULE1BQW1CNVYsT0FBTzRWLElBQVAsQ0FBdkIsRUFBcUM7QUFDbkM3VixtQkFBR0QsS0FBSCxDQUFTOFYsSUFBVCxJQUFpQjVWLE9BQU80VixJQUFQLENBQWpCO0FBQ0Q7QUFDRixhQUpEO0FBS0EsbUJBQU83VixFQUFQO0FBQ0Q7O0FBRUR2VCxpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0FoNkc4Qjs7QUFrNkdyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8seUJBQUMzSyxNQUFELEVBQVNDLE9BQVQsRUFBa0J5SyxtQkFBbEIsRUFBMEM7O0FBRWpEOztBQUdBLG1CQUFTc0YsT0FBVCxDQUFpQmpGLEdBQWpCLEVBQXNCO0FBQUU7QUFBMkIsZ0JBQUksT0FBT2tGLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT0MsUUFBZCxNQUEyQixRQUEvRCxFQUF5RTtBQUFFRix3QkFBVSxTQUFTQSxPQUFULENBQWlCakYsR0FBakIsRUFBc0I7QUFBRSw4QkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixlQUF0RDtBQUF5RCxhQUFwSSxNQUEwSTtBQUFFaUYsd0JBQVUsU0FBU0EsT0FBVCxDQUFpQmpGLEdBQWpCLEVBQXNCO0FBQUUsdUJBQU9BLE9BQU8sT0FBT2tGLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNsRixJQUFJN0ksV0FBSixLQUFvQitOLE1BQTNELElBQXFFbEYsUUFBUWtGLE9BQU9sTyxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSGdKLEdBQWxILDBDQUFrSEEsR0FBbEgsQ0FBUDtBQUErSCxlQUFqSztBQUFvSyxhQUFDLE9BQU9pRixRQUFRakYsR0FBUixDQUFQO0FBQXNCOztBQUUxWHpLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTBLLE9BQVIsR0FBa0IsS0FBSyxDQUF2Qjs7QUFFQSxjQUFJd0YsT0FBT0Msd0JBQXdCMUYscUJBQW9CLGFBQWMscUJBQWxDLENBQXhCLENBQVg7O0FBRUEsY0FBSTJOLFVBQVV4Tix1QkFBdUJILHFCQUFvQiwyQkFBNEIsNkJBQWhELENBQXZCLENBQWQ7O0FBRUEsY0FBSTZVLFlBQVkxVSx1QkFBdUJILHFCQUFvQixpQkFBa0IsbUJBQXRDLENBQXZCLENBQWhCOztBQUVBLGNBQUltVCxnQkFBZ0JoVCx1QkFBdUJILHFCQUFvQixxQkFBc0IsdUJBQTFDLENBQXZCLENBQXBCOztBQUVBLGNBQUl1ZixhQUFhcGYsdUJBQXVCSCxxQkFBb0Isa0JBQW1CLG9CQUF2QyxDQUF2QixDQUFqQjs7QUFFQSxjQUFJd2Ysd0JBQXdCcmYsdUJBQXVCSCxxQkFBb0IsOEJBQStCLGdDQUFuRCxDQUF2QixDQUE1Qjs7QUFFQSxtQkFBU0csc0JBQVQsQ0FBZ0NFLEdBQWhDLEVBQXFDO0FBQUUsbUJBQU9BLE9BQU9BLElBQUlDLFVBQVgsR0FBd0JELEdBQXhCLEdBQThCLEVBQUVKLFNBQVNJLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLG1CQUFTc0Ysd0JBQVQsQ0FBa0NDLFdBQWxDLEVBQStDO0FBQUUsZ0JBQUksT0FBT0MsT0FBUCxLQUFtQixVQUF2QixFQUFtQyxPQUFPLElBQVAsQ0FBYSxJQUFJQyxvQkFBb0IsSUFBSUQsT0FBSixFQUF4QixDQUF1QyxJQUFJRSxtQkFBbUIsSUFBSUYsT0FBSixFQUF2QixDQUFzQyxPQUFPLENBQUNGLDJCQUEyQixTQUFTQSx3QkFBVCxDQUFrQ0MsV0FBbEMsRUFBK0M7QUFBRSxxQkFBT0EsY0FBY0csZ0JBQWQsR0FBaUNELGlCQUF4QztBQUE0RCxhQUF6SSxFQUEySUYsV0FBM0ksQ0FBUDtBQUFpSzs7QUFFL1UsbUJBQVNGLHVCQUFULENBQWlDckYsR0FBakMsRUFBc0N1RixXQUF0QyxFQUFtRDtBQUFFLGdCQUFJLENBQUNBLFdBQUQsSUFBZ0J2RixHQUFoQixJQUF1QkEsSUFBSUMsVUFBL0IsRUFBMkM7QUFBRSxxQkFBT0QsR0FBUDtBQUFhLGFBQUMsSUFBSUEsUUFBUSxJQUFSLElBQWdCaUYsUUFBUWpGLEdBQVIsTUFBaUIsUUFBakIsSUFBNkIsT0FBT0EsR0FBUCxLQUFlLFVBQWhFLEVBQTRFO0FBQUUscUJBQU8sRUFBRUosU0FBU0ksR0FBWCxFQUFQO0FBQTBCLGFBQUMsSUFBSTJGLFFBQVFMLHlCQUF5QkMsV0FBekIsQ0FBWixDQUFtRCxJQUFJSSxTQUFTQSxNQUFNQyxHQUFOLENBQVU1RixHQUFWLENBQWIsRUFBNkI7QUFBRSxxQkFBTzJGLE1BQU1qUSxHQUFOLENBQVVzSyxHQUFWLENBQVA7QUFBd0IsYUFBQyxJQUFJNkYsU0FBUyxFQUFiLENBQWlCLElBQUlDLHdCQUF3QnZRLE9BQU9DLGNBQVAsSUFBeUJELE9BQU93USx3QkFBNUQsQ0FBc0YsS0FBSyxJQUFJckYsR0FBVCxJQUFnQlYsR0FBaEIsRUFBcUI7QUFBRSxrQkFBSVUsUUFBUSxTQUFSLElBQXFCbkwsT0FBT3lCLFNBQVAsQ0FBaUJnUCxjQUFqQixDQUFnQzFILElBQWhDLENBQXFDMEIsR0FBckMsRUFBMENVLEdBQTFDLENBQXpCLEVBQXlFO0FBQUUsb0JBQUl1RixPQUFPSCx3QkFBd0J2USxPQUFPd1Esd0JBQVAsQ0FBZ0MvRixHQUFoQyxFQUFxQ1UsR0FBckMsQ0FBeEIsR0FBb0UsSUFBL0UsQ0FBcUYsSUFBSXVGLFNBQVNBLEtBQUt2USxHQUFMLElBQVl1USxLQUFLQyxHQUExQixDQUFKLEVBQW9DO0FBQUUzUSx5QkFBT0MsY0FBUCxDQUFzQnFRLE1BQXRCLEVBQThCbkYsR0FBOUIsRUFBbUN1RixJQUFuQztBQUEyQyxpQkFBakYsTUFBdUY7QUFBRUoseUJBQU9uRixHQUFQLElBQWNWLElBQUlVLEdBQUosQ0FBZDtBQUF5QjtBQUFFO0FBQUUsYUFBQ21GLE9BQU9qRyxPQUFQLEdBQWlCSSxHQUFqQixDQUFzQixJQUFJMkYsS0FBSixFQUFXO0FBQUVBLG9CQUFNTyxHQUFOLENBQVVsRyxHQUFWLEVBQWU2RixNQUFmO0FBQXlCLGFBQUMsT0FBT0EsTUFBUDtBQUFnQjs7QUFFdHlCLG1CQUFTTSxTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxnQkFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXRCLElBQW9DQSxlQUFlLElBQXZELEVBQTZEO0FBQUUsb0JBQU0sSUFBSWpHLFNBQUosQ0FBYyxvREFBZCxDQUFOO0FBQTRFLGFBQUNnRyxTQUFTcFAsU0FBVCxHQUFxQnpCLE9BQU8wQixNQUFQLENBQWNvUCxjQUFjQSxXQUFXclAsU0FBdkMsRUFBa0QsRUFBRUcsYUFBYSxFQUFFdUQsT0FBTzBMLFFBQVQsRUFBbUIzRixVQUFVLElBQTdCLEVBQW1DRCxjQUFjLElBQWpELEVBQWYsRUFBbEQsQ0FBckIsQ0FBa0osSUFBSTZGLFVBQUosRUFBZ0JDLGdCQUFnQkYsUUFBaEIsRUFBMEJDLFVBQTFCO0FBQXdDOztBQUVqWSxtQkFBU0MsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCO0FBQUVGLDhCQUFrQi9RLE9BQU9rUixjQUFQLElBQXlCLFNBQVNILGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjtBQUFFRCxnQkFBRUcsU0FBRixHQUFjRixDQUFkLENBQWlCLE9BQU9ELENBQVA7QUFBVyxhQUF4RyxDQUEwRyxPQUFPRCxnQkFBZ0JDLENBQWhCLEVBQW1CQyxDQUFuQixDQUFQO0FBQStCOztBQUUxSyxtQkFBU0csWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0I7QUFBRSxnQkFBSUMsNEJBQTRCQywyQkFBaEMsQ0FBNkQsT0FBTyxTQUFTQyxvQkFBVCxHQUFnQztBQUFFLGtCQUFJQyxRQUFRQyxnQkFBZ0JMLE9BQWhCLENBQVo7QUFBQSxrQkFBc0NNLE1BQXRDLENBQThDLElBQUlMLHlCQUFKLEVBQStCO0FBQUUsb0JBQUlNLFlBQVlGLGdCQUFnQixJQUFoQixFQUFzQjlQLFdBQXRDLENBQW1EK1AsU0FBU0UsUUFBUUMsU0FBUixDQUFrQkwsS0FBbEIsRUFBeUJNLFNBQXpCLEVBQW9DSCxTQUFwQyxDQUFUO0FBQTBELGVBQTlJLE1BQW9KO0FBQUVELHlCQUFTRixNQUFNTyxLQUFOLENBQVksSUFBWixFQUFrQkQsU0FBbEIsQ0FBVDtBQUF3QyxlQUFDLE9BQU9FLDJCQUEyQixJQUEzQixFQUFpQ04sTUFBakMsQ0FBUDtBQUFrRCxhQUF4VTtBQUEyVTs7QUFFemEsbUJBQVNNLDBCQUFULENBQW9DblEsSUFBcEMsRUFBMENpSCxJQUExQyxFQUFnRDtBQUFFLGdCQUFJQSxTQUFTMkcsUUFBUTNHLElBQVIsTUFBa0IsUUFBbEIsSUFBOEIsT0FBT0EsSUFBUCxLQUFnQixVQUF2RCxDQUFKLEVBQXdFO0FBQUUscUJBQU9BLElBQVA7QUFBYyxhQUFDLE9BQU9tSix1QkFBdUJwUSxJQUF2QixDQUFQO0FBQXNDOztBQUVqTCxtQkFBU29RLHNCQUFULENBQWdDcFEsSUFBaEMsRUFBc0M7QUFBRSxnQkFBSUEsU0FBUyxLQUFLLENBQWxCLEVBQXFCO0FBQUUsb0JBQU0sSUFBSXFRLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsYUFBQyxPQUFPclEsSUFBUDtBQUFjOztBQUV0SyxtQkFBU3lQLHlCQUFULEdBQXFDO0FBQUUsZ0JBQUksT0FBT00sT0FBUCxLQUFtQixXQUFuQixJQUFrQyxDQUFDQSxRQUFRQyxTQUEvQyxFQUEwRCxPQUFPLEtBQVAsQ0FBYyxJQUFJRCxRQUFRQyxTQUFSLENBQWtCTSxJQUF0QixFQUE0QixPQUFPLEtBQVAsQ0FBYyxJQUFJLE9BQU9DLEtBQVAsS0FBaUIsVUFBckIsRUFBaUMsT0FBTyxJQUFQLENBQWEsSUFBSTtBQUFFQyxzQkFBUTdRLFNBQVIsQ0FBa0I4USxPQUFsQixDQUEwQnhKLElBQTFCLENBQStCOEksUUFBUUMsU0FBUixDQUFrQlEsT0FBbEIsRUFBMkIsRUFBM0IsRUFBK0IsWUFBWSxDQUFFLENBQTdDLENBQS9CLEVBQWdGLE9BQU8sSUFBUDtBQUFjLGFBQXBHLENBQXFHLE9BQU9wTixDQUFQLEVBQVU7QUFBRSxxQkFBTyxLQUFQO0FBQWU7QUFBRTs7QUFFelUsbUJBQVN3TSxlQUFULENBQXlCVixDQUF6QixFQUE0QjtBQUFFVSw4QkFBa0IxUixPQUFPa1IsY0FBUCxHQUF3QmxSLE9BQU93UyxjQUEvQixHQUFnRCxTQUFTZCxlQUFULENBQXlCVixDQUF6QixFQUE0QjtBQUFFLHFCQUFPQSxFQUFFRyxTQUFGLElBQWVuUixPQUFPd1MsY0FBUCxDQUFzQnhCLENBQXRCLENBQXRCO0FBQWlELGFBQWpKLENBQW1KLE9BQU9VLGdCQUFnQlYsQ0FBaEIsQ0FBUDtBQUE0Qjs7QUFFN00sbUJBQVNyRyxlQUFULENBQXlCdEIsUUFBekIsRUFBbUN1QixXQUFuQyxFQUFnRDtBQUFFLGdCQUFJLEVBQUV2QixvQkFBb0J1QixXQUF0QixDQUFKLEVBQXdDO0FBQUUsb0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosbUJBQVNDLGlCQUFULENBQTJCMUYsTUFBM0IsRUFBbUMyRixLQUFuQyxFQUEwQztBQUFFLGlCQUFLLElBQUkxSyxJQUFJLENBQWIsRUFBZ0JBLElBQUkwSyxNQUFNaEosTUFBMUIsRUFBa0MxQixHQUFsQyxFQUF1QztBQUFFLGtCQUFJMkssYUFBYUQsTUFBTTFLLENBQU4sQ0FBakIsQ0FBMkIySyxXQUFXOUssVUFBWCxHQUF3QjhLLFdBQVc5SyxVQUFYLElBQXlCLEtBQWpELENBQXdEOEssV0FBV0MsWUFBWCxHQUEwQixJQUExQixDQUFnQyxJQUFJLFdBQVdELFVBQWYsRUFBMkJBLFdBQVdFLFFBQVgsR0FBc0IsSUFBdEIsQ0FBNEJsTCxPQUFPQyxjQUFQLENBQXNCbUYsTUFBdEIsRUFBOEI0RixXQUFXRyxHQUF6QyxFQUE4Q0gsVUFBOUM7QUFBNEQ7QUFBRTs7QUFFN1QsbUJBQVNJLFlBQVQsQ0FBc0JSLFdBQXRCLEVBQW1DUyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxnQkFBSUQsVUFBSixFQUFnQlAsa0JBQWtCRixZQUFZbkosU0FBOUIsRUFBeUM0SixVQUF6QyxFQUFzRCxJQUFJQyxXQUFKLEVBQWlCUixrQkFBa0JGLFdBQWxCLEVBQStCVSxXQUEvQixFQUE2QyxPQUFPVixXQUFQO0FBQXFCOztBQUV2Tjs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0hBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7QUFTQSxjQUFJaWYsY0FBYyxhQUFhLFlBQVk7QUFDekM7Ozs7OztBQU1BLHFCQUFTQSxXQUFULENBQXFCaHBCLE1BQXJCLEVBQTZCaXBCLEVBQTdCLEVBQWlDO0FBQy9CbmYsOEJBQWdCLElBQWhCLEVBQXNCa2YsV0FBdEI7QUFDRDtBQUNEOzs7Ozs7O0FBUUF6ZSx5QkFBYXllLFdBQWIsRUFBMEIsQ0FBQztBQUN6QjFlLG1CQUFLLFFBRG9CO0FBRXpCaEc7QUFDQTs7Ozs7Ozs7OztBQVVBLHVCQUFTekQsTUFBVCxDQUFnQmIsTUFBaEIsRUFBd0IsQ0FBRTtBQWJELGFBQUQsRUFjdkI7QUFDRHNLLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVN0RCxJQUFULEdBQWdCLENBQUU7QUFDekI7Ozs7Ozs7QUFIQyxhQWR1QixFQXdCdkI7QUFDRHNKLG1CQUFLLFNBREo7QUFFRGhHLHFCQUFPLFNBQVM2SixPQUFULEdBQW1CLENBQUU7QUFGM0IsYUF4QnVCLENBQTFCOztBQTZCQSxtQkFBTzZhLFdBQVA7QUFDRCxXQWhEOEIsRUFBL0I7QUFpREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsY0FBSTVuQixhQUFhLGFBQWEsVUFBVXlRLGNBQVYsRUFBMEI7QUFDdEQ5QixzQkFBVTNPLFVBQVYsRUFBc0J5USxjQUF0Qjs7QUFFQSxnQkFBSUMsU0FBU3ZCLGFBQWFuUCxVQUFiLENBQWI7O0FBRUE7Ozs7Ozs7O0FBUUEscUJBQVNBLFVBQVQsQ0FBb0JwQixNQUFwQixFQUE0QjtBQUMxQixrQkFBSXdPLEtBQUo7O0FBRUExRSw4QkFBZ0IsSUFBaEIsRUFBc0IxSSxVQUF0Qjs7QUFFQW9OLHNCQUFRc0QsT0FBTzVKLElBQVAsQ0FBWSxJQUFaLENBQVI7QUFDQTs7Ozs7QUFLQXNHLG9CQUFNMGEsYUFBTixHQUFzQjtBQUNwQkMsOEJBQWMsSUFETTtBQUVwQkMsc0NBQXNCLElBRkY7QUFHcEIvTCwyQkFBVyxDQUhTO0FBSXBCN0csNEJBQVksSUFKUTtBQUtwQlYsZ0NBQWdCLENBTEk7QUFNcEJZLHVDQUF1QixLQU5IO0FBT3BCMlMseUJBQVMsVUFQVztBQVFwQkMsaUNBQWlCLElBUkc7QUFTcEI3bkIsMkJBQVcsQ0FUUztBQVVwQnFXLDJCQUFXLENBVlM7QUFXcEJnQyx3QkFBUSxJQVhZO0FBWXBCRyw4QkFBYyxJQVpNO0FBYXBCN1osMkJBQVcsSUFiUztBQWNwQnNZLDZCQUFhLE1BZE87QUFlcEJGLDZCQUFhLENBZk87QUFnQnBCclcsK0JBQWUsSUFoQks7QUFpQnBCd1YsMENBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBNFIsa0NBQWdCO0FBSlEsaUJBakJOO0FBdUJwQi9LLDBCQUFVLElBdkJVO0FBd0JwQmpkLDRCQUFZLElBeEJRO0FBeUJwQmlvQiw2QkFBYSxLQXpCTztBQTBCcEJoZSx3QkFBUSxHQTFCWTtBQTJCcEJ3SCwrQkFBZSxLQTNCSztBQTRCcEI2QiwwQkFBVSxJQTVCVTtBQTZCcEI0VSwrQkFBZSxJQTdCSztBQThCcEJuUyxnQ0FBZ0IsSUE5Qkk7QUErQnBCb1MsZ0NBQWdCLElBL0JJO0FBZ0NwQnpKLCtCQUFlLEtBaENLO0FBaUNwQnBCLDJCQUFXLE9BakNTO0FBa0NwQjhLLDZCQUFhLEVBbENPO0FBbUNwQnJOLDJCQUFXLEtBbkNTO0FBb0NwQnNOLCtCQUFlLEtBcENLO0FBcUNwQjVYLDRCQUFZd1csT0FBT3FCLGdCQUFQLElBQTJCQyxPQUFPQyxVQUFQLEdBQW9CRCxPQUFPRSxXQXJDOUM7QUFzQ3BCdG9CLHlCQUFTLEVBdENXO0FBdUNwQkosK0JBQWUsTUF2Q0s7QUF3Q3BCdWdCLDZDQUE2QixJQXhDVDtBQXlDcEJvSSwwQkFBVS9TLFFBQVExTixPQXpDRTtBQTBDcEJoSSw0QkFBWSxLQTFDUTtBQTJDcEIyUyxxQkFBSyxLQTNDZTtBQTRDcEJyQiw4QkFBYyxLQTVDTTtBQTZDcEJvWCw0QkFBWSxDQTdDUTtBQThDcEI5TywrQkFBZSxLQTlDSztBQStDcEJYLHNDQUFzQjtBQUNwQnVCLDJCQUFTLEtBRFc7QUFFcEJ0QixpQ0FBZSxFQUZLO0FBR3BCVyxrQ0FBZ0IsRUFISTtBQUlwQmEseUNBQXVCO0FBSkgsaUJBL0NGO0FBcURwQmhRLDBCQUFVLEtBckRVO0FBc0RwQjdLLDJCQUFXLE1BdERTO0FBdURwQjhvQixxQkFBSztBQXZEZSxlQUF0QjtBQXlEQTNiLG9CQUFNNGIsUUFBTixHQUFpQjtBQUNmL0wsOEJBQWMzQixjQUFjbFQsT0FEYjtBQUVmNmdCLDBCQUFVak0sVUFBVTVVLE9BRkw7QUFHZnlULHNDQUFzQjhMLHNCQUFzQnZmO0FBSDdCLGVBQWpCO0FBS0FnRixvQkFBTVEsSUFBTixHQUFhQSxJQUFiO0FBQ0FSLG9CQUFNeE8sTUFBTixHQUFlLFNBQWMsRUFBZCxFQUFrQndPLE1BQU0wYSxhQUF4QixFQUF1Q2xwQixNQUF2QyxDQUFmO0FBQ0F3TyxvQkFBTXhPLE1BQU4sQ0FBYXlhLG9CQUFiLEdBQW9DLFNBQWMsRUFBZCxFQUFrQmpNLE1BQU0wYSxhQUFOLENBQW9Cek8sb0JBQXRDLEVBQTREemEsT0FBT3lhLG9CQUFuRSxDQUFwQztBQUNBOztBQUVBak0sb0JBQU1wTyxTQUFOLEdBQWtCLFlBQVksT0FBT0osT0FBT0ksU0FBMUIsR0FBc0NvUyxTQUFTeE8sYUFBVCxDQUF1QndLLE1BQU14TyxNQUFOLENBQWFJLFNBQXBDLENBQXRDLEdBQXVGb08sTUFBTXhPLE1BQU4sQ0FBYUksU0FBdEg7O0FBRUEsa0JBQUksQ0FBQ29PLE1BQU1wTyxTQUFYLEVBQXNCO0FBQ3BCLHNCQUFNLElBQUlvZ0IsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDRDs7QUFFRCxrQkFBSWhTLE1BQU14TyxNQUFOLENBQWEwcEIsY0FBYixJQUErQixJQUFuQyxFQUF5QztBQUN2QztBQUNBbGIsc0JBQU1rYixjQUFOLEdBQXVCbGIsTUFBTXBPLFNBQTdCO0FBQ0QsZUFIRCxNQUdPLElBQUksT0FBT29PLE1BQU14TyxNQUFOLENBQWEwcEIsY0FBcEIsSUFBc0MsUUFBMUMsRUFBb0Q7QUFDekQ7QUFDQWxiLHNCQUFNa2IsY0FBTixHQUF1QmxYLFNBQVN4TyxhQUFULENBQXVCd0ssTUFBTXhPLE1BQU4sQ0FBYTBwQixjQUFwQyxDQUF2QjtBQUNELGVBSE0sTUFHQTtBQUNMO0FBQ0FsYixzQkFBTWtiLGNBQU4sR0FBdUJsYixNQUFNeE8sTUFBTixDQUFhMHBCLGNBQXBDO0FBQ0Q7O0FBRUQsa0JBQUksQ0FBQ2xiLE1BQU1rYixjQUFYLEVBQTJCO0FBQ3pCLHNCQUFNLElBQUlsSixLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNEOztBQUVELGtCQUFJaFMsTUFBTXhPLE1BQU4sQ0FBYXNYLGNBQWIsSUFBK0IsQ0FBbkMsRUFBc0M7QUFDcEMsc0JBQU0sSUFBSWtKLEtBQUosQ0FBVSx1Q0FBVixDQUFOO0FBQ0QsZUFGRCxNQUVPLElBQUloUyxNQUFNeE8sTUFBTixDQUFhc1gsY0FBYixHQUE4QixDQUE5QixJQUFtQyxDQUF2QyxFQUEwQztBQUMvQyxzQkFBTSxJQUFJa0osS0FBSixDQUFVLHVDQUFWLENBQU47QUFDRDs7QUFFRCxrQkFBSWhTLE1BQU14TyxNQUFOLENBQWFtVSxHQUFiLEtBQXFCLElBQXpCLEVBQStCO0FBQzdCLG9CQUFJM0YsTUFBTXhPLE1BQU4sQ0FBYWtNLFFBQWIsS0FBMEIsSUFBOUIsRUFBb0M7QUFDbEM4Qyx1QkFBS21ELEtBQUwsQ0FBVzNELE1BQU1wTyxTQUFqQixFQUE0QjtBQUMxQmtxQiwrQkFBVztBQURlLG1CQUE1QjtBQUdELGlCQUpELE1BSU87QUFDTHRiLHVCQUFLbUQsS0FBTCxDQUFXM0QsTUFBTXBPLFNBQWpCLEVBQTRCO0FBQzFCa3FCLCtCQUFXO0FBRGUsbUJBQTVCO0FBR0Q7QUFDRjs7QUFFRCxrQkFBSTliLE1BQU14TyxNQUFOLENBQWFzcEIsZUFBakIsRUFBa0M7QUFDaEM5YSxzQkFBTStiLGtCQUFOLENBQXlCL2IsTUFBTXhPLE1BQU4sQ0FBYXNwQixlQUF0QztBQUNEO0FBQ0Q7Ozs7OztBQU9BOWEsb0JBQU1nYyxXQUFOLEdBQW9CLENBQXBCO0FBQ0E7Ozs7O0FBS0FoYyxvQkFBTXVRLE9BQU4sR0FBZ0IsS0FBaEI7QUFDQTs7Ozs7O0FBTUF2USxvQkFBTWljLFNBQU4sR0FBa0IsRUFBbEI7QUFDQTs7Ozs7QUFLQWpjLG9CQUFNa2MsY0FBTixHQUF1QixJQUF2QjtBQUNBOztBQUVBbGMsb0JBQU1tYyxXQUFOLEdBQW9CLElBQXBCO0FBQ0E7O0FBRUFuYyxvQkFBTW9jLE1BQU4sR0FBZSxJQUFmO0FBQ0E7O0FBRUFwYyxvQkFBTTZhLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQTs7QUFFQTdhLG9CQUFNcWMsU0FBTixHQUFrQixJQUFsQixDQTlKMEIsQ0E4SkY7O0FBRXhCLGtCQUFJLE9BQU9yYyxNQUFNeE8sTUFBTixDQUFhaXFCLFFBQXBCLEtBQWlDLFVBQXJDLEVBQWlEO0FBQy9DLHNCQUFNLElBQUl6SixLQUFKLENBQVUsK0JBQVYsQ0FBTjtBQUNEO0FBQ0Q7Ozs7QUFLQWhTLG9CQUFNb0QsTUFBTixHQUFlcEQsTUFBTXhPLE1BQU4sQ0FBYWlxQixRQUE1QjtBQUNBOzs7QUFHQTs7QUFFQSxrQkFBSXpiLE1BQU14TyxNQUFOLENBQWFxcEIsT0FBYixJQUF3QixjQUE1QixFQUE0QztBQUMxQzdhLHNCQUFNeE8sTUFBTixDQUFhcXBCLE9BQWIsR0FBdUIsY0FBdkI7QUFDRDs7QUFFRCxrQkFBSSxDQUFDN2EsTUFBTXhPLE1BQU4sQ0FBYXFwQixPQUFiLElBQXdCLFVBQXhCLElBQXNDN2EsTUFBTXhPLE1BQU4sQ0FBYXFwQixPQUFiLEtBQXlCLHNCQUFoRSxLQUEyRixDQUFDakwsVUFBVTVVLE9BQVYsQ0FBa0I1SSxTQUFsQixDQUE0QmtxQixnQkFBNUIsQ0FBNkM1aUIsSUFBN0MsQ0FBa0QsSUFBbEQsQ0FBaEcsRUFBeUo7QUFDdkpzRyxzQkFBTXhPLE1BQU4sQ0FBYXFwQixPQUFiLEdBQXVCLGNBQXZCO0FBQ0Q7O0FBRUQ3YSxvQkFBTXVjLE9BQU4sR0FBZ0J2YyxNQUFNNGIsUUFBTixDQUFlNWIsTUFBTXhPLE1BQU4sQ0FBYXFwQixPQUE1QixDQUFoQjtBQUNBOzs7O0FBSUE3YSxvQkFBTXdjLHFCQUFOLEdBQThCLEVBQTlCO0FBQ0E7O0FBRUF4YyxvQkFBTXljLFdBQU4sR0FBb0IsS0FBcEI7QUFDQTs7Ozs7OztBQU9BemMsb0JBQU0wYyxPQUFOLEdBQWdCLEtBQWhCLENBdE0wQixDQXNNSDtBQUN2QjtBQUNBOztBQUVBLGtCQUFJQyxZQUFZLENBQWhCO0FBQ0EzYyxvQkFBTTRjLFNBQU4sR0FBa0JwYyxLQUFLcWMsUUFBTCxDQUFjLFlBQVk7QUFDMUMsb0JBQUlGLGFBQWEzYyxNQUFNb2MsTUFBTixDQUFhMVksT0FBYixDQUFxQndELFdBQWxDLElBQWlELENBQUNsSCxNQUFNeE8sTUFBTixDQUFhOFMsWUFBbkUsRUFBaUY7QUFDL0VxWSw4QkFBWTNjLE1BQU1vYyxNQUFOLENBQWExWSxPQUFiLENBQXFCd0QsV0FBakM7O0FBRUFsSCx3QkFBTW9jLE1BQU4sQ0FBYTlWLFNBQWIsQ0FBdUIsUUFBdkI7QUFDRDtBQUNGLGVBTmlCLEVBTWYsT0FBT3RHLE1BQU14TyxNQUFOLENBQWF3QixVQUFwQixLQUFtQyxRQUFuQyxHQUE4Q2dOLE1BQU14TyxNQUFOLENBQWF3QixVQUEzRCxHQUF3RSxHQU56RCxDQUFsQjtBQU9BLHFCQUFPNFAsMkJBQTJCNUMsS0FBM0IsRUFBa0M2Qyx1QkFBdUI3QyxLQUF2QixDQUFsQyxDQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBVUFqRSx5QkFBYW5KLFVBQWIsRUFBeUIsQ0FBQztBQUN4QmtKLG1CQUFLLE1BRG1CO0FBRXhCaEcscUJBQU8sU0FBU3RELElBQVQsR0FBZ0I7QUFDckIscUJBQUtzcUIsZUFBTCxDQUFxQixLQUFLdHJCLE1BQUwsQ0FBWTBCLE9BQWpDO0FBQ0EscUJBQUs2cEIsWUFBTDtBQUNBLHFCQUFLQyxhQUFMO0FBQ0EscUJBQUtDLGVBQUw7QUFDQSx1QkFBTyxJQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBVHdCLGFBQUQsRUFrQnRCO0FBQ0RuaEIsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVNnbkIsZUFBVCxDQUF5QjVwQixPQUF6QixFQUFrQztBQUN2QyxvQkFBSTRTLFNBQVMsSUFBYjs7QUFFQTtBQUNBNVMsd0JBQVFxWCxPQUFSLENBQWdCLFVBQVUyUyxNQUFWLEVBQWtCO0FBQ2hDLHlCQUFPcFgsT0FBT3FYLFNBQVAsQ0FBaUJELE1BQWpCLENBQVA7QUFDRCxpQkFGRCxFQUp1QyxDQU1uQzs7QUFFSmhxQix3QkFBUXFYLE9BQVIsQ0FBZ0IsVUFBVTJTLE1BQVYsRUFBa0I7QUFDaEM7QUFDQTtBQUNBLHNCQUFJLENBQUNBLE9BQU9FLFNBQVosRUFBdUI7QUFDckJ0WCwyQkFBT3VYLFVBQVAsQ0FBa0JILE9BQU81a0IsSUFBekI7QUFDRDtBQUNGLGlCQU5EO0FBT0EscUJBQUtnTyxTQUFMLENBQWUsb0JBQWYsRUFBcUNwVCxPQUFyQztBQUNBLHVCQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBcEJDLGFBbEJzQixFQTZDdEI7QUFDRDRJLG1CQUFLLGtCQURKO0FBRURoRyxxQkFBTyxTQUFTd25CLGdCQUFULEdBQTRCO0FBQ2pDLHVCQUFPLEtBQUtkLHFCQUFaO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBTEMsYUE3Q3NCLEVBMkR0QjtBQUNEMWdCLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVNxbkIsU0FBVCxDQUFtQkQsTUFBbkIsRUFBMkI7QUFDaEMsb0JBQUl0UyxTQUFTLElBQWI7O0FBRUEsb0JBQUksQ0FBQ3NTLE9BQU81a0IsSUFBWixFQUFrQjtBQUNoQix3QkFBTSxJQUFJMFosS0FBSixDQUFVLDhCQUFWLENBQU47QUFDRDs7QUFFRCxvQkFBSSxDQUFDa0wsT0FBT2xqQixRQUFaLEVBQXNCO0FBQ3BCLHdCQUFNLElBQUlnWSxLQUFKLENBQVUsVUFBVThCLE1BQVYsQ0FBaUJvSixPQUFPNWtCLElBQXhCLEVBQThCLHNDQUE5QixDQUFWLENBQU47QUFDRCxpQkFUK0IsQ0FTOUI7OztBQUdGLG9CQUFJNGtCLE9BQU9qaEIsV0FBWCxFQUF3QjtBQUN0QnRMLHlCQUFPdWdCLElBQVAsQ0FBWWdNLE9BQU9qaEIsV0FBbkIsRUFBZ0NzTyxPQUFoQyxDQUF3QyxVQUFVZ1QsZ0JBQVYsRUFBNEI7QUFDbEU7Ozs7QUFJQTNTLDJCQUFPMlMsZ0JBQVAsSUFBMkJMLE9BQU9qaEIsV0FBUCxDQUFtQnNoQixnQkFBbkIsQ0FBM0I7QUFDRCxtQkFORDtBQU9EOztBQUVELG9CQUFJQyxXQUFXTixPQUFPbGpCLFFBQXRCLENBdEJnQyxDQXNCQTs7QUFFaEMsb0JBQUl5akIsd0JBQXdCOXNCLE9BQU8rc0IsbUJBQVAsQ0FBMkJsZCxLQUFLaUksUUFBTCxDQUFjclcsU0FBekMsQ0FBNUI7QUFDQXFyQixzQ0FBc0JsVCxPQUF0QixDQUE4QixVQUFVek8sR0FBVixFQUFlO0FBQzNDMGhCLDJCQUFTcHJCLFNBQVQsQ0FBbUIwSixHQUFuQixJQUEwQjBFLEtBQUtpSSxRQUFMLENBQWNyVyxTQUFkLENBQXdCMEosR0FBeEIsQ0FBMUI7QUFDRCxpQkFGRDtBQUdBOzs7Ozs7QUFNQSxxQkFBS29oQixPQUFPNWtCLElBQVosSUFBb0IsSUFBSWtsQixRQUFKLENBQWFOLE9BQU8xckIsTUFBUCxJQUFpQixFQUE5QixFQUFrQyxJQUFsQyxDQUFwQjtBQUNBLHFCQUFLOFUsU0FBTCxDQUFlLGNBQWYsRUFBK0I0VyxPQUFPNWtCLElBQXRDO0FBQ0EsdUJBQU8sSUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7OztBQXhDQyxhQTNEc0IsRUE0R3RCO0FBQ0R3RCxtQkFBSyxZQURKO0FBRURoRyxxQkFBTyxTQUFTdW5CLFVBQVQsQ0FBb0Iva0IsSUFBcEIsRUFBMEI7QUFDL0Isb0JBQUksQ0FBQyxLQUFLQSxJQUFMLENBQUwsRUFBaUI7QUFDZix3QkFBTSxJQUFJMFosS0FBSixDQUFVLFVBQVU4QixNQUFWLENBQWlCeGIsSUFBakIsRUFBdUIsMEJBQXZCLENBQVYsQ0FBTjtBQUNEOztBQUVELG9CQUFJLEtBQUtra0IscUJBQUwsQ0FBMkJsa0IsSUFBM0IsQ0FBSixFQUFzQztBQUNwQztBQUNBLHVCQUFLcWxCLGFBQUwsQ0FBbUJybEIsSUFBbkI7QUFDRDs7QUFFRCxxQkFBS0EsSUFBTCxFQUFXOUYsSUFBWDtBQUNBLHFCQUFLZ3FCLHFCQUFMLENBQTJCbGtCLElBQTNCLElBQW1DLElBQW5DO0FBQ0EscUJBQUtnTyxTQUFMLENBQWUsb0JBQWYsRUFBcUNoTyxJQUFyQztBQUNBLHVCQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFqQkMsYUE1R3NCLEVBc0l0QjtBQUNEd0QsbUJBQUssZUFESjtBQUVEaEcscUJBQU8sU0FBUzZuQixhQUFULENBQXVCcmxCLElBQXZCLEVBQTZCO0FBQ2xDLG9CQUFJLENBQUMsS0FBS0EsSUFBTCxDQUFMLEVBQWlCO0FBQ2Ysd0JBQU0sSUFBSTBaLEtBQUosQ0FBVSxVQUFVOEIsTUFBVixDQUFpQnhiLElBQWpCLEVBQXVCLGtEQUF2QixDQUFWLENBQU47QUFDRDs7QUFFRCxvQkFBSSxDQUFDLEtBQUtra0IscUJBQUwsQ0FBMkJsa0IsSUFBM0IsQ0FBTCxFQUF1QztBQUNyQyx3QkFBTSxJQUFJMFosS0FBSixDQUFVLFVBQVU4QixNQUFWLENBQWlCeGIsSUFBakIsRUFBdUIseUNBQXZCLENBQVYsQ0FBTjtBQUNEOztBQUVELG9CQUFJLE9BQU8sS0FBS0EsSUFBTCxFQUFXcUgsT0FBbEIsS0FBOEIsVUFBbEMsRUFBOEM7QUFDNUMsd0JBQU0sSUFBSXFTLEtBQUosQ0FBVSxVQUFVOEIsTUFBVixDQUFpQnhiLElBQWpCLEVBQXVCLG9DQUF2QixDQUFWLENBQU47QUFDRDs7QUFFRCxxQkFBS0EsSUFBTCxFQUFXcUgsT0FBWDtBQUNBLHVCQUFPLEtBQUs2YyxxQkFBTCxDQUEyQmxrQixJQUEzQixDQUFQO0FBQ0EscUJBQUtnTyxTQUFMLENBQWUsa0JBQWYsRUFBbUNoTyxJQUFuQztBQUNBLHVCQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBcEJDLGFBdElzQixFQWlLdEI7QUFDRHdELG1CQUFLLG1CQURKO0FBRURoRyxxQkFBTyxTQUFTOG5CLGlCQUFULEdBQTZCO0FBQ2xDLG9CQUFJOVMsU0FBUyxJQUFiOztBQUVBbmEsdUJBQU91Z0IsSUFBUCxDQUFZLEtBQUtzTCxxQkFBakIsRUFBd0NqUyxPQUF4QyxDQUFnRCxVQUFValMsSUFBVixFQUFnQjtBQUM5RCx5QkFBT3dTLE9BQU82UyxhQUFQLENBQXFCcmxCLElBQXJCLENBQVA7QUFDRCxpQkFGRDtBQUdEO0FBQ0Q7Ozs7Ozs7QUFUQyxhQWpLc0IsRUFpTHRCO0FBQ0R3RCxtQkFBSyxjQURKO0FBRURoRyxxQkFBTyxTQUFTaW5CLFlBQVQsR0FBd0I7QUFDN0Isb0JBQUlyUixTQUFTLElBQWI7O0FBRUEscUJBQUswUSxNQUFMLEdBQWMsSUFBSSxLQUFLaFosTUFBVCxDQUFnQixLQUFLeFIsU0FBckIsRUFBZ0MsS0FBS0osTUFBckMsQ0FBZDtBQUNBLHFCQUFLNHFCLE1BQUwsQ0FBWTVwQixJQUFaO0FBQ0EscUJBQUs4VCxTQUFMLENBQWUsZ0JBQWYsRUFBaUMsS0FBSzhWLE1BQXRDOztBQUVBLG9CQUFJLEtBQUs1cUIsTUFBTCxDQUFZd0IsVUFBWixLQUEyQixLQUEvQixFQUFzQztBQUNwQ2duQix5QkFBT3BrQixnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLZ25CLFNBQXZDLEVBQWtELElBQWxEO0FBQ0E1Qyx5QkFBT3BrQixnQkFBUCxDQUF3QixtQkFBeEIsRUFBNkMsS0FBS2duQixTQUFsRCxFQUE2RCxJQUE3RDtBQUNEOztBQUVELHFCQUFLUixNQUFMLENBQVl4bkIsRUFBWixDQUFlLFFBQWYsRUFBeUIsWUFBWTtBQUNuQzhXLHlCQUFPbVMsVUFBUDs7QUFFQW5TLHlCQUFPMFEsTUFBUCxDQUFjL2YsUUFBZCxDQUF1QnFQLE9BQU9tUCxPQUFQLENBQWV4SSxpQkFBZixFQUF2QjtBQUNELGlCQUpELEVBWjZCLENBZ0J6Qjs7QUFFSixxQkFBSytKLE1BQUwsQ0FBWXhuQixFQUFaLENBQWUsT0FBZixFQUF3QixVQUFVaUIsQ0FBVixFQUFhd0csUUFBYixFQUF1QjtBQUM3QzdILDZCQUFXLFlBQVk7QUFDckIsMkJBQU9rWCxPQUFPNkcsTUFBUCxDQUFjbFcsUUFBZCxDQUFQO0FBQ0QsbUJBRkQsRUFFRyxDQUZIO0FBR0QsaUJBSkQsRUFsQjZCLENBc0J6Qjs7QUFFSixxQkFBSytmLE1BQUwsQ0FBWXhuQixFQUFaLENBQWUsUUFBZixFQUF5QixVQUFVaUIsQ0FBVixFQUFhO0FBQ3BDLHNCQUFJNlYsT0FBT2xhLE1BQVAsQ0FBYzRwQixhQUFsQixFQUFpQztBQUMvQjFQLDJCQUFPbVMsVUFBUDtBQUNEOztBQUVEblMseUJBQU9wRixTQUFQLENBQWlCLFFBQWpCLEVBQTJCelEsQ0FBM0I7QUFDRCxpQkFORDtBQU9EO0FBQ0Q7Ozs7Ozs7QUFsQ0MsYUFqTHNCLEVBME50QjtBQUNEaUcsbUJBQUssZUFESjtBQUVEaEcscUJBQU8sU0FBU2tuQixhQUFULEdBQXlCO0FBQzlCLG9CQUFJalIsU0FBUyxJQUFiOztBQUVBLG9CQUFJLEtBQUs4TyxPQUFULEVBQWtCO0FBQ2hCLHVCQUFLQSxPQUFMLENBQWFsYixPQUFiO0FBQ0Q7O0FBRUQscUJBQUtrYixPQUFMLEdBQWUsSUFBSSxLQUFLMEIsT0FBVCxDQUFpQixLQUFLL3FCLE1BQXRCLENBQWY7QUFDQSxxQkFBS3FwQixPQUFMLENBQWFyb0IsSUFBYjtBQUNBLHFCQUFLOFQsU0FBTCxDQUFlLGlCQUFmLEVBQWtDLEtBQUt1VSxPQUF2QztBQUNBLHFCQUFLQSxPQUFMLENBQWFqbUIsRUFBYixDQUFnQixRQUFoQixFQUEwQixZQUFZO0FBQ3BDbVgseUJBQU9xUSxNQUFQLENBQWMvZixRQUFkLENBQXVCMFAsT0FBTzhPLE9BQVAsQ0FBZXhJLGlCQUFmLEVBQXZCOztBQUVBdEcseUJBQU96RixTQUFQLENBQWlCLFFBQWpCO0FBQ0QsaUJBSkQ7QUFLQSxxQkFBS3VVLE9BQUwsQ0FBYWptQixFQUFiLENBQWdCLE1BQWhCLEVBQXdCLFlBQVk7QUFDbEMseUJBQU9tWCxPQUFPekYsU0FBUCxDQUFpQixNQUFqQixDQUFQO0FBQ0QsaUJBRkQ7QUFHQSxxQkFBS3VVLE9BQUwsQ0FBYWptQixFQUFiLENBQWdCLE9BQWhCLEVBQXlCLFlBQVk7QUFDbkMseUJBQU9tWCxPQUFPekYsU0FBUCxDQUFpQixPQUFqQixDQUFQO0FBQ0QsaUJBRkQ7QUFHQSxxQkFBS3VVLE9BQUwsQ0FBYWptQixFQUFiLENBQWdCLGNBQWhCLEVBQWdDLFVBQVVnZSxJQUFWLEVBQWdCO0FBQzlDN0cseUJBQU9xUSxNQUFQLENBQWMvZixRQUFkLENBQXVCMFAsT0FBTzhPLE9BQVAsQ0FBZXhJLGlCQUFmLEVBQXZCOztBQUVBdEcseUJBQU96RixTQUFQLENBQWlCLGNBQWpCLEVBQWlDc00sSUFBakM7QUFDRCxpQkFKRCxFQXJCOEIsQ0F5QjFCOztBQUVKLG9CQUFJLEtBQUtwaEIsTUFBTCxDQUFZcXBCLE9BQVosS0FBd0IsY0FBeEIsSUFBMEMsS0FBS3JwQixNQUFMLENBQVlxcEIsT0FBWixLQUF3QixzQkFBdEUsRUFBOEY7QUFDNUYsdUJBQUtBLE9BQUwsQ0FBYWptQixFQUFiLENBQWdCLE1BQWhCLEVBQXdCLFlBQVk7QUFDbENtWCwyQkFBT3FRLE1BQVAsQ0FBYy9mLFFBQWQsQ0FBdUIwUCxPQUFPOE8sT0FBUCxDQUFleEksaUJBQWYsRUFBdkI7QUFDRCxtQkFGRDtBQUdBLHVCQUFLd0ksT0FBTCxDQUFham1CLEVBQWIsQ0FBZ0IsUUFBaEIsRUFBMEIsWUFBWTtBQUNwQyx3QkFBSWtwQixZQUFZL1IsT0FBT21ILFNBQVAsRUFBaEI7O0FBRUFuSCwyQkFBT3pGLFNBQVAsQ0FBaUIsUUFBakIsRUFBMkJ3WCxTQUEzQjs7QUFFQSx3QkFBSS9SLE9BQU84TyxPQUFQLENBQWV0SyxPQUFmLEtBQTJCeEUsT0FBT3dFLE9BQXRDLEVBQStDO0FBQzdDeEUsNkJBQU93RSxPQUFQLEdBQWlCeEUsT0FBTzhPLE9BQVAsQ0FBZXRLLE9BQWhDOztBQUVBeEUsNkJBQU96RixTQUFQLENBQWlCLE1BQWpCLEVBQXlCeUYsT0FBT3dFLE9BQWhDO0FBQ0Q7QUFDRixtQkFWRDtBQVdEO0FBQ0Y7QUFDRDs7Ozs7O0FBOUNDLGFBMU5zQixFQThRdEI7QUFDRHpVLG1CQUFLLGlCQURKO0FBRURoRyxxQkFBTyxTQUFTbW5CLGVBQVQsR0FBMkI7QUFDaEMsb0JBQUksS0FBS3pyQixNQUFMLENBQVk0cEIsYUFBaEIsRUFBK0I7QUFDN0IsdUJBQUtpQixTQUFMLEdBQWlCLElBQUkvQixXQUFXdGYsT0FBZixFQUFqQjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7OztBQVBDLGFBOVFzQixFQTRSdEI7QUFDRGMsbUJBQUssYUFESjtBQUVEaEcscUJBQU8sU0FBU2IsV0FBVCxHQUF1QjtBQUM1Qix1QkFBTyxLQUFLNGxCLE9BQUwsQ0FBYTVsQixXQUFiLEVBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUE1UnNCLEVBd1N0QjtBQUNENkcsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVN3YixjQUFULEdBQTBCO0FBQy9CLHVCQUFPLEtBQUt1SixPQUFMLENBQWF2SixjQUFiLEVBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUF4U3NCLEVBb1R0QjtBQUNEeFYsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVNpb0IsY0FBVCxDQUF3QkMsT0FBeEIsRUFBaUM7QUFDdEMsb0JBQUlBLFdBQVcsS0FBSy9vQixXQUFMLEVBQWYsRUFBbUM7QUFDakMsdUJBQUtzZCxNQUFMLENBQVksQ0FBWjtBQUNELGlCQUZELE1BRU87QUFDTCx1QkFBS0EsTUFBTCxDQUFZeUwsVUFBVSxLQUFLL29CLFdBQUwsRUFBdEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUFUQyxhQXBUc0IsRUEwVXRCO0FBQ0Q2RyxtQkFBSyxNQURKO0FBRURoRyxxQkFBTyxTQUFTbUIsSUFBVCxDQUFjMUQsS0FBZCxFQUFxQkMsR0FBckIsRUFBMEI7QUFDL0Isb0JBQUkwWixTQUFTLElBQWI7O0FBRUEscUJBQUs1RyxTQUFMLENBQWUsYUFBZixFQUE4QixZQUFZO0FBQ3hDLHlCQUFPNEcsT0FBT2pXLElBQVAsQ0FBWTFELEtBQVosRUFBbUJDLEdBQW5CLENBQVA7QUFDRCxpQkFGRDtBQUdBLHVCQUFPLEtBQUtxbkIsT0FBTCxDQUFhNWpCLElBQWIsQ0FBa0IxRCxLQUFsQixFQUF5QkMsR0FBekIsQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFWQyxhQTFVc0IsRUEyVnRCO0FBQ0RzSSxtQkFBSyxZQURKO0FBRURoRyxxQkFBTyxTQUFTNGMsVUFBVCxDQUFvQnZPLFFBQXBCLEVBQThCO0FBQ25DLHFCQUFLMFcsT0FBTCxDQUFhbkksVUFBYixDQUF3QnZPLFFBQXhCO0FBQ0Q7QUFDRDs7Ozs7OztBQUxDLGFBM1ZzQixFQXVXdEI7QUFDRHJJLG1CQUFLLE9BREo7QUFFRGhHLHFCQUFPLFNBQVNxYSxLQUFULEdBQWlCO0FBQ3RCLG9CQUFJLENBQUMsS0FBSzBLLE9BQUwsQ0FBYXhKLFFBQWIsRUFBTCxFQUE4QjtBQUM1Qix5QkFBTyxLQUFLd0osT0FBTCxDQUFhMUssS0FBYixFQUFQO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7O0FBUEMsYUF2V3NCLEVBcVh0QjtBQUNEclUsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU21vQixTQUFULEdBQXFCO0FBQzFCLHVCQUFPLEtBQUtwRCxPQUFMLENBQWF4SixRQUFiLEtBQTBCLEtBQUtwYSxJQUFMLEVBQTFCLEdBQXdDLEtBQUtrWixLQUFMLEVBQS9DO0FBQ0Q7QUFDRDs7Ozs7OztBQUxDLGFBclhzQixFQWlZdEI7QUFDRHJVLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVNvb0IsU0FBVCxHQUFxQjtBQUMxQix1QkFBTyxDQUFDLEtBQUtyRCxPQUFMLENBQWF4SixRQUFiLEVBQVI7QUFDRDtBQUNEOzs7Ozs7OztBQUxDLGFBallzQixFQThZdEI7QUFDRHZWLG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVNxb0IsWUFBVCxDQUFzQkgsT0FBdEIsRUFBK0I7QUFDcEMscUJBQUtJLElBQUwsQ0FBVSxDQUFDSixPQUFELElBQVksQ0FBQyxLQUFLeHNCLE1BQUwsQ0FBWWtxQixVQUFuQztBQUNEO0FBQ0Q7Ozs7Ozs7O0FBTEMsYUE5WXNCLEVBMlp0QjtBQUNENWYsbUJBQUssYUFESjtBQUVEaEcscUJBQU8sU0FBU3VvQixXQUFULENBQXFCTCxPQUFyQixFQUE4QjtBQUNuQyxxQkFBS0ksSUFBTCxDQUFVSixXQUFXLEtBQUt4c0IsTUFBTCxDQUFZa3FCLFVBQWpDO0FBQ0Q7QUFDRDs7Ozs7Ozs7OztBQUxDLGFBM1pzQixFQTBhdEI7QUFDRDVmLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVNzb0IsSUFBVCxDQUFjaFgsTUFBZCxFQUFzQjtBQUMzQixvQkFBSTRJLFdBQVcsS0FBSy9hLFdBQUwsTUFBc0IsQ0FBckM7QUFDQSxvQkFBSWtQLFdBQVcsS0FBS21OLGNBQUwsTUFBeUIsQ0FBeEM7QUFDQW5OLDJCQUFXbkYsS0FBS3VJLEdBQUwsQ0FBUyxDQUFULEVBQVl2SSxLQUFLd0ksR0FBTCxDQUFTd0ksUUFBVCxFQUFtQjdMLFlBQVlpRCxVQUFVLENBQXRCLENBQW5CLENBQVosQ0FBWDtBQUNBLHFCQUFLa1gsYUFBTCxDQUFtQm5hLFdBQVc2TCxRQUE5QjtBQUNEO0FBQ0Q7Ozs7Ozs7OztBQVJDLGFBMWFzQixFQTJidEI7QUFDRGxVLG1CQUFLLGVBREo7QUFFRGhHLHFCQUFPLFNBQVN3b0IsYUFBVCxDQUF1QmppQixRQUF2QixFQUFpQztBQUN0QyxxQkFBS2tXLE1BQUwsQ0FBWWxXLFFBQVo7QUFDQSxxQkFBSytmLE1BQUwsQ0FBWXZWLFFBQVosQ0FBcUJ4SyxRQUFyQjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7O0FBTkMsYUEzYnNCLEVBNGN0QjtBQUNEUCxtQkFBSyxRQURKO0FBRURoRyxxQkFBTyxTQUFTeWMsTUFBVCxDQUFnQmxXLFFBQWhCLEVBQTBCO0FBQy9CLG9CQUFJa2lCLFNBQVMsSUFBYjs7QUFFQTtBQUNBLG9CQUFJLE9BQU9saUIsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDbWlCLFNBQVNuaUIsUUFBVCxDQUFqQyxJQUF1REEsV0FBVyxDQUFsRSxJQUF1RUEsV0FBVyxDQUF0RixFQUF5RjtBQUN2Rix3QkFBTSxJQUFJMlYsS0FBSixDQUFVLDhFQUFWLENBQU47QUFDRDs7QUFFRCxxQkFBSzFMLFNBQUwsQ0FBZSxhQUFmLEVBQThCLFlBQVk7QUFDeEMseUJBQU9pWSxPQUFPaE0sTUFBUCxDQUFjbFcsUUFBZCxDQUFQO0FBQ0QsaUJBRkQ7QUFHQSxvQkFBSW9pQixvQkFBb0IsS0FBS2p0QixNQUFMLENBQVlxcEIsT0FBWixLQUF3QixVQUFoRDtBQUNBLG9CQUFJNUssU0FBUyxLQUFLNEssT0FBTCxDQUFheEosUUFBYixFQUFiOztBQUVBLG9CQUFJb04scUJBQXFCLENBQUN4TyxNQUExQixFQUFrQztBQUNoQyx1QkFBSzRLLE9BQUwsQ0FBYTFLLEtBQWI7QUFDRCxpQkFoQjhCLENBZ0I3Qjs7O0FBR0Ysb0JBQUl1TyxrQkFBa0IsS0FBS2x0QixNQUFMLENBQVk4UyxZQUFsQztBQUNBLHFCQUFLOVMsTUFBTCxDQUFZOFMsWUFBWixHQUEyQixLQUEzQjtBQUNBLHFCQUFLdVcsT0FBTCxDQUFhdEksTUFBYixDQUFvQmxXLFdBQVcsS0FBS3BILFdBQUwsRUFBL0I7QUFDQSxxQkFBS21uQixNQUFMLENBQVkvZixRQUFaLENBQXFCQSxRQUFyQjs7QUFFQSxvQkFBSW9pQixxQkFBcUIsQ0FBQ3hPLE1BQTFCLEVBQWtDO0FBQ2hDLHVCQUFLNEssT0FBTCxDQUFhNWpCLElBQWI7QUFDRDs7QUFFRCxxQkFBS3pGLE1BQUwsQ0FBWThTLFlBQVosR0FBMkJvYSxlQUEzQjtBQUNBLHFCQUFLcFksU0FBTCxDQUFlLE1BQWYsRUFBdUJqSyxRQUF2QjtBQUNEO0FBQ0Q7Ozs7OztBQWpDQyxhQTVjc0IsRUFtZnRCO0FBQ0RQLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVM2b0IsSUFBVCxHQUFnQjtBQUNyQixxQkFBS3hPLEtBQUw7QUFDQSxxQkFBS29DLE1BQUwsQ0FBWSxDQUFaO0FBQ0EscUJBQUs2SixNQUFMLENBQVkvZixRQUFaLENBQXFCLENBQXJCO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBUEMsYUFuZnNCLEVBbWdCdEI7QUFDRFAsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU2lkLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCO0FBQ2xDLHVCQUFPLEtBQUs2SCxPQUFMLENBQWE5SCxTQUFiLENBQXVCQyxRQUF2QixDQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFMQyxhQW5nQnNCLEVBZ2hCdEI7QUFDRGxYLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVNtYyxTQUFULENBQW1CNkwsU0FBbkIsRUFBOEI7QUFDbkMscUJBQUtqRCxPQUFMLENBQWE1SSxTQUFiLENBQXVCNkwsU0FBdkI7QUFDQSxxQkFBS3hYLFNBQUwsQ0FBZSxRQUFmLEVBQXlCd1gsU0FBekI7QUFDRDtBQUNEOzs7Ozs7O0FBTkMsYUFoaEJzQixFQTZoQnRCO0FBQ0RoaUIsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU29kLFNBQVQsR0FBcUI7QUFDMUIsdUJBQU8sS0FBSzJILE9BQUwsQ0FBYTNILFNBQWIsRUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7O0FBTEMsYUE3aEJzQixFQTBpQnRCO0FBQ0RwWCxtQkFBSyxpQkFESjtBQUVEaEcscUJBQU8sU0FBUzhZLGVBQVQsQ0FBeUJ2SCxJQUF6QixFQUErQjtBQUNwQyxxQkFBS3dULE9BQUwsQ0FBYWpNLGVBQWIsQ0FBNkJ2SCxJQUE3QjtBQUNEO0FBQ0Q7Ozs7OztBQUxDLGFBMWlCc0IsRUFxakJ0QjtBQUNEdkwsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVN3YyxlQUFULEdBQTJCO0FBQ2hDLHVCQUFPLEtBQUt1SSxPQUFMLENBQWF2SSxlQUFiLEVBQVA7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFMQyxhQXJqQnNCLEVBbWtCdEI7QUFDRHhXLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVM4b0IsVUFBVCxHQUFzQjtBQUMzQixxQkFBS3pMLE9BQUwsQ0FBYSxDQUFDLEtBQUs1QyxPQUFuQjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7OztBQUxDLGFBbmtCc0IsRUFvbEJ0QjtBQUNEelUsbUJBQUssU0FESjtBQUVEaEcscUJBQU8sU0FBU3FkLE9BQVQsQ0FBaUIwTCxJQUFqQixFQUF1QjtBQUM1QjtBQUNBLG9CQUFJQSxTQUFTLEtBQUt0TyxPQUFsQixFQUEyQjtBQUN6Qix1QkFBS2pLLFNBQUwsQ0FBZSxNQUFmLEVBQXVCLEtBQUtpSyxPQUE1QjtBQUNBO0FBQ0Q7O0FBRUQsb0JBQUksS0FBS3NLLE9BQUwsQ0FBYTFILE9BQWpCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQSx1QkFBSzBILE9BQUwsQ0FBYTFILE9BQWIsQ0FBcUIwTCxJQUFyQjtBQUNBLHVCQUFLdE8sT0FBTCxHQUFlc08sSUFBZjtBQUNELGlCQUxELE1BS087QUFDTCxzQkFBSUEsSUFBSixFQUFVO0FBQ1I7QUFDQTtBQUNBLHlCQUFLN0MsV0FBTCxHQUFtQixLQUFLbkIsT0FBTCxDQUFhM0gsU0FBYixFQUFuQjtBQUNBLHlCQUFLMkgsT0FBTCxDQUFhNUksU0FBYixDQUF1QixDQUF2QjtBQUNBLHlCQUFLMUIsT0FBTCxHQUFlLElBQWY7QUFDQSx5QkFBS2pLLFNBQUwsQ0FBZSxRQUFmLEVBQXlCLENBQXpCO0FBQ0QsbUJBUEQsTUFPTztBQUNMO0FBQ0E7QUFDQSx5QkFBS3VVLE9BQUwsQ0FBYTVJLFNBQWIsQ0FBdUIsS0FBSytKLFdBQTVCO0FBQ0EseUJBQUt6TCxPQUFMLEdBQWUsS0FBZjtBQUNBLHlCQUFLakssU0FBTCxDQUFlLFFBQWYsRUFBeUIsS0FBSzBWLFdBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxxQkFBSzFWLFNBQUwsQ0FBZSxNQUFmLEVBQXVCLEtBQUtpSyxPQUE1QjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFqQ0MsYUFwbEJzQixFQTRuQnRCO0FBQ0R6VSxtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTZ3BCLE9BQVQsR0FBbUI7QUFDeEIsdUJBQU8sS0FBS3ZPLE9BQVo7QUFDRDtBQUNEOzs7Ozs7OztBQUxDLGFBNW5Cc0IsRUF5b0J0QjtBQUNEelUsbUJBQUssWUFESjtBQUVEaEcscUJBQU8sU0FBU2lwQixVQUFULEdBQXNCO0FBQzNCLHVCQUFPLEtBQUtsRSxPQUFMLENBQWFtRSxPQUFiLElBQXdCLEVBQS9CO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUF6b0JzQixFQW9wQnRCO0FBQ0RsakIsbUJBQUssY0FESjtBQUVEaEcscUJBQU8sU0FBU21wQixZQUFULEdBQXdCO0FBQzdCLHFCQUFLenRCLE1BQUwsQ0FBWThTLFlBQVosR0FBMkIsQ0FBQyxLQUFLOVMsTUFBTCxDQUFZOFMsWUFBeEM7QUFDQSxxQkFBS3VaLFVBQUw7QUFDRDtBQUNEOzs7Ozs7QUFOQyxhQXBwQnNCLEVBZ3FCdEI7QUFDRC9oQixtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU29wQixpQkFBVCxHQUE2QjtBQUNsQyxxQkFBSzF0QixNQUFMLENBQVk2VSxRQUFaLEdBQXVCLENBQUMsS0FBSzdVLE1BQUwsQ0FBWTZVLFFBQXBDO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUFocUJzQixFQTJxQnRCO0FBQ0R2SyxtQkFBSyxjQURKO0FBRURoRyxxQkFBTyxTQUFTcXBCLFlBQVQsR0FBd0I7QUFDN0IsdUJBQU8sS0FBSzN0QixNQUFMLENBQVlxQixTQUFuQjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFMQyxhQTNxQnNCLEVBdXJCdEI7QUFDRGlKLG1CQUFLLGNBREo7QUFFRGhHLHFCQUFPLFNBQVNzcEIsWUFBVCxDQUFzQjFyQixLQUF0QixFQUE2QjtBQUNsQyxxQkFBS2xDLE1BQUwsQ0FBWXFCLFNBQVosR0FBd0JhLEtBQXhCO0FBQ0EscUJBQUttcUIsVUFBTDtBQUNEO0FBQ0Q7Ozs7OztBQU5DLGFBdnJCc0IsRUFtc0J0QjtBQUNEL2hCLG1CQUFLLGtCQURKO0FBRURoRyxxQkFBTyxTQUFTdXBCLGdCQUFULEdBQTRCO0FBQ2pDLHVCQUFPLEtBQUs3dEIsTUFBTCxDQUFZc0IsYUFBbkI7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUFuc0JzQixFQStzQnRCO0FBQ0RnSixtQkFBSyxrQkFESjtBQUVEaEcscUJBQU8sU0FBU3dwQixnQkFBVCxDQUEwQjVyQixLQUExQixFQUFpQztBQUN0QyxxQkFBS2xDLE1BQUwsQ0FBWXNCLGFBQVosR0FBNEJZLEtBQTVCO0FBQ0EscUJBQUttcUIsVUFBTDtBQUNEO0FBQ0Q7Ozs7OztBQU5DLGFBL3NCc0IsRUEydEJ0QjtBQUNEL2hCLG1CQUFLLG9CQURKO0FBRURoRyxxQkFBTyxTQUFTeXBCLGtCQUFULEdBQThCO0FBQ25DLHVCQUFPLEtBQUsvdEIsTUFBTCxDQUFZc3BCLGVBQW5CO0FBQ0Q7QUFDRDs7Ozs7OztBQUxDLGFBM3RCc0IsRUF1dUJ0QjtBQUNEaGYsbUJBQUssb0JBREo7QUFFRGhHLHFCQUFPLFNBQVNpbUIsa0JBQVQsQ0FBNEJyb0IsS0FBNUIsRUFBbUM7QUFDeEMscUJBQUtsQyxNQUFMLENBQVlzcEIsZUFBWixHQUE4QnBuQixLQUE5QjtBQUNBOE0scUJBQUttRCxLQUFMLENBQVcsS0FBSy9SLFNBQWhCLEVBQTJCO0FBQ3pCNHRCLDhCQUFZLEtBQUtodUIsTUFBTCxDQUFZc3BCO0FBREMsaUJBQTNCO0FBR0Q7QUFDRDs7Ozs7OztBQVJDLGFBdnVCc0IsRUFzdkJ0QjtBQUNEaGYsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVMycEIsY0FBVCxHQUEwQjtBQUMvQix1QkFBTyxLQUFLanVCLE1BQUwsQ0FBWTBZLFdBQW5CO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFMQyxhQXR2QnNCLEVBbXdCdEI7QUFDRHBPLG1CQUFLLGdCQURKO0FBRURoRyxxQkFBTyxTQUFTNHBCLGNBQVQsQ0FBd0Joc0IsS0FBeEIsRUFBK0I7QUFDcEMscUJBQUtsQyxNQUFMLENBQVkwWSxXQUFaLEdBQTBCeFcsS0FBMUI7QUFDQSxxQkFBSzBvQixNQUFMLENBQVk3VCxZQUFaO0FBQ0Q7QUFDRDs7Ozs7O0FBTkMsYUFud0JzQixFQSt3QnRCO0FBQ0R6TSxtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTNnBCLFNBQVQsR0FBcUI7QUFDMUIsdUJBQU8sS0FBS251QixNQUFMLENBQVl3TCxNQUFuQjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFMQyxhQS93QnNCLEVBMnhCdEI7QUFDRGxCLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVM4UixTQUFULENBQW1CNUssTUFBbkIsRUFBMkI7QUFDaEMscUJBQUt4TCxNQUFMLENBQVl3TCxNQUFaLEdBQXFCQSxNQUFyQjtBQUNBLHFCQUFLb2YsTUFBTCxDQUFZeFUsU0FBWixDQUFzQjVLLFNBQVMsS0FBS3hMLE1BQUwsQ0FBWWdTLFVBQTNDO0FBQ0EscUJBQUtxYSxVQUFMO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUFQQyxhQTN4QnNCLEVBZ3pCdEI7QUFDRC9oQixtQkFBSyxxQkFESjtBQUVEaEcscUJBQU8sU0FBUzhwQixtQkFBVCxDQUE2QkMsY0FBN0IsRUFBNkM7QUFDbEQscUJBQUtydUIsTUFBTCxDQUFZeWEsb0JBQVosQ0FBaUNZLGNBQWpDLEdBQWtEZ1QsY0FBbEQ7QUFDQSxxQkFBS2hDLFVBQUw7QUFDRDtBQUNEOzs7Ozs7O0FBTkMsYUFoekJzQixFQTZ6QnRCO0FBQ0QvaEIsbUJBQUssWUFESjtBQUVEaEcscUJBQU8sU0FBUytuQixVQUFULEdBQXNCO0FBQzNCLG9CQUFJM1ksZUFBZWxHLEtBQUtDLEtBQUwsQ0FBVyxLQUFLaEssV0FBTCxLQUFxQixLQUFLekQsTUFBTCxDQUFZMnBCLFdBQWpDLEdBQStDLEtBQUszcEIsTUFBTCxDQUFZZ1MsVUFBdEUsQ0FBbkI7QUFDQSxvQkFBSTJCLGNBQWMsS0FBS2lYLE1BQUwsQ0FBWWhYLFFBQVosRUFBbEI7QUFDQSxvQkFBSXJRLFFBQVFtUSxZQUFaLENBSDJCLENBR0Q7O0FBRTFCLG9CQUFJM1IsUUFBUSxDQUFaO0FBQ0Esb0JBQUlDLE1BQU13TCxLQUFLdUksR0FBTCxDQUFTaFUsUUFBUTRSLFdBQWpCLEVBQThCcFEsS0FBOUIsQ0FBVixDQU4yQixDQU1xQjs7QUFFaEQsb0JBQUksS0FBS3ZELE1BQUwsQ0FBWXVCLFVBQVosS0FBMkIsQ0FBQyxLQUFLdkIsTUFBTCxDQUFZOFMsWUFBYixJQUE2QlksZUFBZUMsV0FBdkUsQ0FBSixFQUF5RjtBQUN2RnBRLDBCQUFRb1EsV0FBUjtBQUNBNVIsMEJBQVEsQ0FBUjtBQUNBQyx3QkFBTXVCLEtBQU47QUFDRDs7QUFFRCxvQkFBSTRKLEtBQUo7O0FBRUEsb0JBQUksS0FBS25OLE1BQUwsQ0FBWTRwQixhQUFoQixFQUErQjtBQUM3QixzQkFBSTBFLFlBQVksS0FBS3pELFNBQUwsQ0FBZTNJLG1CQUFmLENBQW1DM2UsS0FBbkMsRUFBMEN4QixLQUExQyxFQUFpREMsR0FBakQsQ0FBaEI7QUFDQSxzQkFBSXhDLENBQUo7O0FBRUEsdUJBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJOHVCLFVBQVVwdEIsTUFBMUIsRUFBa0MxQixHQUFsQyxFQUF1QztBQUNyQzJOLDRCQUFRLEtBQUtrYyxPQUFMLENBQWEvSCxRQUFiLENBQXNCL2QsS0FBdEIsRUFBNkIrcUIsVUFBVTl1QixDQUFWLEVBQWEsQ0FBYixDQUE3QixFQUE4Qzh1QixVQUFVOXVCLENBQVYsRUFBYSxDQUFiLENBQTlDLENBQVI7QUFDQSx5QkFBS29yQixNQUFMLENBQVk3VixTQUFaLENBQXNCNUgsS0FBdEIsRUFBNkI1SixLQUE3QixFQUFvQytxQixVQUFVOXVCLENBQVYsRUFBYSxDQUFiLENBQXBDLEVBQXFEOHVCLFVBQVU5dUIsQ0FBVixFQUFhLENBQWIsQ0FBckQ7QUFDRDtBQUNGLGlCQVJELE1BUU87QUFDTDJOLDBCQUFRLEtBQUtrYyxPQUFMLENBQWEvSCxRQUFiLENBQXNCL2QsS0FBdEIsRUFBNkJ4QixLQUE3QixFQUFvQ0MsR0FBcEMsQ0FBUjtBQUNBLHVCQUFLNG9CLE1BQUwsQ0FBWTdWLFNBQVosQ0FBc0I1SCxLQUF0QixFQUE2QjVKLEtBQTdCLEVBQW9DeEIsS0FBcEMsRUFBMkNDLEdBQTNDO0FBQ0Q7O0FBRUQscUJBQUs4UyxTQUFMLENBQWUsUUFBZixFQUF5QjNILEtBQXpCLEVBQWdDNUosS0FBaEM7QUFDRDtBQUNEOzs7Ozs7Ozs7OztBQWpDQyxhQTd6QnNCLEVBeTJCdEI7QUFDRCtHLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVNpcUIsSUFBVCxDQUFjQyxRQUFkLEVBQXdCO0FBQzdCLG9CQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiLHVCQUFLeHVCLE1BQUwsQ0FBWTJwQixXQUFaLEdBQTBCLEtBQUtULGFBQUwsQ0FBbUJTLFdBQTdDO0FBQ0EsdUJBQUszcEIsTUFBTCxDQUFZOFMsWUFBWixHQUEyQixLQUEzQjtBQUNELGlCQUhELE1BR087QUFDTCx1QkFBSzlTLE1BQUwsQ0FBWTJwQixXQUFaLEdBQTBCNkUsUUFBMUI7QUFDQSx1QkFBS3h1QixNQUFMLENBQVk4UyxZQUFaLEdBQTJCLElBQTNCO0FBQ0Q7O0FBRUQscUJBQUt1WixVQUFMO0FBQ0EscUJBQUt6QixNQUFMLENBQVkvZixRQUFaLENBQXFCLEtBQUt3ZSxPQUFMLENBQWF4SSxpQkFBYixFQUFyQjtBQUNBLHFCQUFLK0osTUFBTCxDQUFZdlYsUUFBWixDQUFxQixLQUFLeUssY0FBTCxLQUF3QixLQUFLcmMsV0FBTCxFQUE3QztBQUNBLHFCQUFLcVIsU0FBTCxDQUFlLE1BQWYsRUFBdUIwWixRQUF2QjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFoQkMsYUF6MkJzQixFQWc0QnRCO0FBQ0Rsa0IsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVNtcUIsZUFBVCxDQUF5QjlELFdBQXpCLEVBQXNDO0FBQzNDLG9CQUFJK0QsU0FBUyxJQUFiOztBQUVBLHFCQUFLQyxpQkFBTCxDQUF1QmhFLFdBQXZCLEVBQW9DLFVBQVVpRSxJQUFWLEVBQWdCO0FBQ2xELHNCQUFJLENBQUNGLE9BQU96RCxXQUFaLEVBQXlCO0FBQ3ZCeUQsMkJBQU9HLGlCQUFQLENBQXlCRCxJQUF6QjtBQUNEO0FBQ0YsaUJBSkQ7QUFLRDtBQUNEOzs7Ozs7OztBQVhDLGFBaDRCc0IsRUFtNUJ0QjtBQUNEdGtCLG1CQUFLLG1CQURKO0FBRURoRyxxQkFBTyxTQUFTdXFCLGlCQUFULENBQTJCN1AsTUFBM0IsRUFBbUM7QUFDeEMscUJBQUtxSyxPQUFMLENBQWFwbUIsSUFBYixDQUFrQitiLE1BQWxCO0FBQ0EscUJBQUtxTixVQUFMO0FBQ0EscUJBQUtuQixPQUFMLEdBQWUsSUFBZjtBQUNBLHFCQUFLcFcsU0FBTCxDQUFlLE9BQWY7QUFDRDtBQUNEOzs7Ozs7O0FBUkMsYUFuNUJzQixFQWs2QnRCO0FBQ0R4SyxtQkFBSyxVQURKO0FBRURoRyxxQkFBTyxTQUFTd3FCLFFBQVQsQ0FBa0JsSixJQUFsQixFQUF3QjtBQUM3QixvQkFBSW1KLFVBQVUsSUFBZDs7QUFFQTtBQUNBLG9CQUFJQyxTQUFTLElBQUlDLFVBQUosRUFBYjtBQUNBRCx1QkFBTzVxQixnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxVQUFVQyxDQUFWLEVBQWE7QUFDL0MseUJBQU8wcUIsUUFBUWxMLFVBQVIsQ0FBbUJ4ZixDQUFuQixDQUFQO0FBQ0QsaUJBRkQ7QUFHQTJxQix1QkFBTzVxQixnQkFBUCxDQUF3QixNQUF4QixFQUFnQyxVQUFVQyxDQUFWLEVBQWE7QUFDM0MseUJBQU8wcUIsUUFBUU4sZUFBUixDQUF3QnBxQixFQUFFRSxNQUFGLENBQVN1TSxNQUFqQyxDQUFQO0FBQ0QsaUJBRkQ7QUFHQWtlLHVCQUFPNXFCLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLFlBQVk7QUFDM0MseUJBQU8ycUIsUUFBUWphLFNBQVIsQ0FBa0IsT0FBbEIsRUFBMkIsb0JBQTNCLENBQVA7QUFDRCxpQkFGRDtBQUdBa2EsdUJBQU9FLGlCQUFQLENBQXlCdEosSUFBekI7QUFDQSxxQkFBS3VKLEtBQUw7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbkJDLGFBbDZCc0IsRUFpOUJ0QjtBQUNEN2tCLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVNyQixJQUFULENBQWM4YyxHQUFkLEVBQW1CNVMsS0FBbkIsRUFBMEJ5USxPQUExQixFQUFtQ1ksUUFBbkMsRUFBNkM7QUFDbEQsb0JBQUksQ0FBQ3VCLEdBQUwsRUFBVTtBQUNSLHdCQUFNLElBQUlTLEtBQUosQ0FBVSwrQkFBVixDQUFOO0FBQ0Q7O0FBRUQscUJBQUsyTyxLQUFMOztBQUVBLG9CQUFJdlIsT0FBSixFQUFhO0FBQ1g7QUFDQTtBQUNBLHNCQUFJd1IsdUJBQXVCO0FBQ3pCLG1FQUErQyxDQUFDLE1BQUQsRUFBUyxVQUFULEVBQXFCLE1BQXJCLEVBQTZCeG5CLE9BQTdCLENBQXFDZ1csT0FBckMsTUFBa0QsQ0FBQyxDQUR6RTtBQUV6Qiw4Q0FBMEIsQ0FBQ3pRLEtBRkY7QUFHekIsdUZBQW1FLENBQUMsY0FBRCxFQUFpQixzQkFBakIsRUFBeUN2RixPQUF6QyxDQUFpRCxLQUFLNUgsTUFBTCxDQUFZcXBCLE9BQTdELE1BQTBFLENBQUMsQ0FIckg7QUFJekIsaURBQTZCLE9BQU90SixHQUFQLEtBQWU7QUFKbkIsbUJBQTNCO0FBTUEsc0JBQUlzUCxnQkFBZ0Jsd0IsT0FBT3VnQixJQUFQLENBQVkwUCxvQkFBWixFQUFrQ3RULE1BQWxDLENBQXlDLFVBQVV3VCxNQUFWLEVBQWtCO0FBQzdFLDJCQUFPRixxQkFBcUJFLE1BQXJCLENBQVA7QUFDRCxtQkFGbUIsQ0FBcEI7O0FBSUEsc0JBQUlELGNBQWNudUIsTUFBbEIsRUFBMEI7QUFDeEI7QUFDQTJDLDRCQUFRMHJCLElBQVIsQ0FBYSx3RUFBd0VGLGNBQWNHLElBQWQsQ0FBbUIsUUFBbkIsQ0FBckYsRUFGd0IsQ0FFNEY7O0FBRXBINVIsOEJBQVUsSUFBVjtBQUNEO0FBQ0YsaUJBMUJpRCxDQTBCaEQ7QUFDRjs7O0FBR0Esb0JBQUksS0FBSzVkLE1BQUwsQ0FBWXFwQixPQUFaLEtBQXdCLFVBQXhCLElBQXNDdEosZUFBZVEsZ0JBQXpELEVBQTJFO0FBQ3pFUix3QkFBTUEsSUFBSUksR0FBVjtBQUNEOztBQUVELHdCQUFRLEtBQUtuZ0IsTUFBTCxDQUFZcXBCLE9BQXBCO0FBQ0UsdUJBQUssVUFBTDtBQUNFLDJCQUFPLEtBQUtvRyxVQUFMLENBQWdCMVAsR0FBaEIsRUFBcUI1UyxLQUFyQixFQUE0QnFSLFFBQTVCLENBQVA7O0FBRUYsdUJBQUssY0FBTDtBQUNBLHVCQUFLLHNCQUFMO0FBQ0UsMkJBQU8sS0FBS2tSLGdCQUFMLENBQXNCM1AsR0FBdEIsRUFBMkI1UyxLQUEzQixFQUFrQ3lRLE9BQWxDLEVBQTJDWSxRQUEzQyxDQUFQO0FBTko7QUFRRDtBQUNEOzs7Ozs7Ozs7OztBQTdDQyxhQWo5QnNCLEVBeWdDdEI7QUFDRGxVLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVNtckIsVUFBVCxDQUFvQjFQLEdBQXBCLEVBQXlCNVMsS0FBekIsRUFBZ0NxUixRQUFoQyxFQUEwQztBQUMvQyxvQkFBSW1SLFVBQVUsSUFBZDs7QUFFQSxvQkFBSTFzQixPQUFPLFNBQVNBLElBQVQsQ0FBY3FFLE1BQWQsRUFBc0I7QUFDL0Isc0JBQUlBLE1BQUosRUFBWTtBQUNWcW9CLDRCQUFRbEYsU0FBUixDQUFrQmhpQixJQUFsQixDQUF1QmtuQixRQUFRckksSUFBUixDQUFhLE9BQWIsRUFBc0JoZ0IsTUFBdEIsQ0FBdkI7QUFDRDs7QUFFRCx5QkFBT3FvQixRQUFRQyxjQUFSLENBQXVCN1AsR0FBdkIsRUFBNEIsVUFBVTZPLElBQVYsRUFBZ0I7QUFDakQsMkJBQU9lLFFBQVFsQixlQUFSLENBQXdCRyxJQUF4QixDQUFQO0FBQ0QsbUJBRk0sQ0FBUDtBQUdELGlCQVJEOztBQVVBLG9CQUFJemhCLEtBQUosRUFBVztBQUNULHVCQUFLa2MsT0FBTCxDQUFhd0csUUFBYixDQUFzQjFpQixLQUF0QixFQUE2QnFSLFFBQTdCO0FBQ0EsdUJBQUs2TixVQUFMO0FBQ0EsdUJBQUt2WCxTQUFMLENBQWUsZ0JBQWY7QUFDQSx1QkFBSzJWLFNBQUwsQ0FBZWhpQixJQUFmLENBQW9CLEtBQUs2ZSxJQUFMLENBQVUsYUFBVixFQUF5QnJrQixJQUF6QixDQUFwQjtBQUNELGlCQUxELE1BS087QUFDTCx5QkFBT0EsTUFBUDtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUF4QkMsYUF6Z0NzQixFQStpQ3RCO0FBQ0RxSCxtQkFBSyxrQkFESjtBQUVEaEcscUJBQU8sU0FBU29yQixnQkFBVCxDQUEwQkksUUFBMUIsRUFBb0MzaUIsS0FBcEMsRUFBMkN5USxPQUEzQyxFQUFvRFksUUFBcEQsRUFBOEQ7QUFDbkUsb0JBQUl1UixVQUFVLElBQWQ7O0FBRUEsb0JBQUloUSxNQUFNK1AsUUFBVjs7QUFFQSxvQkFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLHVCQUFLekcsT0FBTCxDQUFhcG1CLElBQWIsQ0FBa0I4YyxHQUFsQixFQUF1QixLQUFLMkosY0FBNUIsRUFBNEN2YyxLQUE1QyxFQUFtRHlRLE9BQW5EO0FBQ0QsaUJBRkQsTUFFTztBQUNMLHNCQUFJMEMsTUFBTXdQLFFBQVY7QUFDQSx1QkFBS3pHLE9BQUwsQ0FBYWhKLE9BQWIsQ0FBcUJDLEdBQXJCLEVBQTBCblQsS0FBMUIsRUFGSyxDQUU2QjtBQUNsQzs7QUFFQTRTLHdCQUFNTyxJQUFJSCxHQUFWO0FBQ0Q7O0FBRUQscUJBQUtzSyxTQUFMLENBQWVoaUIsSUFBZixDQUFvQixLQUFLNGdCLE9BQUwsQ0FBYS9CLElBQWIsQ0FBa0IsU0FBbEIsRUFBNkIsWUFBWTtBQUMzRDtBQUNBLHNCQUFJLENBQUN5SSxRQUFRMUcsT0FBUixDQUFnQnpILFNBQXJCLEVBQWdDO0FBQzlCbU8sNEJBQVExRCxVQUFSOztBQUVBMEQsNEJBQVE3RSxPQUFSLEdBQWtCLElBQWxCOztBQUVBNkUsNEJBQVFqYixTQUFSLENBQWtCLE9BQWxCO0FBQ0Q7QUFDRixpQkFUbUIsQ0FBcEIsRUFTSSxLQUFLdVUsT0FBTCxDQUFhL0IsSUFBYixDQUFrQixPQUFsQixFQUEyQixVQUFVMEksR0FBVixFQUFlO0FBQzVDLHlCQUFPRCxRQUFRamIsU0FBUixDQUFrQixPQUFsQixFQUEyQmtiLEdBQTNCLENBQVA7QUFDRCxpQkFGRyxDQVRKLEVBZm1FLENBMEI5RDs7QUFFTCxvQkFBSTdpQixLQUFKLEVBQVc7QUFDVCx1QkFBS2tjLE9BQUwsQ0FBYXdHLFFBQWIsQ0FBc0IxaUIsS0FBdEIsRUFBNkJxUixRQUE3QjtBQUNBLHVCQUFLNk4sVUFBTDtBQUNBLHVCQUFLdlgsU0FBTCxDQUFlLGdCQUFmO0FBQ0QsaUJBaENrRSxDQWdDakU7QUFDRjtBQUNBOzs7QUFHQSxvQkFBSSxDQUFDLENBQUMzSCxLQUFELElBQVUsS0FBS25OLE1BQUwsQ0FBWXdwQixXQUF2QixLQUF1QyxLQUFLSCxPQUFMLENBQWF5QixnQkFBYixFQUEzQyxFQUE0RTtBQUMxRSx1QkFBSzhFLGNBQUwsQ0FBb0I3UCxHQUFwQixFQUF5QixVQUFVNEssV0FBVixFQUF1QjtBQUM5Q29GLDRCQUFRcEIsaUJBQVIsQ0FBMEJoRSxXQUExQixFQUF1QyxVQUFVM0wsTUFBVixFQUFrQjtBQUN2RCtRLDhCQUFRMUcsT0FBUixDQUFnQnJLLE1BQWhCLEdBQXlCQSxNQUF6Qjs7QUFFQStRLDhCQUFRMUcsT0FBUixDQUFnQndHLFFBQWhCLENBQXlCLElBQXpCOztBQUVBRSw4QkFBUTFELFVBQVI7O0FBRUEwRCw4QkFBUWpiLFNBQVIsQ0FBa0IsZ0JBQWxCO0FBQ0QscUJBUkQ7QUFTRCxtQkFWRDtBQVdEO0FBQ0Y7QUFDRDs7Ozs7Ozs7QUFyREMsYUEvaUNzQixFQTRtQ3RCO0FBQ0R4SyxtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU3FxQixpQkFBVCxDQUEyQmhFLFdBQTNCLEVBQXdDdEQsUUFBeEMsRUFBa0Q7QUFDdkQsb0JBQUk0SSxVQUFVLElBQWQ7O0FBRUEscUJBQUt0RixXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLHFCQUFLdEIsT0FBTCxDQUFhc0YsaUJBQWIsQ0FBK0JoRSxXQUEvQixFQUE0QyxVQUFVaUUsSUFBVixFQUFnQjtBQUMxRDtBQUNBO0FBQ0Esc0JBQUksQ0FBQ3FCLFFBQVFoRixXQUFULElBQXdCZ0YsUUFBUXRGLFdBQVIsSUFBdUJBLFdBQW5ELEVBQWdFO0FBQzlEdEQsNkJBQVN1SCxJQUFUO0FBQ0FxQiw0QkFBUXRGLFdBQVIsR0FBc0IsSUFBdEI7QUFDRDtBQUNGLGlCQVBELEVBT0csWUFBWTtBQUNiLHlCQUFPc0YsUUFBUW5iLFNBQVIsQ0FBa0IsT0FBbEIsRUFBMkIsNEJBQTNCLENBQVA7QUFDRCxpQkFURDtBQVVEO0FBQ0Q7Ozs7Ozs7OztBQWpCQyxhQTVtQ3NCLEVBc29DdEI7QUFDRHhLLG1CQUFLLGdCQURKO0FBRURoRyxxQkFBTyxTQUFTc3JCLGNBQVQsQ0FBd0I3UCxHQUF4QixFQUE2QnNILFFBQTdCLEVBQXVDO0FBQzVDLG9CQUFJNkksVUFBVSxJQUFkOztBQUVBLG9CQUFJL0wsVUFBVSxTQUFjO0FBQzFCcEUsdUJBQUtBLEdBRHFCO0FBRTFCNEUsZ0NBQWM7QUFGWSxpQkFBZCxFQUdYLEtBQUsza0IsTUFBTCxDQUFZbXFCLEdBSEQsQ0FBZDtBQUlBLG9CQUFJZ0csVUFBVW5oQixLQUFLK1QsU0FBTCxDQUFlb0IsT0FBZixDQUFkO0FBQ0EscUJBQUt1RyxjQUFMLEdBQXNCeUYsT0FBdEI7QUFDQSxxQkFBSzFGLFNBQUwsQ0FBZWhpQixJQUFmLENBQW9CMG5CLFFBQVEvc0IsRUFBUixDQUFXLFVBQVgsRUFBdUIsVUFBVWlCLENBQVYsRUFBYTtBQUN0RDZyQiwwQkFBUXJNLFVBQVIsQ0FBbUJ4ZixDQUFuQjtBQUNELGlCQUZtQixDQUFwQixFQUVJOHJCLFFBQVEvc0IsRUFBUixDQUFXLFNBQVgsRUFBc0IsVUFBVXdyQixJQUFWLEVBQWdCO0FBQ3hDdkgsMkJBQVN1SCxJQUFUO0FBQ0FzQiwwQkFBUXhGLGNBQVIsR0FBeUIsSUFBekI7QUFDRCxpQkFIRyxDQUZKLEVBS0l5RixRQUFRL3NCLEVBQVIsQ0FBVyxPQUFYLEVBQW9CLFVBQVVpQixDQUFWLEVBQWE7QUFDbkM2ckIsMEJBQVFwYixTQUFSLENBQWtCLE9BQWxCLEVBQTJCelEsQ0FBM0I7O0FBRUE2ckIsMEJBQVF4RixjQUFSLEdBQXlCLElBQXpCO0FBQ0QsaUJBSkcsQ0FMSjtBQVVBLHVCQUFPeUYsT0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7O0FBdkJDLGFBdG9Dc0IsRUFxcUN0QjtBQUNEN2xCLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVN1ZixVQUFULENBQW9CeGYsQ0FBcEIsRUFBdUI7QUFDNUIsb0JBQUkrckIsZUFBSjs7QUFFQSxvQkFBSS9yQixFQUFFeWYsZ0JBQU4sRUFBd0I7QUFDdEJzTSxvQ0FBa0IvckIsRUFBRW9mLE1BQUYsR0FBV3BmLEVBQUVrZixLQUEvQjtBQUNELGlCQUZELE1BRU87QUFDTDtBQUNBO0FBQ0E2TSxvQ0FBa0IvckIsRUFBRW9mLE1BQUYsSUFBWXBmLEVBQUVvZixNQUFGLEdBQVcsT0FBdkIsQ0FBbEI7QUFDRDs7QUFFRCxxQkFBSzNPLFNBQUwsQ0FBZSxTQUFmLEVBQTBCdEgsS0FBS0MsS0FBTCxDQUFXMmlCLGtCQUFrQixHQUE3QixDQUExQixFQUE2RC9yQixFQUFFRSxNQUEvRDtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUFmQyxhQXJxQ3NCLEVBaXNDdEI7QUFDRCtGLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVMrckIsU0FBVCxDQUFtQm52QixNQUFuQixFQUEyQm92QixRQUEzQixFQUFxQ0MsUUFBckMsRUFBK0N4dUIsS0FBL0MsRUFBc0RDLEdBQXRELEVBQTJEO0FBQ2hFZCx5QkFBU0EsVUFBVSxJQUFuQjtBQUNBYSx3QkFBUUEsU0FBUyxDQUFqQjtBQUNBdXVCLDJCQUFXQSxZQUFZLEtBQXZCO0FBQ0FDLDJCQUFXQSxZQUFZLEtBQXZCO0FBQ0Esb0JBQUlwakIsUUFBUSxLQUFLa2MsT0FBTCxDQUFhL0gsUUFBYixDQUFzQnBnQixNQUF0QixFQUE4QmEsS0FBOUIsRUFBcUNDLEdBQXJDLENBQVo7QUFDQSxvQkFBSXFnQixNQUFNLEdBQUdsRyxHQUFILENBQU9qVSxJQUFQLENBQVlpRixLQUFaLEVBQW1CLFVBQVVoSSxHQUFWLEVBQWU7QUFDMUMseUJBQU9xSSxLQUFLQyxLQUFMLENBQVd0SSxNQUFNbXJCLFFBQWpCLElBQTZCQSxRQUFwQztBQUNELGlCQUZTLENBQVY7QUFHQSx1QkFBTyxJQUFJN2hCLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CK1MsTUFBbkIsRUFBMkI7QUFDNUMsc0JBQUksQ0FBQzhPLFFBQUwsRUFBZTtBQUNiLHdCQUFJQyxXQUFXLElBQUlDLElBQUosQ0FBUyxDQUFDQyxLQUFLQyxTQUFMLENBQWV0TyxHQUFmLENBQUQsQ0FBVCxFQUFnQztBQUM3QzlULDRCQUFNO0FBRHVDLHFCQUFoQyxDQUFmO0FBR0Esd0JBQUlxaUIsU0FBU0MsSUFBSUMsZUFBSixDQUFvQk4sUUFBcEIsQ0FBYjtBQUNBaEksMkJBQU91SSxJQUFQLENBQVlILE1BQVo7QUFDQUMsd0JBQUlHLGVBQUosQ0FBb0JKLE1BQXBCO0FBQ0Q7O0FBRURsaUIsMEJBQVEyVCxHQUFSO0FBQ0QsaUJBWE0sQ0FBUDtBQVlEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF4QkMsYUFqc0NzQixFQTR1Q3RCO0FBQ0QvWCxtQkFBSyxhQURKO0FBRURoRyxxQkFBTyxTQUFTMnNCLFdBQVQsQ0FBcUI1aUIsTUFBckIsRUFBNkJDLE9BQTdCLEVBQXNDQyxJQUF0QyxFQUE0QztBQUNqRCxvQkFBSSxDQUFDRixNQUFMLEVBQWE7QUFDWEEsMkJBQVMsV0FBVDtBQUNEOztBQUVELG9CQUFJLENBQUNDLE9BQUwsRUFBYztBQUNaQSw0QkFBVSxDQUFWO0FBQ0Q7O0FBRUQsb0JBQUksQ0FBQ0MsSUFBTCxFQUFXO0FBQ1RBLHlCQUFPLFNBQVA7QUFDRDs7QUFFRCx1QkFBTyxLQUFLcWMsTUFBTCxDQUFZeGMsUUFBWixDQUFxQkMsTUFBckIsRUFBNkJDLE9BQTdCLEVBQXNDQyxJQUF0QyxDQUFQO0FBQ0Q7QUFDRDs7OztBQWpCQyxhQTV1Q3NCLEVBaXdDdEI7QUFDRGpFLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVM0c0IsVUFBVCxHQUFzQjtBQUMzQixvQkFBSSxLQUFLeEcsY0FBTCxJQUF1QixLQUFLQSxjQUFMLENBQW9CaEgsVUFBL0MsRUFBMkQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esc0JBQUksS0FBS2dILGNBQUwsQ0FBb0J0SCxPQUF4QixFQUFpQztBQUMvQjtBQUNBLHlCQUFLc0gsY0FBTCxDQUFvQnRILE9BQXBCLENBQTRCK04sTUFBNUIsR0FBcUNqTixLQUFyQyxDQUEyQyxVQUFVOEwsR0FBVixFQUFlLENBQUUsQ0FBNUQ7QUFDRDs7QUFFRCx1QkFBS3RGLGNBQUwsQ0FBb0JoSCxVQUFwQixDQUErQjBOLEtBQS9CO0FBQ0EsdUJBQUsxRyxjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7QUFDRjtBQUNEOzs7O0FBaEJDLGFBandDc0IsRUFxeEN0QjtBQUNEcGdCLG1CQUFLLGdCQURKO0FBRURoRyxxQkFBTyxTQUFTK3NCLGNBQVQsR0FBMEI7QUFDL0IscUJBQUs1RyxTQUFMLENBQWUxUixPQUFmLENBQXVCLFVBQVUxVSxDQUFWLEVBQWE7QUFDbEMseUJBQU9BLEVBQUVnZCxFQUFGLEVBQVA7QUFDRCxpQkFGRDtBQUdEO0FBQ0Q7Ozs7QUFQQyxhQXJ4Q3NCLEVBZ3lDdEI7QUFDRC9XLG1CQUFLLE9BREo7QUFFRGhHLHFCQUFPLFNBQVM2cUIsS0FBVCxHQUFpQjtBQUN0QixvQkFBSSxDQUFDLEtBQUs5RixPQUFMLENBQWF4SixRQUFiLEVBQUwsRUFBOEI7QUFDNUIsdUJBQUtzTixJQUFMO0FBQ0EsdUJBQUs5RCxPQUFMLENBQWFpSSxnQkFBYjtBQUNEOztBQUVELHFCQUFLcEcsT0FBTCxHQUFlLEtBQWY7QUFDQSxxQkFBS2dHLFVBQUw7QUFDQSxxQkFBS0csY0FBTCxHQVJzQixDQVFDOztBQUV2QixxQkFBS3pHLE1BQUwsQ0FBWS9mLFFBQVosQ0FBcUIsQ0FBckI7QUFDQSxxQkFBSytmLE1BQUwsQ0FBWTVWLFFBQVosQ0FBcUIsQ0FBckI7QUFDQSxxQkFBSzRWLE1BQUwsQ0FBWTdWLFNBQVosQ0FBc0I7QUFDcEI3VCwwQkFBUSxLQUFLMHBCLE1BQUwsQ0FBWWhYLFFBQVo7QUFEWSxpQkFBdEIsRUFFRyxDQUZIO0FBR0Q7QUFDRDs7Ozs7O0FBbEJDLGFBaHlDc0IsRUF3ekN0QjtBQUNEdEosbUJBQUssU0FESjtBQUVEaEcscUJBQU8sU0FBUzZKLE9BQVQsR0FBbUI7QUFDeEIscUJBQUtpZSxpQkFBTDtBQUNBLHFCQUFLdFgsU0FBTCxDQUFlLFNBQWY7QUFDQSxxQkFBS29jLFVBQUw7QUFDQSxxQkFBS0csY0FBTDtBQUNBLHFCQUFLemEsS0FBTDs7QUFFQSxvQkFBSSxLQUFLNVcsTUFBTCxDQUFZd0IsVUFBWixLQUEyQixLQUEvQixFQUFzQztBQUNwQ2duQix5QkFBTzdJLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDLEtBQUt5TCxTQUExQyxFQUFxRCxJQUFyRDtBQUNBNUMseUJBQU83SSxtQkFBUCxDQUEyQixtQkFBM0IsRUFBZ0QsS0FBS3lMLFNBQXJELEVBQWdFLElBQWhFO0FBQ0Q7O0FBRUQsb0JBQUksS0FBSy9CLE9BQVQsRUFBa0I7QUFDaEIsdUJBQUtBLE9BQUwsQ0FBYWxiLE9BQWIsR0FEZ0IsQ0FDUTs7QUFFeEIsdUJBQUtrYixPQUFMLEdBQWUsSUFBZjtBQUNEOztBQUVELG9CQUFJLEtBQUt1QixNQUFULEVBQWlCO0FBQ2YsdUJBQUtBLE1BQUwsQ0FBWXpjLE9BQVo7QUFDRDs7QUFFRCxxQkFBSzhjLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxxQkFBS0MsT0FBTCxHQUFlLEtBQWY7QUFDQSxxQkFBS1AsV0FBTCxHQUFtQixJQUFuQjtBQUNEO0FBM0JBLGFBeHpDc0IsQ0FBekIsRUFvMUNJLENBQUM7QUFDSHJnQixtQkFBSyxRQURGO0FBRUhoRztBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FBT0EsdUJBQVN6RCxNQUFULENBQWdCYixNQUFoQixFQUF3QjtBQUN0QixvQkFBSW1CLGFBQWEsSUFBSUMsVUFBSixDQUFlcEIsTUFBZixDQUFqQjtBQUNBLHVCQUFPbUIsV0FBV0gsSUFBWCxFQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBbEJHLGFBQUQsQ0FwMUNKOztBQWkzQ0EsbUJBQU9JLFVBQVA7QUFDRCxXQTdsRDZCLENBNmxENUI0TixLQUFLaUksUUE3bER1QixDQUE5Qjs7QUErbERBblksa0JBQVEwSyxPQUFSLEdBQWtCcEksVUFBbEI7QUFDQUEscUJBQVdtd0IsT0FBWCxHQUFxQixPQUFyQjtBQUNBbndCLHFCQUFXNE4sSUFBWCxHQUFrQkEsSUFBbEI7QUFDQW5RLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQTN6SzhCOztBQTZ6S3JDLGFBQU07QUFDTjs7O0FBR0EsYUFBTyx1QkFBQzNLLE1BQUQsRUFBU0MsT0FBVCxFQUFrQnlLLG1CQUFsQixFQUEwQzs7QUFFakQ7O0FBR0EsbUJBQVNzRixPQUFULENBQWlCakYsR0FBakIsRUFBc0I7QUFBRTtBQUEyQixnQkFBSSxPQUFPa0YsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxTQUFPQSxPQUFPQyxRQUFkLE1BQTJCLFFBQS9ELEVBQXlFO0FBQUVGLHdCQUFVLFNBQVNBLE9BQVQsQ0FBaUJqRixHQUFqQixFQUFzQjtBQUFFLDhCQUFjQSxHQUFkLDBDQUFjQSxHQUFkO0FBQW9CLGVBQXREO0FBQXlELGFBQXBJLE1BQTBJO0FBQUVpRix3QkFBVSxTQUFTQSxPQUFULENBQWlCakYsR0FBakIsRUFBc0I7QUFBRSx1QkFBT0EsT0FBTyxPQUFPa0YsTUFBUCxLQUFrQixVQUF6QixJQUF1Q2xGLElBQUk3SSxXQUFKLEtBQW9CK04sTUFBM0QsSUFBcUVsRixRQUFRa0YsT0FBT2xPLFNBQXBGLEdBQWdHLFFBQWhHLFVBQWtIZ0osR0FBbEgsMENBQWtIQSxHQUFsSCxDQUFQO0FBQStILGVBQWpLO0FBQW9LLGFBQUMsT0FBT2lGLFFBQVFqRixHQUFSLENBQVA7QUFBc0I7O0FBRTFYekssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLGNBQUl3RixPQUFPQyx3QkFBd0IxRixxQkFBb0IsYUFBYyxxQkFBbEMsQ0FBeEIsQ0FBWDs7QUFFQSxtQkFBUzJGLHdCQUFULENBQWtDQyxXQUFsQyxFQUErQztBQUFFLGdCQUFJLE9BQU9DLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUMsT0FBTyxJQUFQLENBQWEsSUFBSUMsb0JBQW9CLElBQUlELE9BQUosRUFBeEIsQ0FBdUMsSUFBSUUsbUJBQW1CLElBQUlGLE9BQUosRUFBdkIsQ0FBc0MsT0FBTyxDQUFDRiwyQkFBMkIsU0FBU0Esd0JBQVQsQ0FBa0NDLFdBQWxDLEVBQStDO0FBQUUscUJBQU9BLGNBQWNHLGdCQUFkLEdBQWlDRCxpQkFBeEM7QUFBNEQsYUFBekksRUFBMklGLFdBQTNJLENBQVA7QUFBaUs7O0FBRS9VLG1CQUFTRix1QkFBVCxDQUFpQ3JGLEdBQWpDLEVBQXNDdUYsV0FBdEMsRUFBbUQ7QUFBRSxnQkFBSSxDQUFDQSxXQUFELElBQWdCdkYsR0FBaEIsSUFBdUJBLElBQUlDLFVBQS9CLEVBQTJDO0FBQUUscUJBQU9ELEdBQVA7QUFBYSxhQUFDLElBQUlBLFFBQVEsSUFBUixJQUFnQmlGLFFBQVFqRixHQUFSLE1BQWlCLFFBQWpCLElBQTZCLE9BQU9BLEdBQVAsS0FBZSxVQUFoRSxFQUE0RTtBQUFFLHFCQUFPLEVBQUVKLFNBQVNJLEdBQVgsRUFBUDtBQUEwQixhQUFDLElBQUkyRixRQUFRTCx5QkFBeUJDLFdBQXpCLENBQVosQ0FBbUQsSUFBSUksU0FBU0EsTUFBTUMsR0FBTixDQUFVNUYsR0FBVixDQUFiLEVBQTZCO0FBQUUscUJBQU8yRixNQUFNalEsR0FBTixDQUFVc0ssR0FBVixDQUFQO0FBQXdCLGFBQUMsSUFBSTZGLFNBQVMsRUFBYixDQUFpQixJQUFJQyx3QkFBd0J2USxPQUFPQyxjQUFQLElBQXlCRCxPQUFPd1Esd0JBQTVELENBQXNGLEtBQUssSUFBSXJGLEdBQVQsSUFBZ0JWLEdBQWhCLEVBQXFCO0FBQUUsa0JBQUlVLFFBQVEsU0FBUixJQUFxQm5MLE9BQU95QixTQUFQLENBQWlCZ1AsY0FBakIsQ0FBZ0MxSCxJQUFoQyxDQUFxQzBCLEdBQXJDLEVBQTBDVSxHQUExQyxDQUF6QixFQUF5RTtBQUFFLG9CQUFJdUYsT0FBT0gsd0JBQXdCdlEsT0FBT3dRLHdCQUFQLENBQWdDL0YsR0FBaEMsRUFBcUNVLEdBQXJDLENBQXhCLEdBQW9FLElBQS9FLENBQXFGLElBQUl1RixTQUFTQSxLQUFLdlEsR0FBTCxJQUFZdVEsS0FBS0MsR0FBMUIsQ0FBSixFQUFvQztBQUFFM1EseUJBQU9DLGNBQVAsQ0FBc0JxUSxNQUF0QixFQUE4Qm5GLEdBQTlCLEVBQW1DdUYsSUFBbkM7QUFBMkMsaUJBQWpGLE1BQXVGO0FBQUVKLHlCQUFPbkYsR0FBUCxJQUFjVixJQUFJVSxHQUFKLENBQWQ7QUFBeUI7QUFBRTtBQUFFLGFBQUNtRixPQUFPakcsT0FBUCxHQUFpQkksR0FBakIsQ0FBc0IsSUFBSTJGLEtBQUosRUFBVztBQUFFQSxvQkFBTU8sR0FBTixDQUFVbEcsR0FBVixFQUFlNkYsTUFBZjtBQUF5QixhQUFDLE9BQU9BLE1BQVA7QUFBZ0I7O0FBRXR5QixtQkFBUytoQixlQUFULENBQXlCNW5CLEdBQXpCLEVBQThCVSxHQUE5QixFQUFtQ2hHLEtBQW5DLEVBQTBDO0FBQUUsZ0JBQUlnRyxPQUFPVixHQUFYLEVBQWdCO0FBQUV6SyxxQkFBT0MsY0FBUCxDQUFzQndLLEdBQXRCLEVBQTJCVSxHQUEzQixFQUFnQyxFQUFFaEcsT0FBT0EsS0FBVCxFQUFnQmpGLFlBQVksSUFBNUIsRUFBa0MrSyxjQUFjLElBQWhELEVBQXNEQyxVQUFVLElBQWhFLEVBQWhDO0FBQTBHLGFBQTVILE1BQWtJO0FBQUVULGtCQUFJVSxHQUFKLElBQVdoRyxLQUFYO0FBQW1CLGFBQUMsT0FBT3NGLEdBQVA7QUFBYTs7QUFFak4sbUJBQVNFLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOLG1CQUFTZ0csU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQUUsZ0JBQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLG9CQUFNLElBQUlqRyxTQUFKLENBQWMsb0RBQWQsQ0FBTjtBQUE0RSxhQUFDZ0csU0FBU3BQLFNBQVQsR0FBcUJ6QixPQUFPMEIsTUFBUCxDQUFjb1AsY0FBY0EsV0FBV3JQLFNBQXZDLEVBQWtELEVBQUVHLGFBQWEsRUFBRXVELE9BQU8wTCxRQUFULEVBQW1CM0YsVUFBVSxJQUE3QixFQUFtQ0QsY0FBYyxJQUFqRCxFQUFmLEVBQWxELENBQXJCLENBQWtKLElBQUk2RixVQUFKLEVBQWdCQyxnQkFBZ0JGLFFBQWhCLEVBQTBCQyxVQUExQjtBQUF3Qzs7QUFFalksbUJBQVNDLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjtBQUFFRiw4QkFBa0IvUSxPQUFPa1IsY0FBUCxJQUF5QixTQUFTSCxlQUFULENBQXlCQyxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0I7QUFBRUQsZ0JBQUVHLFNBQUYsR0FBY0YsQ0FBZCxDQUFpQixPQUFPRCxDQUFQO0FBQVcsYUFBeEcsQ0FBMEcsT0FBT0QsZ0JBQWdCQyxDQUFoQixFQUFtQkMsQ0FBbkIsQ0FBUDtBQUErQjs7QUFFMUssbUJBQVNHLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCO0FBQUUsZ0JBQUlDLDRCQUE0QkMsMkJBQWhDLENBQTZELE9BQU8sU0FBU0Msb0JBQVQsR0FBZ0M7QUFBRSxrQkFBSUMsUUFBUUMsZ0JBQWdCTCxPQUFoQixDQUFaO0FBQUEsa0JBQXNDTSxNQUF0QyxDQUE4QyxJQUFJTCx5QkFBSixFQUErQjtBQUFFLG9CQUFJTSxZQUFZRixnQkFBZ0IsSUFBaEIsRUFBc0I5UCxXQUF0QyxDQUFtRCtQLFNBQVNFLFFBQVFDLFNBQVIsQ0FBa0JMLEtBQWxCLEVBQXlCTSxTQUF6QixFQUFvQ0gsU0FBcEMsQ0FBVDtBQUEwRCxlQUE5SSxNQUFvSjtBQUFFRCx5QkFBU0YsTUFBTU8sS0FBTixDQUFZLElBQVosRUFBa0JELFNBQWxCLENBQVQ7QUFBd0MsZUFBQyxPQUFPRSwyQkFBMkIsSUFBM0IsRUFBaUNOLE1BQWpDLENBQVA7QUFBa0QsYUFBeFU7QUFBMlU7O0FBRXphLG1CQUFTTSwwQkFBVCxDQUFvQ25RLElBQXBDLEVBQTBDaUgsSUFBMUMsRUFBZ0Q7QUFBRSxnQkFBSUEsU0FBUzJHLFFBQVEzRyxJQUFSLE1BQWtCLFFBQWxCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsVUFBdkQsQ0FBSixFQUF3RTtBQUFFLHFCQUFPQSxJQUFQO0FBQWMsYUFBQyxPQUFPbUosdUJBQXVCcFEsSUFBdkIsQ0FBUDtBQUFzQzs7QUFFakwsbUJBQVNvUSxzQkFBVCxDQUFnQ3BRLElBQWhDLEVBQXNDO0FBQUUsZ0JBQUlBLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUFFLG9CQUFNLElBQUlxUSxjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLGFBQUMsT0FBT3JRLElBQVA7QUFBYzs7QUFFdEssbUJBQVN5UCx5QkFBVCxHQUFxQztBQUFFLGdCQUFJLE9BQU9NLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0MsQ0FBQ0EsUUFBUUMsU0FBL0MsRUFBMEQsT0FBTyxLQUFQLENBQWMsSUFBSUQsUUFBUUMsU0FBUixDQUFrQk0sSUFBdEIsRUFBNEIsT0FBTyxLQUFQLENBQWMsSUFBSSxPQUFPQyxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDLE9BQU8sSUFBUCxDQUFhLElBQUk7QUFBRUMsc0JBQVE3USxTQUFSLENBQWtCOFEsT0FBbEIsQ0FBMEJ4SixJQUExQixDQUErQjhJLFFBQVFDLFNBQVIsQ0FBa0JRLE9BQWxCLEVBQTJCLEVBQTNCLEVBQStCLFlBQVksQ0FBRSxDQUE3QyxDQUEvQixFQUFnRixPQUFPLElBQVA7QUFBYyxhQUFwRyxDQUFxRyxPQUFPcE4sQ0FBUCxFQUFVO0FBQUUscUJBQU8sS0FBUDtBQUFlO0FBQUU7O0FBRXpVLG1CQUFTd00sZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRVUsOEJBQWtCMVIsT0FBT2tSLGNBQVAsR0FBd0JsUixPQUFPd1MsY0FBL0IsR0FBZ0QsU0FBU2QsZUFBVCxDQUF5QlYsQ0FBekIsRUFBNEI7QUFBRSxxQkFBT0EsRUFBRUcsU0FBRixJQUFlblIsT0FBT3dTLGNBQVAsQ0FBc0J4QixDQUF0QixDQUF0QjtBQUFpRCxhQUFqSixDQUFtSixPQUFPVSxnQkFBZ0JWLENBQWhCLENBQVA7QUFBNEI7O0FBRTdNO0FBQ0EsY0FBSXNoQixVQUFVLFNBQWQ7QUFDQSxjQUFJQyxTQUFTLFFBQWI7QUFDQSxjQUFJQyxXQUFXLFVBQWY7QUFDQTs7Ozs7O0FBTUEsY0FBSXRILFdBQVcsYUFBYSxVQUFVeFksY0FBVixFQUEwQjtBQUNwRDlCLHNCQUFVc2EsUUFBVixFQUFvQnhZLGNBQXBCOztBQUVBLGdCQUFJQyxTQUFTdkIsYUFBYThaLFFBQWIsQ0FBYjs7QUFFQTs7Ozs7QUFLQSxxQkFBU0EsUUFBVCxDQUFrQnJxQixNQUFsQixFQUEwQjtBQUN4QixrQkFBSTR4QixvQkFBSixFQUEwQkMsWUFBMUI7O0FBRUEsa0JBQUlyakIsS0FBSjs7QUFFQTFFLDhCQUFnQixJQUFoQixFQUFzQnVnQixRQUF0Qjs7QUFFQTdiLHNCQUFRc0QsT0FBTzVKLElBQVAsQ0FBWSxJQUFaLENBQVI7QUFDQTs7QUFFQXNHLG9CQUFNMmEsWUFBTixHQUFxQixJQUFyQjtBQUNBM2Esb0JBQU1zakIsbUJBQU4sR0FBNEIsSUFBNUI7QUFDQXRqQixvQkFBTXVqQixjQUFOLElBQXdCSCx1QkFBdUIsRUFBdkIsRUFBMkJKLGdCQUFnQkksb0JBQWhCLEVBQXNDSCxPQUF0QyxFQUErQztBQUNoR3p3QixzQkFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLHVCQUFLZ3hCLGlCQUFMO0FBQ0QsaUJBSCtGO0FBSWhHblIsbUNBQW1CLFNBQVNBLGlCQUFULEdBQTZCO0FBQzlDLHNCQUFJckMsV0FBVyxLQUFLL2EsV0FBTCxFQUFmO0FBQ0EseUJBQU8sS0FBS3FjLGNBQUwsS0FBd0J0QixRQUF4QixJQUFvQyxDQUEzQztBQUNELGlCQVArRjtBQVFoR3NCLGdDQUFnQixTQUFTQSxjQUFULEdBQTBCO0FBQ3hDLHlCQUFPLEtBQUttUyxhQUFMLEdBQXFCLEtBQUtDLGFBQUwsRUFBNUI7QUFDRDtBQVYrRixlQUEvQyxDQUEzQixFQVdwQlYsZ0JBQWdCSSxvQkFBaEIsRUFBc0NGLE1BQXRDLEVBQThDO0FBQ2hEMXdCLHNCQUFNLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsdUJBQUtteEIsb0JBQUw7QUFDRCxpQkFIK0M7QUFJaER0UixtQ0FBbUIsU0FBU0EsaUJBQVQsR0FBNkI7QUFDOUMsc0JBQUlyQyxXQUFXLEtBQUsvYSxXQUFMLEVBQWY7QUFDQSx5QkFBTyxLQUFLcWMsY0FBTCxLQUF3QnRCLFFBQXhCLElBQW9DLENBQTNDO0FBQ0QsaUJBUCtDO0FBUWhEc0IsZ0NBQWdCLFNBQVNBLGNBQVQsR0FBMEI7QUFDeEMseUJBQU8sS0FBS21TLGFBQVo7QUFDRDtBQVYrQyxlQUE5QyxDQVhvQixFQXNCcEJULGdCQUFnQkksb0JBQWhCLEVBQXNDRCxRQUF0QyxFQUFnRDtBQUNsRDN3QixzQkFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLHVCQUFLbXhCLG9CQUFMO0FBQ0EsdUJBQUtyZCxTQUFMLENBQWUsUUFBZjtBQUNELGlCQUppRDtBQUtsRCtMLG1DQUFtQixTQUFTQSxpQkFBVCxHQUE2QjtBQUM5Qyx5QkFBTyxDQUFQO0FBQ0QsaUJBUGlEO0FBUWxEZixnQ0FBZ0IsU0FBU0EsY0FBVCxHQUEwQjtBQUN4Qyx5QkFBTyxLQUFLcmMsV0FBTCxFQUFQO0FBQ0Q7QUFWaUQsZUFBaEQsQ0F0Qm9CLEVBaUNwQm11QixvQkFqQ0o7QUFrQ0FwakIsb0JBQU14TyxNQUFOLEdBQWVBLE1BQWY7QUFDQTs7QUFFQXdPLG9CQUFNdVAsRUFBTixHQUFXL2QsT0FBT21wQixZQUFQLEtBQXdCM2EsTUFBTXNjLGdCQUFOLEtBQTJCdGMsTUFBTTRqQixlQUFOLEVBQTNCLEdBQXFELEVBQTdFLENBQVg7QUFDQTs7QUFFQTVqQixvQkFBTTZqQixRQUFOLEdBQWlCN2pCLE1BQU11UCxFQUFOLENBQVNRLFdBQTFCO0FBQ0E7O0FBRUEvUCxvQkFBTXlqQixhQUFOLEdBQXNCLENBQXRCO0FBQ0E7O0FBRUF6akIsb0JBQU04akIsY0FBTixHQUF1QixJQUF2QjtBQUNBOztBQUVBOWpCLG9CQUFNK2pCLE1BQU4sSUFBZ0JWLGVBQWUsRUFBZixFQUFtQkwsZ0JBQWdCSyxZQUFoQixFQUE4QkosT0FBOUIsRUFBdUN0eUIsT0FBTzBCLE1BQVAsQ0FBYzJOLE1BQU11akIsY0FBTixDQUFxQk4sT0FBckIsQ0FBZCxDQUF2QyxDQUFuQixFQUF5R0QsZ0JBQWdCSyxZQUFoQixFQUE4QkgsTUFBOUIsRUFBc0N2eUIsT0FBTzBCLE1BQVAsQ0FBYzJOLE1BQU11akIsY0FBTixDQUFxQkwsTUFBckIsQ0FBZCxDQUF0QyxDQUF6RyxFQUE2TEYsZ0JBQWdCSyxZQUFoQixFQUE4QkYsUUFBOUIsRUFBd0N4eUIsT0FBTzBCLE1BQVAsQ0FBYzJOLE1BQU11akIsY0FBTixDQUFxQkosUUFBckIsQ0FBZCxDQUF4QyxDQUE3TCxFQUFxUkUsWUFBclM7QUFDQTs7QUFFQXJqQixvQkFBTXdRLE1BQU4sR0FBZSxJQUFmO0FBQ0E7O0FBRUF4USxvQkFBTWdmLE9BQU4sR0FBZ0IsRUFBaEI7QUFDQTs7QUFFQWhmLG9CQUFNZ2tCLFFBQU4sR0FBaUIsSUFBakI7QUFDQTs7QUFFQWhrQixvQkFBTWlrQixXQUFOLEdBQW9CLElBQXBCO0FBQ0E7O0FBRUFqa0Isb0JBQU1ra0IsU0FBTixHQUFrQixJQUFsQjtBQUNBOztBQUVBbGtCLG9CQUFNckIsS0FBTixHQUFjLElBQWQ7QUFDQTs7QUFFQXFCLG9CQUFNa1EsWUFBTixHQUFxQixDQUFyQjtBQUNBOztBQUVBbFEsb0JBQU15UCxRQUFOLEdBQWlCLElBQWpCO0FBQ0E7O0FBRUF6UCxvQkFBTW1rQixVQUFOLEdBQW1CLElBQW5CO0FBQ0E7O0FBRUFua0Isb0JBQU1va0IsTUFBTixHQUFlLElBQWY7QUFDQTs7QUFFQXBrQixvQkFBTXFrQixVQUFOLEdBQW1CLEVBQW5CO0FBQ0E7O0FBRUFya0Isb0JBQU1za0IsS0FBTixHQUFjLElBQWQ7QUFDQTs7QUFFQXRrQixvQkFBTWtTLGdCQUFOLEdBQXlCMWdCLE9BQU93ZSxRQUFoQztBQUNBOzs7O0FBSUFoUSxvQkFBTW9ULFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxxQkFBT3BULEtBQVA7QUFDRDtBQUNEOzs7O0FBS0FqRSx5QkFBYThmLFFBQWIsRUFBdUIsQ0FBQztBQUN0Qi9mLG1CQUFLLGtCQURpQjtBQUV0QmhHO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7O0FBS0EsdUJBQVN3bUIsZ0JBQVQsR0FBNEI7QUFDMUIsdUJBQU8sQ0FBQyxFQUFFdEMsT0FBT3VLLFlBQVAsSUFBdUJ2SyxPQUFPd0ssa0JBQWhDLENBQVI7QUFDRDtBQUNEOzs7Ozs7QUFuQnNCLGFBQUQsRUF5QnBCO0FBQ0Qxb0IsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVM4dEIsZUFBVCxHQUEyQjtBQUNoQyxvQkFBSSxDQUFDNUosT0FBT3lLLHNCQUFaLEVBQW9DO0FBQ2xDeksseUJBQU95SyxzQkFBUCxHQUFnQyxLQUFLekssT0FBT3VLLFlBQVAsSUFBdUJ2SyxPQUFPd0ssa0JBQW5DLEdBQWhDO0FBQ0Q7O0FBRUQsdUJBQU94SyxPQUFPeUssc0JBQWQ7QUFDRDtBQUNEOzs7Ozs7OztBQVRDLGFBekJvQixFQTBDcEI7QUFDRDNvQixtQkFBSyx3QkFESjtBQUVEaEcscUJBQU8sU0FBUzR1QixzQkFBVCxDQUFnQ0MsVUFBaEMsRUFBNEM7QUFDakQsb0JBQUksQ0FBQzNLLE9BQU80Syw2QkFBWixFQUEyQztBQUN6QzVLLHlCQUFPNEssNkJBQVAsR0FBdUMsS0FBSzVLLE9BQU82SyxtQkFBUCxJQUE4QjdLLE9BQU84Syx5QkFBMUMsRUFBcUUsQ0FBckUsRUFBd0UsQ0FBeEUsRUFBMkVILFVBQTNFLENBQXZDO0FBQ0Q7O0FBRUQsdUJBQU8zSyxPQUFPNEssNkJBQWQ7QUFDRDtBQVJBLGFBMUNvQixFQW1EcEI7QUFDRDlvQixtQkFBSyxNQURKO0FBRURoRyxxQkFBTyxTQUFTdEQsSUFBVCxHQUFnQjtBQUNyQixxQkFBS3VjLGdCQUFMO0FBQ0EscUJBQUtDLGdCQUFMO0FBQ0EscUJBQUtDLGtCQUFMO0FBQ0EscUJBQUs4VixRQUFMLENBQWM3QixNQUFkO0FBQ0EscUJBQUt0VSxlQUFMLENBQXFCLEtBQUtwZCxNQUFMLENBQVlxZCxTQUFqQztBQUNBLHFCQUFLbVcsU0FBTCxDQUFlLENBQWY7QUFDRDtBQUNEOztBQVZDLGFBbkRvQixFQStEcEI7QUFDRGxwQixtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU212QixpQkFBVCxHQUE2QjtBQUNsQyxvQkFBSSxLQUFLakcsT0FBVCxFQUFrQjtBQUNoQix1QkFBS0EsT0FBTCxDQUFhelUsT0FBYixDQUFxQixVQUFVK0MsTUFBVixFQUFrQjtBQUNyQ0EsOEJBQVVBLE9BQU80WCxVQUFQLEVBQVY7QUFDRCxtQkFGRDtBQUdBLHVCQUFLbEcsT0FBTCxHQUFlLElBQWYsQ0FKZ0IsQ0FJSzs7QUFFckIsdUJBQUt2UCxRQUFMLENBQWNELE9BQWQsQ0FBc0IsS0FBS3dVLFFBQTNCO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7QUFaQyxhQS9Eb0IsRUFpRnBCO0FBQ0Rsb0IsbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBU2l2QixRQUFULENBQWtCVCxLQUFsQixFQUF5QjtBQUM5QixvQkFBSSxLQUFLQSxLQUFMLEtBQWUsS0FBS1AsTUFBTCxDQUFZTyxLQUFaLENBQW5CLEVBQXVDO0FBQ3JDLHVCQUFLQSxLQUFMLEdBQWEsS0FBS1AsTUFBTCxDQUFZTyxLQUFaLENBQWI7QUFDQSx1QkFBS0EsS0FBTCxDQUFXOXhCLElBQVgsQ0FBZ0JrSCxJQUFoQixDQUFxQixJQUFyQjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7O0FBUkMsYUFqRm9CLEVBK0ZwQjtBQUNEb0MsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU3F2QixTQUFULEdBQXFCO0FBQzFCLHFCQUFLLElBQUkzTixPQUFPOVUsVUFBVWhRLE1BQXJCLEVBQTZCc3NCLFVBQVUsSUFBSTdSLEtBQUosQ0FBVXFLLElBQVYsQ0FBdkMsRUFBd0RFLE9BQU8sQ0FBcEUsRUFBdUVBLE9BQU9GLElBQTlFLEVBQW9GRSxNQUFwRixFQUE0RjtBQUMxRnNILDBCQUFRdEgsSUFBUixJQUFnQmhWLFVBQVVnVixJQUFWLENBQWhCO0FBQ0Q7O0FBRUQscUJBQUswTixVQUFMLENBQWdCcEcsT0FBaEI7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFUQyxhQS9Gb0IsRUFpSHBCO0FBQ0RsakIsbUJBQUssWUFESjtBQUVEaEcscUJBQU8sU0FBU3N2QixVQUFULENBQW9CcEcsT0FBcEIsRUFBNkI7QUFDbEM7QUFDQSxxQkFBS2lHLGlCQUFMLEdBRmtDLENBRVI7O0FBRTFCLG9CQUFJakcsV0FBV0EsUUFBUXRzQixNQUF2QixFQUErQjtBQUM3Qix1QkFBS3NzQixPQUFMLEdBQWVBLE9BQWYsQ0FENkIsQ0FDTDs7QUFFeEIsdUJBQUt2UCxRQUFMLENBQWN5VixVQUFkLEdBSDZCLENBR0Q7O0FBRTVCbEcsMEJBQVFxRyxNQUFSLENBQWUsVUFBVUMsSUFBVixFQUFnQkMsSUFBaEIsRUFBc0I7QUFDbkNELHlCQUFLOVYsT0FBTCxDQUFhK1YsSUFBYjtBQUNBLDJCQUFPQSxJQUFQO0FBQ0QsbUJBSEQsRUFHRyxLQUFLOVYsUUFIUixFQUdrQkQsT0FIbEIsQ0FHMEIsS0FBS3dVLFFBSC9CO0FBSUQ7QUFDRjtBQUNEOztBQWpCQyxhQWpIb0IsRUFvSXBCO0FBQ0Rsb0IsbUJBQUssa0JBREo7QUFFRGhHLHFCQUFPLFNBQVNrWixnQkFBVCxHQUE0QjtBQUNqQyxvQkFBSSxLQUFLeGQsTUFBTCxDQUFZb3BCLG9CQUFoQixFQUFzQztBQUNwQyx1QkFBS3VKLFVBQUwsR0FBa0IsS0FBSzN5QixNQUFMLENBQVlvcEIsb0JBQTlCO0FBQ0QsaUJBRkQsTUFFTztBQUNMLHNCQUFJLEtBQUtyTCxFQUFMLENBQVFpVyxxQkFBWixFQUFtQztBQUNqQyx5QkFBS3JCLFVBQUwsR0FBa0IsS0FBSzVVLEVBQUwsQ0FBUWlXLHFCQUFSLENBQThCM0osU0FBUzRKLGdCQUF2QyxDQUFsQjtBQUNELG1CQUZELE1BRU87QUFDTCx5QkFBS3RCLFVBQUwsR0FBa0IsS0FBSzVVLEVBQUwsQ0FBUW1XLG9CQUFSLENBQTZCN0osU0FBUzRKLGdCQUF0QyxDQUFsQjtBQUNEO0FBQ0Y7O0FBRUQscUJBQUt0QixVQUFMLENBQWdCM1UsT0FBaEIsQ0FBd0IsS0FBS0QsRUFBTCxDQUFRb1csV0FBaEM7QUFDRDtBQUNEOztBQWZDLGFBcElvQixFQXFKcEI7QUFDRDdwQixtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBUzB0QixpQkFBVCxHQUE2QjtBQUNsQyxvQkFBSTFkLFNBQVMsSUFBYjs7QUFFQSxxQkFBS3FlLFVBQUwsQ0FBZ0J5QixjQUFoQixHQUFpQyxZQUFZO0FBQzNDLHNCQUFJaFQsT0FBTzlNLE9BQU93TCxjQUFQLEVBQVg7O0FBRUEsc0JBQUlzQixRQUFROU0sT0FBTzdRLFdBQVAsRUFBWixFQUFrQztBQUNoQzZRLDJCQUFPaWYsUUFBUCxDQUFnQjVCLFFBQWhCOztBQUVBcmQsMkJBQU9RLFNBQVAsQ0FBaUIsT0FBakI7QUFDRCxtQkFKRCxNQUlPLElBQUlzTSxRQUFROU0sT0FBT2dlLGNBQW5CLEVBQW1DO0FBQ3hDaGUsMkJBQU9xSyxLQUFQO0FBQ0QsbUJBRk0sTUFFQSxJQUFJckssT0FBT3dlLEtBQVAsS0FBaUJ4ZSxPQUFPaWUsTUFBUCxDQUFjZCxPQUFkLENBQXJCLEVBQTZDO0FBQ2xEbmQsMkJBQU9RLFNBQVAsQ0FBaUIsY0FBakIsRUFBaUNzTSxJQUFqQztBQUNEO0FBQ0YsaUJBWkQ7QUFhRDtBQUNEOztBQW5CQyxhQXJKb0IsRUEwS3BCO0FBQ0Q5VyxtQkFBSyxzQkFESjtBQUVEaEcscUJBQU8sU0FBUzZ0QixvQkFBVCxHQUFnQztBQUNyQyxxQkFBS1EsVUFBTCxDQUFnQnlCLGNBQWhCLEdBQWlDLElBQWpDO0FBQ0Q7QUFDRDs7QUFMQyxhQTFLb0IsRUFpTHBCO0FBQ0Q5cEIsbUJBQUssb0JBREo7QUFFRGhHLHFCQUFPLFNBQVNtWixrQkFBVCxHQUE4QjtBQUNuQyxxQkFBS1EsUUFBTCxHQUFnQixLQUFLRixFQUFMLENBQVFzVyxjQUFSLEVBQWhCO0FBQ0EscUJBQUtwVyxRQUFMLENBQWNELE9BQWQsQ0FBc0IsS0FBS3dVLFFBQTNCO0FBQ0Q7QUFDRDs7Ozs7QUFOQyxhQWpMb0IsRUE0THBCO0FBQ0Rsb0IsbUJBQUssa0JBREo7QUFFRGhHLHFCQUFPLFNBQVNpWixnQkFBVCxHQUE0QjtBQUNqQztBQUNBLG9CQUFJLEtBQUtRLEVBQUwsQ0FBUXVXLFVBQVosRUFBd0I7QUFDdEIsdUJBQUs5QixRQUFMLEdBQWdCLEtBQUt6VSxFQUFMLENBQVF1VyxVQUFSLEVBQWhCO0FBQ0QsaUJBRkQsTUFFTztBQUNMLHVCQUFLOUIsUUFBTCxHQUFnQixLQUFLelUsRUFBTCxDQUFRd1csY0FBUixFQUFoQjtBQUNELGlCQU5nQyxDQU0vQjs7O0FBR0YscUJBQUsvQixRQUFMLENBQWN4VSxPQUFkLENBQXNCLEtBQUtELEVBQUwsQ0FBUW9XLFdBQTlCO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFiQyxhQTVMb0IsRUFpTnBCO0FBQ0Q3cEIsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU2lkLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCO0FBQ2xDLG9CQUFJQSxRQUFKLEVBQWM7QUFDWjs7Ozs7QUFLQSxzQkFBSWdULFFBQVEsSUFBSWhNLE9BQU9pTSxLQUFYLEVBQVo7O0FBRUEsc0JBQUksQ0FBQ0QsTUFBTWpULFNBQVgsRUFBc0I7QUFDcEIsMkJBQU85UyxRQUFRZ1QsTUFBUixDQUFlLElBQUlqQixLQUFKLENBQVUsNENBQVYsQ0FBZixDQUFQO0FBQ0Q7O0FBRURnVSx3QkFBTXRVLFFBQU4sR0FBaUIsSUFBakI7QUFDQSxzQkFBSXdVLE9BQU8sS0FBSzNXLEVBQUwsQ0FBUTRXLDRCQUFSLEVBQVg7QUFDQSx1QkFBS25DLFFBQUwsQ0FBY2tCLFVBQWQ7QUFDQSx1QkFBS2xCLFFBQUwsQ0FBY3hVLE9BQWQsQ0FBc0IwVyxJQUF0QjtBQUNBRix3QkFBTUksU0FBTixHQUFrQkYsS0FBS0csTUFBdkI7QUFDQSx5QkFBT0wsTUFBTWpULFNBQU4sQ0FBZ0JDLFFBQWhCLENBQVA7QUFDRCxpQkFsQkQsTUFrQk87QUFDTCx5QkFBTy9TLFFBQVFnVCxNQUFSLENBQWUsSUFBSWpCLEtBQUosQ0FBVSx1QkFBdUJnQixRQUFqQyxDQUFmLENBQVA7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQXpCQyxhQWpOb0IsRUFnUHBCO0FBQ0RsWCxtQkFBSyxXQURKO0FBRURoRyxxQkFBTyxTQUFTbWMsU0FBVCxDQUFtQm5jLEtBQW5CLEVBQTBCO0FBQy9CLHFCQUFLa3VCLFFBQUwsQ0FBY3NDLElBQWQsQ0FBbUJDLGNBQW5CLENBQWtDendCLEtBQWxDLEVBQXlDLEtBQUt5WixFQUFMLENBQVFRLFdBQWpEO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUFoUG9CLEVBMlBwQjtBQUNEalUsbUJBQUssV0FESjtBQUVEaEcscUJBQU8sU0FBU29kLFNBQVQsR0FBcUI7QUFDMUIsdUJBQU8sS0FBSzhRLFFBQUwsQ0FBY3NDLElBQWQsQ0FBbUJ4d0IsS0FBMUI7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFMQyxhQTNQb0IsRUF5UXBCO0FBQ0RnRyxtQkFBSyxtQkFESjtBQUVEaEcscUJBQU8sU0FBU3FxQixpQkFBVCxDQUEyQmhFLFdBQTNCLEVBQXdDdEQsUUFBeEMsRUFBa0QyTixPQUFsRCxFQUEyRDtBQUNoRSxvQkFBSSxDQUFDLEtBQUt0QyxTQUFWLEVBQXFCO0FBQ25CLHVCQUFLQSxTQUFMLEdBQWlCLEtBQUtRLHNCQUFMLENBQTRCLEtBQUtuVixFQUFMLElBQVcsS0FBS0EsRUFBTCxDQUFRb1YsVUFBbkIsR0FBZ0MsS0FBS3BWLEVBQUwsQ0FBUW9WLFVBQXhDLEdBQXFELEtBQWpGLENBQWpCO0FBQ0Q7O0FBRUQsb0JBQUksd0JBQXdCM0ssTUFBNUIsRUFBb0M7QUFDbEM7QUFDQTtBQUNBLHVCQUFLa0ssU0FBTCxDQUFldUMsZUFBZixDQUErQnRLLFdBQS9CLEVBQTRDLFVBQVVpRSxJQUFWLEVBQWdCO0FBQzFELDJCQUFPdkgsU0FBU3VILElBQVQsQ0FBUDtBQUNELG1CQUZELEVBRUdvRyxPQUZIO0FBR0QsaUJBTkQsTUFNTztBQUNMLHVCQUFLdEMsU0FBTCxDQUFldUMsZUFBZixDQUErQnRLLFdBQS9CLEVBQTRDL0csSUFBNUMsQ0FBaUQsVUFBVWdMLElBQVYsRUFBZ0I7QUFDL0QsMkJBQU92SCxTQUFTdUgsSUFBVCxDQUFQO0FBQ0QsbUJBRkQsRUFFRzFLLEtBRkgsQ0FFUyxVQUFVOEwsR0FBVixFQUFlO0FBQ3RCLDJCQUFPZ0YsUUFBUWhGLEdBQVIsQ0FBUDtBQUNELG1CQUpEO0FBS0Q7QUFDRjtBQUNEOzs7Ozs7O0FBckJDLGFBelFvQixFQXFTcEI7QUFDRDFsQixtQkFBSyxVQURKO0FBRURoRyxxQkFBTyxTQUFTdXJCLFFBQVQsQ0FBa0IxaUIsS0FBbEIsRUFBeUJxUixRQUF6QixFQUFtQztBQUN4QyxvQkFBSUEsWUFBWSxJQUFoQixFQUFzQjtBQUNwQix1QkFBS2tDLGdCQUFMLEdBQXdCbEMsUUFBeEI7QUFDRDs7QUFFRCxxQkFBS3JSLEtBQUwsR0FBYUEsS0FBYjtBQUNEO0FBQ0Q7Ozs7OztBQVRDLGFBclNvQixFQW9UcEI7QUFDRDdDLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVNrdkIsU0FBVCxDQUFtQnR5QixNQUFuQixFQUEyQjtBQUNoQztBQUNBLG9CQUFJLEtBQUt1eEIsV0FBTCxJQUFvQnZ4QixVQUFVLElBQUksS0FBS3V4QixXQUFMLENBQWlCdnhCLE1BQXJCLEdBQThCLENBQTlCLEdBQWtDLENBQXBFLEVBQXVFO0FBQ3JFO0FBQ0Q7O0FBRUQscUJBQUsyeEIsVUFBTCxHQUFrQixFQUFsQjtBQUNBLHFCQUFLSixXQUFMLEdBQW1CLEVBQW5CLENBUGdDLENBT1Q7QUFDdkI7O0FBRUEsb0JBQUk3VyxXQUFXLEtBQUtvRCxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZa1csZ0JBQTFCLEdBQTZDLENBQTVEO0FBQ0Esb0JBQUluWixDQUFKOztBQUVBLHFCQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSUgsUUFBaEIsRUFBMEJHLEdBQTFCLEVBQStCO0FBQzdCLHVCQUFLOFcsVUFBTCxDQUFnQjlXLENBQWhCLElBQXFCLEVBQXJCO0FBQ0EsdUJBQUs4VyxVQUFMLENBQWdCOVcsQ0FBaEIsRUFBbUIsS0FBSzdhLFNBQVMsQ0FBZCxDQUFuQixJQUF1QyxDQUF2QztBQUNBLHVCQUFLMnhCLFVBQUwsQ0FBZ0I5VyxDQUFoQixFQUFtQixLQUFLN2EsU0FBUyxDQUFkLElBQW1CLENBQXRDLElBQTJDLENBQTNDO0FBQ0Q7O0FBRUQscUJBQUt1eEIsV0FBTCxDQUFpQixLQUFLdnhCLFNBQVMsQ0FBZCxDQUFqQixJQUFxQyxDQUFyQztBQUNBLHFCQUFLdXhCLFdBQUwsQ0FBaUIsS0FBS3Z4QixTQUFTLENBQWQsSUFBbUIsQ0FBcEMsSUFBeUMsQ0FBekM7QUFDRDtBQUNEOzs7Ozs7Ozs7O0FBeEJDLGFBcFRvQixFQXNWcEI7QUFDRG9KLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVNnZCxRQUFULENBQWtCcGdCLE1BQWxCLEVBQTBCb0UsS0FBMUIsRUFBaUNvSSxJQUFqQyxFQUF1QztBQUM1QyxvQkFBSSxLQUFLUCxLQUFULEVBQWdCO0FBQ2QseUJBQU8sS0FBS0EsS0FBWjtBQUNEOztBQUVELG9CQUFJLENBQUMsS0FBSzZSLE1BQVYsRUFBa0I7QUFDaEIseUJBQU8sRUFBUDtBQUNEOztBQUVEMVosd0JBQVFBLFNBQVMsQ0FBakI7QUFDQW9JLHVCQUFPQSxRQUFReE0sU0FBUyxDQUF4QjtBQUNBLHFCQUFLc3lCLFNBQUwsQ0FBZXR5QixNQUFmOztBQUVBLG9CQUFJLENBQUMsS0FBSzhkLE1BQVYsRUFBa0I7QUFDaEIseUJBQU8sS0FBS2hmLE1BQUwsQ0FBWW9iLGFBQVosR0FBNEIsS0FBS3lYLFVBQWpDLEdBQThDLEtBQUtKLFdBQTFEO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFTQSxvQkFBSSxDQUFDLEtBQUt6VCxNQUFMLENBQVk5ZCxNQUFqQixFQUF5QjtBQUN2QixzQkFBSWkwQixZQUFZLEtBQUtDLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIsSUFBckIsRUFBMkIsS0FBS2pDLFVBQWhDLENBQWhCO0FBQ0EsdUJBQUtuVSxNQUFMLEdBQWNtVyxVQUFVblcsTUFBeEI7QUFDRDs7QUFFRCxvQkFBSXFXLGFBQWEsS0FBS3JXLE1BQUwsQ0FBWTlkLE1BQVosR0FBcUJBLE1BQXRDO0FBQ0Esb0JBQUlvMEIsYUFBYSxDQUFDLEVBQUVELGFBQWEsRUFBZixDQUFELElBQXVCLENBQXhDO0FBQ0Esb0JBQUl6WixXQUFXLEtBQUtvRCxNQUFMLENBQVlrVyxnQkFBM0I7QUFDQSxvQkFBSW5aLENBQUo7O0FBRUEscUJBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJSCxRQUFoQixFQUEwQkcsR0FBMUIsRUFBK0I7QUFDN0Isc0JBQUk1TyxRQUFRLEtBQUswbEIsVUFBTCxDQUFnQjlXLENBQWhCLENBQVo7QUFDQSxzQkFBSXdaLE9BQU8sS0FBS3ZXLE1BQUwsQ0FBWXdXLGNBQVosQ0FBMkJ6WixDQUEzQixDQUFYO0FBQ0Esc0JBQUl2YyxJQUFJLEtBQUssQ0FBYjs7QUFFQSx1QkFBS0EsSUFBSThGLEtBQVQsRUFBZ0I5RixLQUFLa08sSUFBckIsRUFBMkJsTyxHQUEzQixFQUFnQztBQUM5Qix3QkFBSXVDLFFBQVEsQ0FBQyxFQUFFdkMsSUFBSTYxQixVQUFOLENBQWI7QUFDQSx3QkFBSXJ6QixNQUFNLENBQUMsRUFBRUQsUUFBUXN6QixVQUFWLENBQVg7QUFDQTs7Ozs7OztBQU9BLHdCQUFJcmYsTUFBTXVmLEtBQUt4ekIsS0FBTCxDQUFWO0FBQ0Esd0JBQUlnVSxNQUFNQyxHQUFWO0FBQ0Esd0JBQUl0TyxJQUFJLEtBQUssQ0FBYjs7QUFFQSx5QkFBS0EsSUFBSTNGLEtBQVQsRUFBZ0IyRixJQUFJMUYsR0FBcEIsRUFBeUIwRixLQUFLNHRCLFVBQTlCLEVBQTBDO0FBQ3hDLDBCQUFJaHhCLFFBQVFpeEIsS0FBSzd0QixDQUFMLENBQVo7O0FBRUEsMEJBQUlwRCxRQUFReVIsR0FBWixFQUFpQjtBQUNmQSw4QkFBTXpSLEtBQU47QUFDRDs7QUFFRCwwQkFBSUEsUUFBUTBSLEdBQVosRUFBaUI7QUFDZkEsOEJBQU0xUixLQUFOO0FBQ0Q7QUFDRjs7QUFFRDZJLDBCQUFNLElBQUkzTixDQUFWLElBQWV1VyxHQUFmO0FBQ0E1SSwwQkFBTSxJQUFJM04sQ0FBSixHQUFRLENBQWQsSUFBbUJ3VyxHQUFuQjs7QUFFQSx3QkFBSStGLEtBQUssQ0FBTCxJQUFVaEcsTUFBTSxLQUFLMGMsV0FBTCxDQUFpQixJQUFJanpCLENBQXJCLENBQXBCLEVBQTZDO0FBQzNDLDJCQUFLaXpCLFdBQUwsQ0FBaUIsSUFBSWp6QixDQUFyQixJQUEwQnVXLEdBQTFCO0FBQ0Q7O0FBRUQsd0JBQUlnRyxLQUFLLENBQUwsSUFBVS9GLE1BQU0sS0FBS3ljLFdBQUwsQ0FBaUIsSUFBSWp6QixDQUFKLEdBQVEsQ0FBekIsQ0FBcEIsRUFBaUQ7QUFDL0MsMkJBQUtpekIsV0FBTCxDQUFpQixJQUFJanpCLENBQUosR0FBUSxDQUF6QixJQUE4QndXLEdBQTlCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELHVCQUFPLEtBQUtoVyxNQUFMLENBQVlvYixhQUFaLEdBQTRCLEtBQUt5WCxVQUFqQyxHQUE4QyxLQUFLSixXQUExRDtBQUNEO0FBQ0Q7Ozs7OztBQW5GQyxhQXRWb0IsRUErYXBCO0FBQ0Rub0IsbUJBQUssbUJBREo7QUFFRGhHLHFCQUFPLFNBQVN1YyxpQkFBVCxHQUE2QjtBQUNsQyx1QkFBTyxLQUFLaVMsS0FBTCxDQUFXalMsaUJBQVgsQ0FBNkIzWSxJQUE3QixDQUFrQyxJQUFsQyxDQUFQO0FBQ0Q7QUFDRDs7QUFMQyxhQS9hb0IsRUFzYnBCO0FBQ0RvQyxtQkFBSyxrQkFESjtBQUVEaEcscUJBQU8sU0FBU2d0QixnQkFBVCxHQUE0QjtBQUNqQyxvQkFBSSxLQUFLc0IsTUFBVCxFQUFpQjtBQUNmLHVCQUFLQSxNQUFMLENBQVljLFVBQVo7QUFDRDtBQUNGO0FBQ0Q7Ozs7QUFQQyxhQXRib0IsRUFpY3BCO0FBQ0RwcEIsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVM2WixlQUFULEdBQTJCO0FBQ2hDLHFCQUFLc1YsaUJBQUw7QUFDQSxxQkFBS25DLGdCQUFMO0FBQ0EscUJBQUtrQixRQUFMLENBQWNrQixVQUFkO0FBQ0EscUJBQUtmLFVBQUwsQ0FBZ0JlLFVBQWhCO0FBQ0EscUJBQUt6VixRQUFMLENBQWN5VixVQUFkLEdBTGdDLENBS0o7O0FBRTVCLG9CQUFJLEtBQUsxekIsTUFBTCxDQUFZeTFCLGlCQUFoQixFQUFtQztBQUNqQztBQUNBLHNCQUFJLE9BQU8sS0FBSzFYLEVBQUwsQ0FBUWdHLEtBQWYsS0FBeUIsVUFBekIsSUFBdUMsS0FBS2hHLEVBQUwsQ0FBUStVLEtBQVIsSUFBaUIsUUFBNUQsRUFBc0U7QUFDcEUseUJBQUsvVSxFQUFMLENBQVFnRyxLQUFSO0FBQ0QsbUJBSmdDLENBSS9COzs7QUFHRix1QkFBS2hHLEVBQUwsR0FBVSxJQUFWLENBUGlDLENBT2pCO0FBQ2hCOztBQUVBLHNCQUFJLENBQUMsS0FBSy9kLE1BQUwsQ0FBWW1wQixZQUFqQixFQUErQjtBQUM3QlgsMkJBQU95SyxzQkFBUCxHQUFnQyxJQUFoQztBQUNELG1CQUZELE1BRU87QUFDTCx5QkFBS2p6QixNQUFMLENBQVltcEIsWUFBWixHQUEyQixJQUEzQjtBQUNELG1CQWRnQyxDQWMvQjs7O0FBR0ZYLHlCQUFPNEssNkJBQVAsR0FBdUMsSUFBdkM7QUFDRDtBQUNGO0FBQ0Q7Ozs7QUE3QkMsYUFqY29CLEVBa2VwQjtBQUNEOW9CLG1CQUFLLFNBREo7QUFFRGhHLHFCQUFPLFNBQVM2SixPQUFULEdBQW1CO0FBQ3hCLG9CQUFJLENBQUMsS0FBSzBSLFFBQUwsRUFBTCxFQUFzQjtBQUNwQix1QkFBS2xCLEtBQUw7QUFDRDs7QUFFRCxxQkFBSy9ILEtBQUw7QUFDQSxxQkFBS29JLE1BQUwsR0FBYyxJQUFkO0FBQ0EscUJBQUs0QyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EscUJBQUt6RCxlQUFMO0FBQ0Q7QUFDRDs7Ozs7O0FBWkMsYUFsZW9CLEVBb2ZwQjtBQUNEN1QsbUJBQUssTUFESjtBQUVEaEcscUJBQU8sU0FBU3JCLElBQVQsQ0FBYytiLE1BQWQsRUFBc0I7QUFDM0IscUJBQUtpVCxhQUFMLEdBQXFCLENBQXJCO0FBQ0EscUJBQUtJLFFBQUwsR0FBZ0IsS0FBS3RVLEVBQUwsQ0FBUVEsV0FBeEI7QUFDQSxxQkFBS1MsTUFBTCxHQUFjQSxNQUFkO0FBQ0EscUJBQUswVyxZQUFMO0FBQ0Q7QUFDRDs7QUFSQyxhQXBmb0IsRUE4ZnBCO0FBQ0RwckIsbUJBQUssY0FESjtBQUVEaEcscUJBQU8sU0FBU294QixZQUFULEdBQXdCO0FBQzdCLHFCQUFLcEUsZ0JBQUw7QUFDQSxxQkFBS3NCLE1BQUwsR0FBYyxLQUFLN1UsRUFBTCxDQUFRNFgsa0JBQVIsRUFBZCxDQUY2QixDQUVlOztBQUU1QyxxQkFBSy9DLE1BQUwsQ0FBWTd3QixLQUFaLEdBQW9CLEtBQUs2d0IsTUFBTCxDQUFZN3dCLEtBQVosSUFBcUIsS0FBSzZ3QixNQUFMLENBQVlnRCxXQUFyRDtBQUNBLHFCQUFLaEQsTUFBTCxDQUFZekYsSUFBWixHQUFtQixLQUFLeUYsTUFBTCxDQUFZekYsSUFBWixJQUFvQixLQUFLeUYsTUFBTCxDQUFZaUQsT0FBbkQ7QUFDQSxxQkFBS3pZLGVBQUwsQ0FBcUIsS0FBS3NCLFlBQTFCO0FBQ0EscUJBQUtrVSxNQUFMLENBQVk1VCxNQUFaLEdBQXFCLEtBQUtBLE1BQTFCO0FBQ0EscUJBQUs0VCxNQUFMLENBQVk1VSxPQUFaLENBQW9CLEtBQUtDLFFBQXpCO0FBQ0Q7QUFDRDs7Ozs7O0FBWkMsYUE5Zm9CLEVBZ2hCcEI7QUFDRDNULG1CQUFLLG9CQURKO0FBRURoRyxxQkFBTyxTQUFTNFosa0JBQVQsR0FBOEI7QUFDbkMsb0JBQUksS0FBS0gsRUFBTCxDQUFRK1UsS0FBUixJQUFpQixXQUFyQixFQUFrQztBQUNoQyx1QkFBSy9VLEVBQUwsQ0FBUStYLE1BQVIsSUFBa0IsS0FBSy9YLEVBQUwsQ0FBUStYLE1BQVIsRUFBbEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQVBDLGFBaGhCb0IsRUE2aEJwQjtBQUNEeHJCLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVN1YixRQUFULEdBQW9CO0FBQ3pCLHVCQUFPLEtBQUtpVCxLQUFMLEtBQWUsS0FBS1AsTUFBTCxDQUFZZCxPQUFaLENBQXRCO0FBQ0Q7QUFDRDs7Ozs7O0FBTEMsYUE3aEJvQixFQXdpQnBCO0FBQ0RubkIsbUJBQUssYUFESjtBQUVEaEcscUJBQU8sU0FBU2IsV0FBVCxHQUF1QjtBQUM1QixvQkFBSSxLQUFLaWQsZ0JBQVQsRUFBMkI7QUFDekIseUJBQU8sS0FBS0EsZ0JBQVo7QUFDRDs7QUFFRCxvQkFBSSxDQUFDLEtBQUsxQixNQUFWLEVBQWtCO0FBQ2hCLHlCQUFPLENBQVA7QUFDRDs7QUFFRCx1QkFBTyxLQUFLQSxNQUFMLENBQVlSLFFBQW5CO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBYkMsYUF4aUJvQixFQThqQnBCO0FBQ0RsVSxtQkFBSyxRQURKO0FBRURoRyxxQkFBTyxTQUFTeWMsTUFBVCxDQUFnQmhmLEtBQWhCLEVBQXVCQyxHQUF2QixFQUE0QjtBQUNqQyxvQkFBSSxDQUFDLEtBQUtnZCxNQUFWLEVBQWtCO0FBQ2hCO0FBQ0Q7O0FBRUQscUJBQUtzVCxjQUFMLEdBQXNCLElBQXRCOztBQUVBLG9CQUFJdndCLFNBQVMsSUFBYixFQUFtQjtBQUNqQkEsMEJBQVEsS0FBSytkLGNBQUwsRUFBUjs7QUFFQSxzQkFBSS9kLFNBQVMsS0FBSzBCLFdBQUwsRUFBYixFQUFpQztBQUMvQjFCLDRCQUFRLENBQVI7QUFDRDtBQUNGOztBQUVELG9CQUFJQyxPQUFPLElBQVgsRUFBaUI7QUFDZkEsd0JBQU0sS0FBS3lCLFdBQUwsRUFBTjtBQUNEOztBQUVELHFCQUFLd3VCLGFBQUwsR0FBcUJsd0IsS0FBckI7QUFDQSxxQkFBS3N3QixRQUFMLEdBQWdCLEtBQUt0VSxFQUFMLENBQVFRLFdBQXhCOztBQUVBLG9CQUFJLEtBQUt1VSxLQUFMLEtBQWUsS0FBS1AsTUFBTCxDQUFZWixRQUFaLENBQW5CLEVBQTBDO0FBQ3hDLHVCQUFLNEIsUUFBTCxDQUFjN0IsTUFBZDtBQUNEOztBQUVELHVCQUFPO0FBQ0wzdkIseUJBQU9BLEtBREY7QUFFTEMsdUJBQUtBO0FBRkEsaUJBQVA7QUFJRDtBQUNEOzs7Ozs7QUFqQ0MsYUE5akJvQixFQXFtQnBCO0FBQ0RzSSxtQkFBSyxlQURKO0FBRURoRyxxQkFBTyxTQUFTNHRCLGFBQVQsR0FBeUI7QUFDOUIsdUJBQU8sQ0FBQyxLQUFLblUsRUFBTCxDQUFRUSxXQUFSLEdBQXNCLEtBQUs4VCxRQUE1QixJQUF3QyxLQUFLM1QsWUFBcEQ7QUFDRDtBQUNEOzs7Ozs7OztBQUxDLGFBcm1Cb0IsRUFrbkJwQjtBQUNEcFUsbUJBQUssTUFESjtBQUVEaEcscUJBQU8sU0FBU21CLElBQVQsQ0FBYzFELEtBQWQsRUFBcUJDLEdBQXJCLEVBQTBCO0FBQy9CLG9CQUFJLENBQUMsS0FBS2dkLE1BQVYsRUFBa0I7QUFDaEI7QUFDRCxpQkFIOEIsQ0FHN0I7OztBQUdGLHFCQUFLMFcsWUFBTDtBQUNBLG9CQUFJSyxlQUFlLEtBQUtoVixNQUFMLENBQVloZixLQUFaLEVBQW1CQyxHQUFuQixDQUFuQjtBQUNBRCx3QkFBUWcwQixhQUFhaDBCLEtBQXJCO0FBQ0FDLHNCQUFNK3pCLGFBQWEvekIsR0FBbkI7QUFDQSxxQkFBS3N3QixjQUFMLEdBQXNCdHdCLEdBQXRCO0FBQ0EscUJBQUs0d0IsTUFBTCxDQUFZN3dCLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUJBLEtBQXJCO0FBQ0EscUJBQUttYyxrQkFBTDtBQUNBLHFCQUFLcVYsUUFBTCxDQUFjOUIsT0FBZDtBQUNBLHFCQUFLM2MsU0FBTCxDQUFlLE1BQWY7QUFDRDtBQUNEOzs7O0FBbEJDLGFBbG5Cb0IsRUF3b0JwQjtBQUNEeEssbUJBQUssT0FESjtBQUVEaEcscUJBQU8sU0FBU3FhLEtBQVQsR0FBaUI7QUFDdEIscUJBQUsyVCxjQUFMLEdBQXNCLElBQXRCO0FBQ0EscUJBQUtMLGFBQUwsSUFBc0IsS0FBS0MsYUFBTCxFQUF0QjtBQUNBLHFCQUFLVSxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZekYsSUFBWixDQUFpQixDQUFqQixDQUFmO0FBQ0EscUJBQUtvRyxRQUFMLENBQWM3QixNQUFkO0FBQ0EscUJBQUs1YyxTQUFMLENBQWUsT0FBZjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFUQyxhQXhvQm9CLEVBd3BCcEI7QUFDRHhLLG1CQUFLLGdCQURKO0FBRURoRyxxQkFBTyxTQUFTd2IsY0FBVCxHQUEwQjtBQUMvQix1QkFBTyxLQUFLZ1QsS0FBTCxDQUFXaFQsY0FBWCxDQUEwQjVYLElBQTFCLENBQStCLElBQS9CLENBQVA7QUFDRDtBQUNEOzs7Ozs7QUFMQyxhQXhwQm9CLEVBbXFCcEI7QUFDRG9DLG1CQUFLLGlCQURKO0FBRURoRyxxQkFBTyxTQUFTd2MsZUFBVCxHQUEyQjtBQUNoQyx1QkFBTyxLQUFLcEMsWUFBWjtBQUNEO0FBQ0Q7Ozs7OztBQUxDLGFBbnFCb0IsRUE4cUJwQjtBQUNEcFUsbUJBQUssaUJBREo7QUFFRGhHLHFCQUFPLFNBQVM4WSxlQUFULENBQXlCOVksS0FBekIsRUFBZ0M7QUFDckMscUJBQUtvYSxZQUFMLEdBQW9CcGEsU0FBUyxDQUE3QjtBQUNBLHFCQUFLc3VCLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVlsVSxZQUFaLENBQXlCcVcsY0FBekIsQ0FBd0MsS0FBS3JXLFlBQTdDLEVBQTJELEtBQUtYLEVBQUwsQ0FBUVEsV0FBbkUsQ0FBZjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFOQyxhQTlxQm9CLEVBMnJCcEI7QUFDRGpVLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVM0YyxVQUFULENBQW9CbGYsR0FBcEIsRUFBeUI7QUFDOUIscUJBQUtzd0IsY0FBTCxHQUFzQnR3QixHQUF0QjtBQUNEO0FBSkEsYUEzckJvQixDQUF2Qjs7QUFrc0JBLG1CQUFPcW9CLFFBQVA7QUFDRCxXQTl6QjJCLENBOHpCMUJyYixLQUFLaUksUUE5ekJxQixDQUE1Qjs7QUFnMEJBblksa0JBQVEwSyxPQUFSLEdBQWtCNmdCLFFBQWxCO0FBQ0FBLG1CQUFTNEosZ0JBQVQsR0FBNEIsR0FBNUI7QUFDQXAxQixpQkFBT0MsT0FBUCxHQUFpQkEsUUFBUTBLLE9BQXpCOztBQUVBO0FBQU8sU0F2ck04Qjs7QUF5ck1yQyxhQUFNO0FBQ047OztBQUdBLGFBQU8scUNBQUMzSyxNQUFELEVBQVk7O0FBRW5COzs7Ozs7Ozs7Ozs7OztBQWNBLG1CQUFTd3NCLFFBQVQsQ0FBa0J0RixJQUFsQixFQUF3QmlRLElBQXhCLEVBQThCeGdCLFNBQTlCLEVBQXdDO0FBQ3RDLGdCQUFJeWdCLE9BQUosRUFBYWhRLElBQWIsRUFBbUJpUSxPQUFuQixFQUE0QkMsU0FBNUIsRUFBdUNybEIsTUFBdkM7QUFDQSxnQkFBSSxRQUFRa2xCLElBQVosRUFBa0JBLE9BQU8sR0FBUDs7QUFFbEIscUJBQVNJLEtBQVQsR0FBaUI7QUFDZixrQkFBSTFvQixPQUFPMm9CLEtBQUtDLEdBQUwsS0FBYUgsU0FBeEI7O0FBRUEsa0JBQUl6b0IsT0FBT3NvQixJQUFQLElBQWV0b0IsUUFBUSxDQUEzQixFQUE4QjtBQUM1QnVvQiwwQkFBVWp6QixXQUFXb3pCLEtBQVgsRUFBa0JKLE9BQU90b0IsSUFBekIsQ0FBVjtBQUNELGVBRkQsTUFFTztBQUNMdW9CLDBCQUFVLElBQVY7QUFDQSxvQkFBSSxDQUFDemdCLFNBQUwsRUFBZ0I7QUFDZDFFLDJCQUFTaVYsS0FBSzVVLEtBQUwsQ0FBVytrQixPQUFYLEVBQW9CalEsSUFBcEIsQ0FBVDtBQUNBaVEsNEJBQVVqUSxPQUFPLElBQWpCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGdCQUFJc1EsWUFBWSxTQUFaQSxTQUFZLEdBQVU7QUFDeEJMLHdCQUFVLElBQVY7QUFDQWpRLHFCQUFPL1UsU0FBUDtBQUNBaWxCLDBCQUFZRSxLQUFLQyxHQUFMLEVBQVo7QUFDQSxrQkFBSUUsVUFBVWhoQixhQUFhLENBQUN5Z0IsT0FBNUI7QUFDQSxrQkFBSSxDQUFDQSxPQUFMLEVBQWNBLFVBQVVqekIsV0FBV296QixLQUFYLEVBQWtCSixJQUFsQixDQUFWO0FBQ2Qsa0JBQUlRLE9BQUosRUFBYTtBQUNYMWxCLHlCQUFTaVYsS0FBSzVVLEtBQUwsQ0FBVytrQixPQUFYLEVBQW9CalEsSUFBcEIsQ0FBVDtBQUNBaVEsMEJBQVVqUSxPQUFPLElBQWpCO0FBQ0Q7O0FBRUQscUJBQU9uVixNQUFQO0FBQ0QsYUFaRDs7QUFjQXlsQixzQkFBVUUsS0FBVixHQUFrQixZQUFXO0FBQzNCLGtCQUFJUixPQUFKLEVBQWE7QUFDWFMsNkJBQWFULE9BQWI7QUFDQUEsMEJBQVUsSUFBVjtBQUNEO0FBQ0YsYUFMRDs7QUFPQU0sc0JBQVVJLEtBQVYsR0FBa0IsWUFBVztBQUMzQixrQkFBSVYsT0FBSixFQUFhO0FBQ1hubEIseUJBQVNpVixLQUFLNVUsS0FBTCxDQUFXK2tCLE9BQVgsRUFBb0JqUSxJQUFwQixDQUFUO0FBQ0FpUSwwQkFBVWpRLE9BQU8sSUFBakI7O0FBRUF5USw2QkFBYVQsT0FBYjtBQUNBQSwwQkFBVSxJQUFWO0FBQ0Q7QUFDRixhQVJEOztBQVVBLG1CQUFPTSxTQUFQO0FBQ0Q7O0FBRUQ7QUFDQWxMLG1CQUFTQSxRQUFULEdBQW9CQSxRQUFwQjs7QUFFQXhzQixpQkFBT0MsT0FBUCxHQUFpQnVzQixRQUFqQjs7QUFHQTtBQUFPOztBQUVQLGdCQXp3TXFDLEVBQTNCO0FBMHdNVjtBQUNBLGNBNXdNdUIsQ0E0d01iO0FBQ1YsY0FBVSxJQUFJdUwsMkJBQTJCLEVBQS9CO0FBQ1Y7QUFDQSxjQS93TXVCLENBK3dNYjtBQUNWLGNBQVUsU0FBU3J0QixtQkFBVCxDQUE2QnN0QixRQUE3QixFQUF1QztBQUNqRCxnQkFEaUQsQ0FDdEM7QUFDWCxnQkFBVyxJQUFJQyxlQUFlRix5QkFBeUJDLFFBQXpCLENBQW5CO0FBQ1gsZ0JBQVcsSUFBSUMsaUJBQWlCdDJCLFNBQXJCLEVBQWdDO0FBQzNDLGtCQUFZLE9BQU9zMkIsYUFBYWg0QixPQUFwQjtBQUNaO0FBQVk7QUFDWixnQkFOaUQsQ0FNdEM7QUFDWCxnQkFBVyxJQUFJRCxTQUFTKzNCLHlCQUF5QkMsUUFBekIsSUFBcUM7QUFDN0Qsa0JBRDZELENBQ2pEO0FBQ1osa0JBRjZELENBRWpEO0FBQ1osa0JBQVkvM0IsU0FBUztBQUNyQixrQkFKNkQsRUFBbEQ7QUFLWDtBQUNBLGdCQWJpRCxDQWF0QztBQUNYLGdCQUFXd0ssb0JBQW9CdXRCLFFBQXBCLEVBQThCaDRCLE1BQTlCLEVBQXNDQSxPQUFPQyxPQUE3QyxFQUFzRHlLLG1CQUF0RDtBQUNYO0FBQ0EsZ0JBaEJpRCxDQWdCdEM7QUFDWCxnQkFBVyxPQUFPMUssT0FBT0MsT0FBZDtBQUNYO0FBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQXR5TXVCLENBc3lNYjtBQUNWLGNBdnlNdUIsQ0F1eU1iO0FBQ1YsY0F4eU11QixDQXd5TWI7QUFDVixjQUFVLElBQUlpNEIsc0JBQXNCeHRCLG9CQUFvQixxQkFBcEIsQ0FBMUI7QUFDVjtBQUNBLGNBQVUsT0FBT3d0QixtQkFBUDtBQUNWO0FBQVUsS0E1eU1NO0FBQWhCO0FBOHlNQyxDQXh6TUQ7QUF5ek1BLHNDOzs7Ozs7Ozs7Ozs7OztBQzl6TUE7Ozs7O0FBS0EsQ0FBQyxTQUFTN3RCLGdDQUFULENBQTBDQyxJQUExQyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDekQsTUFBRyxnQ0FBT3RLLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsZ0NBQU9ELE1BQVAsT0FBa0IsUUFBcEQsRUFDQ0EsT0FBT0MsT0FBUCxHQUFpQnNLLFNBQWpCLENBREQsS0FFSyxJQUFHLElBQUgsRUFDSkMsaUNBQXFCLEVBQXJCLG9DQUF5QkQsT0FBekI7QUFBQTtBQUFBO0FBQUEscUdBREksS0FFQSxJQUFHLFFBQU90SyxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQXRCLEVBQ0pBLFFBQVEsWUFBUixJQUF3QnNLLFNBQXhCLENBREksS0FHSkQsS0FBSyxZQUFMLElBQXFCQSxLQUFLLFlBQUwsS0FBc0IsRUFBM0MsRUFBK0NBLEtBQUssWUFBTCxFQUFtQixRQUFuQixJQUErQkMsU0FBOUU7QUFDRCxDQVRELGFBU1MsWUFBVztBQUNwQixTQUFPLFNBQVUsWUFBTTtBQUFFO0FBQ3pCLGNBQVU7QUFDVjtBQUFVLFVBQUlFLHNCQUF1Qjs7QUFFckMsYUFBTTtBQUNOOzs7QUFHQSxhQUFPLGdDQUFDekssTUFBRCxFQUFTQyxPQUFULEVBQXFCOztBQUk1QkssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLG1CQUFTTSxlQUFULENBQXlCdEIsUUFBekIsRUFBbUN1QixXQUFuQyxFQUFnRDtBQUFFLGdCQUFJLEVBQUV2QixvQkFBb0J1QixXQUF0QixDQUFKLEVBQXdDO0FBQUUsb0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosbUJBQVNDLGlCQUFULENBQTJCMUYsTUFBM0IsRUFBbUMyRixLQUFuQyxFQUEwQztBQUFFLGlCQUFLLElBQUkxSyxJQUFJLENBQWIsRUFBZ0JBLElBQUkwSyxNQUFNaEosTUFBMUIsRUFBa0MxQixHQUFsQyxFQUF1QztBQUFFLGtCQUFJMkssYUFBYUQsTUFBTTFLLENBQU4sQ0FBakIsQ0FBMkIySyxXQUFXOUssVUFBWCxHQUF3QjhLLFdBQVc5SyxVQUFYLElBQXlCLEtBQWpELENBQXdEOEssV0FBV0MsWUFBWCxHQUEwQixJQUExQixDQUFnQyxJQUFJLFdBQVdELFVBQWYsRUFBMkJBLFdBQVdFLFFBQVgsR0FBc0IsSUFBdEIsQ0FBNEJsTCxPQUFPQyxjQUFQLENBQXNCbUYsTUFBdEIsRUFBOEI0RixXQUFXRyxHQUF6QyxFQUE4Q0gsVUFBOUM7QUFBNEQ7QUFBRTs7QUFFN1QsbUJBQVNJLFlBQVQsQ0FBc0JSLFdBQXRCLEVBQW1DUyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxnQkFBSUQsVUFBSixFQUFnQlAsa0JBQWtCRixZQUFZbkosU0FBOUIsRUFBeUM0SixVQUF6QyxFQUFzRCxJQUFJQyxXQUFKLEVBQWlCUixrQkFBa0JGLFdBQWxCLEVBQStCVSxXQUEvQixFQUE2QyxPQUFPVixXQUFQO0FBQXFCOztBQUV2Tjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLGNBQUlpdEIsZUFBZSxhQUFhLFlBQVk7QUFDMUM7Ozs7Ozs7QUFPQSxxQkFBU0EsWUFBVCxDQUFzQmgzQixNQUF0QixFQUE4QmlwQixFQUE5QixFQUFrQztBQUNoQyxrQkFBSXphLFFBQVEsSUFBWjs7QUFFQTFFLDhCQUFnQixJQUFoQixFQUFzQmt0QixZQUF0Qjs7QUFFQSxtQkFBSzlOLGFBQUwsR0FBcUI7QUFDbkIrTiw0QkFBWSxJQURPO0FBRW5CMXpCLHVCQUFPLEtBRlk7QUFHbkJyQix1QkFBTyxPQUhZO0FBSW5CZzFCLHlCQUFTLE1BSlU7QUFLbkIva0IsdUJBQU8sT0FMWTtBQU1uQjZGLHdCQUFRLENBTlc7QUFPbkJtZiw2QkFBYSxFQVBNO0FBUW5CQyxxQ0FBcUIsRUFSRjtBQVNuQkMsMEJBQVUsS0FUUztBQVVuQkMsK0JBQWUsS0FWSTtBQVduQkMsb0NBQW9CO0FBWEQsZUFBckI7O0FBY0EsbUJBQUtDLFlBQUwsR0FBb0IsVUFBVW56QixDQUFWLEVBQWE7QUFDL0Isb0JBQUltUCxPQUFPaEYsTUFBTXJOLFVBQU4sQ0FBaUJmLFNBQWpCLENBQTJCcVQscUJBQTNCLEVBQVg7O0FBRUEsb0JBQUluSCxJQUFJLENBQVI7QUFDQSxvQkFBSUQsSUFBSWhJLEVBQUVpUCxPQUFGLEdBQVlFLEtBQUthLElBQXpCOztBQUVBLG9CQUFJb2pCLE9BQU9qa0IsS0FBS1ksS0FBTCxHQUFhL1AsRUFBRWlQLE9BQUYsR0FBWTlFLE1BQU1rcEIsVUFBTixDQUFpQmxwQixNQUFNbXBCLFdBQXZCLENBQXBDOztBQUVBLG9CQUFJbnBCLE1BQU14TyxNQUFOLENBQWFxM0IsUUFBYixJQUF5QjdvQixNQUFNeE8sTUFBTixDQUFhczNCLGFBQTFDLEVBQXlEO0FBQ3ZEO0FBQ0FockIsc0JBQUlqSSxFQUFFc1EsT0FBRixJQUFhbkIsS0FBS3lFLEdBQUwsR0FBV3pFLEtBQUtoSSxNQUFMLEdBQWMsQ0FBdEMsQ0FBSjtBQUNEOztBQUVEZ0Qsc0JBQU1vcEIsb0JBQU4sQ0FBMkJ2ckIsQ0FBM0IsRUFBOEJDLENBQTlCLEVBQWlDbXJCLElBQWpDO0FBQ0QsZUFkRDs7QUFnQkEsbUJBQUtJLGFBQUwsR0FBcUIsWUFBWTtBQUMvQix1QkFBT3JwQixNQUFNc3BCLFVBQU4sRUFBUDtBQUNELGVBRkQ7O0FBSUEsbUJBQUtDLGFBQUwsR0FBcUIsWUFBWTtBQUMvQix1QkFBT3ZwQixNQUFNd3BCLFVBQU4sRUFBUDtBQUNELGVBRkQ7O0FBSUEsbUJBQUs3MkIsVUFBTCxHQUFrQjhuQixFQUFsQjtBQUNBLG1CQUFLOVcsS0FBTCxHQUFhOFcsR0FBR2phLElBQUgsQ0FBUW1ELEtBQXJCO0FBQ0E7Ozs7OztBQU1BLG1CQUFLOGxCLE1BQUwsR0FBYyxJQUFkO0FBQ0E7Ozs7OztBQU1BLG1CQUFLWixRQUFMLEdBQWdCLElBQWhCO0FBQ0E7Ozs7OztBQU1BLG1CQUFLTSxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsbUJBQUszM0IsTUFBTCxHQUFjLFNBQWMsRUFBZCxFQUFrQixLQUFLa3BCLGFBQXZCLEVBQXNDbHBCLE1BQXRDLENBQWQ7QUFDRDtBQUNEOzs7O0FBS0F1Syx5QkFBYXlzQixZQUFiLEVBQTJCLENBQUM7QUFDMUIxc0IsbUJBQUssTUFEcUI7QUFFMUJoRyxxQkFBTyxTQUFTdEQsSUFBVCxHQUFnQjtBQUNyQixxQkFBS2tSLE9BQUwsR0FBZSxLQUFLL1EsVUFBTCxDQUFnQmYsU0FBL0I7QUFDQSxxQkFBSzYzQixNQUFMLEdBQWMsS0FBSy9sQixPQUFMLENBQWFLLFdBQWIsQ0FBeUIsS0FBS0osS0FBTCxDQUFXSyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQVgsRUFBNkMsU0FBYztBQUNoR0UsNEJBQVUsVUFEc0Y7QUFFaEdxRiwwQkFBUSxLQUFLaFksTUFBTCxDQUFZZ1ksTUFGNEU7QUFHaEczRCx3QkFBTSxDQUgwRjtBQUloRzRELHVCQUFLLENBSjJGO0FBS2hHckQsMEJBQVEsQ0FMd0Y7QUFNaEdyUix5QkFBTyxHQU55RjtBQU9oR21QLDJCQUFTLE1BUHVGO0FBUWhHMEYsb0NBQWtCLEtBQUtwWSxNQUFMLENBQVltUyxLQVJrRTtBQVNoR29HLG9DQUFrQixLQUFLdlksTUFBTCxDQUFZdUQsS0FUa0U7QUFVaEdrVixvQ0FBa0IsS0FBS3pZLE1BQUwsQ0FBWWtDLEtBVmtFO0FBV2hHZzFCLDJCQUFTLEtBQUtsM0IsTUFBTCxDQUFZazNCLE9BWDJFO0FBWWhHN2UsaUNBQWU7QUFaaUYsaUJBQWQsRUFhakYsS0FBS3JZLE1BQUwsQ0FBWW0zQixXQWJxRSxDQUE3QyxDQUF6QixDQUFkOztBQWVBLG9CQUFJLEtBQUtuM0IsTUFBTCxDQUFZcTNCLFFBQWhCLEVBQTBCO0FBQ3hCLHVCQUFLQSxRQUFMLEdBQWdCLEtBQUtubEIsT0FBTCxDQUFhSyxXQUFiLENBQXlCLEtBQUtKLEtBQUwsQ0FBV0ssU0FBU0MsYUFBVCxDQUF1QixXQUF2QixDQUFYLEVBQWdELFNBQWM7QUFDckdFLDhCQUFVLFVBRDJGO0FBRXJHcUYsNEJBQVEsS0FBS2hZLE1BQUwsQ0FBWWdZLE1BRmlGO0FBR3JHM0QsMEJBQU0sQ0FIK0Y7QUFJckc0RCx5QkFBSyxDQUpnRztBQUtyR3JELDRCQUFRLENBTDZGO0FBTXJHclIsMkJBQU8sTUFOOEY7QUFPckdtUCw2QkFBUyxNQVA0RjtBQVFyR3drQiw2QkFBUyxLQUFLbDNCLE1BQUwsQ0FBWWszQixPQVJnRjtBQVNyRzdlLG1DQUFlLE1BVHNGO0FBVXJHN00sNEJBQVE7QUFWNkYsbUJBQWQsRUFXdEYsS0FBS3hMLE1BQUwsQ0FBWW0zQixXQVgwRSxDQUFoRCxDQUF6QixDQUFoQjtBQVlBLHVCQUFLUSxXQUFMLEdBQW1CLEtBQUtOLFFBQUwsQ0FBYzlrQixXQUFkLENBQTBCLEtBQUtKLEtBQUwsQ0FBV0ssU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFYLEVBQTBDLFNBQWM7QUFDbkdDLDZCQUFTLFFBRDBGO0FBRW5HMkYsbUNBQWUsTUFGb0Y7QUFHbkc2Ziw0QkFBUSxNQUgyRjtBQUluR0MsZ0NBQVksUUFKdUYsQ0FJOUU7O0FBSjhFLG1CQUFkLEVBTXBGLEtBQUtuNEIsTUFBTCxDQUFZbzNCLG1CQU53RSxDQUExQyxDQUExQixDQUFuQixDQWJ3QixDQW1CZTs7QUFFdkMsdUJBQUtPLFdBQUwsQ0FBaUJTLFNBQWpCLEdBQTZCLEtBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBN0I7QUFDRDs7QUFFRCxxQkFBS25tQixPQUFMLENBQWE5TixnQkFBYixDQUE4QixXQUE5QixFQUEyQyxLQUFLb3pCLFlBQWhEOztBQUVBLG9CQUFJLEtBQUt4M0IsTUFBTCxDQUFZaTNCLFVBQWhCLEVBQTRCO0FBQzFCO0FBQ0EsdUJBQUtlLFVBQUw7QUFDQSx1QkFBSzlsQixPQUFMLENBQWE5TixnQkFBYixDQUE4QixZQUE5QixFQUE0QyxLQUFLeXpCLGFBQWpEO0FBQ0EsdUJBQUszbEIsT0FBTCxDQUFhOU4sZ0JBQWIsQ0FBOEIsWUFBOUIsRUFBNEMsS0FBSzJ6QixhQUFqRDtBQUNEO0FBQ0Y7QUFDRDs7OztBQXBEMEIsYUFBRCxFQXdEeEI7QUFDRHp0QixtQkFBSyxTQURKO0FBRURoRyxxQkFBTyxTQUFTNkosT0FBVCxHQUFtQjtBQUN4QixvQkFBSSxLQUFLbk8sTUFBTCxDQUFZcTNCLFFBQWhCLEVBQTBCO0FBQ3hCLHVCQUFLWSxNQUFMLENBQVlwaEIsVUFBWixDQUF1QmxPLFdBQXZCLENBQW1DLEtBQUswdUIsUUFBeEM7QUFDRDs7QUFFRCxxQkFBS1ksTUFBTCxDQUFZcGhCLFVBQVosQ0FBdUJsTyxXQUF2QixDQUFtQyxLQUFLc3ZCLE1BQXhDO0FBQ0EscUJBQUsvbEIsT0FBTCxDQUFheU4sbUJBQWIsQ0FBaUMsV0FBakMsRUFBOEMsS0FBSzZYLFlBQW5EOztBQUVBLG9CQUFJLEtBQUt4M0IsTUFBTCxDQUFZaTNCLFVBQWhCLEVBQTRCO0FBQzFCLHVCQUFLL2tCLE9BQUwsQ0FBYXlOLG1CQUFiLENBQWlDLFlBQWpDLEVBQStDLEtBQUtrWSxhQUFwRDtBQUNBLHVCQUFLM2xCLE9BQUwsQ0FBYXlOLG1CQUFiLENBQWlDLFlBQWpDLEVBQStDLEtBQUtvWSxhQUFwRDtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7QUFmQyxhQXhEd0IsRUErRXhCO0FBQ0R6dEIsbUJBQUssc0JBREo7QUFFRGhHLHFCQUFPLFNBQVNzekIsb0JBQVQsQ0FBOEJVLElBQTlCLEVBQW9DQyxJQUFwQyxFQUEwQztBQUMvQyxvQkFBSWQsT0FBT3ZtQixVQUFVaFEsTUFBVixHQUFtQixDQUFuQixJQUF3QmdRLFVBQVUsQ0FBVixNQUFpQjFRLFNBQXpDLEdBQXFEMFEsVUFBVSxDQUFWLENBQXJELEdBQW9FLEtBQS9FO0FBQ0EscUJBQUtpQixLQUFMLENBQVcsS0FBSzhsQixNQUFoQixFQUF3QjtBQUN0QjVqQix3QkFBTSxHQUFHaU8sTUFBSCxDQUFVZ1csSUFBVixFQUFnQixJQUFoQjtBQURnQixpQkFBeEI7O0FBSUEsb0JBQUksS0FBS3Q0QixNQUFMLENBQVlxM0IsUUFBaEIsRUFBMEI7QUFDeEIsc0JBQUk3WSxXQUFXLEtBQUtyZCxVQUFMLENBQWdCc0MsV0FBaEIsRUFBZjtBQUNBLHNCQUFJNkgsZUFBZSxLQUFLbkssVUFBTCxDQUFnQnlwQixNQUFoQixDQUF1QnJuQixLQUF2QixHQUErQixLQUFLcEMsVUFBTCxDQUFnQm5CLE1BQWhCLENBQXVCZ1MsVUFBekU7QUFDQSxzQkFBSWdDLGNBQWMsS0FBSzdTLFVBQUwsQ0FBZ0J5cEIsTUFBaEIsQ0FBdUIzVSxVQUF2QixFQUFsQjtBQUNBLHNCQUFJdWlCLGFBQWFoYSxXQUFXLEtBQUtyZCxVQUFMLENBQWdCeXBCLE1BQWhCLENBQXVCcm5CLEtBQWxDLEdBQTBDeVEsV0FBM0Q7QUFDQSxzQkFBSXlrQixZQUFZanJCLEtBQUt1SSxHQUFMLENBQVMsQ0FBVCxFQUFZdWlCLE9BQU9odEIsWUFBUCxHQUFzQmtULFFBQWxDLElBQThDZ2EsVUFBOUQ7QUFDQSxzQkFBSUUsY0FBYyxLQUFLTCxVQUFMLENBQWdCSSxTQUFoQixDQUFsQjs7QUFFQSxzQkFBSWhCLElBQUosRUFBVTtBQUNSLHdCQUFJa0IsYUFBYSxLQUFLakIsVUFBTCxDQUFnQixLQUFLQyxXQUFyQixDQUFqQjtBQUNBVyw0QkFBUUssVUFBUjtBQUNEOztBQUVELHVCQUFLeG1CLEtBQUwsQ0FBVyxLQUFLa2xCLFFBQWhCLEVBQTBCO0FBQ3hCaGpCLDBCQUFNLEdBQUdpTyxNQUFILENBQVVnVyxJQUFWLEVBQWdCLElBQWhCLENBRGtCO0FBRXhCcmdCLHlCQUFLLEdBQUdxSyxNQUFILENBQVVpVyxJQUFWLEVBQWdCLElBQWhCO0FBRm1CLG1CQUExQjtBQUlBLHVCQUFLcG1CLEtBQUwsQ0FBVyxLQUFLd2xCLFdBQWhCLEVBQTZCO0FBQzNCUSxnQ0FBWTtBQURlLG1CQUE3QjtBQUdBLHVCQUFLUixXQUFMLENBQWlCUyxTQUFqQixHQUE2QixHQUFHOVYsTUFBSCxDQUFVb1csV0FBVixDQUE3QjtBQUNEO0FBQ0Y7QUFDRDs7OztBQS9CQyxhQS9Fd0IsRUFrSHhCO0FBQ0RwdUIsbUJBQUssWUFESjtBQUVEaEcscUJBQU8sU0FBU3d6QixVQUFULEdBQXNCO0FBQzNCLHFCQUFLM2xCLEtBQUwsQ0FBVyxLQUFLOGxCLE1BQWhCLEVBQXdCO0FBQ3RCdmxCLDJCQUFTO0FBRGEsaUJBQXhCOztBQUlBLG9CQUFJLEtBQUsxUyxNQUFMLENBQVlxM0IsUUFBaEIsRUFBMEI7QUFDeEIsdUJBQUtsbEIsS0FBTCxDQUFXLEtBQUtrbEIsUUFBaEIsRUFBMEI7QUFDeEIza0IsNkJBQVM7QUFEZSxtQkFBMUI7QUFHRDtBQUNGO0FBQ0Q7Ozs7QUFiQyxhQWxId0IsRUFtSXhCO0FBQ0RwSSxtQkFBSyxZQURKO0FBRURoRyxxQkFBTyxTQUFTMHpCLFVBQVQsR0FBc0I7QUFDM0IscUJBQUs3bEIsS0FBTCxDQUFXLEtBQUs4bEIsTUFBaEIsRUFBd0I7QUFDdEJ2bEIsMkJBQVM7QUFEYSxpQkFBeEI7O0FBSUEsb0JBQUksS0FBSzFTLE1BQUwsQ0FBWXEzQixRQUFoQixFQUEwQjtBQUN4Qix1QkFBS2xsQixLQUFMLENBQVcsS0FBS2tsQixRQUFoQixFQUEwQjtBQUN4QjNrQiw2QkFBUztBQURlLG1CQUExQjtBQUdEO0FBQ0Y7QUFDRDs7Ozs7OztBQWJDLGFBbkl3QixFQXVKeEI7QUFDRHBJLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVMrekIsVUFBVCxDQUFvQk8sVUFBcEIsRUFBZ0M7QUFDckNBLDZCQUFhcDBCLE1BQU1vMEIsVUFBTixJQUFvQixDQUFwQixHQUF3QkEsVUFBckM7O0FBRUEsb0JBQUksS0FBSzU0QixNQUFMLENBQVl1M0Isa0JBQWhCLEVBQW9DO0FBQ2xDLHlCQUFPLEtBQUt2M0IsTUFBTCxDQUFZdTNCLGtCQUFaLENBQStCcUIsVUFBL0IsQ0FBUDtBQUNEOztBQUVELHVCQUFPLENBQUNBLFVBQUQsRUFBYXpjLEdBQWIsQ0FBaUIsVUFBVWlGLElBQVYsRUFBZ0I7QUFDdEMseUJBQU8sQ0FBQzVULEtBQUt3TSxLQUFMLENBQVdvSCxPQUFPLElBQVAsR0FBYyxFQUF6QixDQUFELEVBQStCO0FBQ3RDLG1CQUFDLE9BQU81VCxLQUFLd00sS0FBTCxDQUFXb0gsT0FBTyxFQUFsQixDQUFSLEVBQStCeVgsS0FBL0IsQ0FBcUMsQ0FBQyxDQUF0QyxDQURPLEVBQ21DO0FBQzFDLG1CQUFDLFFBQVFyckIsS0FBS3dNLEtBQUwsQ0FBV29ILE9BQU8sQ0FBUCxHQUFXLElBQXRCLENBQVQsRUFBc0N5WCxLQUF0QyxDQUE0QyxDQUFDLENBQTdDLENBRk8sQ0FFeUM7QUFGekMsb0JBR0xySixJQUhLLENBR0EsR0FIQSxDQUFQO0FBSUQsaUJBTE0sQ0FBUDtBQU1EO0FBQ0Q7Ozs7Ozs7QUFoQkMsYUF2SndCLEVBOEt4QjtBQUNEbGxCLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVNvekIsVUFBVCxDQUFvQnhzQixPQUFwQixFQUE2QjtBQUNsQyxvQkFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWix5QkFBTyxDQUFQO0FBQ0Q7O0FBRUQsb0JBQUkzSCxRQUFRMkgsUUFBUTZjLFdBQXBCO0FBQ0Esb0JBQUk1VixRQUFRMm1CLGlCQUFpQjV0QixPQUFqQixDQUFaO0FBQ0EzSCx5QkFBU2lnQixTQUFTclIsTUFBTTRtQixVQUFOLEdBQW1CNW1CLE1BQU02bUIsV0FBbEMsQ0FBVDtBQUNBLHVCQUFPejFCLEtBQVA7QUFDRDtBQVhBLGFBOUt3QixDQUEzQixFQTBMSSxDQUFDO0FBQ0grRyxtQkFBSyxRQURGO0FBRUhoRztBQUNBOzs7Ozs7Ozs7O0FBVUEsdUJBQVN6RCxNQUFULENBQWdCYixNQUFoQixFQUF3QjtBQUN0Qix1QkFBTztBQUNMOEcsd0JBQU0sUUFERDtBQUVMOGtCLDZCQUFXNXJCLFVBQVVBLE9BQU80ckIsU0FBakIsR0FBNkI1ckIsT0FBTzRyQixTQUFwQyxHQUFnRCxLQUZ0RDtBQUdMNXJCLDBCQUFRQSxNQUhIO0FBSUx5SywrQkFBYSxFQUpSO0FBS0xqQyw0QkFBVXd1QjtBQUxMLGlCQUFQO0FBT0Q7QUFDRDs7OztBQXRCRyxhQUFELENBMUxKOztBQXNOQSxtQkFBT0EsWUFBUDtBQUNELFdBeFMrQixFQUFoQzs7QUEwU0FsNEIsa0JBQVEwSyxPQUFSLEdBQWtCd3RCLFlBQWxCO0FBQ0FuNEIsaUJBQU9DLE9BQVAsR0FBaUJBLFFBQVEwSyxPQUF6Qjs7QUFFQTtBQUFPOztBQUVQLGdCQWxYcUMsRUFBM0I7QUFtWFY7QUFDQSxjQXRYdUIsQ0FzWGI7QUFDVixjQUFVLElBQUlvdEIsMkJBQTJCLEVBQS9CO0FBQ1Y7QUFDQSxjQXpYdUIsQ0F5WGI7QUFDVixjQUFVLFNBQVNydEIsbUJBQVQsQ0FBNkJzdEIsUUFBN0IsRUFBdUM7QUFDakQsZ0JBRGlELENBQ3RDO0FBQ1gsZ0JBQVcsSUFBSUMsZUFBZUYseUJBQXlCQyxRQUF6QixDQUFuQjtBQUNYLGdCQUFXLElBQUlDLGlCQUFpQnQyQixTQUFyQixFQUFnQztBQUMzQyxrQkFBWSxPQUFPczJCLGFBQWFoNEIsT0FBcEI7QUFDWjtBQUFZO0FBQ1osZ0JBTmlELENBTXRDO0FBQ1gsZ0JBQVcsSUFBSUQsU0FBUyszQix5QkFBeUJDLFFBQXpCLElBQXFDO0FBQzdELGtCQUQ2RCxDQUNqRDtBQUNaLGtCQUY2RCxDQUVqRDtBQUNaLGtCQUFZLzNCLFNBQVM7QUFDckIsa0JBSjZELEVBQWxEO0FBS1g7QUFDQSxnQkFiaUQsQ0FhdEM7QUFDWCxnQkFBV3dLLG9CQUFvQnV0QixRQUFwQixFQUE4Qmg0QixNQUE5QixFQUFzQ0EsT0FBT0MsT0FBN0MsRUFBc0R5SyxtQkFBdEQ7QUFDWDtBQUNBLGdCQWhCaUQsQ0FnQnRDO0FBQ1gsZ0JBQVcsT0FBTzFLLE9BQU9DLE9BQWQ7QUFDWDtBQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FoWnVCLENBZ1piO0FBQ1YsY0FqWnVCLENBaVpiO0FBQ1YsY0FsWnVCLENBa1piO0FBQ1YsY0FBVSxJQUFJaTRCLHNCQUFzQnh0QixvQkFBb0IsOEJBQXBCLENBQTFCO0FBQ1Y7QUFDQSxjQUFVLE9BQU93dEIsbUJBQVA7QUFDVjtBQUFVLEtBdFpNO0FBQWhCO0FBd1pDLENBbGFEO0FBbWFBLDZDOzs7Ozs7Ozs7Ozs7OztBQ3hhQTs7Ozs7QUFLQSxDQUFDLFNBQVM3dEIsZ0NBQVQsQ0FBMENDLElBQTFDLEVBQWdEQyxPQUFoRCxFQUF5RDtBQUN6RCxNQUFHLGdDQUFPdEssT0FBUCxPQUFtQixRQUFuQixJQUErQixnQ0FBT0QsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxPQUFPQyxPQUFQLEdBQWlCc0ssU0FBakIsQ0FERCxLQUVLLElBQUcsSUFBSCxFQUNKQyxpQ0FBcUIsRUFBckIsb0NBQXlCRCxPQUF6QjtBQUFBO0FBQUE7QUFBQSxxR0FESSxLQUVBLElBQUcsUUFBT3RLLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBdEIsRUFDSkEsUUFBUSxZQUFSLElBQXdCc0ssU0FBeEIsQ0FESSxLQUdKRCxLQUFLLFlBQUwsSUFBcUJBLEtBQUssWUFBTCxLQUFzQixFQUEzQyxFQUErQ0EsS0FBSyxZQUFMLEVBQW1CLFNBQW5CLElBQWdDQyxTQUEvRTtBQUNELENBVEQsYUFTUyxZQUFXO0FBQ3BCLFNBQU8sU0FBVSxZQUFNO0FBQUU7QUFDekIsY0FBVTtBQUNWO0FBQVUsVUFBSUUsc0JBQXVCOztBQUVyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8saUNBQUN6SyxNQUFELEVBQVNDLE9BQVQsRUFBa0J5SyxtQkFBbEIsRUFBMEM7O0FBSWpEcEssaUJBQU9DLGNBQVAsQ0FBc0JOLE9BQXRCLEVBQStCLFlBQS9CLEVBQThDO0FBQzVDd0YsbUJBQU87QUFEcUMsV0FBOUM7QUFHQXhGLGtCQUFRMEssT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLGNBQUl5dkIsVUFBVTF2QixxQkFBb0Isa0JBQW1CLGdDQUF2QyxDQUFkOztBQUVBLG1CQUFTMnZCLE9BQVQsQ0FBaUJsYyxNQUFqQixFQUF5Qm1jLGNBQXpCLEVBQXlDO0FBQUUsZ0JBQUl6WixPQUFPdmdCLE9BQU91Z0IsSUFBUCxDQUFZMUMsTUFBWixDQUFYLENBQWdDLElBQUk3ZCxPQUFPaTZCLHFCQUFYLEVBQWtDO0FBQUUsa0JBQUlDLFVBQVVsNkIsT0FBT2k2QixxQkFBUCxDQUE2QnBjLE1BQTdCLENBQWQsQ0FBb0QsSUFBSW1jLGNBQUosRUFBb0I7QUFBRUUsMEJBQVVBLFFBQVF2ZCxNQUFSLENBQWUsVUFBVXdkLEdBQVYsRUFBZTtBQUFFLHlCQUFPbjZCLE9BQU93USx3QkFBUCxDQUFnQ3FOLE1BQWhDLEVBQXdDc2MsR0FBeEMsRUFBNkNqNkIsVUFBcEQ7QUFBaUUsaUJBQWpHLENBQVY7QUFBK0csZUFBQ3FnQixLQUFLalgsSUFBTCxDQUFVMEksS0FBVixDQUFnQnVPLElBQWhCLEVBQXNCMlosT0FBdEI7QUFBaUMsYUFBQyxPQUFPM1osSUFBUDtBQUFjOztBQUV6VixtQkFBUzZaLGFBQVQsQ0FBdUJoMUIsTUFBdkIsRUFBK0I7QUFBRSxpQkFBSyxJQUFJL0UsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMFIsVUFBVWhRLE1BQTlCLEVBQXNDMUIsR0FBdEMsRUFBMkM7QUFBRSxrQkFBSW96QixTQUFTMWhCLFVBQVUxUixDQUFWLEtBQWdCLElBQWhCLEdBQXVCMFIsVUFBVTFSLENBQVYsQ0FBdkIsR0FBc0MsRUFBbkQsQ0FBdUQsSUFBSUEsSUFBSSxDQUFSLEVBQVc7QUFBRTA1Qix3QkFBUS81QixPQUFPeXpCLE1BQVAsQ0FBUixFQUF3QixJQUF4QixFQUE4QjdaLE9BQTlCLENBQXNDLFVBQVV6TyxHQUFWLEVBQWU7QUFBRWtuQixrQ0FBZ0JqdEIsTUFBaEIsRUFBd0IrRixHQUF4QixFQUE2QnNvQixPQUFPdG9CLEdBQVAsQ0FBN0I7QUFBNEMsaUJBQW5HO0FBQXVHLGVBQXBILE1BQTBILElBQUluTCxPQUFPcTZCLHlCQUFYLEVBQXNDO0FBQUVyNkIsdUJBQU9zNkIsZ0JBQVAsQ0FBd0JsMUIsTUFBeEIsRUFBZ0NwRixPQUFPcTZCLHlCQUFQLENBQWlDNUcsTUFBakMsQ0FBaEM7QUFBNEUsZUFBcEgsTUFBMEg7QUFBRXNHLHdCQUFRLzVCLE9BQU95ekIsTUFBUCxDQUFSLEVBQXdCN1osT0FBeEIsQ0FBZ0MsVUFBVXpPLEdBQVYsRUFBZTtBQUFFbkwseUJBQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QitGLEdBQTlCLEVBQW1DbkwsT0FBT3dRLHdCQUFQLENBQWdDaWpCLE1BQWhDLEVBQXdDdG9CLEdBQXhDLENBQW5DO0FBQW1GLGlCQUFwSTtBQUF3STtBQUFFLGFBQUMsT0FBTy9GLE1BQVA7QUFBZ0I7O0FBRXRoQixtQkFBU2l0QixlQUFULENBQXlCNW5CLEdBQXpCLEVBQThCVSxHQUE5QixFQUFtQ2hHLEtBQW5DLEVBQTBDO0FBQUUsZ0JBQUlnRyxPQUFPVixHQUFYLEVBQWdCO0FBQUV6SyxxQkFBT0MsY0FBUCxDQUFzQndLLEdBQXRCLEVBQTJCVSxHQUEzQixFQUFnQyxFQUFFaEcsT0FBT0EsS0FBVCxFQUFnQmpGLFlBQVksSUFBNUIsRUFBa0MrSyxjQUFjLElBQWhELEVBQXNEQyxVQUFVLElBQWhFLEVBQWhDO0FBQTBHLGFBQTVILE1BQWtJO0FBQUVULGtCQUFJVSxHQUFKLElBQVdoRyxLQUFYO0FBQW1CLGFBQUMsT0FBT3NGLEdBQVA7QUFBYTs7QUFFak4sbUJBQVNFLGVBQVQsQ0FBeUJ0QixRQUF6QixFQUFtQ3VCLFdBQW5DLEVBQWdEO0FBQUUsZ0JBQUksRUFBRXZCLG9CQUFvQnVCLFdBQXRCLENBQUosRUFBd0M7QUFBRSxvQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixtQkFBU0MsaUJBQVQsQ0FBMkIxRixNQUEzQixFQUFtQzJGLEtBQW5DLEVBQTBDO0FBQUUsaUJBQUssSUFBSTFLLElBQUksQ0FBYixFQUFnQkEsSUFBSTBLLE1BQU1oSixNQUExQixFQUFrQzFCLEdBQWxDLEVBQXVDO0FBQUUsa0JBQUkySyxhQUFhRCxNQUFNMUssQ0FBTixDQUFqQixDQUEyQjJLLFdBQVc5SyxVQUFYLEdBQXdCOEssV0FBVzlLLFVBQVgsSUFBeUIsS0FBakQsQ0FBd0Q4SyxXQUFXQyxZQUFYLEdBQTBCLElBQTFCLENBQWdDLElBQUksV0FBV0QsVUFBZixFQUEyQkEsV0FBV0UsUUFBWCxHQUFzQixJQUF0QixDQUE0QmxMLE9BQU9DLGNBQVAsQ0FBc0JtRixNQUF0QixFQUE4QjRGLFdBQVdHLEdBQXpDLEVBQThDSCxVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxtQkFBU0ksWUFBVCxDQUFzQlIsV0FBdEIsRUFBbUNTLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLGdCQUFJRCxVQUFKLEVBQWdCUCxrQkFBa0JGLFlBQVluSixTQUE5QixFQUF5QzRKLFVBQXpDLEVBQXNELElBQUlDLFdBQUosRUFBaUJSLGtCQUFrQkYsV0FBbEIsRUFBK0JVLFdBQS9CLEVBQTZDLE9BQU9WLFdBQVA7QUFBcUI7O0FBRXZOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEsY0FBSXBJLGdCQUFnQixhQUFhLFlBQVk7QUFDM0MscUJBQVNBLGFBQVQsQ0FBdUIzQixNQUF2QixFQUErQmlwQixFQUEvQixFQUFtQztBQUNqQyxrQkFBSXphLFFBQVEsSUFBWjs7QUFFQTFFLDhCQUFnQixJQUFoQixFQUFzQm5JLGFBQXRCOztBQUVBLG1CQUFLM0IsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsbUJBQUttQixVQUFMLEdBQWtCOG5CLEVBQWxCO0FBQ0EsbUJBQUtqYSxJQUFMLEdBQVl1cUIsY0FBY0EsY0FBYyxFQUFkLEVBQWtCdFEsR0FBR2phLElBQXJCLENBQWQsRUFBMEMsRUFBMUMsRUFBOEM7QUFDeEQwcUIsMENBQTBCLFNBQVNBLHdCQUFULENBQWtDcDFCLEtBQWxDLEVBQXlDO0FBQ2pFLHlCQUFPa0ssTUFBTWtyQix3QkFBTixDQUErQnAxQixLQUEvQixFQUFzQ3RFLE1BQXRDLENBQVA7QUFDRDtBQUh1RCxlQUE5QyxDQUFaO0FBS0EsbUJBQUs2QixVQUFMLEdBQWtCN0IsT0FBTzZCLFVBQXpCO0FBQ0EsbUJBQUtELGdCQUFMLEdBQXdCNUIsT0FBTzRCLGdCQUFQLElBQTJCLElBQW5ELENBYmlDLENBYXdCOztBQUV6RCxrQkFBSXFxQix3QkFBd0I5c0IsT0FBTytzQixtQkFBUCxDQUEyQixLQUFLbGQsSUFBTCxDQUFVaUksUUFBVixDQUFtQnJXLFNBQTlDLENBQTVCO0FBQ0FxckIsb0NBQXNCbFQsT0FBdEIsQ0FBOEIsVUFBVXpPLEdBQVYsRUFBZTtBQUMzQzJ1Qix3QkFBUVUsTUFBUixDQUFlLzRCLFNBQWYsQ0FBeUIwSixHQUF6QixJQUFnQ2tFLE1BQU1RLElBQU4sQ0FBV2lJLFFBQVgsQ0FBb0JyVyxTQUFwQixDQUE4QjBKLEdBQTlCLENBQWhDO0FBQ0QsZUFGRDtBQUdBLG1CQUFLbkosVUFBTCxDQUFnQnc0QixNQUFoQixHQUF5QlYsUUFBUVUsTUFBakMsQ0FuQmlDLENBbUJRO0FBQ3pDOztBQUVBLGtCQUFJQyx3QkFBd0IsSUFBNUI7O0FBRUEsbUJBQUtDLGlCQUFMLEdBQXlCLFlBQVk7QUFDbkNyckIsc0JBQU0wRCxPQUFOLEdBQWdCMUQsTUFBTXJOLFVBQU4sQ0FBaUJ5cEIsTUFBakIsQ0FBd0IxWSxPQUF4QztBQUNBMUQsc0JBQU1zckIsV0FBTixHQUFvQnRyQixNQUFNck4sVUFBTixDQUFpQnlwQixNQUFqQixDQUF3QmtQLFdBQTVDOztBQUVBLG9CQUFJdHJCLE1BQU14TyxNQUFOLENBQWE4QixPQUFqQixFQUEwQjtBQUN4QjBNLHdCQUFNeE8sTUFBTixDQUFhOEIsT0FBYixDQUFxQmlYLE9BQXJCLENBQTZCLFVBQVV6VyxNQUFWLEVBQWtCO0FBQzdDQSwyQkFBT3kzQixlQUFQLEdBQXlCdnJCLE1BQU14TyxNQUFOLENBQWErNUIsZUFBYixJQUFnQ3ZyQixNQUFNMEQsT0FBTixDQUFjd0QsV0FBZCxHQUE0QmtrQixxQkFBckY7O0FBRUFwckIsMEJBQU13ckIsR0FBTixDQUFVMTNCLE1BQVY7QUFDRCxtQkFKRDtBQUtEO0FBQ0YsZUFYRCxDQXhCaUMsQ0FtQzlCOzs7QUFHSCxtQkFBS2dCLElBQUwsR0FBWSxFQUFaOztBQUVBLG1CQUFLMjJCLFFBQUwsR0FBZ0IsWUFBWTtBQUMxQnpyQixzQkFBTTBELE9BQU4sR0FBZ0IxRCxNQUFNck4sVUFBTixDQUFpQnlwQixNQUFqQixDQUF3QjFZLE9BQXhDO0FBQ0ExRCxzQkFBTXRDLFFBQU4sR0FBaUJzQyxNQUFNck4sVUFBTixDQUFpQnlwQixNQUFqQixDQUF3QjVxQixNQUF4QixDQUErQmtNLFFBQWhEOztBQUVBLG9CQUFJc0MsTUFBTXhPLE1BQU4sQ0FBYW1DLGFBQWpCLEVBQWdDO0FBQzlCcU0sd0JBQU0wckIsbUJBQU4sQ0FBMEIxckIsTUFBTXhPLE1BQWhDO0FBQ0Q7O0FBRURiLHVCQUFPdWdCLElBQVAsQ0FBWWxSLE1BQU1sTCxJQUFsQixFQUF3QnlWLE9BQXhCLENBQWdDLFVBQVU3WSxFQUFWLEVBQWM7QUFDNUNzTyx3QkFBTWxMLElBQU4sQ0FBV3BELEVBQVgsRUFBZWk2QixZQUFmO0FBQ0QsaUJBRkQ7QUFHRCxlQVhEO0FBWUQ7O0FBRUQ1dkIseUJBQWE1SSxhQUFiLEVBQTRCLENBQUM7QUFDM0IySSxtQkFBSyxNQURzQjtBQUUzQmhHLHFCQUFPLFNBQVN0RCxJQUFULEdBQWdCO0FBQ3JCO0FBQ0Esb0JBQUksS0FBS0csVUFBTCxDQUFnQitwQixPQUFwQixFQUE2QjtBQUMzQix1QkFBSzJPLGlCQUFMOztBQUVBLHVCQUFLSSxRQUFMO0FBQ0QsaUJBSkQsTUFJTztBQUNMLHVCQUFLOTRCLFVBQUwsQ0FBZ0JtbUIsSUFBaEIsQ0FBcUIsT0FBckIsRUFBOEIsS0FBSzJTLFFBQW5DO0FBQ0EsdUJBQUs5NEIsVUFBTCxDQUFnQm1tQixJQUFoQixDQUFxQixpQkFBckIsRUFBd0MsS0FBS3VTLGlCQUE3QztBQUNEO0FBQ0Y7QUFaMEIsYUFBRCxFQWF6QjtBQUNEdnZCLG1CQUFLLFNBREo7QUFFRGhHLHFCQUFPLFNBQVM2SixPQUFULEdBQW1CO0FBQ3hCLHFCQUFLaE4sVUFBTCxDQUFnQmtnQixFQUFoQixDQUFtQixPQUFuQixFQUE0QixLQUFLNFksUUFBakM7QUFDQSxxQkFBSzk0QixVQUFMLENBQWdCa2dCLEVBQWhCLENBQW1CLGlCQUFuQixFQUFzQyxLQUFLd1ksaUJBQTNDO0FBQ0EscUJBQUtPLG9CQUFMO0FBQ0EscUJBQUszRCxLQUFMO0FBQ0Q7QUFDRDs7Ozs7O0FBUkMsYUFieUIsRUEyQnpCO0FBQ0Ruc0IsbUJBQUssdUJBREo7QUFFRGhHLHFCQUFPLFNBQVMrMUIscUJBQVQsR0FBaUM7QUFDdEMsdUJBQU8sS0FBS3g0QixVQUFMLElBQW1CMUMsT0FBT3VnQixJQUFQLENBQVksS0FBS3BjLElBQWpCLEVBQXVCcEMsTUFBdkIsSUFBaUMsS0FBS1csVUFBaEU7QUFDRDtBQUNEOzs7Ozs7O0FBTEMsYUEzQnlCLEVBdUN6QjtBQUNEeUksbUJBQUssS0FESjtBQUVEaEcscUJBQU8sU0FBUzAxQixHQUFULENBQWFoNkIsTUFBYixFQUFxQjtBQUMxQixvQkFBSXNVLFNBQVMsSUFBYjs7QUFFQSxvQkFBSSxLQUFLK2xCLHFCQUFMLEVBQUosRUFBa0M7QUFDaEMseUJBQU8sSUFBUDtBQUNEOztBQUVELG9CQUFJLENBQUNyNkIsT0FBT3M2QixTQUFSLElBQXFCLEtBQUsxNEIsZ0JBQTlCLEVBQWdEO0FBQzlDNUIsMkJBQVN1NUIsY0FBY0EsY0FBYyxFQUFkLEVBQWtCdjVCLE1BQWxCLENBQWQsRUFBeUMsRUFBekMsRUFBNkM7QUFDcERzNkIsK0JBQVcsS0FBSzE0QjtBQURvQyxtQkFBN0MsQ0FBVDtBQUdEOztBQUVELG9CQUFJVSxTQUFTLElBQUksS0FBS25CLFVBQUwsQ0FBZ0J3NEIsTUFBcEIsQ0FBMkIzNUIsTUFBM0IsRUFBbUMsS0FBS2dQLElBQXhDLEVBQThDLEtBQUs3TixVQUFuRCxDQUFiO0FBQ0EscUJBQUttQyxJQUFMLENBQVVoQixPQUFPcEMsRUFBakIsSUFBdUJvQyxNQUF2QjtBQUNBQSx1QkFBT2MsRUFBUCxDQUFVLFFBQVYsRUFBb0IsWUFBWTtBQUM5Qix5QkFBT2tSLE9BQU9oUixJQUFQLENBQVloQixPQUFPcEMsRUFBbkIsQ0FBUDtBQUNELGlCQUZEO0FBR0EsdUJBQU9vQyxNQUFQO0FBQ0Q7QUFDRDs7OztBQXRCQyxhQXZDeUIsRUFpRXpCO0FBQ0RnSSxtQkFBSyxPQURKO0FBRURoRyxxQkFBTyxTQUFTbXlCLEtBQVQsR0FBaUI7QUFDdEIsb0JBQUlyZCxTQUFTLElBQWI7O0FBRUFqYSx1QkFBT3VnQixJQUFQLENBQVksS0FBS3BjLElBQWpCLEVBQXVCeVYsT0FBdkIsQ0FBK0IsVUFBVTdZLEVBQVYsRUFBYztBQUMzQ2taLHlCQUFPOVYsSUFBUCxDQUFZcEQsRUFBWixFQUFnQjJILE1BQWhCO0FBQ0QsaUJBRkQ7QUFHRDtBQVJBLGFBakV5QixFQTBFekI7QUFDRHlDLG1CQUFLLHFCQURKO0FBRURoRyxxQkFBTyxTQUFTNDFCLG1CQUFULENBQTZCbDZCLE1BQTdCLEVBQXFDO0FBQzFDLG9CQUFJc1osU0FBUyxJQUFiOztBQUVBLHFCQUFLOGdCLG9CQUFMO0FBQ0Esb0JBQUloNEIsT0FBT3BDLE9BQU9vQyxJQUFQLElBQWUsQ0FBMUI7QUFDQSxvQkFBSWhDLFlBQVksS0FBS2UsVUFBTCxDQUFnQnlwQixNQUFoQixDQUF1QnhxQixTQUF2QztBQUNBLG9CQUFJbTZCLFNBQVN2NkIsT0FBT3U2QixNQUFQLEtBQWtCLEtBQWxCLElBQTJCLEtBQUtwNUIsVUFBTCxDQUFnQm5CLE1BQWhCLENBQXVCOFMsWUFBL0Q7QUFDQSxvQkFBSTBuQixjQUFjeDZCLE9BQU93NkIsV0FBUCxJQUFzQixDQUF4QztBQUNBLG9CQUFJQyxrQkFBa0J6NkIsT0FBT3k2QixlQUFQLElBQTBCLEVBQWhEO0FBQ0Esb0JBQUlDLElBQUo7QUFDQSxvQkFBSWxjLFdBQVcsS0FBS3JkLFVBQUwsQ0FBZ0JzQyxXQUFoQixFQUFmO0FBQ0Esb0JBQUlrUyxTQUFKO0FBQ0Esb0JBQUk1VCxLQUFKO0FBQ0Esb0JBQUlPLE1BQUo7QUFDQSxvQkFBSXE0QixPQUFKO0FBQ0Esb0JBQUlDLFNBQVMsQ0FBYjtBQUNBLG9CQUFJQyxlQUFKO0FBQ0Esb0JBQUlDLFdBQUosQ0FqQjBDLENBaUJ6Qjs7QUFFakIsb0JBQUlDLGFBQWEsU0FBU0EsVUFBVCxDQUFvQjEyQixDQUFwQixFQUF1QjtBQUN0QyxzQkFBSSxDQUFDL0IsTUFBRCxJQUFXLENBQUN1NEIsZUFBaEIsRUFBaUM7QUFDL0I7QUFDRCxtQkFIcUMsQ0FHcEM7OztBQUdGLHNCQUFJOW1CLGFBQWF1RixPQUFPcEgsT0FBUCxDQUFlNkIsVUFBZixHQUE0QnltQixjQUFjSyxlQUEzRDtBQUNBdmhCLHlCQUFPcEgsT0FBUCxDQUFlNkIsVUFBZixHQUE0QkEsYUFBYXZHLEtBQUt3SSxHQUFMLENBQVNMLFNBQVQsRUFBb0JuSSxLQUFLdUksR0FBTCxDQUFTLENBQVQsRUFBWWhDLFVBQVosQ0FBcEIsQ0FBekMsQ0FQc0MsQ0FPaUQ7O0FBRXZGLHNCQUFJL1IsTUFBTXNYLE9BQU9uWSxVQUFQLENBQWtCeXBCLE1BQWxCLENBQXlCelgsV0FBekIsQ0FBcUM5TyxDQUFyQyxDQUFWOztBQUVBL0IseUJBQU91QyxNQUFQLENBQWM7QUFDWjlDLDJCQUFPeUwsS0FBS3dJLEdBQUwsQ0FBU2hVLE1BQU13YyxRQUFmLEVBQXlCemMsUUFBUXljLFFBQWpDLENBREs7QUFFWnhjLHlCQUFLd0wsS0FBS3VJLEdBQUwsQ0FBUy9ULE1BQU13YyxRQUFmLEVBQXlCemMsUUFBUXljLFFBQWpDO0FBRk8sbUJBQWQsRUFYc0MsQ0FjbEM7O0FBRUosc0JBQUl6SyxhQUFhNEIsU0FBYixJQUEwQjVCLGFBQWEsQ0FBM0MsRUFBOEM7QUFDNUN5VSwyQkFBT0MscUJBQVAsQ0FBNkIsWUFBWTtBQUN2Q3NTLGlDQUFXMTJCLENBQVg7QUFDRCxxQkFGRDtBQUdEO0FBQ0YsaUJBckJEOztBQXVCQSxvQkFBSTIyQixZQUFZLFNBQVNBLFNBQVQsQ0FBbUIzMkIsQ0FBbkIsRUFBc0I7QUFDcEMsc0JBQUlBLEVBQUU0MkIsT0FBRixJQUFhNTJCLEVBQUU0MkIsT0FBRixDQUFVLzVCLE1BQVYsR0FBbUIsQ0FBcEMsRUFBdUM7QUFDckM7QUFDRDs7QUFFRHNkLDZCQUFXbEYsT0FBT25ZLFVBQVAsQ0FBa0JzQyxXQUFsQixFQUFYO0FBQ0FrM0IsNEJBQVV0MkIsRUFBRWtQLGFBQUYsR0FBa0JsUCxFQUFFa1AsYUFBRixDQUFnQixDQUFoQixFQUFtQjJuQixVQUFyQyxHQUFrRCxJQUE1RCxDQU5vQyxDQU04Qjs7QUFFbEV2bEIsOEJBQVkyRCxPQUFPcEgsT0FBUCxDQUFlOEIsV0FBZixHQUE2QnNGLE9BQU9wSCxPQUFQLENBQWV3RCxXQUF4RDtBQUNBb2xCLGdDQUFjeGhCLE9BQU90SyxJQUFQLENBQVkrQyxlQUFaLENBQTRCdUgsT0FBT3BILE9BQVAsQ0FBZXVCLHFCQUFmLEVBQTVCLEVBQW9FNkYsT0FBT3BOLFFBQTNFLENBQWQ7QUFDQXd1Qix5QkFBTyxJQUFQO0FBQ0EzNEIsMEJBQVF1WCxPQUFPblksVUFBUCxDQUFrQnlwQixNQUFsQixDQUF5QnpYLFdBQXpCLENBQXFDOU8sQ0FBckMsRUFBd0MsSUFBeEMsQ0FBUjtBQUNBL0IsMkJBQVMsSUFBVDtBQUNBdTRCLG9DQUFrQixJQUFsQjtBQUNELGlCQWREOztBQWdCQSxxQkFBSzNvQixPQUFMLENBQWE5TixnQkFBYixDQUE4QixXQUE5QixFQUEyQzQyQixTQUEzQztBQUNBLHFCQUFLOW9CLE9BQUwsQ0FBYTlOLGdCQUFiLENBQThCLFlBQTlCLEVBQTRDNDJCLFNBQTVDO0FBQ0EscUJBQUs1M0IsRUFBTCxDQUFRLHdCQUFSLEVBQWtDLFlBQVk7QUFDNUNrVyx5QkFBT3BILE9BQVAsQ0FBZXlOLG1CQUFmLENBQW1DLFlBQW5DLEVBQWlEcWIsU0FBakQ7O0FBRUExaEIseUJBQU9wSCxPQUFQLENBQWV5TixtQkFBZixDQUFtQyxXQUFuQyxFQUFnRHFiLFNBQWhEO0FBQ0QsaUJBSkQ7O0FBTUEsb0JBQUlHLFVBQVUsU0FBU0EsT0FBVCxDQUFpQjkyQixDQUFqQixFQUFvQjtBQUNoQyxzQkFBSUEsRUFBRTQyQixPQUFGLElBQWE1MkIsRUFBRTQyQixPQUFGLENBQVUvNUIsTUFBVixHQUFtQixDQUFwQyxFQUF1QztBQUNyQztBQUNEOztBQUVEdzVCLHlCQUFPLEtBQVA7QUFDQUUsMkJBQVMsQ0FBVDtBQUNBQyxvQ0FBa0IsSUFBbEI7O0FBRUEsc0JBQUl2NEIsTUFBSixFQUFZO0FBQ1ZnWCwyQkFBT3RLLElBQVAsQ0FBWW9aLFlBQVo7O0FBRUE5bEIsMkJBQU93UyxTQUFQLENBQWlCLFlBQWpCLEVBQStCelEsQ0FBL0I7O0FBRUFpViwyQkFBT25ZLFVBQVAsQ0FBa0IyVCxTQUFsQixDQUE0QixtQkFBNUIsRUFBaUR4UyxNQUFqRCxFQUF5RCtCLENBQXpEO0FBQ0Q7O0FBRUQvQiwyQkFBUyxJQUFUO0FBQ0QsaUJBbEJEOztBQW9CQSxxQkFBSzRQLE9BQUwsQ0FBYTlOLGdCQUFiLENBQThCLFlBQTlCLEVBQTRDKzJCLE9BQTVDO0FBQ0EscUJBQUtqcEIsT0FBTCxDQUFhOU4sZ0JBQWIsQ0FBOEIsU0FBOUIsRUFBeUMrMkIsT0FBekM7QUFDQSxxQkFBS2pwQixPQUFMLENBQWE5TixnQkFBYixDQUE4QixVQUE5QixFQUEwQysyQixPQUExQztBQUNBM29CLHlCQUFTNlEsSUFBVCxDQUFjamYsZ0JBQWQsQ0FBK0IsU0FBL0IsRUFBMEMrMkIsT0FBMUM7QUFDQTNvQix5QkFBUzZRLElBQVQsQ0FBY2pmLGdCQUFkLENBQStCLFVBQS9CLEVBQTJDKzJCLE9BQTNDO0FBQ0EscUJBQUsvM0IsRUFBTCxDQUFRLHdCQUFSLEVBQWtDLFlBQVk7QUFDNUNvUCwyQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLFNBQWxDLEVBQTZDd2IsT0FBN0M7QUFDQTNvQiwyQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLFVBQWxDLEVBQThDd2IsT0FBOUM7O0FBRUE3aEIseUJBQU9wSCxPQUFQLENBQWV5TixtQkFBZixDQUFtQyxVQUFuQyxFQUErQ3diLE9BQS9DOztBQUVBN2hCLHlCQUFPcEgsT0FBUCxDQUFleU4sbUJBQWYsQ0FBbUMsU0FBbkMsRUFBOEN3YixPQUE5Qzs7QUFFQTdoQix5QkFBT3BILE9BQVAsQ0FBZXlOLG1CQUFmLENBQW1DLFlBQW5DLEVBQWlEd2IsT0FBakQ7QUFDRCxpQkFURDs7QUFXQSxvQkFBSUMsWUFBWSxTQUFTQSxTQUFULENBQW1CcDJCLEtBQW5CLEVBQTBCO0FBQ3hDLHNCQUFJLENBQUMwMUIsSUFBTCxFQUFXO0FBQ1Q7QUFDRDs7QUFFRCxzQkFBSSxFQUFFRSxNQUFGLElBQVl4NEIsSUFBaEIsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxzQkFBSTRDLE1BQU1pMkIsT0FBTixJQUFpQmoyQixNQUFNaTJCLE9BQU4sQ0FBYy81QixNQUFkLEdBQXVCLENBQTVDLEVBQStDO0FBQzdDO0FBQ0Q7O0FBRUQsc0JBQUk4RCxNQUFNdU8sYUFBTixJQUF1QnZPLE1BQU11TyxhQUFOLENBQW9CLENBQXBCLEVBQXVCMm5CLFVBQXZCLElBQXFDUCxPQUFoRSxFQUF5RTtBQUN2RTtBQUNELG1CQWZ1QyxDQWV0Qzs7O0FBR0Ysc0JBQUksQ0FBQ3I0QixNQUFMLEVBQWE7QUFDWEEsNkJBQVNnWCxPQUFPMGdCLEdBQVAsQ0FBV2g2QixVQUFVLEVBQXJCLENBQVQ7O0FBRUEsd0JBQUksQ0FBQ3NDLE1BQUwsRUFBYTtBQUNYO0FBQ0Q7QUFDRjs7QUFFRCxzQkFBSU4sTUFBTXNYLE9BQU9uWSxVQUFQLENBQWtCeXBCLE1BQWxCLENBQXlCelgsV0FBekIsQ0FBcUNuTyxLQUFyQyxDQUFWOztBQUVBLHNCQUFJcTJCLGNBQWMvaEIsT0FBT25ZLFVBQVAsQ0FBa0JXLE9BQWxCLENBQTBCa04sSUFBMUIsQ0FBK0IwcUIsd0JBQS9CLENBQXdEMzNCLFFBQVF5YyxRQUFoRSxDQUFsQjs7QUFFQSxzQkFBSThjLFlBQVloaUIsT0FBT25ZLFVBQVAsQ0FBa0JXLE9BQWxCLENBQTBCa04sSUFBMUIsQ0FBK0IwcUIsd0JBQS9CLENBQXdEMTNCLE1BQU13YyxRQUE5RCxDQUFoQjs7QUFFQWxjLHlCQUFPdUMsTUFBUCxDQUFjO0FBQ1o5QywyQkFBT3lMLEtBQUt3SSxHQUFMLENBQVNzbEIsU0FBVCxFQUFvQkQsV0FBcEIsQ0FESztBQUVacjVCLHlCQUFLd0wsS0FBS3VJLEdBQUwsQ0FBU3VsQixTQUFULEVBQW9CRCxXQUFwQjtBQUZPLG1CQUFkOztBQUtBLHNCQUFJOW1CLGdCQUFnQitFLE9BQU90SyxJQUFQLENBQVkrQyxlQUFaLENBQTRCL00sS0FBNUIsRUFBbUNzVSxPQUFPcE4sUUFBMUMsQ0FBcEIsQ0FyQ3dDLENBcUNpQzs7O0FBR3pFLHNCQUFJcXVCLFVBQVVuNkIsVUFBVXNWLFdBQVYsR0FBd0I0RCxPQUFPcEgsT0FBUCxDQUFlOEIsV0FBckQsRUFBa0U7QUFDaEU7QUFDQSx3QkFBSTNILElBQUlrSSxjQUFjakIsT0FBZCxHQUF3QnduQixZQUFZem1CLElBQTVDOztBQUVBLHdCQUFJaEksS0FBS291QixlQUFULEVBQTBCO0FBQ3hCSSx3Q0FBa0IsQ0FBQyxDQUFuQjtBQUNELHFCQUZELE1BRU8sSUFBSXh1QixLQUFLeXVCLFlBQVkxbUIsS0FBWixHQUFvQnFtQixlQUE3QixFQUE4QztBQUNuREksd0NBQWtCLENBQWxCO0FBQ0QscUJBRk0sTUFFQTtBQUNMQSx3Q0FBa0IsSUFBbEI7QUFDRDs7QUFFREEsdUNBQW1CRSxXQUFXLzFCLEtBQVgsQ0FBbkI7QUFDRDtBQUNGLGlCQXRERDs7QUF3REEscUJBQUtrTixPQUFMLENBQWE5TixnQkFBYixDQUE4QixXQUE5QixFQUEyQ2czQixTQUEzQztBQUNBLHFCQUFLbHBCLE9BQUwsQ0FBYTlOLGdCQUFiLENBQThCLFdBQTlCLEVBQTJDZzNCLFNBQTNDO0FBQ0EscUJBQUtoNEIsRUFBTCxDQUFRLHdCQUFSLEVBQWtDLFlBQVk7QUFDNUNrVyx5QkFBT3BILE9BQVAsQ0FBZXlOLG1CQUFmLENBQW1DLFdBQW5DLEVBQWdEeWIsU0FBaEQ7O0FBRUE5aEIseUJBQU9wSCxPQUFQLENBQWV5TixtQkFBZixDQUFtQyxXQUFuQyxFQUFnRHliLFNBQWhEO0FBQ0QsaUJBSkQ7QUFLQSxxQkFBS2o2QixVQUFMLENBQWdCaUMsRUFBaEIsQ0FBbUIsZ0JBQW5CLEVBQXFDLFVBQVVkLE1BQVYsRUFBa0I7QUFDckQsc0JBQUlnWCxPQUFPMVgsZ0JBQVgsRUFBNkI7QUFDM0JVLDJCQUFPZzRCLFNBQVAsR0FBbUJoaEIsT0FBTzFYLGdCQUExQjtBQUNEO0FBQ0YsaUJBSkQ7QUFLRDtBQTVLQSxhQTFFeUIsRUF1UHpCO0FBQ0QwSSxtQkFBSyxzQkFESjtBQUVEaEcscUJBQU8sU0FBUzgxQixvQkFBVCxHQUFnQztBQUNyQyxxQkFBS3RsQixTQUFMLENBQWUsd0JBQWY7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFMQyxhQXZQeUIsRUFxUXpCO0FBQ0R4SyxtQkFBSyxrQkFESjtBQUVEaEcscUJBQU8sU0FBU2kzQixnQkFBVCxHQUE0QjtBQUNqQyxvQkFBSXJoQixTQUFTLElBQWI7O0FBRUEsb0JBQUlrSCxPQUFPLEtBQUtqZ0IsVUFBTCxDQUFnQjJlLGNBQWhCLEVBQVg7QUFDQSxvQkFBSTlKLE1BQU0sSUFBVjtBQUNBN1csdUJBQU91Z0IsSUFBUCxDQUFZLEtBQUtwYyxJQUFqQixFQUF1QnlWLE9BQXZCLENBQStCLFVBQVU3WSxFQUFWLEVBQWM7QUFDM0Msc0JBQUlzN0IsTUFBTXRoQixPQUFPNVcsSUFBUCxDQUFZcEQsRUFBWixDQUFWOztBQUVBLHNCQUFJczdCLElBQUl6NUIsS0FBSixJQUFhcWYsSUFBYixJQUFxQm9hLElBQUl4NUIsR0FBSixJQUFXb2YsSUFBcEMsRUFBMEM7QUFDeEMsd0JBQUksQ0FBQ3BMLEdBQUQsSUFBUXdsQixJQUFJeDVCLEdBQUosR0FBVXc1QixJQUFJejVCLEtBQWQsR0FBc0JpVSxJQUFJaFUsR0FBSixHQUFVZ1UsSUFBSWpVLEtBQWhELEVBQXVEO0FBQ3JEaVUsNEJBQU13bEIsR0FBTjtBQUNEO0FBQ0Y7QUFDRixpQkFSRDtBQVNBLHVCQUFPeGxCLEdBQVA7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7QUFsQkMsYUFyUXlCLEVBbVN6QjtBQUNEMUwsbUJBQUssMEJBREo7QUFFRGhHLHFCQUFPLFNBQVNvMUIsd0JBQVQsQ0FBa0NwMUIsS0FBbEMsRUFBeUN0RSxNQUF6QyxFQUFpRDtBQUN0RCxvQkFBSUEsT0FBT3k3QixrQkFBWCxFQUErQjtBQUM3QjtBQUNBLHNCQUFJN2xCLFNBQVM1VixPQUFPMDdCLGdCQUFQLElBQTJCLENBQXhDO0FBQ0EseUJBQU9sdUIsS0FBS0MsS0FBTCxDQUFXLENBQUNuSixRQUFRc1IsTUFBVCxJQUFtQjVWLE9BQU95N0Isa0JBQXJDLElBQTJEejdCLE9BQU95N0Isa0JBQWxFLEdBQXVGN2xCLE1BQTlGO0FBQ0QsaUJBTHFELENBS3BEOzs7QUFHRix1QkFBT3RSLEtBQVA7QUFDRDtBQVhBLGFBblN5QixDQUE1QixFQStTSSxDQUFDO0FBQ0hnRyxtQkFBSyxRQURGO0FBRUhoRztBQUNBOzs7Ozs7Ozs7QUFTQSx1QkFBU3pELE1BQVQsQ0FBZ0JiLE1BQWhCLEVBQXdCO0FBQ3RCLHVCQUFPO0FBQ0w4Ryx3QkFBTSxTQUREO0FBRUw4a0IsNkJBQVc1ckIsVUFBVUEsT0FBTzRyQixTQUFqQixHQUE2QjVyQixPQUFPNHJCLFNBQXBDLEdBQWdELEtBRnREO0FBR0w1ckIsMEJBQVFBLE1BSEg7QUFJTHlLLCtCQUFhO0FBQ1hreEIsK0JBQVcsU0FBU0EsU0FBVCxDQUFtQnhYLE9BQW5CLEVBQTRCO0FBQ3JDLDBCQUFJLENBQUMsS0FBSzZHLHFCQUFMLENBQTJCbHBCLE9BQWhDLEVBQXlDO0FBQ3ZDLDZCQUFLK3BCLFVBQUwsQ0FBZ0IsU0FBaEI7QUFDRDs7QUFFRCw2QkFBTyxLQUFLL3BCLE9BQUwsQ0FBYWs0QixHQUFiLENBQWlCN1YsT0FBakIsQ0FBUDtBQUNELHFCQVBVO0FBUVh5WCxrQ0FBYyxTQUFTQSxZQUFULEdBQXdCO0FBQ3BDLDJCQUFLOTVCLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhMjBCLEtBQWIsRUFBaEI7QUFDRCxxQkFWVTtBQVdYeUQseUNBQXFCLFNBQVNBLG1CQUFULENBQTZCL1YsT0FBN0IsRUFBc0M7QUFDekQsMEJBQUksQ0FBQyxLQUFLNkcscUJBQUwsQ0FBMkJscEIsT0FBaEMsRUFBeUM7QUFDdkMsNkJBQUsrcEIsVUFBTCxDQUFnQixTQUFoQjtBQUNEOztBQUVELDJCQUFLL3BCLE9BQUwsQ0FBYW80QixtQkFBYixDQUFpQy9WLE9BQWpDO0FBQ0QscUJBakJVO0FBa0JYaVcsMENBQXNCLFNBQVNBLG9CQUFULEdBQWdDO0FBQ3BELDJCQUFLdDRCLE9BQUwsQ0FBYXM0QixvQkFBYjtBQUNEO0FBcEJVLG1CQUpSO0FBMEJMNXhCLDRCQUFVN0c7QUExQkwsaUJBQVA7QUE0QkQ7QUF6Q0UsYUFBRCxDQS9TSjs7QUEyVkEsbUJBQU9BLGFBQVA7QUFDRCxXQW5aZ0MsRUFBakM7O0FBcVpBN0Msa0JBQVEwSyxPQUFSLEdBQWtCN0gsYUFBbEI7QUFDQTlDLGlCQUFPQyxPQUFQLEdBQWlCQSxRQUFRMEssT0FBekI7O0FBRUE7QUFBTyxTQW5kOEI7O0FBcWRyQyxhQUFNO0FBQ047OztBQUdBLGFBQU8sa0NBQUNnZCx1QkFBRCxFQUEwQjFuQixPQUExQixFQUFzQzs7QUFJN0NLLGlCQUFPQyxjQUFQLENBQXNCTixPQUF0QixFQUErQixZQUEvQixFQUE4QztBQUM1Q3dGLG1CQUFPO0FBRHFDLFdBQTlDO0FBR0F4RixrQkFBUTY2QixNQUFSLEdBQWlCLEtBQUssQ0FBdEI7O0FBRUEsbUJBQVM3dkIsZUFBVCxDQUF5QnRCLFFBQXpCLEVBQW1DdUIsV0FBbkMsRUFBZ0Q7QUFBRSxnQkFBSSxFQUFFdkIsb0JBQW9CdUIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLG9CQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLG1CQUFTQyxpQkFBVCxDQUEyQjFGLE1BQTNCLEVBQW1DMkYsS0FBbkMsRUFBMEM7QUFBRSxpQkFBSyxJQUFJMUssSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEssTUFBTWhKLE1BQTFCLEVBQWtDMUIsR0FBbEMsRUFBdUM7QUFBRSxrQkFBSTJLLGFBQWFELE1BQU0xSyxDQUFOLENBQWpCLENBQTJCMkssV0FBVzlLLFVBQVgsR0FBd0I4SyxXQUFXOUssVUFBWCxJQUF5QixLQUFqRCxDQUF3RDhLLFdBQVdDLFlBQVgsR0FBMEIsSUFBMUIsQ0FBZ0MsSUFBSSxXQUFXRCxVQUFmLEVBQTJCQSxXQUFXRSxRQUFYLEdBQXNCLElBQXRCLENBQTRCbEwsT0FBT0MsY0FBUCxDQUFzQm1GLE1BQXRCLEVBQThCNEYsV0FBV0csR0FBekMsRUFBOENILFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULG1CQUFTSSxZQUFULENBQXNCUixXQUF0QixFQUFtQ1MsVUFBbkMsRUFBK0NDLFdBQS9DLEVBQTREO0FBQUUsZ0JBQUlELFVBQUosRUFBZ0JQLGtCQUFrQkYsWUFBWW5KLFNBQTlCLEVBQXlDNEosVUFBekMsRUFBc0QsSUFBSUMsV0FBSixFQUFpQlIsa0JBQWtCRixXQUFsQixFQUErQlUsV0FBL0IsRUFBNkMsT0FBT1YsV0FBUDtBQUFxQjs7QUFFdk47Ozs7Ozs7Ozs7QUFVQSxjQUFJNHZCLFNBQVMsYUFBYSxZQUFZO0FBQ3BDLHFCQUFTQSxNQUFULENBQWdCMzVCLE1BQWhCLEVBQXdCNjdCLFlBQXhCLEVBQXNDNVMsRUFBdEMsRUFBMEM7QUFDeEMsa0JBQUk2UyxtQkFBSjtBQUFBLGtCQUNJdHRCLFFBQVEsSUFEWjs7QUFHQTFFLDhCQUFnQixJQUFoQixFQUFzQjZ2QixNQUF0Qjs7QUFFQSxtQkFBS3g0QixVQUFMLEdBQWtCOG5CLEVBQWxCO0FBQ0EsbUJBQUsvVyxPQUFMLEdBQWUrVyxHQUFHMkIsTUFBSCxDQUFVMVksT0FBekI7QUFDQSxtQkFBS2xELElBQUwsR0FBWWlhLEdBQUdqYSxJQUFmO0FBQ0EsbUJBQUttRCxLQUFMLEdBQWEsS0FBS25ELElBQUwsQ0FBVW1ELEtBQXZCO0FBQ0EsbUJBQUs0cEIsV0FBTCxHQUFtQkYsWUFBbkI7QUFDQSxtQkFBSzN2QixRQUFMLEdBQWdCK2MsR0FBRzJCLE1BQUgsQ0FBVTVxQixNQUFWLENBQWlCa00sUUFBakM7QUFDQSxtQkFBS2hNLEVBQUwsR0FBVUYsT0FBT0UsRUFBUCxJQUFhLElBQWIsR0FBb0Irb0IsR0FBR2phLElBQUgsQ0FBUW1YLEtBQVIsRUFBcEIsR0FBc0NubUIsT0FBT0UsRUFBdkQ7QUFDQSxtQkFBSzZCLEtBQUwsR0FBYW1sQixPQUFPbG5CLE9BQU8rQixLQUFkLEtBQXdCLENBQXJDO0FBQ0EsbUJBQUtDLEdBQUwsR0FBV2hDLE9BQU9nQyxHQUFQLElBQWMsSUFBZCxHQUFxQjtBQUNoQyxtQkFBS0QsS0FBTCxHQUFhLElBQUksS0FBS21RLE9BQUwsQ0FBYThCLFdBQWpCLEdBQStCLEtBQUs3UyxVQUFMLENBQWdCc0MsV0FBaEIsRUFEakMsR0FDaUV5akIsT0FBT2xuQixPQUFPZ0MsR0FBZCxDQUQ1RTtBQUVBLG1CQUFLZzZCLE1BQUwsR0FBY2g4QixPQUFPZzhCLE1BQVAsS0FBa0J4N0IsU0FBbEIsR0FBOEIsSUFBOUIsR0FBcUNpUixRQUFRelIsT0FBT2c4QixNQUFmLENBQW5EO0FBQ0EsbUJBQUt0QixJQUFMLEdBQVkxNkIsT0FBTzA2QixJQUFQLEtBQWdCbDZCLFNBQWhCLEdBQTRCLElBQTVCLEdBQW1DaVIsUUFBUXpSLE9BQU8wNkIsSUFBZixDQUEvQyxDQWpCd0MsQ0FpQjZCOztBQUVyRSxtQkFBS3VCLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxtQkFBS0MsVUFBTCxHQUFrQixLQUFsQjtBQUNBLG1CQUFLajZCLElBQUwsR0FBWXdQLFFBQVF6UixPQUFPaUMsSUFBZixDQUFaO0FBQ0EsbUJBQUtDLEtBQUwsR0FBYWxDLE9BQU9rQyxLQUFQLElBQWdCLG9CQUE3QixDQXRCd0MsQ0FzQlc7QUFDbkQ7O0FBRUEsbUJBQUtpNkIsV0FBTCxHQUFtQm44QixPQUFPbThCLFdBQVAsSUFBc0I7QUFDdkM5bkIsc0JBQU0sRUFEaUM7QUFFdkNELHVCQUFPO0FBRmdDLGVBQXpDO0FBSUEsbUJBQUtnb0IsWUFBTCxHQUFvQixJQUFwQjtBQUNBLG1CQUFLQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0EsbUJBQUt6TixJQUFMLEdBQVk1dUIsT0FBTzR1QixJQUFQLElBQWUsRUFBM0I7QUFDQSxtQkFBSzBOLFVBQUwsR0FBa0J0OEIsT0FBT3M4QixVQUFQLElBQXFCLEVBQXZDO0FBQ0EsbUJBQUtDLFdBQUwsR0FBbUIsQ0FBQ1Qsc0JBQXNCOTdCLE9BQU91OEIsV0FBOUIsTUFBK0MsSUFBL0MsSUFBdURULHdCQUF3QixLQUFLLENBQXBGLEdBQXdGQSxtQkFBeEYsR0FBOEcsSUFBakk7QUFDQSxtQkFBS1UsU0FBTCxHQUFpQng4QixPQUFPdzhCLFNBQXhCLENBbEN3QyxDQWtDTDs7QUFFbkMsbUJBQUtsQyxTQUFMLEdBQWlCdDZCLE9BQU9zNkIsU0FBeEI7O0FBRUEsbUJBQUttQyxTQUFMLEdBQWlCLFlBQVk7QUFDM0IsdUJBQU9qdUIsTUFBTTJyQixZQUFOLEVBQVA7QUFDRCxlQUZEOztBQUlBLG1CQUFLSSxNQUFMLEdBQWN2NkIsT0FBT3U2QixNQUFQLEtBQWtCLEtBQWxCLElBQTJCdFIsR0FBR2pwQixNQUFILENBQVU4UyxZQUFuRDtBQUNBLG1CQUFLMG5CLFdBQUwsR0FBbUJ4NkIsT0FBT3c2QixXQUFQLElBQXNCLENBQXpDO0FBQ0EsbUJBQUtDLGVBQUwsR0FBdUJ6NkIsT0FBT3k2QixlQUFQLElBQTBCLEVBQWpELENBNUN3QyxDQTRDYTs7QUFFckQsbUJBQUtpQyxrQkFBTCxHQUEwQjE4QixPQUFPMDhCLGtCQUFQLEtBQThCbDhCLFNBQTlCLEdBQTBDLEtBQTFDLEdBQWtEaVIsUUFBUXpSLE9BQU8wOEIsa0JBQWYsQ0FBNUUsQ0E5Q3dDLENBOEN3RTs7QUFFaEgsa0JBQUlDLGFBQWEzOEIsT0FBTzI4QixVQUFQLElBQXFCLElBQXJCLEdBQTRCLENBQUMsQ0FBN0IsR0FBaUNuWixTQUFTeGpCLE9BQU8yOEIsVUFBaEIsQ0FBbEQ7QUFDQSxtQkFBS0MsWUFBTCxHQUFvQixNQUFwQjtBQUNBLG1CQUFLQyxTQUFMLEdBQWlCLEtBQWpCOztBQUVBLGtCQUFJRixlQUFlLENBQUMsQ0FBcEIsRUFBdUI7QUFDckIsb0JBQUlHLGVBQWUsS0FBSzM3QixVQUFMLENBQWdCa29CLE9BQWhCLENBQXdCckssTUFBeEIsSUFBa0MsSUFBbEMsR0FBeUMsS0FBSzdkLFVBQUwsQ0FBZ0Jrb0IsT0FBaEIsQ0FBd0JySyxNQUF4QixDQUErQmtXLGdCQUF4RSxHQUEyRixDQUFDLENBQS9HOztBQUVBLG9CQUFJNEgsZ0JBQWdCLENBQWhCLElBQXFCSCxhQUFhRyxZQUF0QyxFQUFvRDtBQUNsRCx1QkFBS0YsWUFBTCxHQUFvQnB2QixLQUFLd00sS0FBTCxDQUFXLElBQUk4aUIsWUFBSixHQUFtQixHQUE5QixJQUFxQyxHQUF6RDtBQUNBLHVCQUFLRCxTQUFMLEdBQWlCLEtBQUsxN0IsVUFBTCxDQUFnQmd0QixTQUFoQixLQUE4QndPLFVBQTlCLEdBQTJDLElBQTVEO0FBQ0Q7QUFDRjs7QUFFRCxtQkFBS3BGLGtCQUFMLEdBQTBCdjNCLE9BQU91M0Isa0JBQWpDO0FBQ0EsbUJBQUt3QyxlQUFMLEdBQXVCLzVCLE9BQU8rNUIsZUFBOUI7QUFDQSxtQkFBS2dELFNBQUw7QUFDQSxtQkFBS0MsTUFBTDtBQUNBLG1CQUFLNzdCLFVBQUwsQ0FBZ0JpQyxFQUFoQixDQUFtQixNQUFuQixFQUEyQixLQUFLcTVCLFNBQWhDO0FBQ0EsbUJBQUt0N0IsVUFBTCxDQUFnQmlDLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLEtBQUtxNUIsU0FBbEM7QUFDQSxtQkFBS3Q3QixVQUFMLENBQWdCMlQsU0FBaEIsQ0FBMEIsZ0JBQTFCLEVBQTRDLElBQTVDO0FBQ0Q7QUFDRDs7QUFHQXZLLHlCQUFhb3ZCLE1BQWIsRUFBcUIsQ0FBQztBQUNwQnJ2QixtQkFBSyxRQURlO0FBRXBCaEcscUJBQU8sU0FBU08sTUFBVCxDQUFnQjdFLE1BQWhCLEVBQXdCO0FBQzdCLG9CQUFJQSxPQUFPK0IsS0FBUCxJQUFnQixJQUFwQixFQUEwQjtBQUN4Qix1QkFBS0EsS0FBTCxHQUFhbWxCLE9BQU9sbkIsT0FBTytCLEtBQWQsQ0FBYjtBQUNEOztBQUVELG9CQUFJL0IsT0FBT2dDLEdBQVAsSUFBYyxJQUFsQixFQUF3QjtBQUN0Qix1QkFBS0EsR0FBTCxHQUFXa2xCLE9BQU9sbkIsT0FBT2dDLEdBQWQsQ0FBWDtBQUNEOztBQUVELG9CQUFJaEMsT0FBT2lDLElBQVAsSUFBZSxJQUFuQixFQUF5QjtBQUN2Qix1QkFBS0EsSUFBTCxHQUFZd1AsUUFBUXpSLE9BQU9pQyxJQUFmLENBQVo7QUFDRDs7QUFFRCxvQkFBSWpDLE9BQU9rQyxLQUFQLElBQWdCLElBQXBCLEVBQTBCO0FBQ3hCLHVCQUFLQSxLQUFMLEdBQWFsQyxPQUFPa0MsS0FBcEI7QUFDRDs7QUFFRCxvQkFBSWxDLE9BQU9tOEIsV0FBUCxJQUFzQixJQUExQixFQUFnQztBQUM5Qix1QkFBS0EsV0FBTCxHQUFtQm44QixPQUFPbThCLFdBQTFCO0FBQ0Q7O0FBRUQsb0JBQUluOEIsT0FBTzR1QixJQUFQLElBQWUsSUFBbkIsRUFBeUI7QUFDdkIsdUJBQUtBLElBQUwsR0FBWTV1QixPQUFPNHVCLElBQW5CO0FBQ0Q7O0FBRUQsb0JBQUk1dUIsT0FBT2c4QixNQUFQLElBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLHVCQUFLQSxNQUFMLEdBQWN2cUIsUUFBUXpSLE9BQU9nOEIsTUFBZixDQUFkO0FBQ0EsdUJBQUtpQixtQkFBTCxDQUF5QixLQUFLakIsTUFBOUI7QUFDRDs7QUFFRCxvQkFBSWg4QixPQUFPMDZCLElBQVAsSUFBZSxJQUFuQixFQUF5QjtBQUN2Qix1QkFBS0EsSUFBTCxHQUFZanBCLFFBQVF6UixPQUFPMDZCLElBQWYsQ0FBWjtBQUNEOztBQUVELG9CQUFJMTZCLE9BQU93OEIsU0FBUCxJQUFvQixJQUF4QixFQUE4QjtBQUM1Qix1QkFBS0EsU0FBTCxHQUFpQnRWLE9BQU9sbkIsT0FBT3c4QixTQUFkLENBQWpCO0FBQ0Q7O0FBRUQsb0JBQUl4OEIsT0FBT3M2QixTQUFQLElBQW9CLElBQXhCLEVBQThCO0FBQzVCLHVCQUFLQSxTQUFMLEdBQWlCcFQsT0FBT2xuQixPQUFPczZCLFNBQWQsQ0FBakI7QUFDRDs7QUFFRCxvQkFBSXQ2QixPQUFPczhCLFVBQVAsSUFBcUIsSUFBekIsRUFBK0I7QUFDN0IsdUJBQUtBLFVBQUwsR0FBa0J0OEIsT0FBT3M4QixVQUF6QjtBQUNEOztBQUVELHFCQUFLbkMsWUFBTDtBQUNBLHFCQUFLcmxCLFNBQUwsQ0FBZSxRQUFmO0FBQ0EscUJBQUszVCxVQUFMLENBQWdCMlQsU0FBaEIsQ0FBMEIsZ0JBQTFCLEVBQTRDLElBQTVDO0FBQ0Q7QUFDRDs7QUFwRG9CLGFBQUQsRUFzRGxCO0FBQ0R4SyxtQkFBSyxRQURKO0FBRURoRyxxQkFBTyxTQUFTdUQsTUFBVCxHQUFrQjtBQUN2QixvQkFBSSxLQUFLcUQsT0FBVCxFQUFrQjtBQUNoQix1QkFBS2dILE9BQUwsQ0FBYXZKLFdBQWIsQ0FBeUIsS0FBS3VDLE9BQUwsQ0FBYTRMLFVBQXRDO0FBQ0EsdUJBQUs1TCxPQUFMLEdBQWUsSUFBZjtBQUNBLHVCQUFLNEosU0FBTCxDQUFlLFFBQWY7QUFDQSx1QkFBSzNULFVBQUwsQ0FBZ0JrZ0IsRUFBaEIsQ0FBbUIsTUFBbkIsRUFBMkIsS0FBS29iLFNBQWhDO0FBQ0EsdUJBQUt0N0IsVUFBTCxDQUFnQmtnQixFQUFoQixDQUFtQixRQUFuQixFQUE2QixLQUFLb2IsU0FBbEM7QUFDQSx1QkFBS3Q3QixVQUFMLENBQWdCMlQsU0FBaEIsQ0FBMEIsZ0JBQTFCLEVBQTRDLElBQTVDO0FBQ0Q7QUFDRjtBQUNEOzs7OztBQVpDLGFBdERrQixFQXVFbEI7QUFDRHhLLG1CQUFLLE1BREo7QUFFRGhHLHFCQUFPLFNBQVNtQixJQUFULENBQWMxRCxLQUFkLEVBQXFCO0FBQzFCLG9CQUFJbTdCLElBQUluN0IsU0FBUyxLQUFLQSxLQUF0QjtBQUNBLHFCQUFLWixVQUFMLENBQWdCc0UsSUFBaEIsQ0FBcUJ5M0IsQ0FBckIsRUFBd0IsS0FBS2w3QixHQUE3QjtBQUNBLHFCQUFLOFMsU0FBTCxDQUFlLE1BQWY7QUFDQSxxQkFBSzNULFVBQUwsQ0FBZ0IyVCxTQUFoQixDQUEwQixhQUExQixFQUF5QyxJQUF6QztBQUNEO0FBQ0Q7Ozs7O0FBUkMsYUF2RWtCLEVBb0ZsQjtBQUNEeEssbUJBQUssVUFESjtBQUVEaEcscUJBQU8sU0FBUzY0QixRQUFULENBQWtCcDdCLEtBQWxCLEVBQXlCO0FBQzlCLHFCQUFLRSxJQUFMLEdBQVksSUFBWjtBQUNBLHFCQUFLd0QsSUFBTCxDQUFVMUQsS0FBVjtBQUNEO0FBQ0Q7Ozs7O0FBTkMsYUFwRmtCLEVBK0ZsQjtBQUNEdUksbUJBQUssU0FESjtBQUVEaEcscUJBQU8sU0FBUzg0QixPQUFULENBQWlCbjdCLElBQWpCLEVBQXVCO0FBQzVCLHFCQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDRDtBQUNEOztBQUxDLGFBL0ZrQixFQXNHbEI7QUFDRHFJLG1CQUFLLFFBREo7QUFFRGhHLHFCQUFPLFNBQVMwNEIsTUFBVCxHQUFrQjtBQUN2QixxQkFBSzl4QixPQUFMLEdBQWUsS0FBSzhELElBQUwsQ0FBVStDLGVBQVYsQ0FBMEIsS0FBS0csT0FBTCxDQUFhSyxXQUFiLENBQXlCQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQXpCLENBQTFCLEVBQXNGLEtBQUt2RyxRQUEzRixDQUFmO0FBQ0EscUJBQUtoQixPQUFMLENBQWFteUIsU0FBYixHQUF5QixtQkFBekI7O0FBRUEsb0JBQUksS0FBS2QsV0FBVCxFQUFzQjtBQUNwQix1QkFBS3J4QixPQUFMLENBQWFveUIsS0FBYixHQUFxQixLQUFLakYsVUFBTCxDQUFnQixLQUFLdDJCLEtBQXJCLEVBQTRCLEtBQUtDLEdBQWpDLENBQXJCO0FBQ0Q7O0FBRUQscUJBQUtrSixPQUFMLENBQWFxeUIsWUFBYixDQUEwQixTQUExQixFQUFxQyxLQUFLcjlCLEVBQTFDOztBQUVBLHFCQUFLLElBQUlzOUIsUUFBVCxJQUFxQixLQUFLbEIsVUFBMUIsRUFBc0M7QUFDcEMsdUJBQUtweEIsT0FBTCxDQUFhcXlCLFlBQWIsQ0FBMEIsaUJBQWlCQyxRQUEzQyxFQUFxRCxLQUFLbEIsVUFBTCxDQUFnQmtCLFFBQWhCLENBQXJEO0FBQ0Q7O0FBRUQscUJBQUtyckIsS0FBTCxDQUFXLEtBQUtqSCxPQUFoQixFQUF5QjtBQUN2QnlILDRCQUFVLFVBRGE7QUFFdkJxRiwwQkFBUSxDQUZlO0FBR3ZCeE0sMEJBQVEsS0FBS294QixZQUhVO0FBSXZCM2tCLHVCQUFLLEtBQUs0a0I7QUFKYSxpQkFBekI7QUFNQTs7QUFFQSxvQkFBSSxLQUFLYixNQUFULEVBQWlCO0FBQ2YsdUJBQUtJLFlBQUwsR0FBb0IsS0FBS3B0QixJQUFMLENBQVUrQyxlQUFWLENBQTBCLEtBQUs3RyxPQUFMLENBQWFxSCxXQUFiLENBQXlCQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQXpCLENBQTFCLEVBQXNGLEtBQUt2RyxRQUEzRixDQUFwQjtBQUNBLHVCQUFLbXdCLGFBQUwsR0FBcUIsS0FBS3J0QixJQUFMLENBQVUrQyxlQUFWLENBQTBCLEtBQUs3RyxPQUFMLENBQWFxSCxXQUFiLENBQXlCQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQXpCLENBQTFCLEVBQXNGLEtBQUt2RyxRQUEzRixDQUFyQjtBQUNBLHVCQUFLa3dCLFlBQUwsQ0FBa0JpQixTQUFsQixHQUE4QiwyQ0FBOUI7QUFDQSx1QkFBS2hCLGFBQUwsQ0FBbUJnQixTQUFuQixHQUErQix5Q0FBL0IsQ0FKZSxDQUkyRDs7QUFFMUUsc0JBQUloN0IsTUFBTTtBQUNSNDFCLDRCQUFRLEtBQUsvckIsUUFBTCxHQUFnQixZQUFoQixHQUErQixZQUQvQjtBQUVSeUcsOEJBQVUsVUFGRjtBQUdSc0YseUJBQUssS0FIRztBQUlSMVUsMkJBQU8sS0FKQztBQUtSaUksNEJBQVEsTUFMQTtBQU1SOGQscUNBQWlCO0FBTlQsbUJBQVYsQ0FOZSxDQWFaOztBQUVILHNCQUFJbVUsZ0JBQWdCLEtBQUt0QixXQUFMLENBQWlCOW5CLElBQWpCLEtBQTBCLE1BQTFCLEdBQW1DLFNBQWM7QUFDbkVBLDBCQUFNO0FBRDZELG1CQUFkLEVBRXBEaFMsR0FGb0QsRUFFL0MsS0FBSzg1QixXQUFMLENBQWlCOW5CLElBRjhCLENBQW5DLEdBRWEsSUFGakM7QUFHQSxzQkFBSXFwQixpQkFBaUIsS0FBS3ZCLFdBQUwsQ0FBaUIvbkIsS0FBakIsS0FBMkIsTUFBM0IsR0FBb0MsU0FBYztBQUNyRUEsMkJBQU87QUFEOEQsbUJBQWQsRUFFdEQvUixHQUZzRCxFQUVqRCxLQUFLODVCLFdBQUwsQ0FBaUIvbkIsS0FGZ0MsQ0FBcEMsR0FFYSxJQUZsQzs7QUFJQSxzQkFBSXFwQixhQUFKLEVBQW1CO0FBQ2pCLHlCQUFLdHJCLEtBQUwsQ0FBVyxLQUFLaXFCLFlBQWhCLEVBQThCcUIsYUFBOUI7QUFDRDs7QUFFRCxzQkFBSUMsY0FBSixFQUFvQjtBQUNsQix5QkFBS3ZyQixLQUFMLENBQVcsS0FBS2txQixhQUFoQixFQUErQnFCLGNBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxxQkFBS3ZELFlBQUw7QUFDQSxxQkFBS3dELFVBQUw7QUFDRDtBQXpEQSxhQXRHa0IsRUFnS2xCO0FBQ0RyekIsbUJBQUssWUFESjtBQUVEaEcscUJBQU8sU0FBUyt6QixVQUFULENBQW9CdDJCLEtBQXBCLEVBQTJCQyxHQUEzQixFQUFnQztBQUNyQyxvQkFBSSxLQUFLdTFCLGtCQUFULEVBQTZCO0FBQzNCLHlCQUFPLEtBQUtBLGtCQUFMLENBQXdCeDFCLEtBQXhCLEVBQStCQyxHQUEvQixDQUFQO0FBQ0Q7O0FBRUQsdUJBQU8sQ0FBQ0QsU0FBU0MsR0FBVCxHQUFlLENBQUNELEtBQUQsQ0FBZixHQUF5QixDQUFDQSxLQUFELEVBQVFDLEdBQVIsQ0FBMUIsRUFBd0NtYSxHQUF4QyxDQUE0QyxVQUFVaUYsSUFBVixFQUFnQjtBQUNqRSx5QkFBTyxDQUFDNVQsS0FBS3dNLEtBQUwsQ0FBV29ILE9BQU8sSUFBUCxHQUFjLEVBQXpCLENBQUQsRUFBK0I7QUFDdEMsbUJBQUMsT0FBTzVULEtBQUt3TSxLQUFMLENBQVdvSCxPQUFPLEVBQWxCLENBQVIsRUFBK0J5WCxLQUEvQixDQUFxQyxDQUFDLENBQXRDLENBRE8sQ0FDa0M7QUFEbEMsb0JBRUxySixJQUZLLENBRUEsR0FGQSxDQUFQO0FBR0QsaUJBSk0sRUFJSkEsSUFKSSxDQUlDLEdBSkQsQ0FBUDtBQUtEO0FBWkEsYUFoS2tCLEVBNktsQjtBQUNEbGxCLG1CQUFLLFVBREo7QUFFRGhHLHFCQUFPLFNBQVNzUCxRQUFULEdBQW9CO0FBQ3pCLHVCQUFPLEtBQUt6UyxVQUFMLENBQWdCeXBCLE1BQWhCLENBQXVCcm5CLEtBQXZCLEdBQStCLEtBQUtwQyxVQUFMLENBQWdCbkIsTUFBaEIsQ0FBdUJnUyxVQUE3RDtBQUNEO0FBQ0Q7O0FBTEMsYUE3S2tCLEVBb0xsQjtBQUNEMUgsbUJBQUssY0FESjtBQUVEaEcscUJBQU8sU0FBUzYxQixZQUFULEdBQXdCO0FBQzdCO0FBQ0Esb0JBQUl5RCxNQUFNLEtBQUt6OEIsVUFBTCxDQUFnQnNDLFdBQWhCLEVBQVY7QUFDQSxvQkFBSUYsUUFBUSxLQUFLcVEsUUFBTCxFQUFaO0FBQ0Esb0JBQUlpcUIsZUFBZSxLQUFLOTdCLEtBQXhCO0FBQ0Esb0JBQUkrN0IsYUFBYSxLQUFLOTdCLEdBQXRCOztBQUVBLG9CQUFJNjdCLGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEJBLGlDQUFlLENBQWY7QUFDQUMsK0JBQWFBLGFBQWFELFlBQTFCO0FBQ0Q7O0FBRUQsb0JBQUlDLGFBQWFGLEdBQWpCLEVBQXNCO0FBQ3BCRSwrQkFBYUYsR0FBYjtBQUNBQyxpQ0FBZUQsT0FBT0UsYUFBYUQsWUFBcEIsQ0FBZjtBQUNEOztBQUVELG9CQUFJLEtBQUt2RCxTQUFMLElBQWtCLElBQXRCLEVBQTRCO0FBQzFCd0QsK0JBQWF0d0IsS0FBS3VJLEdBQUwsQ0FBUzhuQixlQUFlLEtBQUt2RCxTQUE3QixFQUF3Q3dELFVBQXhDLENBQWI7QUFDRDs7QUFFRCxvQkFBSSxLQUFLdEIsU0FBTCxJQUFrQixJQUF0QixFQUE0QjtBQUMxQnNCLCtCQUFhdHdCLEtBQUt3SSxHQUFMLENBQVM2bkIsZUFBZSxLQUFLckIsU0FBN0IsRUFBd0NzQixVQUF4QyxDQUFiO0FBQ0Q7O0FBRUQsb0JBQUksS0FBSzV5QixPQUFMLElBQWdCLElBQXBCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQSxzQkFBSW1KLE9BQU83RyxLQUFLQyxLQUFMLENBQVdvd0IsZUFBZUQsR0FBZixHQUFxQnI2QixLQUFoQyxDQUFYO0FBQ0Esc0JBQUl3NkIsY0FBY3Z3QixLQUFLQyxLQUFMLENBQVdxd0IsYUFBYUYsR0FBYixHQUFtQnI2QixLQUE5QixJQUF1QzhRLElBQXpEO0FBQ0EsdUJBQUtsQyxLQUFMLENBQVcsS0FBS2pILE9BQWhCLEVBQXlCO0FBQ3ZCbUosMEJBQU1BLE9BQU8sSUFEVTtBQUV2QjlRLDJCQUFPdzZCLGNBQWMsSUFGRTtBQUd2QnpVLHFDQUFpQixLQUFLcG5CLEtBSEM7QUFJdkIrMUIsNEJBQVEsS0FBS3lDLElBQUwsR0FBWSxNQUFaLEdBQXFCO0FBSk4sbUJBQXpCOztBQU9BLHVCQUFLLElBQUk4QyxRQUFULElBQXFCLEtBQUtsQixVQUExQixFQUFzQztBQUNwQyx5QkFBS3B4QixPQUFMLENBQWFxeUIsWUFBYixDQUEwQixpQkFBaUJDLFFBQTNDLEVBQXFELEtBQUtsQixVQUFMLENBQWdCa0IsUUFBaEIsQ0FBckQ7QUFDRDs7QUFFRCxzQkFBSSxLQUFLakIsV0FBVCxFQUFzQjtBQUNwQix5QkFBS3J4QixPQUFMLENBQWFveUIsS0FBYixHQUFxQixLQUFLakYsVUFBTCxDQUFnQixLQUFLdDJCLEtBQXJCLEVBQTRCLEtBQUtDLEdBQWpDLENBQXJCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7O0FBaERDLGFBcExrQixFQXNPbEI7QUFDRHNJLG1CQUFLLFdBREo7QUFFRGhHLHFCQUFPLFNBQVN5NEIsU0FBVCxHQUFxQjtBQUMxQixvQkFBSXpvQixTQUFTLElBQWI7O0FBRUEscUJBQUswcEIsT0FBTCxHQUFlLEtBQWY7QUFDQSxxQkFBS0MsUUFBTCxHQUFnQixLQUFoQjs7QUFFQSxvQkFBSUMsWUFBWSxTQUFTQSxTQUFULENBQW1COWMsSUFBbkIsRUFBeUI7QUFDdkMsc0JBQUlyZixRQUFReUwsS0FBS0MsS0FBTCxDQUFXNkcsT0FBT3ZTLEtBQVAsR0FBZSxFQUExQixJQUFnQyxFQUE1QztBQUNBLHNCQUFJQyxNQUFNd0wsS0FBS0MsS0FBTCxDQUFXNkcsT0FBT3RTLEdBQVAsR0FBYSxFQUF4QixJQUE4QixFQUF4QztBQUNBb2YseUJBQU81VCxLQUFLQyxLQUFMLENBQVcyVCxPQUFPLEVBQWxCLElBQXdCLEVBQS9COztBQUVBLHNCQUFJLENBQUM5TSxPQUFPMnBCLFFBQVIsSUFBb0IzcEIsT0FBTzBwQixPQUEzQixLQUF1Q2o4QixRQUFRcWYsSUFBUixJQUFnQnBmLE9BQU9vZixJQUE5RCxDQUFKLEVBQXlFO0FBQ3ZFOU0sMkJBQU8ycEIsUUFBUCxHQUFrQixJQUFsQjtBQUNBM3BCLDJCQUFPMHBCLE9BQVAsR0FBaUIsS0FBakI7O0FBRUExcEIsMkJBQU9RLFNBQVAsQ0FBaUIsS0FBakI7O0FBRUFSLDJCQUFPblQsVUFBUCxDQUFrQjJULFNBQWxCLENBQTRCLFlBQTVCLEVBQTBDUixNQUExQztBQUNEOztBQUVELHNCQUFJLENBQUNBLE9BQU8wcEIsT0FBUixJQUFtQmo4QixTQUFTcWYsSUFBNUIsSUFBb0NwZixNQUFNb2YsSUFBOUMsRUFBb0Q7QUFDbEQ5TSwyQkFBTzBwQixPQUFQLEdBQWlCLElBQWpCO0FBQ0ExcEIsMkJBQU8ycEIsUUFBUCxHQUFrQixLQUFsQjs7QUFFQTNwQiwyQkFBT1EsU0FBUCxDQUFpQixJQUFqQjs7QUFFQVIsMkJBQU9uVCxVQUFQLENBQWtCMlQsU0FBbEIsQ0FBNEIsV0FBNUIsRUFBeUNSLE1BQXpDO0FBQ0Q7QUFDRixpQkF0QkQ7O0FBd0JBLHFCQUFLblQsVUFBTCxDQUFnQmtvQixPQUFoQixDQUF3QmptQixFQUF4QixDQUEyQixjQUEzQixFQUEyQzg2QixTQUEzQztBQUNBLHFCQUFLOTZCLEVBQUwsQ0FBUSxRQUFSLEVBQWtCLFlBQVk7QUFDNUJrUix5QkFBT25ULFVBQVAsQ0FBa0Jrb0IsT0FBbEIsQ0FBMEJoSSxFQUExQixDQUE2QixjQUE3QixFQUE2QzZjLFNBQTdDO0FBQ0QsaUJBRkQ7QUFHQTs7QUFFQSxxQkFBSzk2QixFQUFMLENBQVEsS0FBUixFQUFlLFlBQVk7QUFDekIsc0JBQUlrUixPQUFPclMsSUFBWCxFQUFpQjtBQUNmLHdCQUFJazhCLFdBQVc3cEIsT0FBT25ULFVBQVAsQ0FBa0IyZSxjQUFsQixFQUFmOztBQUVBLHdCQUFJcWUsWUFBWTdwQixPQUFPdlMsS0FBbkIsSUFBNEJvOEIsWUFBWTdwQixPQUFPdFMsR0FBbkQsRUFBd0Q7QUFDdERzUyw2QkFBT25ULFVBQVAsQ0FBa0JzRSxJQUFsQixDQUF1QjZPLE9BQU92UyxLQUE5QjtBQUNEO0FBQ0Y7QUFDRixpQkFSRDtBQVNEO0FBQ0Q7O0FBaERDLGFBdE9rQixFQXdSbEI7QUFDRHVJLG1CQUFLLFlBREo7QUFFRGhHLHFCQUFPLFNBQVNxNUIsVUFBVCxHQUFzQjtBQUMzQixvQkFBSXZrQixTQUFTLElBQWI7O0FBRUEsb0JBQUlzakIscUJBQXFCLEtBQUtBLGtCQUE5QjtBQUNBLHFCQUFLeHhCLE9BQUwsQ0FBYTlHLGdCQUFiLENBQThCLFlBQTlCLEVBQTRDLFVBQVVDLENBQVYsRUFBYTtBQUN2RCtVLHlCQUFPdEUsU0FBUCxDQUFpQixZQUFqQixFQUErQnpRLENBQS9COztBQUVBK1UseUJBQU9qWSxVQUFQLENBQWtCMlQsU0FBbEIsQ0FBNEIsbUJBQTVCLEVBQWlEc0UsTUFBakQsRUFBeUQvVSxDQUF6RDtBQUNELGlCQUpEO0FBS0EscUJBQUs2RyxPQUFMLENBQWE5RyxnQkFBYixDQUE4QixZQUE5QixFQUE0QyxVQUFVQyxDQUFWLEVBQWE7QUFDdkQrVSx5QkFBT3RFLFNBQVAsQ0FBaUIsWUFBakIsRUFBK0J6USxDQUEvQjs7QUFFQStVLHlCQUFPalksVUFBUCxDQUFrQjJULFNBQWxCLENBQTRCLG1CQUE1QixFQUFpRHNFLE1BQWpELEVBQXlEL1UsQ0FBekQ7QUFDRCxpQkFKRDtBQUtBLHFCQUFLNkcsT0FBTCxDQUFhOUcsZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBVUMsQ0FBVixFQUFhO0FBQ2xEQSxvQkFBRWdQLGNBQUY7O0FBRUErRix5QkFBT3RFLFNBQVAsQ0FBaUIsT0FBakIsRUFBMEJ6USxDQUExQjs7QUFFQStVLHlCQUFPalksVUFBUCxDQUFrQjJULFNBQWxCLENBQTRCLGNBQTVCLEVBQTRDc0UsTUFBNUMsRUFBb0QvVSxDQUFwRDtBQUNELGlCQU5EO0FBT0EscUJBQUs2RyxPQUFMLENBQWE5RyxnQkFBYixDQUE4QixVQUE5QixFQUEwQyxVQUFVQyxDQUFWLEVBQWE7QUFDckRBLG9CQUFFaWtCLGVBQUY7QUFDQWprQixvQkFBRWdQLGNBQUY7O0FBRUErRix5QkFBT3RFLFNBQVAsQ0FBaUIsVUFBakIsRUFBNkJ6USxDQUE3Qjs7QUFFQStVLHlCQUFPalksVUFBUCxDQUFrQjJULFNBQWxCLENBQTRCLGlCQUE1QixFQUErQ3NFLE1BQS9DLEVBQXVEL1UsQ0FBdkQ7QUFDRCxpQkFQRDtBQVFBLHFCQUFLNkcsT0FBTCxDQUFhOUcsZ0JBQWIsQ0FBOEIsYUFBOUIsRUFBNkMsVUFBVUMsQ0FBVixFQUFhO0FBQ3hELHNCQUFJcTRCLGtCQUFKLEVBQXdCO0FBQ3RCcjRCLHNCQUFFZ1AsY0FBRjtBQUNEOztBQUVEK0YseUJBQU90RSxTQUFQLENBQWlCLGFBQWpCLEVBQWdDelEsQ0FBaEM7O0FBRUErVSx5QkFBT2pZLFVBQVAsQ0FBa0IyVCxTQUFsQixDQUE0QixvQkFBNUIsRUFBa0RzRSxNQUFsRCxFQUEwRC9VLENBQTFEO0FBQ0QsaUJBUkQ7QUFTQTs7QUFFQSxvQkFBSSxLQUFLcTJCLElBQUwsSUFBYSxLQUFLc0IsTUFBdEIsRUFBOEI7QUFDNUIsdUJBQUtvQyxjQUFMO0FBQ0Q7QUFDRjtBQTdDQSxhQXhSa0IsRUFzVWxCO0FBQ0Q5ekIsbUJBQUssZ0JBREo7QUFFRGhHLHFCQUFPLFNBQVM4NUIsY0FBVCxHQUEwQjtBQUMvQixvQkFBSTlrQixTQUFTLElBQWI7O0FBRUEsb0JBQUlsWixZQUFZLEtBQUtlLFVBQUwsQ0FBZ0J5cEIsTUFBaEIsQ0FBdUJ4cUIsU0FBdkM7QUFDQSxvQkFBSW82QixjQUFjLEtBQUtBLFdBQXZCO0FBQ0Esb0JBQUlDLGtCQUFrQixLQUFLQSxlQUEzQjtBQUNBLG9CQUFJbjZCLFNBQUo7QUFDQSxvQkFBSXE2QixPQUFKO0FBQ0Esb0JBQUlELElBQUo7QUFDQSxvQkFBSS9rQixTQUFKO0FBQ0Esb0JBQUlxbUIsTUFBSjtBQUNBLG9CQUFJcUMsVUFBVSxLQUFkO0FBQ0Esb0JBQUl4RCxlQUFKO0FBQ0Esb0JBQUlDLFdBQUo7QUFDQSxvQkFBSXdELGtCQUFKO0FBQ0Esb0JBQUlDLG1CQUFKLENBZitCLENBZU47O0FBRXpCLG9CQUFJeEQsYUFBYSxTQUFTQSxVQUFULENBQW9CLzFCLEtBQXBCLEVBQTJCO0FBQzFDLHNCQUFJdVAsZ0JBQWdCK0UsT0FBT3RLLElBQVAsQ0FBWStDLGVBQVosQ0FBNEIvTSxLQUE1QixFQUFtQ3NVLE9BQU9wTixRQUExQyxDQUFwQjs7QUFFQSxzQkFBSXNTLFdBQVdsRixPQUFPblksVUFBUCxDQUFrQnNDLFdBQWxCLEVBQWY7O0FBRUEsc0JBQUksQ0FBQ28zQixlQUFELElBQW9CLENBQUNILElBQUQsSUFBUyxDQUFDc0IsTUFBbEMsRUFBMEM7QUFDeEM7QUFDRDs7QUFFRCxzQkFBSTN2QixJQUFJa0ksY0FBY2pCLE9BQXRCO0FBQ0Esc0JBQUlrckIsc0NBQXNDLENBQTFDO0FBQ0Esc0JBQUlDLHNCQUFzQixDQUExQjtBQUNBLHNCQUFJQyxhQUFhLENBQWpCLENBWjBDLENBWXRCOztBQUVwQixzQkFBSXRkLE9BQU85SCxPQUFPeWlCLFdBQVAsQ0FBbUJyQyx3QkFBbkIsQ0FBNENwZ0IsT0FBT25ZLFVBQVAsQ0FBa0J5cEIsTUFBbEIsQ0FBeUJ6WCxXQUF6QixDQUFxQ25PLEtBQXJDLElBQThDd1osUUFBMUYsQ0FBWDs7QUFFQSxzQkFBSWtjLElBQUosRUFBVTtBQUNSO0FBQ0Esd0JBQUlHLG9CQUFvQixDQUFDLENBQXpCLEVBQTRCO0FBQzFCNEQsNENBQXNCSCxxQkFBcUJobEIsT0FBT25ZLFVBQVAsQ0FBa0JuQixNQUFsQixDQUF5QjJwQixXQUFwRTtBQUNBNlUsNERBQXNDbnlCLElBQUl5dUIsWUFBWXptQixJQUF0RDtBQUNELHFCQUhELE1BR087QUFDTG9xQiw0Q0FBc0JGLHNCQUFzQmpsQixPQUFPblksVUFBUCxDQUFrQm5CLE1BQWxCLENBQXlCMnBCLFdBQXJFO0FBQ0E2VSw0REFBc0MxRCxZQUFZMW1CLEtBQVosR0FBb0IvSCxDQUExRDtBQUNEO0FBQ0YsbUJBVEQsTUFTTztBQUNMO0FBQ0Esd0JBQUlpdUIsWUFBWWhoQixPQUFPZ2hCLFNBQXZCOztBQUVBLHdCQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZEEsa0NBQVksQ0FBWjtBQUNEOztBQUVELHdCQUFJMEIsV0FBVyxPQUFmLEVBQXdCO0FBQ3RCLDBCQUFJNWEsT0FBTzlILE9BQU90WCxHQUFQLEdBQWFzNEIsU0FBeEIsRUFBbUM7QUFDakNsWiwrQkFBTzlILE9BQU90WCxHQUFQLEdBQWFzNEIsU0FBcEI7QUFDQW9FLHFDQUFhbEUsY0FBY0ssZUFBM0I7QUFDRDs7QUFFRCwwQkFBSXpaLE9BQU8sQ0FBWCxFQUFjO0FBQ1pBLCtCQUFPLENBQVA7QUFDRDtBQUNGLHFCQVRELE1BU08sSUFBSTRhLFdBQVcsS0FBZixFQUFzQjtBQUMzQiwwQkFBSTVhLE9BQU85SCxPQUFPdlgsS0FBUCxHQUFldTRCLFNBQTFCLEVBQXFDO0FBQ25DbFosK0JBQU85SCxPQUFPdlgsS0FBUCxHQUFldTRCLFNBQXRCO0FBQ0FvRSxxQ0FBYWxFLGNBQWNLLGVBQTNCO0FBQ0Q7O0FBRUQsMEJBQUl6WixPQUFPNUMsUUFBWCxFQUFxQjtBQUNuQjRDLCtCQUFPNUMsUUFBUDtBQUNEO0FBQ0Y7QUFDRixtQkFwRHlDLENBb0R4Qzs7O0FBR0Ysc0JBQUltZ0Isb0JBQW9CcmxCLE9BQU9wSCxPQUFQLENBQWU2QixVQUF2Qzs7QUFFQSxzQkFBSThtQixvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUMxQix3QkFBSXJ0QixLQUFLQyxLQUFMLENBQVdreEIsaUJBQVgsTUFBa0MsQ0FBdEMsRUFBeUM7QUFDdkM7QUFDRDs7QUFFRCx3QkFBSW54QixLQUFLQyxLQUFMLENBQVdreEIsb0JBQW9CRixtQkFBcEIsR0FBMENELG1DQUFyRCxLQUE2RixDQUFqRyxFQUFvRztBQUNsRztBQUNEO0FBQ0YsbUJBUkQsTUFRTztBQUNMLHdCQUFJaHhCLEtBQUtDLEtBQUwsQ0FBV2t4QixpQkFBWCxNQUFrQ2hwQixTQUF0QyxFQUFpRDtBQUMvQztBQUNEOztBQUVELHdCQUFJbkksS0FBS0MsS0FBTCxDQUFXa3hCLG9CQUFvQkYsbUJBQXBCLEdBQTBDRCxtQ0FBckQsS0FBNkY3b0IsU0FBakcsRUFBNEc7QUFDMUc7QUFDRDtBQUNGLG1CQXpFeUMsQ0F5RXhDOzs7QUFHRixzQkFBSTVCLGFBQWE0cUIsb0JBQW9CRCxVQUFwQixHQUFpQ2xFLGNBQWNLLGVBQWhFOztBQUVBLHNCQUFJQSxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUMxQix3QkFBSStELGlCQUFpQnB4QixLQUFLdUksR0FBTCxDQUFTLElBQUkwb0IsbUJBQUosR0FBMEJELG1DQUFuQyxFQUF3RXpxQixVQUF4RSxDQUFyQjtBQUNBdUYsMkJBQU9wSCxPQUFQLENBQWU2QixVQUFmLEdBQTRCQSxhQUFhNnFCLGNBQXpDO0FBQ0QsbUJBSEQsTUFHTztBQUNMLHdCQUFJQyxrQkFBa0JyeEIsS0FBS3dJLEdBQUwsQ0FBU0wsWUFBWThvQixtQkFBWixHQUFrQ0QsbUNBQTNDLEVBQWdGenFCLFVBQWhGLENBQXRCO0FBQ0F1RiwyQkFBT3BILE9BQVAsQ0FBZTZCLFVBQWYsR0FBNEJBLGFBQWE4cUIsZUFBekM7QUFDRDs7QUFFRCxzQkFBSUMsUUFBUTFkLE9BQU85Z0IsU0FBbkI7QUFDQUEsOEJBQVk4Z0IsSUFBWixDQXZGMEMsQ0F1RnhCOztBQUVsQnNaLHlCQUFPcGhCLE9BQU95bEIsTUFBUCxDQUFjRCxLQUFkLENBQVAsR0FBOEJ4bEIsT0FBTzBsQixRQUFQLENBQWdCRixLQUFoQixFQUF1QjlDLE1BQXZCLENBQTlCLENBekYwQyxDQXlGb0I7O0FBRTlEeFQseUJBQU9DLHFCQUFQLENBQTZCLFlBQVk7QUFDdkNzUywrQkFBVy8xQixLQUFYO0FBQ0QsbUJBRkQ7QUFHRCxpQkE5RkQ7O0FBZ0dBLG9CQUFJaTZCLFNBQVMsU0FBU0EsTUFBVCxDQUFnQmo2QixLQUFoQixFQUF1QjtBQUNsQyxzQkFBSXdaLFdBQVdsRixPQUFPblksVUFBUCxDQUFrQnNDLFdBQWxCLEVBQWY7O0FBRUEsc0JBQUl1QixNQUFNaTJCLE9BQU4sSUFBaUJqMkIsTUFBTWkyQixPQUFOLENBQWMvNUIsTUFBZCxHQUF1QixDQUE1QyxFQUErQztBQUM3QztBQUNEOztBQUVEeTVCLDRCQUFVMzFCLE1BQU11TyxhQUFOLEdBQXNCdk8sTUFBTXVPLGFBQU4sQ0FBb0IsQ0FBcEIsRUFBdUIybkIsVUFBN0MsR0FBMEQsSUFBcEUsQ0FQa0MsQ0FPd0M7QUFDMUU7O0FBRUEsc0JBQUk1aEIsT0FBT29oQixJQUFQLElBQWVwaEIsT0FBTzBpQixNQUExQixFQUFrQztBQUNoQ2gzQiwwQkFBTXNqQixlQUFOO0FBQ0QsbUJBWmlDLENBWWhDOzs7QUFHRmhvQiw4QkFBWWdaLE9BQU95aUIsV0FBUCxDQUFtQnJDLHdCQUFuQixDQUE0Q3BnQixPQUFPblksVUFBUCxDQUFrQnlwQixNQUFsQixDQUF5QnpYLFdBQXpCLENBQXFDbk8sS0FBckMsRUFBNEMsSUFBNUMsSUFBb0R3WixRQUFoRyxDQUFaLENBZmtDLENBZXFGOztBQUV2SDhmLHVDQUFxQmgrQixZQUFZZ1osT0FBT3ZYLEtBQXhDO0FBQ0F3OEIsd0NBQXNCamxCLE9BQU90WCxHQUFQLEdBQWExQixTQUFuQyxDQWxCa0MsQ0FrQlk7O0FBRTlDcVYsOEJBQVkyRCxPQUFPcEgsT0FBUCxDQUFlOEIsV0FBZixHQUE2QnNGLE9BQU9wSCxPQUFQLENBQWV3RCxXQUF4RDtBQUNBb2xCLGdDQUFjeGhCLE9BQU90SyxJQUFQLENBQVkrQyxlQUFaLENBQTRCdUgsT0FBT3BILE9BQVAsQ0FBZXVCLHFCQUFmLEVBQTVCLEVBQW9FNkYsT0FBT3BOLFFBQTNFLENBQWQ7QUFDQW9OLHlCQUFPMmlCLFVBQVAsR0FBb0IsS0FBcEI7QUFDQTNpQix5QkFBTzRpQixVQUFQLEdBQW9CLEtBQXBCOztBQUVBLHNCQUFJbDNCLE1BQU1ULE1BQU4sQ0FBYTI2QixPQUFiLENBQXFCbjBCLFdBQXJCLE9BQXVDLFFBQTNDLEVBQXFEO0FBQ25EdU8sMkJBQU8yaUIsVUFBUCxHQUFvQixJQUFwQjtBQUNBRCw2QkFBU2gzQixNQUFNVCxNQUFOLENBQWE0NkIsU0FBYixDQUF1QkMsUUFBdkIsQ0FBZ0MseUJBQWhDLElBQTZELE9BQTdELEdBQXVFLEtBQWhGO0FBQ0QsbUJBSEQsTUFHTztBQUNMOWxCLDJCQUFPNGlCLFVBQVAsR0FBb0IsSUFBcEI7QUFDQXhCLDJCQUFPLElBQVA7QUFDQXNCLDZCQUFTLEtBQVQ7QUFDRDtBQUNGLGlCQWpDRDs7QUFtQ0Esb0JBQUlxRCxPQUFPLFNBQVNBLElBQVQsQ0FBY3I2QixLQUFkLEVBQXFCO0FBQzlCLHNCQUFJQSxNQUFNaTJCLE9BQU4sSUFBaUJqMkIsTUFBTWkyQixPQUFOLENBQWMvNUIsTUFBZCxHQUF1QixDQUE1QyxFQUErQztBQUM3QztBQUNEOztBQUVELHNCQUFJdzVCLFFBQVFzQixNQUFaLEVBQW9CO0FBQ2xCMWlCLDJCQUFPNGlCLFVBQVAsR0FBb0IsS0FBcEI7QUFDQTVpQiwyQkFBTzJpQixVQUFQLEdBQW9CLEtBQXBCO0FBQ0F2QiwyQkFBTyxLQUFQO0FBQ0FHLHNDQUFrQixJQUFsQjtBQUNBbUIsNkJBQVMsS0FBVDtBQUNEOztBQUVELHNCQUFJcUMsT0FBSixFQUFhO0FBQ1hBLDhCQUFVLEtBQVY7O0FBRUEva0IsMkJBQU90SyxJQUFQLENBQVlvWixZQUFaOztBQUVBOU8sMkJBQU94RSxTQUFQLENBQWlCLFlBQWpCLEVBQStCOVAsS0FBL0I7O0FBRUFzVSwyQkFBT25ZLFVBQVAsQ0FBa0IyVCxTQUFsQixDQUE0QixtQkFBNUIsRUFBaUR3RSxNQUFqRCxFQUF5RHRVLEtBQXpEO0FBQ0Q7QUFDRixpQkF0QkQ7O0FBd0JBLG9CQUFJczZCLFNBQVMsU0FBU0EsTUFBVCxDQUFnQnQ2QixLQUFoQixFQUF1QjtBQUNsQyxzQkFBSXdaLFdBQVdsRixPQUFPblksVUFBUCxDQUFrQnNDLFdBQWxCLEVBQWY7O0FBRUEsc0JBQUk4USxnQkFBZ0IrRSxPQUFPdEssSUFBUCxDQUFZK0MsZUFBWixDQUE0Qi9NLEtBQTVCLEVBQW1Dc1UsT0FBT3BOLFFBQTFDLENBQXBCOztBQUVBLHNCQUFJbEgsTUFBTWkyQixPQUFOLElBQWlCajJCLE1BQU1pMkIsT0FBTixDQUFjLzVCLE1BQWQsR0FBdUIsQ0FBNUMsRUFBK0M7QUFDN0M7QUFDRDs7QUFFRCxzQkFBSThELE1BQU11TyxhQUFOLElBQXVCdk8sTUFBTXVPLGFBQU4sQ0FBb0IsQ0FBcEIsRUFBdUIybkIsVUFBdkIsSUFBcUNQLE9BQWhFLEVBQXlFO0FBQ3ZFO0FBQ0Q7O0FBRUQsc0JBQUksQ0FBQ0QsSUFBRCxJQUFTLENBQUNzQixNQUFkLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRUQsc0JBQUl1RCxVQUFVai9CLFNBQWQ7O0FBRUEsc0JBQUk4Z0IsT0FBTzlILE9BQU95aUIsV0FBUCxDQUFtQnJDLHdCQUFuQixDQUE0Q3BnQixPQUFPblksVUFBUCxDQUFrQnlwQixNQUFsQixDQUF5QnpYLFdBQXpCLENBQXFDbk8sS0FBckMsSUFBOEN3WixRQUExRixDQUFYOztBQUVBLHNCQUFJa2MsSUFBSixFQUFVO0FBQ1I7QUFDQSx3QkFBSThFLFNBQVNsbUIsT0FBT25ZLFVBQVAsQ0FBa0JzQyxXQUFsQixFQUFiOztBQUVBLHdCQUFJMmQsT0FBT29lLFNBQVNqQixtQkFBcEIsRUFBeUM7QUFDdkNuZCw2QkFBT29lLFNBQVNqQixtQkFBaEI7QUFDRDs7QUFFRCx3QkFBSW5kLE9BQU9rZCxrQkFBUCxHQUE0QixDQUFoQyxFQUFtQztBQUNqQ2xkLDZCQUFPa2Qsa0JBQVA7QUFDRDtBQUNGOztBQUVELHNCQUFJdEMsTUFBSixFQUFZO0FBQ1Y7QUFDQTtBQUNBLHdCQUFJMUIsWUFBWWhoQixPQUFPZ2hCLFNBQXZCOztBQUVBLHdCQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZEEsa0NBQVksQ0FBWjtBQUNEOztBQUVELHdCQUFJMEIsV0FBVyxPQUFmLEVBQXdCO0FBQ3RCLDBCQUFJNWEsT0FBTzlILE9BQU90WCxHQUFQLEdBQWFzNEIsU0FBeEIsRUFBbUM7QUFDakNsWiwrQkFBTzlILE9BQU90WCxHQUFQLEdBQWFzNEIsU0FBcEI7QUFDRDs7QUFFRCwwQkFBSWxaLE9BQU8sQ0FBWCxFQUFjO0FBQ1pBLCtCQUFPLENBQVA7QUFDRDtBQUNGLHFCQVJELE1BUU8sSUFBSTRhLFdBQVcsS0FBZixFQUFzQjtBQUMzQiwwQkFBSTVhLE9BQU85SCxPQUFPdlgsS0FBUCxHQUFldTRCLFNBQTFCLEVBQXFDO0FBQ25DbFosK0JBQU85SCxPQUFPdlgsS0FBUCxHQUFldTRCLFNBQXRCO0FBQ0Q7O0FBRUQsMEJBQUlsWixPQUFPNUMsUUFBWCxFQUFxQjtBQUNuQjRDLCtCQUFPNUMsUUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxzQkFBSXNnQixRQUFRMWQsT0FBTzlnQixTQUFuQjtBQUNBQSw4QkFBWThnQixJQUFaLENBL0RrQyxDQStEaEI7O0FBRWxCLHNCQUFJOUgsT0FBT29oQixJQUFQLElBQWVBLElBQW5CLEVBQXlCO0FBQ3ZCMkQsOEJBQVVBLFdBQVcsQ0FBQyxDQUFDUyxLQUF2Qjs7QUFFQXhsQiwyQkFBT3lsQixNQUFQLENBQWNELEtBQWQ7QUFDRCxtQkFyRWlDLENBcUVoQzs7O0FBR0Ysc0JBQUl4bEIsT0FBTzBpQixNQUFQLElBQWlCQSxNQUFyQixFQUE2QjtBQUMzQnFDLDhCQUFVQSxXQUFXLENBQUMsQ0FBQ1MsS0FBdkI7O0FBRUF4bEIsMkJBQU8wbEIsUUFBUCxDQUFnQkYsS0FBaEIsRUFBdUI5QyxNQUF2QjtBQUNEOztBQUVELHNCQUFJMWlCLE9BQU9paEIsTUFBUCxJQUFpQm42QixVQUFVc1YsV0FBVixHQUF3QjRELE9BQU9wSCxPQUFQLENBQWU4QixXQUE1RCxFQUF5RTtBQUN2RTtBQUNBLHdCQUFJM0gsSUFBSWtJLGNBQWNqQixPQUF0QixDQUZ1RSxDQUV4Qzs7QUFFL0Isd0JBQUlqSCxJQUFJeXVCLFlBQVl6bUIsSUFBWixHQUFtQmlGLE9BQU95Z0IsZUFBbEMsRUFBbUQ7QUFDakRjLHdDQUFrQixDQUFDLENBQW5CO0FBQ0QscUJBRkQsTUFFTyxJQUFJeHVCLElBQUl5dUIsWUFBWTFtQixLQUFaLEdBQW9Ca0YsT0FBT3lnQixlQUFuQyxFQUFvRDtBQUN6RGMsd0NBQWtCLENBQWxCO0FBQ0QscUJBRk0sTUFFQTtBQUNMQSx3Q0FBa0IsSUFBbEI7QUFDRDs7QUFFRCx3QkFBSUEsZUFBSixFQUFxQjtBQUNuQkUsaUNBQVcvMUIsS0FBWDtBQUNEO0FBQ0Y7QUFDRixpQkE5RkQ7O0FBZ0dBLHFCQUFLa0csT0FBTCxDQUFhOUcsZ0JBQWIsQ0FBOEIsV0FBOUIsRUFBMkM2NkIsTUFBM0M7QUFDQSxxQkFBSy96QixPQUFMLENBQWE5RyxnQkFBYixDQUE4QixZQUE5QixFQUE0QzY2QixNQUE1QztBQUNBenNCLHlCQUFTNlEsSUFBVCxDQUFjamYsZ0JBQWQsQ0FBK0IsV0FBL0IsRUFBNENrN0IsTUFBNUM7QUFDQTlzQix5QkFBUzZRLElBQVQsQ0FBY2pmLGdCQUFkLENBQStCLFdBQS9CLEVBQTRDazdCLE1BQTVDLEVBQW9EO0FBQ2xERywyQkFBUztBQUR5QyxpQkFBcEQ7QUFHQWp0Qix5QkFBU3BPLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDaTdCLElBQXJDO0FBQ0E3c0IseUJBQVM2USxJQUFULENBQWNqZixnQkFBZCxDQUErQixVQUEvQixFQUEyQ2k3QixJQUEzQztBQUNBLHFCQUFLajhCLEVBQUwsQ0FBUSxRQUFSLEVBQWtCLFlBQVk7QUFDNUJvUCwyQkFBU21OLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDMGYsSUFBeEM7QUFDQTdzQiwyQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLFVBQWxDLEVBQThDMGYsSUFBOUM7QUFDQTdzQiwyQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLFdBQWxDLEVBQStDMmYsTUFBL0M7QUFDQTlzQiwyQkFBUzZRLElBQVQsQ0FBYzFELG1CQUFkLENBQWtDLFdBQWxDLEVBQStDMmYsTUFBL0M7QUFDRCxpQkFMRDtBQU1BLHFCQUFLbitCLFVBQUwsQ0FBZ0JpQyxFQUFoQixDQUFtQixTQUFuQixFQUE4QixZQUFZO0FBQ3hDb1AsMkJBQVNtTixtQkFBVCxDQUE2QixTQUE3QixFQUF3QzBmLElBQXhDO0FBQ0E3c0IsMkJBQVM2USxJQUFULENBQWMxRCxtQkFBZCxDQUFrQyxVQUFsQyxFQUE4QzBmLElBQTlDO0FBQ0QsaUJBSEQ7QUFJRDtBQWhTQSxhQXRVa0IsRUF1bUJsQjtBQUNELzBCLG1CQUFLLFFBREo7QUFFRGhHLHFCQUFPLFNBQVN5NkIsTUFBVCxDQUFnQkQsS0FBaEIsRUFBdUI7QUFDNUIsb0JBQUlVLFNBQVMsS0FBS3IrQixVQUFMLENBQWdCc0MsV0FBaEIsRUFBYjs7QUFFQSxvQkFBSSxLQUFLekIsR0FBTCxHQUFXODhCLEtBQVgsR0FBbUJVLE1BQXZCLEVBQStCO0FBQzdCViwwQkFBUVUsU0FBUyxLQUFLeDlCLEdBQXRCO0FBQ0Q7O0FBRUQsb0JBQUksS0FBS0QsS0FBTCxHQUFhKzhCLEtBQWIsR0FBcUIsQ0FBekIsRUFBNEI7QUFDMUJBLDBCQUFRLEtBQUsvOEIsS0FBTCxHQUFhLENBQUMsQ0FBdEI7QUFDRDs7QUFFRCxxQkFBSzhDLE1BQUwsQ0FBWTtBQUNWOUMseUJBQU8sS0FBS0EsS0FBTCxHQUFhKzhCLEtBRFY7QUFFVjk4Qix1QkFBSyxLQUFLQSxHQUFMLEdBQVc4OEI7QUFGTixpQkFBWjtBQUlEO0FBQ0Q7Ozs7Ozs7OztBQWxCQyxhQXZtQmtCLEVBa29CbEI7QUFDRHgwQixtQkFBSyxVQURKO0FBRURoRyxxQkFBTyxTQUFTMDZCLFFBQVQsQ0FBa0JGLEtBQWxCLEVBQXlCWSxTQUF6QixFQUFvQztBQUN6QyxvQkFBSWxoQixXQUFXLEtBQUtyZCxVQUFMLENBQWdCc0MsV0FBaEIsRUFBZjs7QUFFQSxvQkFBSWk4QixjQUFjLE9BQWxCLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBSVosUUFBUSxDQUFSLElBQWEsS0FBSzk4QixHQUFMLElBQVksS0FBS0QsS0FBTCxHQUFhKzhCLEtBQXpCLElBQWtDLEtBQUt4RSxTQUF4RCxFQUFtRTtBQUNqRXdFLDRCQUFRLEtBQUs5OEIsR0FBTCxHQUFXLEtBQUtzNEIsU0FBaEIsR0FBNEIsS0FBS3Y0QixLQUF6QztBQUNEOztBQUVELHNCQUFJKzhCLFFBQVEsQ0FBUixJQUFhLEtBQUsvOEIsS0FBTCxHQUFhKzhCLEtBQWIsR0FBcUIsQ0FBdEMsRUFBeUM7QUFDdkNBLDRCQUFRLEtBQUsvOEIsS0FBTCxHQUFhLENBQUMsQ0FBdEI7QUFDRDs7QUFFRCx1QkFBSzhDLE1BQUwsQ0FBWTtBQUNWOUMsMkJBQU95TCxLQUFLd0ksR0FBTCxDQUFTLEtBQUtqVSxLQUFMLEdBQWErOEIsS0FBdEIsRUFBNkIsS0FBSzk4QixHQUFsQyxDQURHO0FBRVZBLHlCQUFLd0wsS0FBS3VJLEdBQUwsQ0FBUyxLQUFLaFUsS0FBTCxHQUFhKzhCLEtBQXRCLEVBQTZCLEtBQUs5OEIsR0FBbEM7QUFGSyxtQkFBWjtBQUlELGlCQWZELE1BZU87QUFDTDtBQUNBO0FBQ0Esc0JBQUk4OEIsUUFBUSxDQUFSLElBQWEsS0FBSzk4QixHQUFMLEdBQVc4OEIsS0FBWCxHQUFtQixLQUFLLzhCLEtBQXhCLEdBQWdDLEtBQUt1NEIsU0FBdEQsRUFBaUU7QUFDL0R3RSw0QkFBUSxLQUFLLzhCLEtBQUwsR0FBYSxLQUFLdTRCLFNBQWxCLEdBQThCLEtBQUt0NEIsR0FBM0M7QUFDRDs7QUFFRCxzQkFBSTg4QixRQUFRLENBQVIsSUFBYSxLQUFLOThCLEdBQUwsR0FBVzg4QixLQUFYLEdBQW1CdGdCLFFBQXBDLEVBQThDO0FBQzVDc2dCLDRCQUFRdGdCLFdBQVcsS0FBS3hjLEdBQXhCO0FBQ0Q7O0FBRUQsdUJBQUs2QyxNQUFMLENBQVk7QUFDVjlDLDJCQUFPeUwsS0FBS3dJLEdBQUwsQ0FBUyxLQUFLaFUsR0FBTCxHQUFXODhCLEtBQXBCLEVBQTJCLEtBQUsvOEIsS0FBaEMsQ0FERztBQUVWQyx5QkFBS3dMLEtBQUt1SSxHQUFMLENBQVMsS0FBSy9ULEdBQUwsR0FBVzg4QixLQUFwQixFQUEyQixLQUFLLzhCLEtBQWhDO0FBRkssbUJBQVo7QUFJRDtBQUNGO0FBcENBLGFBbG9Ca0IsRUF1cUJsQjtBQUNEdUksbUJBQUsscUJBREo7QUFFRGhHLHFCQUFPLFNBQVMyNEIsbUJBQVQsQ0FBNkJqQixNQUE3QixFQUFxQztBQUMxQyxvQkFBSTJELFdBQUo7O0FBRUEsb0JBQUkzRCxNQUFKLEVBQVk7QUFDVjJELGdDQUFjLEtBQUt6ekIsUUFBTCxHQUFnQixZQUFoQixHQUErQixZQUE3QztBQUNELGlCQUZELE1BRU87QUFDTHl6QixnQ0FBYyxNQUFkO0FBQ0Q7O0FBRUQscUJBQUt2RCxZQUFMLElBQXFCLEtBQUtqcUIsS0FBTCxDQUFXLEtBQUtpcUIsWUFBaEIsRUFBOEI7QUFDakRuRSwwQkFBUTBIO0FBRHlDLGlCQUE5QixDQUFyQjtBQUdBLHFCQUFLdEQsYUFBTCxJQUFzQixLQUFLbHFCLEtBQUwsQ0FBVyxLQUFLa3FCLGFBQWhCLEVBQStCO0FBQ25EcEUsMEJBQVEwSDtBQUQyQyxpQkFBL0IsQ0FBdEI7QUFHRDtBQWpCQSxhQXZxQmtCLENBQXJCOztBQTJyQkEsbUJBQU9oRyxNQUFQO0FBQ0QsV0Fyd0J5QixFQUExQjs7QUF1d0JBNzZCLGtCQUFRNjZCLE1BQVIsR0FBaUJBLE1BQWpCOztBQUVBO0FBQU87O0FBRVAsZ0JBN3ZDcUMsRUFBM0I7QUE4dkNWO0FBQ0EsY0Fqd0N1QixDQWl3Q2I7QUFDVixjQUFVLElBQUkvQywyQkFBMkIsRUFBL0I7QUFDVjtBQUNBLGNBcHdDdUIsQ0Fvd0NiO0FBQ1YsY0FBVSxTQUFTcnRCLG1CQUFULENBQTZCc3RCLFFBQTdCLEVBQXVDO0FBQ2pELGdCQURpRCxDQUN0QztBQUNYLGdCQUFXLElBQUlDLGVBQWVGLHlCQUF5QkMsUUFBekIsQ0FBbkI7QUFDWCxnQkFBVyxJQUFJQyxpQkFBaUJ0MkIsU0FBckIsRUFBZ0M7QUFDM0Msa0JBQVksT0FBT3MyQixhQUFhaDRCLE9BQXBCO0FBQ1o7QUFBWTtBQUNaLGdCQU5pRCxDQU10QztBQUNYLGdCQUFXLElBQUlELFNBQVMrM0IseUJBQXlCQyxRQUF6QixJQUFxQztBQUM3RCxrQkFENkQsQ0FDakQ7QUFDWixrQkFGNkQsQ0FFakQ7QUFDWixrQkFBWS8zQixTQUFTO0FBQ3JCLGtCQUo2RCxFQUFsRDtBQUtYO0FBQ0EsZ0JBYmlELENBYXRDO0FBQ1gsZ0JBQVd3SyxvQkFBb0J1dEIsUUFBcEIsRUFBOEJoNEIsTUFBOUIsRUFBc0NBLE9BQU9DLE9BQTdDLEVBQXNEeUssbUJBQXREO0FBQ1g7QUFDQSxnQkFoQmlELENBZ0J0QztBQUNYLGdCQUFXLE9BQU8xSyxPQUFPQyxPQUFkO0FBQ1g7QUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBM3hDdUIsQ0EyeENiO0FBQ1YsY0E1eEN1QixDQTR4Q2I7QUFDVixjQTd4Q3VCLENBNnhDYjtBQUNWLGNBQVUsSUFBSWk0QixzQkFBc0J4dEIsb0JBQW9CLCtCQUFwQixDQUExQjtBQUNWO0FBQ0EsY0FBVSxPQUFPd3RCLG1CQUFQO0FBQ1Y7QUFBVSxLQWp5Q007QUFBaEI7QUFteUNDLENBN3lDRDtBQTh5Q0EsOEMiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDIxOGE1OTNjYTUwNWQ3ZTQxYWZiIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImltcG9ydCAnLi9zdHlsZXMvd2F2ZWZvcm0uY3NzJ1xyXG5pbXBvcnQgV2F2ZWZvcm1Jbml0IGZyb20gXCIuL3NjcmlwdHMvV2F2ZWZvcm1Jbml0XCI7XHJcblxyXG4vLyBMb2FkIGxpYnJhcnlcclxuSDVQID0gSDVQIHx8IHt9O1xyXG5INVBFZGl0b3Iud2lkZ2V0cy53YXZlZm9ybUluaXQgPSBINVBFZGl0b3IuV2F2ZWZvcm1Jbml0ID0gV2F2ZWZvcm1Jbml0O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kaXN0LmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy93YXZlZm9ybS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhcmVudCBmcm9tICdoNXAtcGFyZW50JztcclxuaW1wb3J0IHtcclxuICBqUXVlcnkgYXMgJFxyXG59IGZyb20gJy4uL2dsb2JhbHMnO1xyXG5pbXBvcnQgV2F2ZVN1cmZlciBmcm9tICd3YXZlc3VyZmVyLmpzJztcclxuaW1wb3J0IEN1cnNvclBsdWdpbiBmcm9tIFwid2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qc1wiO1xyXG5pbXBvcnQgUmVnaW9uc1BsdWdpbiBmcm9tIFwid2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanNcIjtcclxuXHJcbmxldCBXYXZlZm9ybUluaXQgPSBmdW5jdGlvbiAocGFyZW50LCBmaWVsZCwgcGFyYW1zLCBzZXRWYWx1ZSkge1xyXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICB0aGlzLnNldFZhbHVlID0gc2V0VmFsdWU7XHJcblxyXG4gIHRoaXMuaWQgPSBudWxsO1xyXG4gIHRoaXMuY3JBdWRpb0luZGV4ID0gMDtcclxuICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgdGhpcy5hdWRpb1BhcmFtcyA9IHRoaXMucGFyZW50LnBhcmVudC5wYXJlbnQucGFyYW1zLnBhcmFtcztcclxuICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMucGFyZW50LnBhcmFtcy5zdGFydER1cmF0aW9uICE9IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50LnBhcmFtcy5zdGFydER1cmF0aW9uIDogMDtcclxuICB0aGlzLmVuZFRpbWUgPSB0aGlzLnBhcmVudC5wYXJhbXMuZW5kRHVyYXRpb24gIT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnQucGFyYW1zLmVuZER1cmF0aW9uIDogMC4yO1xyXG4gIHRoaXMuYXVkaW9EdXJhdGlvbjtcclxufVxyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYXZlZm9ybUluaXQ7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSB0aGUgd2F2ZWZvcm0gZWRpdG9yLlxyXG4gKiBAcGFyYW0geyp9ICR3cmFwcGVyIFxyXG4gKi9cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBpZiAoIXNlbGYuY29udGFpbmVyIHx8IChzZWxmLmNvbnRhaW5lciAmJiBzZWxmLmNvbnRhaW5lci5sZW5ndGggPT0gMCkpIHJldHVybjtcclxuICB2YXIgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHtcclxuICAgIGNvbnRhaW5lcjogc2VsZi5jb250YWluZXJbMF0sXHJcbiAgICB3YXZlQ29sb3I6ICdncmVlbicsXHJcbiAgICBwcm9ncmVzc0NvbG9yOiAnZ3JleScsXHJcbiAgICBmaWxsUGFyZW50OiB0cnVlLFxyXG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgIGJhckhlaWdodDogOCxcclxuICAgIHBsdWdpbnM6IFtcclxuICAgICAgUmVnaW9uc1BsdWdpbi5jcmVhdGUoe1xyXG4gICAgICAgIHJlZ2lvbnNNaW5MZW5ndGg6IDAuMSxcclxuICAgICAgICBtYXhSZWdpb25zOiAxLFxyXG4gICAgICAgIHJlZ2lvbnM6IFt7XHJcbiAgICAgICAgICBzdGFydDogc2VsZi5zdGFydFRpbWUsXHJcbiAgICAgICAgICBlbmQ6IHNlbGYuZW5kVGltZSxcclxuICAgICAgICAgIGxvb3A6IGZhbHNlLFxyXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDI1MCwgMjAzLCAxMTAsIDAuNSknXHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgZHJhZ1NlbGVjdGlvbjoge1xyXG4gICAgICAgICAgc2xvcDogNVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIF1cclxuICB9KTtcclxuXHJcbiAgJCgnLndhdmVzdXJmZXItaGFuZGxlJykuY3NzKFwid2lkdGhcIiwgXCI0cHhcIik7XHJcbiAgJCgnLndhdmVzdXJmZXItaGFuZGxlJykuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM3MDcwNzBcIik7XHJcblxyXG4gIGxldCByZWdpb247XHJcbiAgc2VsZi5jckF1ZGlvSW5kZXggPSBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHMubGVuZ3RoO1xyXG4gIC8vIGxldCBwYXRoID0gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzW3NlbGYuY3JBdWRpb0luZGV4LSAxXS5wYXJhbXMuZmlsZXMgPyBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHNbc2VsZi5jckF1ZGlvSW5kZXggLSAxXS5wYXJhbXMuZmlsZXNbMF0ucGF0aCA6IHVuZGVmaW5lZDtcclxuICBsZXQgaWQgPSBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHNbMF0ucGFyZW50LnBhcmFtcy5zdWJDb250ZW50SWQ7XHJcbiAgbGV0IHBhdGggPSBzZWxmLmF1ZGlvUGFyYW1zLmZpbGVzID8gc2VsZi5hdWRpb1BhcmFtcy5maWxlc1swXS5wYXRoIDogdW5kZWZpbmVkO1xyXG4gIC8vIGxldCBpZCA9ICBzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmFtcy5zdWJDb250ZW50SWQ7XHJcbiAgaWYgKHBhdGggIT0gdW5kZWZpbmVkICYmIGlkICE9IHVuZGVmaW5lZCkge1xyXG4gICAgbGV0IGZpbGUgPSBINVAuZ2V0UGF0aChwYXRoLCBpZCk7XHJcbiAgICAkLmdldChmaWxlKS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2F2ZXN1cmZlci5sb2FkKGZpbGUpO1xyXG4gICAgICB9LCAxMDAwKVxyXG4gICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGxldCBpZCA9IEg1UEVkaXRvci5jb250ZW50SWQ7XHJcbiAgICAgIGxldCBmaWxlID0gSDVQLmdldFBhdGgocGF0aCwgaWQpO1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3YXZlc3VyZmVyLmxvYWQoZmlsZSk7XHJcbiAgICAgIH0sIDEwMDApXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcblxyXG4gIHdhdmVzdXJmZXIub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmVnaW9uID0gT2JqZWN0LnZhbHVlcyh3YXZlc3VyZmVyLnJlZ2lvbnMubGlzdClbMF07XHJcbiAgICBsZXQgd2lkdGggPSBzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC53aWR0aCArIChzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC53aWR0aCAqIDAuMjUpO1xyXG4gICAgc2VsZi5hdWRpb0R1cmF0aW9uID0gd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xyXG4gICAgLy8gd2F2ZXN1cmZlci5wYXJhbXMubWluUHhQZXJTZWMgPSB3aWR0aCAvIHdhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcclxuICAgIC8vIHdhdmVzdXJmZXIuZHJhd0J1ZmZlcigpO1xyXG5cclxuICAgIC8vIGxldCByZWdpb25JZCA9IHNlbGYuaWQgKyBcInBsYXlSZWdpb25cIlxyXG4gICAgLy8gbGV0ICRwbGF5UmVnaW9uQnV0dG9uID0gJzxidXR0b24gaWQgPSAnKyByZWdpb25JZCArJyBjbGFzcyA9IFwicGxheVJlZ2lvblwiPlBsYXk8L2J1dHRvbj4nXHJcbiAgICAvLyAkKCcjJyArIHNlbGYuaWQpLmZpbmQoJy53YXZlc3VyZmVyLXJlZ2lvbicpLmFwcGVuZCgkcGxheVJlZ2lvbkJ1dHRvbilcclxuICAgIC8vICQoJyMnICsgcmVnaW9uSWQpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAvLyAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgIC8vICAgaWYgKHJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgIC8vICAgICByZWdpb24ucGxheSgpXHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH0pXHJcbiAgICBsZXQgd2F2ZWZvcm0gPSBzZWxmLmNvbnRhaW5lclswXTtcclxuICAgIGxldCB3YXZlZm9ybVBhcmVudCA9IHdhdmVmb3JtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgIGNvbnNvbGUubG9nKHdhdmVmb3JtUGFyZW50KTtcclxuICAgIGxldCBzdGFydER1cmF0aW9uRmllbGQgPSB3YXZlZm9ybVBhcmVudC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtbmFtZS1zdGFydER1cmF0aW9uJyk7XHJcbiAgICBsZXQgZW5kRHVyYXRpb25GaWVsZCA9IHdhdmVmb3JtUGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1uYW1lLWVuZER1cmF0aW9uJyk7XHJcblxyXG4gICAgY29uc29sZS5sb2coc3RhcnREdXJhdGlvbkZpZWxkKTtcclxuICAgIGNvbnNvbGUubG9nKGVuZER1cmF0aW9uRmllbGQpO1xyXG4gIH0pO1xyXG5cclxuICBjb25zb2xlLmxvZyhcIlRlc3Rpbmc6IFwiKTtcclxuICBpZiAoc2VsZi5jb250YWluZXJbMF0pIHtcclxuICAgIGxldCB3YXZlZm9ybSA9IHNlbGYuY29udGFpbmVyWzBdO1xyXG4gICAgbGV0IHdhdmVmb3JtUGFyZW50ID0gd2F2ZWZvcm0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgY29uc29sZS5sb2cod2F2ZWZvcm1QYXJlbnQpO1xyXG4gICAgbGV0IHN0YXJ0RHVyYXRpb25GaWVsZCA9IHdhdmVmb3JtUGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1uYW1lLXN0YXJ0RHVyYXRpb24nKTtcclxuICAgIGxldCBlbmREdXJhdGlvbkZpZWxkID0gd2F2ZWZvcm1QYXJlbnQucXVlcnlTZWxlY3RvcignLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKTtcclxuXHJcbiAgICBpZiAoc3RhcnREdXJhdGlvbkZpZWxkICYmIGVuZER1cmF0aW9uRmllbGQpIHtcclxuICAgICAgbGV0IHN0YXJ0RHVyYXRpb25GaWVsZElucHV0ID0gc3RhcnREdXJhdGlvbkZpZWxkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgICAgIGxldCBlbmREdXJhdGlvbkZpZWxkSW5wdXQgPSBlbmREdXJhdGlvbkZpZWxkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgICBcclxuICAgICAgY29uc29sZS5sb2coc3RhcnREdXJhdGlvbkZpZWxkSW5wdXQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhlbmREdXJhdGlvbkZpZWxkSW5wdXQpO1xyXG4gICAgXHJcbiAgICAgIHN0YXJ0RHVyYXRpb25GaWVsZElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChyZWdpb24gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcclxuICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHZhbHVlKSA+IHNlbGYuYXVkaW9EdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpbnB1dFN0YXJ0VGltZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRFbmRUaW1lID0gcmVnaW9uLmVuZCA8PSBwYXJzZUZsb2F0KHZhbHVlKSA/IHBhcnNlRmxvYXQodmFsdWUpICsgMC4yIDogcmVnaW9uLmVuZDtcclxuICAgICAgICAgICAgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgIHN0YXJ0OiBpbnB1dFN0YXJ0VGltZS50b0ZpeGVkKDQpLFxyXG4gICAgICAgICAgICAgIGVuZDogaW5wdXRFbmRUaW1lLnRvRml4ZWQoNClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWdpb24udXBkYXRlKHBhcmFtcylcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmluZCgnLmg1cC1lcnJvcnMnKS5hcHBlbmQoXCI8cD5UaGUgZW50ZXJlZCB2YWx1ZSBtdXN0IGJlIE51bWJlciBub3QgYWxwaGFiZXQ8L3A+XCIpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIFxyXG4gICAgICBlbmREdXJhdGlvbkZpZWxkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQodmFsdWUpID4gc2VsZi5hdWRpb0R1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLmF1ZGlvRHVyYXRpb24gLSAwLjA1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpbnB1dFN0YXJ0VGltZSA9IHBhcnNlRmxvYXQodmFsdWUpIDw9IHJlZ2lvbi5zdGFydCA/IDAgOiByZWdpb24uc3RhcnRcclxuICAgICAgICAgICAgbGV0IGlucHV0RW5kVGltZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IGlucHV0U3RhcnRUaW1lLnRvRml4ZWQoNCksXHJcbiAgICAgICAgICAgICAgZW5kOiBpbnB1dEVuZFRpbWUudG9GaXhlZCg0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZ2lvbi51cGRhdGUocGFyYW1zKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5maW5kKCcuaDVwLWVycm9ycycpLmFwcGVuZChcIjxwPlRoZSBlbnRlcmVkIHZhbHVlIG11c3QgYmUgTnVtYmVyIG5vdCBhbHBoYWJldDwvcD5cIilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd2F2ZXN1cmZlci5vbigncmVnaW9uLXVwZGF0ZWQnLCAoZXZlbnQpID0+IHtcclxuICAgIHRoaXMuc3RhcnQgPSBldmVudC5zdGFydDtcclxuICAgIHRoaXMuZW5kID0gZXZlbnQuZW5kO1xyXG4gICAgdGhpcy4kc3RhcnRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtc3RhcnREdXJhdGlvbicpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLiRlbmRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKS5maW5kKCdpbnB1dCcpXHJcbiAgICB0aGlzLiRzdGFydGlucHV0LnZhbCh0aGlzLnN0YXJ0LnRvRml4ZWQoNCkpO1xyXG4gICAgdGhpcy4kZW5kaW5wdXQudmFsKHRoaXMuZW5kLnRvRml4ZWQoNCkpO1xyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcInN0YXJ0RHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMuc3RhcnQudG9GaXhlZCg0KSk7XHJcbiAgICB0aGlzLnNldFZhbHVlKHRoaXMuZmluZEZpZWxkKFwiZW5kRHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMuZW5kLnRvRml4ZWQoNCkpO1xyXG4gIH0pO1xyXG5cclxuICAkKHNlbGYuY29udGFpbmVyKS5wYXJlbnRzKCcuaDVwLWNyYXVkaW8tZWRpdG9yJykuZmluZChcIi5oNXAtYWRkLWZpbGVcIikuZmlyc3QoKS5wYXJlbnQoKS5maW5kKCd1bCcpLm9uKCdET01TdWJ0cmVlTW9kaWZpZWQnLFxyXG4gICAgKCkgPT4ge1xyXG4gICAgICAvLyBsZXQgcGF0aCA9IEg1UEVkaXRvci5yZW5kZXJhYmxlQ29tbW9uRmllbGRzW1wiSDVQLkNSQXVkaW8gMS40XCJdLmZpZWxkc1tzZWxmLmNyQXVkaW9JbmRleC0gMV0ucGFyYW1zLmZpbGVzID8gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzW3NlbGYuY3JBdWRpb0luZGV4IC0gMV0ucGFyYW1zLmZpbGVzWzBdLnBhdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgIGxldCBpZCA9IEg1UEVkaXRvci5yZW5kZXJhYmxlQ29tbW9uRmllbGRzW1wiSDVQLkNSQXVkaW8gMS40XCJdLmZpZWxkc1tzZWxmLmNyQXVkaW9JbmRleCAtIDFdLnBhcmVudC5wYXJhbXMuc3ViQ29udGVudElkO1xyXG4gICAgICBsZXQgcGF0aCA9IHNlbGYuYXVkaW9QYXJhbXMuZmlsZXMgPyBzZWxmLmF1ZGlvUGFyYW1zLmZpbGVzWzBdLnBhdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChwYXRoICE9IHVuZGVmaW5lZCAmJiBpZCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgZmlsZSA9IEg1UC5nZXRQYXRoKHBhdGgsIGlkKTtcclxuICAgICAgICAkLmdldChmaWxlKS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXZlc3VyZmVyLmxvYWQoZmlsZSk7XHJcbiAgICAgICAgICB9LCAxMDAwKVxyXG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgbGV0IGlkID0gSDVQRWRpdG9yLmNvbnRlbnRJZDtcclxuICAgICAgICAgIGxldCBmaWxlID0gSDVQLmdldFBhdGgocGF0aCwgaWQpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhdmVzdXJmZXIubG9hZChmaWxlKTtcclxuICAgICAgICAgIH0sIDEwMDApXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVnaW9uICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCAkc3RhcnRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtc3RhcnREdXJhdGlvbicpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICAgICAgbGV0ICRlbmRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKS5maW5kKCdpbnB1dCcpXHJcbiAgICAgICAgJHN0YXJ0aW5wdXQudmFsKDApO1xyXG4gICAgICAgICRlbmRpbnB1dC52YWwoMC4yKTtcclxuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuZmluZEZpZWxkKFwic3RhcnREdXJhdGlvblwiLCB0aGlzLnBhcmVudC5maWVsZC5maWVsZHMpLCBcIlwiICsgMCk7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcImVuZER1cmF0aW9uXCIsIHRoaXMucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyAwLjIpO1xyXG4gICAgICAgIHBhcmFtcyA9IHtcclxuICAgICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgICAgZW5kOiAwLjJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaW9uLnVwZGF0ZShwYXJhbXMpXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICBpZiAodGhpcy5pZCAhPSBudWxsKSB7XHJcbiAgICBsZXQgcmVnaW9uSWQgPSB0aGlzLmlkICsgXCJwbGF5UmVnaW9uXCI7XHJcbiAgICBsZXQgJHBsYXlSZWdpb25CdXR0b24gPSAkKCc8YnV0dG9uIGlkID0gJyArIHJlZ2lvbklkICsgJyBjbGFzcyA9IFwicGxheVJlZ2lvblwiPlBsYXk8L2J1dHRvbj4nKTtcclxuICAgICQoc2VsZi5jb250YWluZXIpLnBhcmVudCgnZGl2JykuYXBwZW5kKCRwbGF5UmVnaW9uQnV0dG9uKTtcclxuICAgICQoJHBsYXlSZWdpb25CdXR0b24pLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZWdpb24ucGxheSgpO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGVuZCB0aGUgZmllbGQgdG8gdGhlIHdyYXBwZXIuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtINVAualF1ZXJ5fSAkd3JhcHBlclxyXG4gKi9cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uICgkd3JhcHBlcikge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBjb25zdCBpZCA9IG5zLmdldE5leHRGaWVsZElkKHRoaXMuZmllbGQpO1xyXG4gIHZhciBodG1sID0gSDVQRWRpdG9yLmNyZWF0ZUZpZWxkTWFya3VwKHRoaXMuZmllbGQsICc8ZGl2IGNsYXNzPVwid2F2ZWZvcm1cIiBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cImg1cC1jb2xvci1waWNrZXJcIj4nLCBpZCk7XHJcbiAgc2VsZi4kaXRlbSA9IEg1UEVkaXRvci4kKGh0bWwpO1xyXG4gIHRoaXMuc2V0SWQoaWQpO1xyXG4gIGxldCB3b3JkVGV4dCA9ICh0aGlzLnBhcmVudC5wYXJhbXMudGV4dCAhPSB1bmRlZmluZWQpID8gdGhpcy5wYXJlbnQucGFyYW1zLnRleHQgOiAnJ1xyXG4gICR3cmFwcGVyLmFwcGVuZCgnPGgxIGNsYXNzPVwidGVzdFwiPlNlbGVjdCB3b3JkKHMpPC9oMT4nKVxyXG4gIC8vICR3cmFwcGVyLmFwcGVuZCgnPGxhYmVsIGNsYXNzPVwiaDVwZWRpdG9yLWxhYmVsXCI+PGlucHV0IGlkPVwiZmllbGQtd29yZHMtMTI1XCIgdHlwZT1cImNoZWNrYm94XCI+V2lsbCBEbyBBbmltYXRpb248L2xhYmVsPicpXHJcbiAgLy9sZXQgY2hlY2tCb3hFbGVtZW50Rm9yV29yZD0kd3JhcHBlci5hcHBlbmQodGhpcy5nZXRTZW50ZW5jZShzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC5zbGlkZXMsc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQuY3AuY3VycmVudFNsaWRlSW5kZXgpKVxyXG4gIGxldCBjaGVja0JveEVsZW1lbnRGb3JXb3JkID0gJHdyYXBwZXIuYXBwZW5kKHRoaXMuZ2V0U2VudGVuY2Uoc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQuY3Auc2xpZGVzLCB0aGlzLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmFtcy5wYXJhbXMuY3VyckluZGV4LCB0aGlzLnBhcmVudC5wYXJhbXMudGV4dCkpXHJcbiAgc2VsZi4kaXRlbS5hcHBlbmRUbygkd3JhcHBlcik7XHJcbiAgc2VsZi5jb250YWluZXIgPSBzZWxmLiRpdGVtLmZpbmQoJyMnICsgdGhpcy5pZCk7XHJcbiAgJChjaGVja0JveEVsZW1lbnRGb3JXb3JkKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBpZiAoJCgnIycgKyBldmVudC50YXJnZXQuaWQpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgIHdvcmRUZXh0ID0gd29yZFRleHQgKyAnICcgKyBldmVudC50YXJnZXQudmFsdWUgKyAnICdcclxuICAgICAgJCgnIycgKyBldmVudC50YXJnZXQuaWQpLmF0dHIoJ2NoZWNrZWQnLCB0cnVlKVxyXG4gICAgICB0aGlzLiR3b3JkID0gJCgnIycgKyBpZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtdGV4dCcpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICAgIHRoaXMuJHdvcmQudmFsKCh3b3JkVGV4dC50cmltKCkpLnJlcGxhY2UoLyAgKy9nLCAnICcpKVxyXG4gICAgICAkKHRoaXMuJHdvcmQpLmF0dHIoJ2NoZWNrZWQnLCB0cnVlKVxyXG4gICAgICBzZWxmLnNldFZhbHVlKHNlbGYuZmluZEZpZWxkKFwidGV4dFwiLCBzZWxmLnBhcmVudC5maWVsZC5maWVsZHMpLCBcIlwiICsgd29yZFRleHQucmVwbGFjZSgvICArL2csICcgJykpO1xyXG4gICAgICAvL1dhdmVmb3JtSW5pdC5zZWxmMi5zZXRWYWx1ZShINVBFZGl0b3IuQ3VyaW91c1JlYWRlci5maW5kRmllbGQoXCJ0ZXh0XCIsc2VsZjIucGFyZW50LmZpZWxkLmZpZWxkcyksXCJTYW0tcGxlIGRhdGFcIilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQoJyMnICsgZXZlbnQudGFyZ2V0LmlkKS5hdHRyKCdjaGVja2VkJywgZmFsc2UpXHJcbiAgICAgIGxldCB0ZW1wV29yZFRleHQgPSB3b3JkVGV4dC5yZXBsYWNlKGV2ZW50LnRhcmdldC52YWx1ZSwgJycpXHJcbiAgICAgIHdvcmRUZXh0ID0gdGVtcFdvcmRUZXh0XHJcbiAgICAgIHRoaXMuJHdvcmQgPSAkKCcjJyArIGlkKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuZmllbGQtbmFtZS10ZXh0JykuZmluZCgnaW5wdXQnKTtcclxuICAgICAgc2VsZi5zZXRWYWx1ZShzZWxmLmZpbmRGaWVsZChcInRleHRcIiwgc2VsZi5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHdvcmRUZXh0LnJlcGxhY2UoLyAgKy9nLCAnICcpKTtcclxuICAgICAgJCh0aGlzLiR3b3JkKS5hdHRyKCdjaGVja2VkJywgZmFsc2UpXHJcbiAgICAgIHRoaXMuJHdvcmQudmFsKCh3b3JkVGV4dC50cmltKCkpLnJlcGxhY2UoLyAgKy9nLCAnICcpKVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgc2VsZi5zZXRWYWx1ZShzZWxmLmZpbmRGaWVsZChcInRleHRcIiwgc2VsZi5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMucGFyZW50LnBhcmFtcy50ZXh0KTtcclxuICBzZWxmLmluaXQoKTtcclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZmluZEZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIGZpZWxkcykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoZmllbGRzW2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIGZpZWxkc1tpXTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgdGhpcy5pZCA9IGlkO1xyXG59XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLmZpbmRGaWVsZCA9IGZ1bmN0aW9uIChuYW1lLCBmaWVsZHMpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGZpZWxkc1tpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgIHJldHVybiBmaWVsZHNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyB0aGlzLmhpZGUoKTtcclxuICAvLyByZXR1cm4gKHRoaXMucGFyYW1zICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJhbXMubGVuZ3RoICE9PSAwKTtcclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZ2V0U2VudGVuY2UgPSBmdW5jdGlvbiAoc2xpZGVzLCBzbGlkZUluZGV4LCBwcmV2RGF0YSkge1xyXG4gIHZhciBzZW50ZW5jZVdvcmRzID0gW107XHJcbiAgdmFyIHNwbGl0dGVkUHJldkRhdGEgPSAocHJldkRhdGEgIT0gdW5kZWZpbmVkKSA/IHByZXZEYXRhLnNwbGl0KCcgJykgOiBbXVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzW3NsaWRlSW5kZXhdLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgaWYgKHNsaWRlc1tzbGlkZUluZGV4XS5lbGVtZW50c1tpXS5hY3Rpb24ubGlicmFyeS5zcGxpdCgnICcpWzBdID09IFwiSDVQLkNSQWR2YW5jZWRUZXh0XCIpIHtcclxuICAgICAgdmFyIGNoZWNrQm94V29yZCA9ICcnXHJcbiAgICAgIHNlbnRlbmNlV29yZHMgPSAkKHNsaWRlc1tzbGlkZUluZGV4XS5lbGVtZW50c1tpXS5hY3Rpb24ucGFyYW1zLnRleHQpWzBdLmlubmVyVGV4dC5zcGxpdCgnICcpXHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VudGVuY2VXb3Jkcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBkZWYgPSAoc3BsaXR0ZWRQcmV2RGF0YS5pbmRleE9mKHNlbnRlbmNlV29yZHNbal0pICE9PSAtMSkgPyB0cnVlIDogZmFsc2VcclxuICAgICAgICBpZiAoc2VudGVuY2VXb3Jkc1tqXS5yZXBsYWNlKC8gICsvZywgJyAnKSAhPSAnJykge1xyXG4gICAgICAgICAgaWYgKGRlZikge1xyXG4gICAgICAgICAgICBjaGVja0JveFdvcmQgPSBjaGVja0JveFdvcmQgKyAnPGxhYmVsIGNsYXNzPVwiaDVwZWRpdG9yLWxhYmVsIGlkID0nICsgdGhpcy5pZCArIGogKyAnXCI+PGlucHV0IGlkPScgKyB0aGlzLmlkICsgaiArICcgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCInICsgc2VudGVuY2VXb3Jkc1tqXSArICdcImNoZWNrZWQ+JyArIHNlbnRlbmNlV29yZHNbal0gKyAnPC9sYWJlbD4nXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGVja0JveFdvcmQgPSBjaGVja0JveFdvcmQgKyAnPGxhYmVsIGNsYXNzPVwiaDVwZWRpdG9yLWxhYmVsIGlkID0nICsgdGhpcy5pZCArIGogKyAnXCI+PGlucHV0IGlkPScgKyB0aGlzLmlkICsgaiArICcgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCInICsgc2VudGVuY2VXb3Jkc1tqXSArICdcIj4nICsgc2VudGVuY2VXb3Jkc1tqXSArICc8L2xhYmVsPidcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNoZWNrQm94V29yZDtcclxufVxyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7fTtcclxuZXhwb3J0IGRlZmF1bHQgV2F2ZWZvcm1Jbml0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvV2F2ZWZvcm1Jbml0LmpzIiwiY29uc3QgQ2hpbGQgPSByZXF1aXJlKCcuL2NoaWxkLmpzJyk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlciA9IEg1UC5FdmVudERpc3BhdGNoZXI7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiBQYXJlbnQoY29uc3RydWN0b3IsIHBhcmFtZXRlcnMpIHtcclxuICBjb25zdCBzZWxmID0gdGhpcztcclxuICBFdmVudERpc3BhdGNoZXIuY2FsbChzZWxmKTtcclxuXHJcbiAgc2VsZi5jaGlsZHJlbiA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIGluZGV4ZXMgb2YgdGhlIGNoaWxkcmVuLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbSBXaGVyZSB0byBzdGFydFxyXG4gICAqL1xyXG4gIHZhciB1cGRhdGVJbmRleGVzID0gZnVuY3Rpb24gKGZyb20pIHtcclxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgc2VsZi5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzZWxmLmNoaWxkcmVuW2ldLmluZGV4ID0gaTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHaXZlIGEgbmV3IGNoaWxkIHRvIHRoaXMgcGFyZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBjaGlsZFBhcmFtZXRlcnMgTGF1bmNoIHBhcmFtZXRlcnNcclxuICAgKi9cclxuICBzZWxmLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGFyYW1ldGVycywgaW5kZXgpIHtcclxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGluZGV4ID0gc2VsZi5jaGlsZHJlbi5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgY2hpbGQgd2l0aCB0aGUgY3VycmVudCBpbnN0YW5jZSBhcyBpdHMgcGFyZW50XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDaGlsZChpbmRleCwgc2VsZik7XHJcblxyXG4gICAgaWYgKGluZGV4ID09PSBzZWxmLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAvLyBBZGRlZCBhdCB0aGUgZW5kXHJcbiAgICAgIHNlbGYuY2hpbGRyZW4ucHVzaChpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gSW5zZXJ0ZWQgYXQgYSBzcGVjaWZpYyBsb2NhdGlvblxyXG4gICAgICBzZWxmLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgaW5zdGFuY2UpO1xyXG4gICAgICB1cGRhdGVJbmRleGVzKGluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSdW4gb3JpZ2luYWwgY29uc3RydWN0b3JcclxuICAgIGNvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGNoaWxkUGFyYW1ldGVycyk7XHJcblxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92YSBhIG5ldyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKi9cclxuICBzZWxmLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAvLyBSZW1vdmUgZnJvbSBhcnJheVxyXG4gICAgc2VsZi5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBpbmRleGVzXHJcbiAgICB1cGRhdGVJbmRleGVzKGluZGV4KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBjaGlsZCBpbnRvIGEgbmV3IHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2xkSW5kZXhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXhcclxuICAgKi9cclxuICBzZWxmLm1vdmVDaGlsZCA9IGZ1bmN0aW9uIChvbGRJbmRleCwgbmV3SW5kZXgpIHtcclxuICAgIGNvbnN0IGNoaWxkID0gc2VsZi5jaGlsZHJlbi5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdO1xyXG4gICAgc2VsZi5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICB1cGRhdGVJbmRleGVzKG5ld0luZGV4IDwgb2xkSW5kZXggPyBuZXdJbmRleCA6IG9sZEluZGV4KTtcclxuICB9O1xyXG5cclxuICBpZiAocGFyYW1ldGVycykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHNlbGYuYWRkQ2hpbGQocGFyYW1ldGVyc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5QYXJlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudERpc3BhdGNoZXIucHJvdG90eXBlKTtcclxuUGFyZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFyZW50O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaDVwLXBhcmVudC9zcmMvcGFyZW50LmpzIiwiLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gQ2hpbGQoaW5kZXgsIHBhcmVudCkge1xyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgc2VsZi5wYXJlbnQgPSBwYXJlbnQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hpbGQ7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oNXAtcGFyZW50L3NyYy9jaGlsZC5qcyIsImV4cG9ydCBjb25zdCBqUXVlcnkgPSBINVAualF1ZXJ5O1xyXG5leHBvcnQgY29uc3QgRXZlbnREaXNwYXRjaGVyID0gSDVQLkV2ZW50RGlzcGF0Y2hlcjtcclxuZXhwb3J0IGNvbnN0IEpvdWJlbFVJID0gSDVQLkpvdWJlbFVJO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9nbG9iYWxzLmpzIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIDUuMS4wICgyMDIxLTA2LTIwKVxuICogaHR0cHM6Ly93YXZlc3VyZmVyLWpzLm9yZ1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiV2F2ZVN1cmZlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJXYXZlU3VyZmVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIldhdmVTdXJmZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL3NyYy9kcmF3ZXIuY2FudmFzZW50cnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RyYXdlci5jYW52YXNlbnRyeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9zdHlsZSAqLyBcIi4vc3JjL3V0aWwvc3R5bGUuanNcIikpO1xuXG52YXIgX2dldElkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvZ2V0LWlkICovIFwiLi9zcmMvdXRpbC9nZXQtaWQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogVGhlIGBDYW52YXNFbnRyeWAgY2xhc3MgcmVwcmVzZW50cyBhbiBlbGVtZW50IGNvbnNpc3Rpbmcgb2YgYSB3YXZlIGBjYW52YXNgXG4gKiBhbmQgYW4gKG9wdGlvbmFsKSBwcm9ncmVzcyB3YXZlIGBjYW52YXNgLlxuICpcbiAqIFRoZSBgTXVsdGlDYW52YXNgIHJlbmRlcmVyIHVzZXMgb25lIG9yIG1vcmUgYENhbnZhc0VudHJ5YCBpbnN0YW5jZXMgdG9cbiAqIHJlbmRlciBhIHdhdmVmb3JtLCBkZXBlbmRpbmcgb24gdGhlIHpvb20gbGV2ZWwuXG4gKi9cbnZhciBDYW52YXNFbnRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbnZhc0VudHJ5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNFbnRyeSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2F2ZSBub2RlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy53YXZlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2F2ZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG5cbiAgICB0aGlzLndhdmVDdHggPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSAob3B0aW9uYWwpIHByb2dyZXNzIHdhdmUgbm9kZVxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9ncmVzcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIChvcHRpb25hbCkgcHJvZ3Jlc3Mgd2F2ZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG5cbiAgICB0aGlzLnByb2dyZXNzQ3R4ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBTdGFydCBvZiB0aGUgYXJlYSB0aGUgY2FudmFzIHNob3VsZCByZW5kZXIsIGJldHdlZW4gMCBhbmQgMVxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEVuZCBvZiB0aGUgYXJlYSB0aGUgY2FudmFzIHNob3VsZCByZW5kZXIsIGJldHdlZW4gMCBhbmQgMVxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZW5kID0gMTtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBlbnRyeVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMuaWQgPSAoMCwgX2dldElkLmRlZmF1bHQpKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgIT09ICd1bmRlZmluZWQnID8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCkgKyAnXycgOiAnY2FudmFzZW50cnlfJyk7XG4gICAgLyoqXG4gICAgICogQ2FudmFzIDJkIGNvbnRleHQgYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cblxuICAgIHRoaXMuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogU3RvcmUgdGhlIHdhdmUgY2FudmFzIGVsZW1lbnQgYW5kIGNyZWF0ZSB0aGUgMkQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCBUaGUgd2F2ZSBgY2FudmFzYCBlbGVtZW50LlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDYW52YXNFbnRyeSwgW3tcbiAgICBrZXk6IFwiaW5pdFdhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFdhdmUoZWxlbWVudCkge1xuICAgICAgdGhpcy53YXZlID0gZWxlbWVudDtcbiAgICAgIHRoaXMud2F2ZUN0eCA9IHRoaXMud2F2ZS5nZXRDb250ZXh0KCcyZCcsIHRoaXMuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgcHJvZ3Jlc3Mgd2F2ZSBjYW52YXMgZWxlbWVudCBhbmQgY3JlYXRlIHRoZSAyRCByZW5kZXJpbmdcbiAgICAgKiBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50IFRoZSBwcm9ncmVzcyB3YXZlIGBjYW52YXNgIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBlbGVtZW50O1xuICAgICAgdGhpcy5wcm9ncmVzc0N0eCA9IHRoaXMucHJvZ3Jlc3MuZ2V0Q29udGV4dCgnMmQnLCB0aGlzLmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWxlbWVudFdpZHRoIFdpZHRoIG9mIHRoZSBlbnRyeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFdpZHRoIFRvdGFsIHdpZHRoIG9mIHRoZSBtdWx0aSBjYW52YXMgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aCBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9ucyhlbGVtZW50V2lkdGgsIHRvdGFsV2lkdGgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIHdoZXJlIHRoZSBjYW52YXMgc3RhcnRzIGFuZCBlbmRzIGluIHRoZSB3YXZlZm9ybSwgcmVwcmVzZW50ZWQgYXMgYVxuICAgICAgLy8gZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLndhdmUub2Zmc2V0TGVmdCAvIHRvdGFsV2lkdGggfHwgMDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5zdGFydCArIGVsZW1lbnRXaWR0aCAvIHRvdGFsV2lkdGg7IC8vIHNldCB3YXZlIGNhbnZhcyBkaW1lbnNpb25zXG5cbiAgICAgIHRoaXMud2F2ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy53YXZlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciBlbGVtZW50U2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnRXaWR0aCArICdweCdcbiAgICAgIH07XG4gICAgICAoMCwgX3N0eWxlLmRlZmF1bHQpKHRoaXMud2F2ZSwgZWxlbWVudFNpemUpO1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICAvLyBzZXQgcHJvZ3Jlc3MgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgICAgdGhpcy5wcm9ncmVzcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnByb2dyZXNzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgKDAsIF9zdHlsZS5kZWZhdWx0KSh0aGlzLnByb2dyZXNzLCBlbGVtZW50U2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSB3YXZlIGFuZCBwcm9ncmVzcyByZW5kZXJpbmcgY29udGV4dHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyV2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcldhdmUoKSB7XG4gICAgICAvLyB3YXZlXG4gICAgICB0aGlzLndhdmVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2F2ZUN0eC5jYW52YXMud2lkdGgsIHRoaXMud2F2ZUN0eC5jYW52YXMuaGVpZ2h0KTsgLy8gcHJvZ3Jlc3NcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5wcm9ncmVzc0N0eC5jYW52YXMud2lkdGgsIHRoaXMucHJvZ3Jlc3NDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsbCBzdHlsZXMgZm9yIHdhdmUgYW5kIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2F2ZUNvbG9yIEZpbGwgY29sb3IgZm9yIHRoZSB3YXZlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gcHJvZ3Jlc3NDb2xvciBGaWxsIGNvbG9yIGZvciB0aGUgcHJvZ3Jlc3MgY2FudmFzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGaWxsU3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxTdHlsZXMod2F2ZUNvbG9yLCBwcm9ncmVzc0NvbG9yKSB7XG4gICAgICB0aGlzLndhdmVDdHguZmlsbFN0eWxlID0gd2F2ZUNvbG9yO1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICB0aGlzLnByb2dyZXNzQ3R4LmZpbGxTdHlsZSA9IHByb2dyZXNzQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FudmFzIHRyYW5zZm9ybXMgZm9yIHdhdmUgYW5kIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcnRpY2FsIFdoZXRoZXIgdG8gcmVuZGVyIHZlcnRpY2FsbHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5Q2FudmFzVHJhbnNmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUNhbnZhc1RyYW5zZm9ybXModmVydGljYWwpIHtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAvLyBSZWZsZWN0IHRoZSB3YXZlZm9ybSBhY3Jvc3MgdGhlIGxpbmUgeSA9IC14XG4gICAgICAgIHRoaXMud2F2ZUN0eC5zZXRUcmFuc2Zvcm0oMCwgMSwgMSwgMCwgMCwgMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgICB0aGlzLnByb2dyZXNzQ3R4LnNldFRyYW5zZm9ybSgwLCAxLCAxLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcmVjdGFuZ2xlIGZvciB3YXZlIGFuZCBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaWxsUmVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFJlY3RzKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgICAgdGhpcy5maWxsUmVjdFRvQ29udGV4dCh0aGlzLndhdmVDdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuZmlsbFJlY3RUb0NvbnRleHQodGhpcy5wcm9ncmVzc0N0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgYWN0dWFsIHJlY3RhbmdsZSBvbiBhIGBjYW52YXNgIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNvbnRleHQgb2YgdGFyZ2V0IGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbFJlY3RUb0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFJlY3RUb0NvbnRleHQoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhZGl1cykge1xuICAgICAgICB0aGlzLmRyYXdSb3VuZGVkUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSByb3VuZGVkIHJlY3RhbmdsZSBvbiBDYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ2FudmFzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYLXBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZLXBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBleGFtcGxlIGRyYXdSb3VuZGVkUmVjdChjdHgsIDUwLCA1MCwgNSwgMTAsIDMpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Um91bmRlZFJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1JvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICBpZiAoaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gcGVha3MgYXJlIGZsb2F0IHZhbHVlcyBmcm9tIC0xIHRvIDEuIFVzZSBhYnNvbHV0ZSBoZWlnaHQgdmFsdWVzIGluXG4gICAgICAvLyBvcmRlciB0byBjb3JyZWN0bHkgY2FsY3VsYXRlIHJvdW5kZWQgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzXG5cblxuICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgaGVpZ2h0ICo9IC0xO1xuICAgICAgICB5IC09IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgYWN0dWFsIHdhdmUgYW5kIHByb2dyZXNzIGxpbmVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwZWFrcyBBcnJheSB3aXRoIHBlYWtzIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWJzbWF4IE1heGltdW0gcGVhayB2YWx1ZSAoYWJzb2x1dGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbGZIIEhhbGYgdGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBPZmZzZXQgdG8gdGhlIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGluZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmVzKHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kKSB7XG4gICAgICB0aGlzLmRyYXdMaW5lVG9Db250ZXh0KHRoaXMud2F2ZUN0eCwgcGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICB0aGlzLmRyYXdMaW5lVG9Db250ZXh0KHRoaXMucHJvZ3Jlc3NDdHgsIHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBhY3R1YWwgd2F2ZWZvcm0gbGluZSBvbiBhIGBjYW52YXNgIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNvbnRleHQgb2YgdGFyZ2V0IGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBlYWtzIEFycmF5IHdpdGggcGVha3MgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhYnNtYXggTWF4aW11bSBwZWFrIHZhbHVlIChhYnNvbHV0ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFsZkggSGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIE9mZnNldCB0byB0aGUgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lVG9Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lVG9Db250ZXh0KGN0eCwgcGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHBlYWtzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgZmlyc3QgPSBNYXRoLnJvdW5kKGxlbmd0aCAqIHRoaXMuc3RhcnQpOyAvLyB1c2Ugb25lIG1vcmUgcGVhayB2YWx1ZSB0byBtYWtlIHN1cmUgd2Ugam9pbiBwZWFrcyBhdCBlbmRzIC0tIHVubGVzcyxcbiAgICAgIC8vIG9mIGNvdXJzZSwgdGhpcyBpcyB0aGUgbGFzdCBjYW52YXNcblxuICAgICAgdmFyIGxhc3QgPSBNYXRoLnJvdW5kKGxlbmd0aCAqIHRoaXMuZW5kKSArIDE7XG4gICAgICB2YXIgY2FudmFzU3RhcnQgPSBmaXJzdDtcbiAgICAgIHZhciBjYW52YXNFbmQgPSBsYXN0O1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy53YXZlLndpZHRoIC8gKGNhbnZhc0VuZCAtIGNhbnZhc1N0YXJ0IC0gMSk7IC8vIG9wdGltaXphdGlvblxuXG4gICAgICB2YXIgaGFsZk9mZnNldCA9IGhhbGZIICsgb2Zmc2V0WTtcbiAgICAgIHZhciBhYnNtYXhIYWxmID0gYWJzbWF4IC8gaGFsZkg7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKChjYW52YXNTdGFydCAtIGZpcnN0KSAqIHNjYWxlLCBoYWxmT2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oKGNhbnZhc1N0YXJ0IC0gZmlyc3QpICogc2NhbGUsIGhhbGZPZmZzZXQgLSBNYXRoLnJvdW5kKChwZWFrc1syICogY2FudmFzU3RhcnRdIHx8IDApIC8gYWJzbWF4SGFsZikpO1xuICAgICAgdmFyIGksIHBlYWssIGg7XG5cbiAgICAgIGZvciAoaSA9IGNhbnZhc1N0YXJ0OyBpIDwgY2FudmFzRW5kOyBpKyspIHtcbiAgICAgICAgcGVhayA9IHBlYWtzWzIgKiBpXSB8fCAwO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChwZWFrIC8gYWJzbWF4SGFsZik7XG4gICAgICAgIGN0eC5saW5lVG8oKGkgLSBmaXJzdCkgKiBzY2FsZSArIHRoaXMuaGFsZlBpeGVsLCBoYWxmT2Zmc2V0IC0gaCk7XG4gICAgICB9IC8vIGRyYXcgdGhlIGJvdHRvbSBlZGdlIGdvaW5nIGJhY2t3YXJkcywgdG8gbWFrZSBhIHNpbmdsZVxuICAgICAgLy8gY2xvc2VkIGh1bGwgdG8gZmlsbFxuXG5cbiAgICAgIHZhciBqID0gY2FudmFzRW5kIC0gMTtcblxuICAgICAgZm9yIChqOyBqID49IGNhbnZhc1N0YXJ0OyBqLS0pIHtcbiAgICAgICAgcGVhayA9IHBlYWtzWzIgKiBqICsgMV0gfHwgMDtcbiAgICAgICAgaCA9IE1hdGgucm91bmQocGVhayAvIGFic21heEhhbGYpO1xuICAgICAgICBjdHgubGluZVRvKChqIC0gZmlyc3QpICogc2NhbGUgKyB0aGlzLmhhbGZQaXhlbCwgaGFsZk9mZnNldCAtIGgpO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVRvKChjYW52YXNTdGFydCAtIGZpcnN0KSAqIHNjYWxlLCBoYWxmT2Zmc2V0IC0gTWF0aC5yb3VuZCgocGVha3NbMiAqIGNhbnZhc1N0YXJ0ICsgMV0gfHwgMCkgLyBhYnNtYXhIYWxmKSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGVudHJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLndhdmVDdHggPSBudWxsO1xuICAgICAgdGhpcy53YXZlID0gbnVsbDtcbiAgICAgIHRoaXMucHJvZ3Jlc3NDdHggPSBudWxsO1xuICAgICAgdGhpcy5wcm9ncmVzcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBpbWFnZSBkYXRhIG9mIHRoZSB3YXZlIGBjYW52YXNgIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgYSBgdHlwZWAgb2YgYCdibG9iJ2AsIHRoaXMgd2lsbCByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdFxuICAgICAqIHJlc29sdmVzIHdpdGggYSBgQmxvYmAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0PSdpbWFnZS9wbmcnIEFuIG9wdGlvbmFsIHZhbHVlIG9mIGEgZm9ybWF0IHR5cGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHk9MC45MiBBbiBvcHRpb25hbCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGU9J2RhdGFVUkwnIEVpdGhlciAnZGF0YVVSTCcgb3IgJ2Jsb2InLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlfSBXaGVuIHVzaW5nIHRoZSBkZWZhdWx0IGAnZGF0YVVSTCdgIGB0eXBlYCB0aGlzXG4gICAgICogcmV0dXJucyBhIGRhdGEgVVJMLiBXaGVuIHVzaW5nIHRoZSBgJ2Jsb2InYCBgdHlwZWAgdGhpcyByZXR1cm5zIGFcbiAgICAgKiBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIGEgYEJsb2JgIGluc3RhbmNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIF90aGlzLndhdmUudG9CbG9iKHJlc29sdmUsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGF0YVVSTCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2F2ZS50b0RhdGFVUkwoZm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzRW50cnk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0VudHJ5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RyYXdlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZHJhd2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIHJlbmRlcmVyc1xuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqL1xudmFyIERyYXdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3V0aWwkT2JzZXJ2ZXIpIHtcbiAgX2luaGVyaXRzKERyYXdlciwgX3V0aWwkT2JzZXJ2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRHJhd2VyKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBjb250YWluZXIgbm9kZSBvZiB0aGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBUaGUgd2F2ZXN1cmZlciBpbml0aWFsaXNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBEcmF3ZXIoY29udGFpbmVyLCBwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhd2VyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuY29udGFpbmVyID0gdXRpbC53aXRoT3JpZW50YXRpb24oY29udGFpbmVyLCBwYXJhbXMudmVydGljYWwpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXYXZlc3VyZmVyUGFyYW1zfVxuICAgICAqL1xuXG4gICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgKiBfdGhpcy5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICBfdGhpcy5sYXN0UG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgYDx3YXZlPmAgZWxlbWVudCB3aGljaCBpcyBhZGRlZCB0byB0aGUgY29udGFpbmVyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuXG4gICAgX3RoaXMud3JhcHBlciA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBbGlhcyBvZiBgdXRpbC5zdHlsZWBcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdGhhdCB0aGUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIFRoZSBtYXAgb2YgcHJvcE5hbWU6IGF0dHJpYnV0ZSwgYm90aCBhcmUgdXNlZCBhcy1pc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gZWxcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRHJhd2VyLCBbe1xuICAgIGtleTogXCJzdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHlsZShlbCwgc3R5bGVzKSB7XG4gICAgICByZXR1cm4gdXRpbC5zdHlsZShlbCwgc3R5bGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSB3cmFwcGVyIGA8d2F2ZT5gIGVsZW1lbnQsIHN0eWxlIGl0IGFuZCBzZXQgdXAgdGhlIGV2ZW50cyBmb3JcbiAgICAgKiBpbnRlcmFjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlV3JhcHBlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKCkge1xuICAgICAgdGhpcy53cmFwcGVyID0gdXRpbC53aXRoT3JpZW50YXRpb24odGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd2F2ZScpKSwgdGhpcy5wYXJhbXMudmVydGljYWwpO1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIsIHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgd2Via2l0VXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMucGFyYW1zLmhlaWdodCArICdweCdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuZmlsbFBhcmVudCB8fCB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIsIHtcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIG92ZXJmbG93WDogdGhpcy5wYXJhbXMuaGlkZVNjcm9sbGJhciA/ICdoaWRkZW4nIDogJ2F1dG8nLFxuICAgICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0dXBXcmFwcGVyRXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjbGljayBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBDbGljayBldmVudFxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IG5vUHJldmVudCBTZXQgdG8gdHJ1ZSB0byBub3QgY2FsbCBgZS5wcmV2ZW50RGVmYXVsdCgpYFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gUGxheWJhY2sgcG9zaXRpb24gZnJvbSAwIHRvIDFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGUsIG5vUHJldmVudCkge1xuICAgICAgIW5vUHJldmVudCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgY2xpZW50WCA9IHV0aWwud2l0aE9yaWVudGF0aW9uKGUudGFyZ2V0VG91Y2hlcyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUsIHRoaXMucGFyYW1zLnZlcnRpY2FsKS5jbGllbnRYO1xuICAgICAgdmFyIGJib3ggPSB0aGlzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbm9taW5hbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHZhciBwYXJlbnRXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBwcm9ncmVzc1BpeGVscyA9IHRoaXMuZ2V0UHJvZ3Jlc3NQaXhlbHMoYmJveCwgY2xpZW50WCk7XG4gICAgICB2YXIgcHJvZ3Jlc3M7XG5cbiAgICAgIGlmICghdGhpcy5wYXJhbXMuZmlsbFBhcmVudCAmJiBub21pbmFsV2lkdGggPCBwYXJlbnRXaWR0aCkge1xuICAgICAgICBwcm9ncmVzcyA9IHByb2dyZXNzUGl4ZWxzICogKHRoaXMucGFyYW1zLnBpeGVsUmF0aW8gLyBub21pbmFsV2lkdGgpIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9IChwcm9ncmVzc1BpeGVscyArIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0KSAvIHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCB8fCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXRpbC5jbGFtcChwcm9ncmVzcywgMCwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByb2dyZXNzUGl4ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2dyZXNzUGl4ZWxzKHdyYXBwZXJCYm94LCBjbGllbnRYKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMucnRsKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyQmJveC5yaWdodCAtIGNsaWVudFg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xpZW50WCAtIHdyYXBwZXJCYm94LmxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwV3JhcHBlckV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFdyYXBwZXJFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG9yaWVudGVkRXZlbnQgPSB1dGlsLndpdGhPcmllbnRhdGlvbihlLCBfdGhpczIucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgICAgdmFyIHNjcm9sbGJhckhlaWdodCA9IF90aGlzMi53cmFwcGVyLm9mZnNldEhlaWdodCAtIF90aGlzMi53cmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgICAgICBpZiAoc2Nyb2xsYmFySGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgLy8gc2Nyb2xsYmFyIGlzIHZpc2libGUuICBDaGVjayBpZiBjbGljayB3YXMgb24gaXRcbiAgICAgICAgICB2YXIgYmJveCA9IF90aGlzMi53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgaWYgKG9yaWVudGVkRXZlbnQuY2xpZW50WSA+PSBiYm94LmJvdHRvbSAtIHNjcm9sbGJhckhlaWdodCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIG1vdXNlZG93biBhcyBpdCB3YXMgb24gdGhlIHNjcm9sbGJhclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIucGFyYW1zLmludGVyYWN0KSB7XG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnY2xpY2snLCBlLCBfdGhpczIuaGFuZGxlRXZlbnQoZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpczIucGFyYW1zLmludGVyYWN0KSB7XG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnZGJsY2xpY2snLCBlLCBfdGhpczIuaGFuZGxlRXZlbnQoZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZpcmVFdmVudCgnc2Nyb2xsJywgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBwZWFrcyBvbiB0aGUgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5c1xuICAgICAqIGZvciBzcGxpdCBjaGFubmVsIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHdpZHRoIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlIGRyYXduXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGVha3MocGVha3MsIGxlbmd0aCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLnNldFdpZHRoKGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5jbGVhcldhdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJhbXMuYmFyV2lkdGggPyB0aGlzLmRyYXdCYXJzKHBlYWtzLCAwLCBzdGFydCwgZW5kKSA6IHRoaXMuZHJhd1dhdmUocGVha3MsIDAsIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTY3JvbGwoKSB7XG4gICAgICBpZiAodGhpcy53cmFwcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZW50ZXIgdGhlIHZpZXctcG9ydCBhdCBhIGNlcnRhaW4gcGVyY2VudCBvZiB0aGUgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50IFZhbHVlIGZyb20gMCB0byAxIG9uIHRoZSB3YXZlZm9ybVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVjZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjZW50ZXIocGVyY2VudCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoICogcGVyY2VudDtcbiAgICAgIHRoaXMucmVjZW50ZXJPblBvc2l0aW9uKHBvc2l0aW9uLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZW50ZXIgdGhlIHZpZXctcG9ydCBvbiBhIHBvc2l0aW9uLCBlaXRoZXIgc2Nyb2xsIHRoZXJlIGltbWVkaWF0ZWx5IG9yXG4gICAgICogaW4gc3RlcHMgb2YgNSBwaXhlbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBYLW9mZnNldCBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGltbWVkaWF0ZSBTZXQgdG8gdHJ1ZSB0byBpbW1lZGlhdGVseSBzY3JvbGwgc29tZXdoZXJlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWNlbnRlck9uUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjZW50ZXJPblBvc2l0aW9uKHBvc2l0aW9uLCBpbW1lZGlhdGUpIHtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gdGhpcy53cmFwcGVyLnNjcm9sbExlZnQ7XG4gICAgICB2YXIgaGFsZiA9IH5+KHRoaXMud3JhcHBlci5jbGllbnRXaWR0aCAvIDIpO1xuICAgICAgdmFyIG1heFNjcm9sbCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAtIHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgIHZhciB0YXJnZXQgPSBwb3NpdGlvbiAtIGhhbGY7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGFyZ2V0IC0gc2Nyb2xsTGVmdDtcblxuICAgICAgaWYgKG1heFNjcm9sbCA9PSAwKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gY29udGludWUgaWYgc2Nyb2xsYmFyIGlzIG5vdCB0aGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGlmIHRoZSBjdXJzb3IgaXMgY3VycmVudGx5IHZpc2libGUuLi5cblxuXG4gICAgICBpZiAoIWltbWVkaWF0ZSAmJiAtaGFsZiA8PSBvZmZzZXQgJiYgb2Zmc2V0IDwgaGFsZikge1xuICAgICAgICAvLyBzZXQgcmF0ZSBhdCB3aGljaCB3YXZlZm9ybSBpcyBjZW50ZXJlZFxuICAgICAgICB2YXIgcmF0ZSA9IHRoaXMucGFyYW1zLmF1dG9DZW50ZXJSYXRlOyAvLyBtYWtlIHJhdGUgZGVwZW5kIG9uIHdpZHRoIG9mIHZpZXcgYW5kIGxlbmd0aCBvZiB3YXZlZm9ybVxuXG4gICAgICAgIHJhdGUgLz0gaGFsZjtcbiAgICAgICAgcmF0ZSAqPSBtYXhTY3JvbGw7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KC1yYXRlLCBNYXRoLm1pbihyYXRlLCBvZmZzZXQpKTtcbiAgICAgICAgdGFyZ2V0ID0gc2Nyb2xsTGVmdCArIG9mZnNldDtcbiAgICAgIH0gLy8gbGltaXQgdGFyZ2V0IHRvIHZhbGlkIHJhbmdlICgwIHRvIG1heFNjcm9sbClcblxuXG4gICAgICB0YXJnZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhTY3JvbGwsIHRhcmdldCkpOyAvLyBubyB1c2UgYXR0ZW1wdGluZyB0byBzY3JvbGwgaWYgd2UncmUgbm90IG1vdmluZ1xuXG4gICAgICBpZiAodGFyZ2V0ICE9IHNjcm9sbExlZnQpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnNjcm9sbExlZnQgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2Nyb2xsWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JvbGxYKCkge1xuICAgICAgdmFyIHggPSAwO1xuXG4gICAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICAgICAgeCA9IE1hdGgucm91bmQodGhpcy53cmFwcGVyLnNjcm9sbExlZnQgKiBwaXhlbFJhdGlvKTsgLy8gSW4gY2FzZXMgb2YgZWxhc3RpYyBzY3JvbGwgKHNhZmFyaSB3aXRoIG1vdXNlIHdoZWVsKSB5b3UgY2FuXG4gICAgICAgIC8vIHNjcm9sbCBiZXlvbmQgdGhlIGxpbWl0cyBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbmQgZmxvb3IgdGhlIHNjcm9sbGFibGUgZXh0ZW50IHRvIG1ha2Ugc3VyZSBhbiBvdXRcbiAgICAgICAgLy8gb2YgYm91bmRzIHZhbHVlIGlzIG5vdCByZXR1cm5lZFxuICAgICAgICAvLyBUaWNrZXQgIzEzMTJcblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgdmFyIG1heFNjcm9sbCA9IH5+KHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAqIHBpeGVsUmF0aW8gLSB0aGlzLmdldFdpZHRoKCkpO1xuICAgICAgICAgIHggPSBNYXRoLm1pbihtYXhTY3JvbGwsIE1hdGgubWF4KDAsIHgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoICogdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXIgd2FzIHVwZGF0ZWQgb3Igbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXaWR0aCh3aWR0aCkge1xuICAgICAgaWYgKHRoaXMud2lkdGggPT0gd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5maWxsUGFyZW50IHx8IHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCkge1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMud3JhcHBlciwge1xuICAgICAgICAgIHdpZHRoOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IH5+KHRoaXMud2lkdGggLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKSArICdweCc7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLCB7XG4gICAgICAgICAgd2lkdGg6IG5ld1dpZHRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgd2FzIHVwZGF0ZWQgb3Igbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgaWYgKGhlaWdodCA9PSB0aGlzLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIsIHtcbiAgICAgICAgaGVpZ2h0OiB+fih0aGlzLmhlaWdodCAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pICsgJ3B4J1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgd2F2ZXN1cmZlciB3aGVuIHByb2dyZXNzIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzIEZyb20gMCB0byAxXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBtaW5QeERlbHRhID0gMSAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgICB2YXIgcG9zID0gTWF0aC5yb3VuZChfcHJvZ3Jlc3MgKiB0aGlzLndpZHRoKSAqIG1pblB4RGVsdGE7XG5cbiAgICAgIGlmIChwb3MgPCB0aGlzLmxhc3RQb3MgfHwgcG9zIC0gdGhpcy5sYXN0UG9zID49IG1pblB4RGVsdGEpIHtcbiAgICAgICAgdGhpcy5sYXN0UG9zID0gcG9zO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgJiYgdGhpcy5wYXJhbXMuYXV0b0NlbnRlcikge1xuICAgICAgICAgIHZhciBuZXdQb3MgPSB+fih0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggKiBfcHJvZ3Jlc3MpO1xuICAgICAgICAgIHRoaXMucmVjZW50ZXJPblBvc2l0aW9uKG5ld1BvcywgdGhpcy5wYXJhbXMuYXV0b0NlbnRlckltbWVkaWF0ZWx5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MocG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB3YXZlc3VyZmVyIGlzIGRlc3Ryb3llZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bkFsbCgpO1xuXG4gICAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXIucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRhaW5lci5kb21FbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyLmRvbUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53cmFwcGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUmVuZGVyZXItc3BlY2lmaWMgbWV0aG9kcyAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIGN1cnNvciByZWxhdGVkIHBhcmFtcyBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDdXJzb3IoKSB7fVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgY2hhbmdlcyBzbyB0aGUgcmVuZGVyZXIgY2FuIGFkanVzdFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7fVxuICAgIC8qKlxuICAgICAqIERyYXcgYSB3YXZlZm9ybSB3aXRoIGJhcnNcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzIGZvciBzcGxpdCBjaGFubmVsXG4gICAgICogcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC4gTm9ybWFsbHlcbiAgICAgKiBzaG91bGQgYmUgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFycyhwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kKSB7fVxuICAgIC8qKlxuICAgICAqIERyYXcgYSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXMgZm9yIHNwbGl0IGNoYW5uZWxcbiAgICAgKiByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLiBOb3JtYWxseVxuICAgICAqIHNob3VsZCBiZSAwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXYXZlKHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQpIHt9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyV2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcldhdmUoKSB7fVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgbmV3IHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gWC1PZmZzZXQgb2YgcHJvZ3Jlc3MgcG9zaXRpb24gaW4gcGl4ZWxzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyhwb3NpdGlvbikge31cbiAgfV0pO1xuXG4gIHJldHVybiBEcmF3ZXI7XG59KHV0aWwuT2JzZXJ2ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcmF3ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZHJhd2VyLm11bHRpY2FudmFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kcmF3ZXIubXVsdGljYW52YXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZHJhd2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RyYXdlciAqLyBcIi4vc3JjL2RyYXdlci5qc1wiKSk7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiKSk7XG5cbnZhciBfZHJhd2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kcmF3ZXIuY2FudmFzZW50cnkgKi8gXCIuL3NyYy9kcmF3ZXIuY2FudmFzZW50cnkuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBNdWx0aUNhbnZhcyByZW5kZXJlciBmb3Igd2F2ZXN1cmZlci4gSXMgY3VycmVudGx5IHRoZSBkZWZhdWx0IGFuZCBzb2xlXG4gKiBidWlsdGluIHJlbmRlcmVyLlxuICpcbiAqIEEgYE11bHRpQ2FudmFzYCBjb25zaXN0cyBvZiBvbmUgb3IgbW9yZSBgQ2FudmFzRW50cnlgIGluc3RhbmNlcywgZGVwZW5kaW5nXG4gKiBvbiB0aGUgem9vbSBsZXZlbC5cbiAqL1xudmFyIE11bHRpQ2FudmFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRHJhd2VyKSB7XG4gIF9pbmhlcml0cyhNdWx0aUNhbnZhcywgX0RyYXdlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNdWx0aUNhbnZhcyk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIG5vZGUgb2YgdGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgVGhlIHdhdmVzdXJmZXIgaW5pdGlhbGlzYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gTXVsdGlDYW52YXMoY29udGFpbmVyLCBwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlDYW52YXMpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250YWluZXIsIHBhcmFtcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLm1heENhbnZhc1dpZHRoID0gcGFyYW1zLm1heENhbnZhc1dpZHRoO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGggPSBNYXRoLnJvdW5kKHBhcmFtcy5tYXhDYW52YXNXaWR0aCAvIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvZ3Jlc3Mgd2F2ZSBpcyByZW5kZXJlZC4gSWYgdGhlIGB3YXZlQ29sb3JgXG4gICAgICogYW5kIGBwcm9ncmVzc0NvbG9yYCBhcmUgdGhlIHNhbWUgY29sb3IgaXQgaXMgbm90LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBfdGhpcy5oYXNQcm9ncmVzc0NhbnZhcyA9IHBhcmFtcy53YXZlQ29sb3IgIT0gcGFyYW1zLnByb2dyZXNzQ29sb3I7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLmhhbGZQaXhlbCA9IDAuNSAvIHBhcmFtcy5waXhlbFJhdGlvO1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYENhbnZhc0VudHJ5YCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cbiAgICBfdGhpcy5jYW52YXNlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICAgIF90aGlzLnByb2dyZXNzV2F2ZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQ2xhc3MgdXNlZCB0byBnZW5lcmF0ZSBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuXG4gICAgX3RoaXMuRW50cnlDbGFzcyA9IF9kcmF3ZXIyLmRlZmF1bHQ7XG4gICAgLyoqXG4gICAgICogQ2FudmFzIDJkIGNvbnRleHQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG5cbiAgICBfdGhpcy5jYW52YXNDb250ZXh0QXR0cmlidXRlcyA9IHBhcmFtcy5kcmF3aW5nQ29udGV4dEF0dHJpYnV0ZXM7XG4gICAgLyoqXG4gICAgICogT3ZlcmxhcCBhZGRlZCBiZXR3ZWVuIGVudHJpZXMgdG8gcHJldmVudCB2ZXJ0aWNhbCB3aGl0ZSBzdHJpcGVzXG4gICAgICogYmV0d2VlbiBgY2FudmFzYCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5vdmVybGFwID0gMiAqIE1hdGguY2VpbChwYXJhbXMucGl4ZWxSYXRpbyAvIDIpO1xuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHdhdmUgYmFycy4gTWFrZXMgYmFycyByb3VuZGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMuYmFyUmFkaXVzID0gcGFyYW1zLmJhclJhZGl1cyB8fCAwO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSB3YXZlZm9ybSB2ZXJ0aWNhbGx5LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgX3RoaXMudmVydGljYWwgPSBwYXJhbXMudmVydGljYWw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkcmF3ZXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTXVsdGlDYW52YXMsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuY3JlYXRlV3JhcHBlcigpO1xuICAgICAgdGhpcy5jcmVhdGVFbGVtZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGNhbnZhcyBlbGVtZW50cyBhbmQgc3R5bGUgdGhlbVxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NXYXZlID0gdXRpbC53aXRoT3JpZW50YXRpb24odGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dhdmUnKSksIHRoaXMucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHpJbmRleDogMyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgd2lkdGg6ICcwJyxcbiAgICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgYm9yZGVyUmlnaHRTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkQ2FudmFzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUN1cnNvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY3Vyc29yIHN0eWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKCkge1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSwge1xuICAgICAgICBib3JkZXJSaWdodFdpZHRoOiB0aGlzLnBhcmFtcy5jdXJzb3JXaWR0aCArICdweCcsXG4gICAgICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRoaXMucGFyYW1zLmN1cnNvckNvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRvIHRoZSB1cGRhdGVkIHNpemUgYnkgYWRkaW5nIG9yIHJlbW92aW5nIGNhbnZhc2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHRvdGFsV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHZhciByZXF1aXJlZENhbnZhc2VzID0gTWF0aC5jZWlsKHRvdGFsV2lkdGggLyAodGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGggKyB0aGlzLm92ZXJsYXApKTsgLy8gYWRkIHJlcXVpcmVkIGNhbnZhc2VzXG5cbiAgICAgIHdoaWxlICh0aGlzLmNhbnZhc2VzLmxlbmd0aCA8IHJlcXVpcmVkQ2FudmFzZXMpIHtcbiAgICAgICAgdGhpcy5hZGRDYW52YXMoKTtcbiAgICAgIH0gLy8gcmVtb3ZlIG9sZGVyIGV4aXN0aW5nIGNhbnZhc2VzLCBpZiBhbnlcblxuXG4gICAgICB3aGlsZSAodGhpcy5jYW52YXNlcy5sZW5ndGggPiByZXF1aXJlZENhbnZhc2VzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2FudmFzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IHRoaXMubWF4Q2FudmFzV2lkdGggKyB0aGlzLm92ZXJsYXA7XG4gICAgICB2YXIgbGFzdENhbnZhcyA9IHRoaXMuY2FudmFzZXMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgaWYgKGkgPT0gbGFzdENhbnZhcykge1xuICAgICAgICAgIGNhbnZhc1dpZHRoID0gX3RoaXMyLndpZHRoIC0gX3RoaXMyLm1heENhbnZhc1dpZHRoICogbGFzdENhbnZhcztcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi51cGRhdGVEaW1lbnNpb25zKGVudHJ5LCBjYW52YXNXaWR0aCwgX3RoaXMyLmhlaWdodCk7XG5cbiAgICAgICAgZW50cnkuY2xlYXJXYXZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2FudmFzIHRvIHRoZSBjYW52YXMgbGlzdFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2FudmFzKCkge1xuICAgICAgdmFyIGVudHJ5ID0gbmV3IHRoaXMuRW50cnlDbGFzcygpO1xuICAgICAgZW50cnkuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMgPSB0aGlzLmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzO1xuICAgICAgZW50cnkuaGFzUHJvZ3Jlc3NDYW52YXMgPSB0aGlzLmhhc1Byb2dyZXNzQ2FudmFzO1xuICAgICAgZW50cnkuaGFsZlBpeGVsID0gdGhpcy5oYWxmUGl4ZWw7XG4gICAgICB2YXIgbGVmdE9mZnNldCA9IHRoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoICogdGhpcy5jYW52YXNlcy5sZW5ndGg7IC8vIHdhdmVcblxuICAgICAgdmFyIHdhdmUgPSB1dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpLCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICB0aGlzLnN0eWxlKHdhdmUsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHpJbmRleDogMixcbiAgICAgICAgbGVmdDogbGVmdE9mZnNldCArICdweCcsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIGVudHJ5LmluaXRXYXZlKHdhdmUpOyAvLyBwcm9ncmVzc1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB1dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLnByb2dyZXNzV2F2ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSksIHRoaXMucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgICAgdGhpcy5zdHlsZShwcm9ncmVzcywge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIGxlZnQ6IGxlZnRPZmZzZXQgKyAncHgnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVudHJ5LmluaXRQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FudmFzZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcCBzaW5nbGUgY2FudmFzIGZyb20gdGhlIGxpc3RcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNhbnZhcygpIHtcbiAgICAgIHZhciBsYXN0RW50cnkgPSB0aGlzLmNhbnZhc2VzW3RoaXMuY2FudmFzZXMubGVuZ3RoIC0gMV07IC8vIHdhdmVcblxuICAgICAgbGFzdEVudHJ5LndhdmUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChsYXN0RW50cnkud2F2ZS5kb21FbGVtZW50KTsgLy8gcHJvZ3Jlc3NcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgbGFzdEVudHJ5LnByb2dyZXNzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobGFzdEVudHJ5LnByb2dyZXNzLmRvbUVsZW1lbnQpO1xuICAgICAgfSAvLyBjbGVhbnVwXG5cblxuICAgICAgaWYgKGxhc3RFbnRyeSkge1xuICAgICAgICBsYXN0RW50cnkuZGVzdHJveSgpO1xuICAgICAgICBsYXN0RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGRpbWVuc2lvbnMgb2YgYSBjYW52YXMgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNFbnRyeX0gZW50cnkgVGFyZ2V0IGVudHJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbnMoZW50cnksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtZW50V2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoIC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICB2YXIgdG90YWxXaWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pOyAvLyB1cGRhdGUgY2FudmFzIGRpbWVuc2lvbnNcblxuICAgICAgZW50cnkudXBkYXRlRGltZW5zaW9ucyhlbGVtZW50V2lkdGgsIHRvdGFsV2lkdGgsIHdpZHRoLCBoZWlnaHQpOyAvLyBzdHlsZSBlbGVtZW50XG5cbiAgICAgIHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUsIHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSB3aG9sZSBtdWx0aS1jYW52YXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyV2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcldhdmUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdXRpbC5mcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeS5jbGVhcldhdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgd2F2ZWZvcm0gd2l0aCBiYXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5c1xuICAgICAqIGZvciBzcGxpdCBjaGFubmVsIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuIE5vcm1hbGx5XG4gICAgICogc2hvdWxkIGJlIDAuIE11c3QgYmUgYW4gaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhcnMocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnByZXBhcmVEcmF3KHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBhYnNtYXggPSBfcmVmLmFic21heCxcbiAgICAgICAgICAgIGhhc01pblZhbHMgPSBfcmVmLmhhc01pblZhbHMsXG4gICAgICAgICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldFkgPSBfcmVmLm9mZnNldFksXG4gICAgICAgICAgICBoYWxmSCA9IF9yZWYuaGFsZkgsXG4gICAgICAgICAgICBwZWFrcyA9IF9yZWYucGVha3MsXG4gICAgICAgICAgICBjaCA9IF9yZWYuY2hhbm5lbEluZGV4O1xuXG4gICAgICAgIC8vIGlmIGRyYXdCYXJzIHdhcyBjYWxsZWQgd2l0aGluIHdzLmVtcHR5IHdlIGRvbid0IHBhc3MgYSBzdGFydCBhbmRcbiAgICAgICAgLy8gZG9uJ3Qgd2FudCBhbnl0aGluZyB0byBoYXBwZW5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU2tpcCBldmVyeSBvdGhlciB2YWx1ZSBpZiB0aGVyZSBhcmUgbmVnYXRpdmVzLlxuXG5cbiAgICAgICAgdmFyIHBlYWtJbmRleFNjYWxlID0gaGFzTWluVmFscyA/IDIgOiAxO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGVha3MubGVuZ3RoIC8gcGVha0luZGV4U2NhbGU7XG4gICAgICAgIHZhciBiYXIgPSBfdGhpczQucGFyYW1zLmJhcldpZHRoICogX3RoaXM0LnBhcmFtcy5waXhlbFJhdGlvO1xuICAgICAgICB2YXIgZ2FwID0gX3RoaXM0LnBhcmFtcy5iYXJHYXAgPT09IG51bGwgPyBNYXRoLm1heChfdGhpczQucGFyYW1zLnBpeGVsUmF0aW8sIH5+KGJhciAvIDIpKSA6IE1hdGgubWF4KF90aGlzNC5wYXJhbXMucGl4ZWxSYXRpbywgX3RoaXM0LnBhcmFtcy5iYXJHYXAgKiBfdGhpczQucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgc3RlcCA9IGJhciArIGdhcDtcbiAgICAgICAgdmFyIHNjYWxlID0gbGVuZ3RoIC8gX3RoaXM0LndpZHRoO1xuICAgICAgICB2YXIgZmlyc3QgPSBzdGFydDtcbiAgICAgICAgdmFyIGxhc3QgPSBlbmQ7XG4gICAgICAgIHZhciBpID0gZmlyc3Q7XG5cbiAgICAgICAgZm9yIChpOyBpIDwgbGFzdDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgdmFyIHBlYWsgPSBwZWFrc1tNYXRoLmZsb29yKGkgKiBzY2FsZSAqIHBlYWtJbmRleFNjYWxlKV0gfHwgMDtcbiAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQocGVhayAvIGFic21heCAqIGhhbGZIKTtcbiAgICAgICAgICAvKiBpbiBjYXNlIG9mIHNpbGVuY2VzLCBhbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IHRoYXQgd2VcbiAgICAgICAgICAgKiBhbHdheXMgZHJhdyAqc29tZXRoaW5nKiAobm9ybWFsbHkgYSAxcHggaGlnaCBiYXIpICovXG5cbiAgICAgICAgICBpZiAoaCA9PSAwICYmIF90aGlzNC5wYXJhbXMuYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoID0gX3RoaXM0LnBhcmFtcy5iYXJNaW5IZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM0LmZpbGxSZWN0KGkgKyBfdGhpczQuaGFsZlBpeGVsLCBoYWxmSCAtIGggKyBvZmZzZXRZLCBiYXIgKyBfdGhpczQuaGFsZlBpeGVsLCBoICogMiwgX3RoaXM0LmJhclJhZGl1cywgY2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5c1xuICAgICAqIGZvciBzcGxpdCBjaGFubmVsIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuIE5vcm1hbGx5XG4gICAgICogc2hvdWxkIGJlIDBcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWQgKElmIHRoaXMgaXNuJ3Qgc2V0IG9ubHkgYSBmbGF0IGxpbmUgaXMgcmVuZGVyZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1dhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1dhdmUocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnByZXBhcmVEcmF3KHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgYWJzbWF4ID0gX3JlZjIuYWJzbWF4LFxuICAgICAgICAgICAgaGFzTWluVmFscyA9IF9yZWYyLmhhc01pblZhbHMsXG4gICAgICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXRZID0gX3JlZjIub2Zmc2V0WSxcbiAgICAgICAgICAgIGhhbGZIID0gX3JlZjIuaGFsZkgsXG4gICAgICAgICAgICBwZWFrcyA9IF9yZWYyLnBlYWtzLFxuICAgICAgICAgICAgY2hhbm5lbEluZGV4ID0gX3JlZjIuY2hhbm5lbEluZGV4O1xuXG4gICAgICAgIGlmICghaGFzTWluVmFscykge1xuICAgICAgICAgIHZhciByZWZsZWN0ZWRQZWFrcyA9IFtdO1xuICAgICAgICAgIHZhciBsZW4gPSBwZWFrcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlZmxlY3RlZFBlYWtzWzIgKiBpXSA9IHBlYWtzW2ldO1xuICAgICAgICAgICAgcmVmbGVjdGVkUGVha3NbMiAqIGkgKyAxXSA9IC1wZWFrc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZWFrcyA9IHJlZmxlY3RlZFBlYWtzO1xuICAgICAgICB9IC8vIGlmIGRyYXdXYXZlIHdhcyBjYWxsZWQgd2l0aGluIHdzLmVtcHR5IHdlIGRvbid0IHBhc3MgYSBzdGFydCBhbmRcbiAgICAgICAgLy8gZW5kIGFuZCBzaW1wbHkgd2FudCBhIGZsYXQgbGluZVxuXG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczUuZHJhd0xpbmUocGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQsIGNoYW5uZWxJbmRleCk7XG4gICAgICAgIH0gLy8gYWx3YXlzIGRyYXcgYSBtZWRpYW4gbGluZVxuXG5cbiAgICAgICAgX3RoaXM1LmZpbGxSZWN0KDAsIGhhbGZIICsgb2Zmc2V0WSAtIF90aGlzNS5oYWxmUGl4ZWwsIF90aGlzNS53aWR0aCwgX3RoaXM1LmhhbGZQaXhlbCwgX3RoaXM1LmJhclJhZGl1cywgY2hhbm5lbEluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBjYW52YXMgZW50cmllcyB0byByZW5kZXIgdGhlaXIgcG9ydGlvbiBvZiB0aGUgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBlYWtzIFBlYWtzIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWJzbWF4IE1heGltdW0gcGVhayB2YWx1ZSAoYWJzb2x1dGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbGZIIEhhbGYgdGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBPZmZzZXQgdG8gdGhlIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtjaGFubmVsSW5kZXh9IGNoYW5uZWxJbmRleCBUaGUgY2hhbm5lbCBpbmRleCBvZiB0aGUgbGluZSBkcmF3blxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmUocGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQsIGNoYW5uZWxJbmRleCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmMyA9IHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLmNoYW5uZWxDb2xvcnNbY2hhbm5lbEluZGV4XSB8fCB7fSxcbiAgICAgICAgICB3YXZlQ29sb3IgPSBfcmVmMy53YXZlQ29sb3IsXG4gICAgICAgICAgcHJvZ3Jlc3NDb2xvciA9IF9yZWYzLnByb2dyZXNzQ29sb3I7XG5cbiAgICAgIHRoaXMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgICAgICAgX3RoaXM2LnNldEZpbGxTdHlsZXMoZW50cnksIHdhdmVDb2xvciwgcHJvZ3Jlc3NDb2xvcik7XG5cbiAgICAgICAgX3RoaXM2LmFwcGx5Q2FudmFzVHJhbnNmb3JtcyhlbnRyeSwgX3RoaXM2LnBhcmFtcy52ZXJ0aWNhbCk7XG5cbiAgICAgICAgZW50cnkuZHJhd0xpbmVzKHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcmVjdGFuZ2xlIG9uIHRoZSBtdWx0aS1jYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFgtcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFktcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge2NoYW5uZWxJbmRleH0gY2hhbm5lbEluZGV4IFRoZSBjaGFubmVsIGluZGV4IG9mIHRoZSBiYXIgZHJhd25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbGxSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgY2hhbm5lbEluZGV4KSB7XG4gICAgICB2YXIgc3RhcnRDYW52YXMgPSBNYXRoLmZsb29yKHggLyB0aGlzLm1heENhbnZhc1dpZHRoKTtcbiAgICAgIHZhciBlbmRDYW52YXMgPSBNYXRoLm1pbihNYXRoLmNlaWwoKHggKyB3aWR0aCkgLyB0aGlzLm1heENhbnZhc1dpZHRoKSArIDEsIHRoaXMuY2FudmFzZXMubGVuZ3RoKTtcbiAgICAgIHZhciBpID0gc3RhcnRDYW52YXM7XG5cbiAgICAgIGZvciAoaTsgaSA8IGVuZENhbnZhczsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuY2FudmFzZXNbaV07XG4gICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gaSAqIHRoaXMubWF4Q2FudmFzV2lkdGg7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB7XG4gICAgICAgICAgeDE6IE1hdGgubWF4KHgsIGkgKiB0aGlzLm1heENhbnZhc1dpZHRoKSxcbiAgICAgICAgICB5MTogeSxcbiAgICAgICAgICB4MjogTWF0aC5taW4oeCArIHdpZHRoLCBpICogdGhpcy5tYXhDYW52YXNXaWR0aCArIGVudHJ5LndhdmUud2lkdGgpLFxuICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi54MSA8IGludGVyc2VjdGlvbi54Mikge1xuICAgICAgICAgIHZhciBfcmVmNCA9IHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLmNoYW5uZWxDb2xvcnNbY2hhbm5lbEluZGV4XSB8fCB7fSxcbiAgICAgICAgICAgICAgd2F2ZUNvbG9yID0gX3JlZjQud2F2ZUNvbG9yLFxuICAgICAgICAgICAgICBwcm9ncmVzc0NvbG9yID0gX3JlZjQucHJvZ3Jlc3NDb2xvcjtcblxuICAgICAgICAgIHRoaXMuc2V0RmlsbFN0eWxlcyhlbnRyeSwgd2F2ZUNvbG9yLCBwcm9ncmVzc0NvbG9yKTtcbiAgICAgICAgICB0aGlzLmFwcGx5Q2FudmFzVHJhbnNmb3JtcyhlbnRyeSwgdGhpcy5wYXJhbXMudmVydGljYWwpO1xuICAgICAgICAgIGVudHJ5LmZpbGxSZWN0cyhpbnRlcnNlY3Rpb24ueDEgLSBsZWZ0T2Zmc2V0LCBpbnRlcnNlY3Rpb24ueTEsIGludGVyc2VjdGlvbi54MiAtIGludGVyc2VjdGlvbi54MSwgaW50ZXJzZWN0aW9uLnkyIC0gaW50ZXJzZWN0aW9uLnkxLCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0byBoaWRlIHRoZSBjaGFubmVsIGZyb20gYmVpbmcgZHJhd24gYmFzZWQgb24gcGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbH0gVHJ1ZSB0byBoaWRlIHRoZSBjaGFubmVsLCBmYWxzZSB0byBkcmF3LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZUNoYW5uZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUNoYW5uZWwoY2hhbm5lbEluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVscyAmJiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5maWx0ZXJDaGFubmVscy5pbmNsdWRlcyhjaGFubmVsSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBwcmVwYXJhdGlvbiB0YXNrcyBhbmQgY2FsY3VsYXRpb25zIHdoaWNoIGFyZSBzaGFyZWQgYnkgYGRyYXdCYXJzYFxuICAgICAqIGFuZCBgZHJhd1dhdmVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5cyBmb3JcbiAgICAgKiBzcGxpdCBjaGFubmVsIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuIE5vcm1hbGx5XG4gICAgICogc2hvdWxkIGJlIDBcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWQuIElmIHRoaXMgaXNuJ3Qgc2V0IG9ubHkgYSBmbGF0IGxpbmUgaXMgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIHJlbmRlciBmdW5jdGlvbiB0byBjYWxsLCBlLmcuIGBkcmF3V2F2ZWBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHJhd0luZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsIGFmdGVyIGZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj99IG5vcm1hbGl6ZWRNYXggTWF4aW11bSBtb2R1bGF0aW9uIHZhbHVlIGFjcm9zcyBjaGFubmVscyBmb3IgdXNlIHdpdGggcmVsYXRpdmVOb3JtYWxpemF0aW9uLiBJZ25vcmVkIHdoZW4gdW5kZWZpbmVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlRHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlRHJhdyhwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kLCBmbiwgZHJhd0luZGV4LCBub3JtYWxpemVkTWF4KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHV0aWwuZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTcGxpdCBjaGFubmVscyBhbmQgY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIGNoYW5uZWxJbmRleCBzZXRcbiAgICAgICAgaWYgKHBlYWtzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBwZWFrcztcblxuICAgICAgICAgIGlmIChfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZENoYW5uZWxzID0gY2hhbm5lbHMuZmlsdGVyKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhX3RoaXM3LmhpZGVDaGFubmVsKGkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgIF90aGlzNy5zZXRIZWlnaHQoTWF0aC5tYXgoZmlsdGVyZWRDaGFubmVscy5sZW5ndGgsIDEpICogX3RoaXM3LnBhcmFtcy5oZWlnaHQgKiBfdGhpczcucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3ZlcmFsbEFic01heDtcblxuICAgICAgICAgICAgaWYgKF90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMgJiYgX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5yZWxhdGl2ZU5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1heGltdW0gcGVhayBhY3Jvc3MgY2hhbm5lbHMgdG8gdXNlIGZvciBub3JtYWxpemF0aW9uXG4gICAgICAgICAgICAgIG92ZXJhbGxBYnNNYXggPSB1dGlsLm1heChjaGFubmVscy5tYXAoZnVuY3Rpb24gKGNoYW5uZWxQZWFrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmFic01heChjaGFubmVsUGVha3MpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsUGVha3MsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNy5wcmVwYXJlRHJhdyhjaGFubmVsUGVha3MsIGksIHN0YXJ0LCBlbmQsIGZuLCBmaWx0ZXJlZENoYW5uZWxzLmluZGV4T2YoY2hhbm5lbFBlYWtzKSwgb3ZlcmFsbEFic01heCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZWFrcyA9IGNoYW5uZWxzWzBdO1xuICAgICAgICB9IC8vIFJldHVybiBhbmQgZG8gbm90IGRyYXcgY2hhbm5lbCBwZWFrcyBpZiBoaWRkZW4uXG5cblxuICAgICAgICBpZiAoX3RoaXM3LmhpZGVDaGFubmVsKGNoYW5uZWxJbmRleCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gY2FsY3VsYXRlIG1heGltdW0gbW9kdWxhdGlvbiB2YWx1ZSwgZWl0aGVyIGZyb20gdGhlIGJhckhlaWdodFxuICAgICAgICAvLyBwYXJhbWV0ZXIgb3IgaWYgbm9ybWFsaXplPXRydWUgZnJvbSB0aGUgbGFyZ2VzdCB2YWx1ZSBpbiB0aGUgcGVha1xuICAgICAgICAvLyBzZXRcblxuXG4gICAgICAgIHZhciBhYnNtYXggPSAxIC8gX3RoaXM3LnBhcmFtcy5iYXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKF90aGlzNy5wYXJhbXMubm9ybWFsaXplKSB7XG4gICAgICAgICAgYWJzbWF4ID0gbm9ybWFsaXplZE1heCA9PT0gdW5kZWZpbmVkID8gdXRpbC5hYnNNYXgocGVha3MpIDogbm9ybWFsaXplZE1heDtcbiAgICAgICAgfSAvLyBCYXIgd2F2ZSBkcmF3cyB0aGUgYm90dG9tIG9ubHkgYXMgYSByZWZsZWN0aW9uIG9mIHRoZSB0b3AsXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgbmVnYXRpdmUgdmFsdWVzXG5cblxuICAgICAgICB2YXIgaGFzTWluVmFscyA9IFtdLnNvbWUuY2FsbChwZWFrcywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgPCAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhlaWdodCA9IF90aGlzNy5wYXJhbXMuaGVpZ2h0ICogX3RoaXM3LnBhcmFtcy5waXhlbFJhdGlvO1xuICAgICAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IGhlaWdodCAqIGRyYXdJbmRleCB8fCAwOyAvLyBPdmVycmlkZSBvZmZzZXRZIGlmIG92ZXJsYXkgaXMgdHJ1ZVxuXG4gICAgICAgIGlmIChfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zICYmIF90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgIG9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuKHtcbiAgICAgICAgICBhYnNtYXg6IGFic21heCxcbiAgICAgICAgICBoYXNNaW5WYWxzOiBoYXNNaW5WYWxzLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgICAgaGFsZkg6IGhhbGZILFxuICAgICAgICAgIHBlYWtzOiBwZWFrcyxcbiAgICAgICAgICBjaGFubmVsSW5kZXg6IGNoYW5uZWxJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsbCBzdHlsZXMgZm9yIGEgY2VydGFpbiBlbnRyeSAod2F2ZSBhbmQgcHJvZ3Jlc3MpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VudHJ5fSBlbnRyeSBUYXJnZXQgZW50cnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2F2ZUNvbG9yIFdhdmUgY29sb3IgdG8gZHJhdyB0aGlzIGVudHJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyZXNzQ29sb3IgUHJvZ3Jlc3MgY29sb3IgdG8gZHJhdyB0aGlzIGVudHJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGaWxsU3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxTdHlsZXMoZW50cnkpIHtcbiAgICAgIHZhciB3YXZlQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMucGFyYW1zLndhdmVDb2xvcjtcbiAgICAgIHZhciBwcm9ncmVzc0NvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yO1xuICAgICAgZW50cnkuc2V0RmlsbFN0eWxlcyh3YXZlQ29sb3IsIHByb2dyZXNzQ29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbnZhcyB0cmFuc2Zvcm1zIGZvciBhIGNlcnRhaW4gZW50cnkgKHdhdmUgYW5kIHByb2dyZXNzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNFbnRyeX0gZW50cnkgVGFyZ2V0IGVudHJ5XG4gICAgICogQHBhcmFtIHtib29sZWFufSB2ZXJ0aWNhbCBXaGV0aGVyIHRvIHJlbmRlciB0aGUgd2F2ZWZvcm0gdmVydGljYWxseVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlDYW52YXNUcmFuc2Zvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Q2FudmFzVHJhbnNmb3JtcyhlbnRyeSkge1xuICAgICAgdmFyIHZlcnRpY2FsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGVudHJ5LmFwcGx5Q2FudmFzVHJhbnNmb3Jtcyh2ZXJ0aWNhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBpbWFnZSBkYXRhIG9mIHRoZSBtdWx0aS1jYW52YXNcbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgYSBgdHlwZWAgb2YgYCdibG9iJ2AsIHRoaXMgd2lsbCByZXR1cm4gYSBgUHJvbWlzZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0PSdpbWFnZS9wbmcnIEFuIG9wdGlvbmFsIHZhbHVlIG9mIGEgZm9ybWF0IHR5cGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHk9MC45MiBBbiBvcHRpb25hbCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGU9J2RhdGFVUkwnIEVpdGhlciAnZGF0YVVSTCcgb3IgJ2Jsb2InLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXXxQcm9taXNlfSBXaGVuIHVzaW5nIHRoZSBkZWZhdWx0IGAnZGF0YVVSTCdgXG4gICAgICogYHR5cGVgIHRoaXMgcmV0dXJucyBhIHNpbmdsZSBkYXRhIFVSTCBvciBhbiBhcnJheSBvZiBkYXRhIFVSTHMsXG4gICAgICogb25lIGZvciBlYWNoIGNhbnZhcy4gV2hlbiB1c2luZyB0aGUgYCdibG9iJ2AgYHR5cGVgIHRoaXMgcmV0dXJucyBhXG4gICAgICogYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBgQmxvYmAgaW5zdGFuY2VzLCBvbmUgZm9yIGVhY2hcbiAgICAgKiBjYW52YXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY2FudmFzZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeS5nZXRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkYXRhVVJMJykge1xuICAgICAgICB2YXIgaW1hZ2VzID0gdGhpcy5jYW52YXNlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5LmdldEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW1hZ2VzLmxlbmd0aCA+IDEgPyBpbWFnZXMgOiBpbWFnZXNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgbmV3IHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gWC1vZmZzZXQgb2YgcHJvZ3Jlc3MgcG9zaXRpb24gaW4gcGl4ZWxzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyhwb3NpdGlvbikge1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSwge1xuICAgICAgICB3aWR0aDogcG9zaXRpb24gKyAncHgnXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTXVsdGlDYW52YXM7XG59KF9kcmF3ZXIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpQ2FudmFzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21lZGlhZWxlbWVudC13ZWJhdWRpby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWVkaWFlbGVtZW50LXdlYmF1ZGlvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX21lZGlhZWxlbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZWRpYWVsZW1lbnQgKi8gXCIuL3NyYy9tZWRpYWVsZW1lbnQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogTWVkaWFFbGVtZW50V2ViQXVkaW8gYmFja2VuZDogbG9hZCBhdWRpbyB2aWEgYW4gSFRNTDUgYXVkaW8gdGFnLCBidXQgcGxheWJhY2sgd2l0aCB0aGUgV2ViQXVkaW8gQVBJLlxuICogVGhlIGFkdmFudGFnZSBoZXJlIGlzIHRoYXQgdGhlIGh0bWw1IDxhdWRpbz4gdGFnIGNhbiBwZXJmb3JtIHJhbmdlIHJlcXVlc3RzIG9uIHRoZSBzZXJ2ZXIgYW5kIG5vdFxuICogYnVmZmVyIHRoZSBlbnRpcmUgZmlsZSBpbiBvbmUgcmVxdWVzdCwgYW5kIHlvdSBzdGlsbCBnZXQgdGhlIGZpbHRlcmluZyBhbmQgc2NyaXB0aW5nIGZ1bmN0aW9uYWxpdHlcbiAqIG9mIHRoZSB3ZWJhdWRpbyBBUEkuXG4gKiBOb3RlIHRoYXQgaW4gb3JkZXIgdG8gdXNlIHJhbmdlIHJlcXVlc3RzIGFuZCBwcmV2ZW50IGJ1ZmZlcmluZywgeW91IG11c3QgcHJvdmlkZSBwZWFrIGRhdGEuXG4gKlxuICogQHNpbmNlIDMuMi4wXG4gKi9cbnZhciBNZWRpYUVsZW1lbnRXZWJBdWRpbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01lZGlhRWxlbWVudCkge1xuICBfaW5oZXJpdHMoTWVkaWFFbGVtZW50V2ViQXVkaW8sIF9NZWRpYUVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTWVkaWFFbGVtZW50V2ViQXVkaW8pO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIGJhY2tlbmRcbiAgICpcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgV2F2ZXN1cmZlciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBNZWRpYUVsZW1lbnRXZWJBdWRpbyhwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFFbGVtZW50V2ViQXVkaW8pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc291cmNlTWVkaWFFbGVtZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIGJhY2tlbmQsIGNhbGxlZCBpbiBgd2F2ZXN1cmZlci5jcmVhdGVCYWNrZW5kKClgXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1lZGlhRWxlbWVudFdlYkF1ZGlvLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpO1xuICAgICAgdGhpcy5jcmVhdGVUaW1lcigpO1xuICAgICAgdGhpcy5jcmVhdGVWb2x1bWVOb2RlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVNjcmlwdE5vZGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlQW5hbHlzZXJOb2RlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGNhbGxlZCBieSBib3RoIGBsb2FkYCAoZnJvbSB1cmwpXG4gICAgICogYW5kIGBsb2FkRWx0YCAoZXhpc3RpbmcgbWVkaWEgZWxlbWVudCkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWEgSFRNTDUgQXVkaW8gb3IgVmlkZW8gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQXJyYXkgb2YgcGVhayBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWxvYWQgSFRNTCA1IHByZWxvYWQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkKG1lZGlhLCBwZWFrcywgcHJlbG9hZCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWVkaWFFbGVtZW50V2ViQXVkaW8ucHJvdG90eXBlKSwgXCJfbG9hZFwiLCB0aGlzKS5jYWxsKHRoaXMsIG1lZGlhLCBwZWFrcywgcHJlbG9hZCk7XG5cbiAgICAgIHRoaXMuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKG1lZGlhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIE1lZGlhRWxlbWVudFNvdXJjZSBub2RlXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCBIVE1MNSBBdWRpbyB0byBsb2FkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKG1lZGlhRWxlbWVudCkge1xuICAgICAgdGhpcy5zb3VyY2VNZWRpYUVsZW1lbnQgPSB0aGlzLmFjLmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpO1xuICAgICAgdGhpcy5zb3VyY2VNZWRpYUVsZW1lbnQuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHRoaXMucmVzdW1lQXVkaW9Db250ZXh0KCk7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWVkaWFFbGVtZW50V2ViQXVkaW8ucHJvdG90eXBlKSwgXCJwbGF5XCIsIHRoaXMpLmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gd2F2ZXN1cmZlciBpcyBkZXN0cm95ZWRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWVkaWFFbGVtZW50V2ViQXVkaW8ucHJvdG90eXBlKSwgXCJkZXN0cm95XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuZGVzdHJveVdlYkF1ZGlvKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lZGlhRWxlbWVudFdlYkF1ZGlvO1xufShfbWVkaWFlbGVtZW50LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYUVsZW1lbnRXZWJBdWRpbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9tZWRpYWVsZW1lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21lZGlhZWxlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF93ZWJhdWRpbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93ZWJhdWRpbyAqLyBcIi4vc3JjL3dlYmF1ZGlvLmpzXCIpKTtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogTWVkaWFFbGVtZW50IGJhY2tlbmRcbiAqL1xudmFyIE1lZGlhRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dlYkF1ZGlvKSB7XG4gIF9pbmhlcml0cyhNZWRpYUVsZW1lbnQsIF9XZWJBdWRpbyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNZWRpYUVsZW1lbnQpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIGJhY2tlbmRcbiAgICpcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgV2F2ZXN1cmZlciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBNZWRpYUVsZW1lbnQocGFyYW1zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGx5IGEgZHVtbXkgbWVkaWEgZWxlbWVudCB0byBjYXRjaCBlcnJvcnMuIE9uY2UgYF9sb2FkYCBpc1xuICAgICAqIGNhbGxlZCwgdGhpcyB3aWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIF90aGlzLm1lZGlhID0ge1xuICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogMSxcbiAgICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7fSxcbiAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHt9LFxuICAgICAgdm9sdW1lOiAwXG4gICAgfTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLm1lZGlhVHlwZSA9IHBhcmFtcy5tZWRpYVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmVsZW1lbnRQb3NpdGlvbiA9IHBhcmFtcy5lbGVtZW50UG9zaXRpb247XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wZWFrcyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMudm9sdW1lID0gMTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmlzTXV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5vblBsYXlFbmQgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMubWVkaWFMaXN0ZW5lcnMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIGJhY2tlbmQsIGNhbGxlZCBpbiBgd2F2ZXN1cmZlci5jcmVhdGVCYWNrZW5kKClgXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1lZGlhRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wYXJhbXMuYXVkaW9SYXRlKTtcbiAgICAgIHRoaXMuY3JlYXRlVGltZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byBtZWRpYSBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwTWVkaWFMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwTWVkaWFMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnZXJyb3InLCAnRXJyb3IgbG9hZGluZyBtZWRpYSBlbGVtZW50Jyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLmNhbnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2NhbnBsYXknKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMuZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2ZpbmlzaCcpO1xuICAgICAgfTsgLy8gbGlzdGVuIHRvIGFuZCByZWxheSBwbGF5LCBwYXVzZSBhbmQgc2Vla2VkIGV2ZW50cyB0byBlbmFibGVcbiAgICAgIC8vIHBsYXliYWNrIGNvbnRyb2wgZnJvbSB0aGUgZXh0ZXJuYWwgbWVkaWEgZWxlbWVudFxuXG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgncGxheScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgncGF1c2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMuc2Vla2VkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ3NlZWsnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMudm9sdW1lY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMi5pc011dGVkID0gX3RoaXMyLm1lZGlhLm11dGVkO1xuXG4gICAgICAgIGlmIChfdGhpczIuaXNNdXRlZCkge1xuICAgICAgICAgIF90aGlzMi52b2x1bWUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi52b2x1bWUgPSBfdGhpczIubWVkaWEudm9sdW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgndm9sdW1lJyk7XG4gICAgICB9OyAvLyByZXNldCBldmVudCBsaXN0ZW5lcnNcblxuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm1lZGlhTGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBfdGhpczIubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihpZCwgX3RoaXMyLm1lZGlhTGlzdGVuZXJzW2lkXSk7XG5cbiAgICAgICAgX3RoaXMyLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoaWQsIF90aGlzMi5tZWRpYUxpc3RlbmVyc1tpZF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRpbWVyIHRvIHByb3ZpZGUgYSBtb3JlIHByZWNpc2UgYGF1ZGlvcHJvY2Vzc2AgZXZlbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUaW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUaW1lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb25BdWRpb1Byb2Nlc3MgPSBmdW5jdGlvbiBvbkF1ZGlvUHJvY2VzcygpIHtcbiAgICAgICAgaWYgKF90aGlzMy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnYXVkaW9wcm9jZXNzJywgX3RoaXMzLmdldEN1cnJlbnRUaW1lKCkpOyAvLyBDYWxsIGFnYWluIGluIHRoZSBuZXh0IGZyYW1lXG5cblxuICAgICAgICB1dGlsLmZyYW1lKG9uQXVkaW9Qcm9jZXNzKSgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbigncGxheScsIG9uQXVkaW9Qcm9jZXNzKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyBvbmUgbW9yZSB0aW1lIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBzdHVjayBpblxuICAgICAgLy8gY2FzZSBvZiBsb3dlciBmcmFtZXJhdGVzXG5cbiAgICAgIHRoaXMub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdhdWRpb3Byb2Nlc3MnLCBfdGhpczMuZ2V0Q3VycmVudFRpbWUoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG1lZGlhIGVsZW1lbnQgd2l0aCB1cmwgYXMgaXRzIHNvdXJjZSxcbiAgICAgKiBhbmQgYXBwZW5kIHRvIGNvbnRhaW5lciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBQYXRoIHRvIG1lZGlhIGZpbGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgSFRNTCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBBcnJheSBvZiBwZWFrIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZCBIVE1MIDUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGB1cmxgIGFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIG1lZGlhXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGNvbnRhaW5lciwgcGVha3MsIHByZWxvYWQpIHtcbiAgICAgIHZhciBtZWRpYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tZWRpYVR5cGUpO1xuICAgICAgbWVkaWEuY29udHJvbHMgPSB0aGlzLnBhcmFtcy5tZWRpYUNvbnRyb2xzO1xuICAgICAgbWVkaWEuYXV0b3BsYXkgPSB0aGlzLnBhcmFtcy5hdXRvcGxheSB8fCBmYWxzZTtcbiAgICAgIG1lZGlhLnByZWxvYWQgPSBwcmVsb2FkID09IG51bGwgPyAnYXV0bycgOiBwcmVsb2FkO1xuICAgICAgbWVkaWEuc3JjID0gdXJsO1xuICAgICAgbWVkaWEuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB2YXIgcHJldk1lZGlhID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IodGhpcy5tZWRpYVR5cGUpO1xuXG4gICAgICBpZiAocHJldk1lZGlhKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChwcmV2TWVkaWEpO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWVkaWEpO1xuXG4gICAgICB0aGlzLl9sb2FkKG1lZGlhLCBwZWFrcywgcHJlbG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgZXhpc3RpbmcgbWVkaWEgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gZWx0IEhUTUw1IEF1ZGlvIG9yIFZpZGVvIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIEFycmF5IG9mIHBlYWsgZGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZEVsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkRWx0KGVsdCwgcGVha3MpIHtcbiAgICAgIGVsdC5jb250cm9scyA9IHRoaXMucGFyYW1zLm1lZGlhQ29udHJvbHM7XG4gICAgICBlbHQuYXV0b3BsYXkgPSB0aGlzLnBhcmFtcy5hdXRvcGxheSB8fCBmYWxzZTtcblxuICAgICAgdGhpcy5fbG9hZChlbHQsIHBlYWtzLCBlbHQucHJlbG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgYnkgYm90aCBgbG9hZGAgKGZyb20gdXJsKVxuICAgICAqIGFuZCBgbG9hZEVsdGAgKGV4aXN0aW5nIG1lZGlhIGVsZW1lbnQpIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhIEhUTUw1IEF1ZGlvIG9yIFZpZGVvIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIEFycmF5IG9mIHBlYWsgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVsb2FkIEhUTUwgNSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYG1lZGlhYCBhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBtZWRpYVxuICAgICAqIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkKG1lZGlhLCBwZWFrcywgcHJlbG9hZCkge1xuICAgICAgLy8gdmVyaWZ5IG1lZGlhIGVsZW1lbnQgaXMgdmFsaWRcbiAgICAgIGlmICghKG1lZGlhIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudCkgfHwgdHlwZW9mIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWVkaWEgcGFyYW1ldGVyIGlzIG5vdCBhIHZhbGlkIG1lZGlhIGVsZW1lbnQnKTtcbiAgICAgIH0gLy8gbG9hZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseSBvbiBpT1MsIG90aGVyd2lzZSBwZWFrcyB3b24ndCBkcmF3XG4gICAgICAvLyB1bnRpbCBhIHVzZXIgaW50ZXJhY3Rpb24gdHJpZ2dlcnMgbG9hZCAtLT4gJ3JlYWR5JyBldmVudFxuICAgICAgLy9cbiAgICAgIC8vIG5vdGUgdGhhdCB3ZSBhdm9pZCBjYWxsaW5nIG1lZGlhLmxvYWQgaGVyZSB3aGVuIGdpdmVuIHBlYWtzIGFuZCBwcmVsb2FkID09ICdub25lJ1xuICAgICAgLy8gYXMgdGhpcyBhbG1vc3QgYWx3YXlzIHRyaWdnZXJzIHNvbWUgYnJvd3NlciBmZXRjaCBvZiB0aGUgbWVkaWEuXG5cblxuICAgICAgaWYgKHR5cGVvZiBtZWRpYS5sb2FkID09ICdmdW5jdGlvbicgJiYgIShwZWFrcyAmJiBwcmVsb2FkID09ICdub25lJykpIHtcbiAgICAgICAgLy8gUmVzZXRzIHRoZSBtZWRpYSBlbGVtZW50IGFuZCByZXN0YXJ0cyB0aGUgbWVkaWEgcmVzb3VyY2UuIEFueVxuICAgICAgICAvLyBwZW5kaW5nIGV2ZW50cyBhcmUgZGlzY2FyZGVkLiBIb3cgbXVjaCBtZWRpYSBkYXRhIGlzIGZldGNoZWQgaXNcbiAgICAgICAgLy8gc3RpbGwgYWZmZWN0ZWQgYnkgdGhlIHByZWxvYWQgYXR0cmlidXRlLlxuICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcblxuICAgICAgdGhpcy5fc2V0dXBNZWRpYUxpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLnBlYWtzID0gcGVha3M7XG4gICAgICB0aGlzLm9uUGxheUVuZCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmlzTXV0ZWQgPSBtZWRpYS5tdXRlZDtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKTtcbiAgICAgIHRoaXMuc2V0Vm9sdW1lKHRoaXMudm9sdW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5pc1BsYXlpbmcoKWAgYW5kIGB3YXZlc3VyZmVyLnBsYXlQYXVzZSgpYFxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gTWVkaWEgcGF1c2VkIG9yIG5vdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQYXVzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYS5wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKWBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXhwbGljaXREdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSAodGhpcy5idWZmZXIgfHwgdGhpcy5tZWRpYSkuZHVyYXRpb247XG5cbiAgICAgIGlmIChkdXJhdGlvbiA+PSBJbmZpbml0eSkge1xuICAgICAgICAvLyBzdHJlYW1pbmcgYXVkaW9cbiAgICAgICAgZHVyYXRpb24gPSB0aGlzLm1lZGlhLnNlZWthYmxlLmVuZCgwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyByZWxhdGl2ZSB0byB0aGUgYXVkaW8tY2xpcCdzXG4gICAgICogZHVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEN1cnJlbnQgdGltZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VycmVudFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGZyb20gMCB0byAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEN1cnJlbnQgcG9zaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXllZFBlcmNlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXllZFBlcmNlbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKSAvIHRoaXMuZ2V0RHVyYXRpb24oKSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF1ZGlvIHNvdXJjZSBwbGF5YmFjayByYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBQbGF5YmFjayByYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWJhY2tSYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlIHx8IHRoaXMubWVkaWEucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF1ZGlvIHNvdXJjZSBwbGF5YmFjayByYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFBsYXliYWNrIHJhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5YmFja1JhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWUgfHwgMTtcbiAgICAgIHRoaXMubWVkaWEucGxheWJhY2tSYXRlID0gdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuc2Vla1RvKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgUG9zaXRpb24gdG8gc3RhcnQgYXQgaW4gc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Vla1RvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWtUbyhzdGFydCkge1xuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyUGxheUVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgbG9hZGVkIGF1ZGlvIHJlZ2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXQgaW4gc2Vjb25kcywgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAqIG9mIGEgY2xpcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFdoZW4gdG8gc3RvcCwgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIGNsaXAuXG4gICAgICogQGVtaXRzIE1lZGlhRWxlbWVudCNwbGF5XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzdWx0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5zZWVrVG8oc3RhcnQpO1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICAgIGVuZCAmJiB0aGlzLnNldFBsYXlFbmQoZW5kKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIGxvYWRlZCBhdWRpby5cbiAgICAgKlxuICAgICAqIEBlbWl0cyBNZWRpYUVsZW1lbnQjcGF1c2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXN1bHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLm1lZGlhLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYXJQbGF5RW5kKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwbGF5IGVuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBXaGVyZSB0byBlbmRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXlFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheUVuZChlbmQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsZWFyUGxheUVuZCgpO1xuXG4gICAgICB0aGlzLl9vblBsYXlFbmQgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA+PSBlbmQpIHtcbiAgICAgICAgICBfdGhpczQucGF1c2UoKTtcblxuICAgICAgICAgIF90aGlzNC5zZWVrVG8oZW5kKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignYXVkaW9wcm9jZXNzJywgdGhpcy5fb25QbGF5RW5kKTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclBsYXlFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJQbGF5RW5kKCkge1xuICAgICAgaWYgKHRoaXMuX29uUGxheUVuZCkge1xuICAgICAgICB0aGlzLnVuKCdhdWRpb3Byb2Nlc3MnLCB0aGlzLl9vblBsYXlFbmQpO1xuICAgICAgICB0aGlzLl9vblBsYXlFbmQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXggYW5kIG1pbiB2YWx1ZSBvZiB0aGUgd2F2ZWZvcm0gd2hlbiBicm9rZW4gaW50b1xuICAgICAqIDxsZW5ndGg+IHN1YnJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggSG93IG1hbnkgc3VicmFuZ2VzIHRvIGJyZWFrIHRoZSB3YXZlZm9ybSBpbnRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdCBGaXJzdCBzYW1wbGUgaW4gdGhlIHJlcXVpcmVkIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0IExhc3Qgc2FtcGxlIGluIHRoZSByZXF1aXJlZCByYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBBcnJheSBvZiAyKjxsZW5ndGg+IHBlYWtzIG9yIGFycmF5IG9mXG4gICAgICogYXJyYXlzIG9mIHBlYWtzIGNvbnNpc3Rpbmcgb2YgKG1heCwgbWluKSB2YWx1ZXMgZm9yIGVhY2ggc3VicmFuZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQZWFrcyhsZW5ndGgsIGZpcnN0LCBsYXN0KSB7XG4gICAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lZGlhRWxlbWVudC5wcm90b3R5cGUpLCBcImdldFBlYWtzXCIsIHRoaXMpLmNhbGwodGhpcywgbGVuZ3RoLCBmaXJzdCwgbGFzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBlYWtzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpbmsgaWQgZm9yIHRoZSBtZWRpYSBwbGF5ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCBTdHJpbmcgdmFsdWUgcmVwcmVzZW50aW5nIGF1ZGlvIGRldmljZSBpZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAgd2hlbiB0aGVyZVxuICAgICAqIGFyZSBubyBlcnJvcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTaW5rSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhLnNldFNpbmtJZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3NldFNpbmtJZCBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlcicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhLnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgZGV2aWNlSWQ6ICcgKyBkZXZpY2VJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdm9sdW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIEEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZvbHVtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZvbHVtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdWRpbyB2b2x1bWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBBIGZsb2F0aW5nIHBvaW50IHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWb2x1bWUodmFsdWUpIHtcbiAgICAgIHRoaXMudm9sdW1lID0gdmFsdWU7IC8vIG5vIG5lZWQgdG8gY2hhbmdlIHdoZW4gaXQncyBhbHJlYWR5IGF0IHRoYXQgdm9sdW1lXG5cbiAgICAgIGlmICh0aGlzLm1lZGlhLnZvbHVtZSAhPT0gdGhpcy52b2x1bWUpIHtcbiAgICAgICAgdGhpcy5tZWRpYS52b2x1bWUgPSB0aGlzLnZvbHVtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgbXV0ZWQgYXVkaW9cbiAgICAgKlxuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZWQgU3BlY2lmeSBgdHJ1ZWAgdG8gbXV0ZSBhdWRpby5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE11dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXV0ZShtdXRlZCkge1xuICAgICAgLy8gVGhpcyBjYXVzZXMgYSB2b2x1bWUgY2hhbmdlIHRvIGJlIGVtaXR0ZWQgdG9vIHRocm91Z2ggdGhlXG4gICAgICAvLyB2b2x1bWVjaGFuZ2UgZXZlbnQgbGlzdGVuZXIuXG4gICAgICB0aGlzLmlzTXV0ZWQgPSB0aGlzLm1lZGlhLm11dGVkID0gbXV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gd2F2ZXN1cmZlciBpcyBkZXN0cm95ZWRcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMudW5BbGwoKTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTsgLy8gY2xlYW51cCBtZWRpYSBldmVudCBsaXN0ZW5lcnNcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5tZWRpYUxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKF90aGlzNS5tZWRpYSkge1xuICAgICAgICAgIF90aGlzNS5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKGlkLCBfdGhpczUubWVkaWFMaXN0ZW5lcnNbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5yZW1vdmVNZWRpYUVsZW1lbnRPbkRlc3Ryb3kgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubWVkaWEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVkaWFFbGVtZW50O1xufShfd2ViYXVkaW8uZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1lZGlhRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wZWFrY2FjaGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BlYWtjYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBDYWNoZXMgdGhlIGRlY29kZWQgcGVha3MgZGF0YSB0byBpbXByb3ZlIHJlbmRlcmluZyBzcGVlZCBmb3IgbGFyZ2UgYXVkaW9cbiAqXG4gKiBJcyB1c2VkIGlmIHRoZSBvcHRpb24gcGFyYW1ldGVyIGBwYXJ0aWFsUmVuZGVyYCBpcyBzZXQgdG8gYHRydWVgXG4gKi9cbnZhciBQZWFrQ2FjaGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogSW5zdGFudGlhdGUgY2FjaGVcbiAgICovXG4gIGZ1bmN0aW9uIFBlYWtDYWNoZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVha0NhY2hlKTtcblxuICAgIHRoaXMuY2xlYXJQZWFrQ2FjaGUoKTtcbiAgfVxuICAvKipcbiAgICogRW1wdHkgdGhlIGNhY2hlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBlYWtDYWNoZSwgW3tcbiAgICBrZXk6IFwiY2xlYXJQZWFrQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJQZWFrQ2FjaGUoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZsYXQgYXJyYXkgd2l0aCBlbnRyaWVzIHRoYXQgYXJlIGFsd2F5cyBpbiBwYWlycyB0byBtYXJrIHRoZVxuICAgICAgICogYmVnaW5uaW5nIGFuZCBlbmQgb2YgZWFjaCBzdWJyYW5nZS4gIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBzbyB3ZSBjYW5cbiAgICAgICAqIGl0ZXJhdGUgb3ZlciB0aGUgcGFpcnMgZm9yIGVhc3kgc2V0IGRpZmZlcmVuY2Ugb3BlcmF0aW9ucy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIHRoaXMucGVha0NhY2hlUmFuZ2VzID0gW107XG4gICAgICAvKipcbiAgICAgICAqIExlbmd0aCBvZiB0aGUgZW50aXJlIGNhY2hhYmxlIHJlZ2lvbiwgdXNlZCBmb3IgcmVzZXR0aW5nIHRoZSBjYWNoZVxuICAgICAgICogd2hlbiB0aGlzIGNoYW5nZXMgKHpvb20gZXZlbnRzLCBmb3IgaW5zdGFuY2UpLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLnBlYWtDYWNoZUxlbmd0aCA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSByYW5nZSBvZiBwZWFrcyB0byB0aGUgY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHggb2Zmc2V0IG9mIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4IG9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSByYW5nZVxuICAgICAqIEByZXR1cm4ge051bWJlci48QXJyYXlbXT59IEFycmF5IHdpdGggYXJyYXlzIG9mIG51bWJlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFJhbmdlVG9QZWFrQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmFuZ2VUb1BlYWtDYWNoZShsZW5ndGgsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChsZW5ndGggIT0gdGhpcy5wZWFrQ2FjaGVMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jbGVhclBlYWtDYWNoZSgpO1xuICAgICAgICB0aGlzLnBlYWtDYWNoZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIH0gLy8gUmV0dXJuIHJhbmdlcyB0aGF0IHdlcmVuJ3QgaW4gdGhlIGNhY2hlIGJlZm9yZSB0aGUgY2FsbC5cblxuXG4gICAgICB2YXIgdW5jYWNoZWRSYW5nZXMgPSBbXTtcbiAgICAgIHZhciBpID0gMDsgLy8gU2tpcCByYW5nZXMgYmVmb3JlIHRoZSBjdXJyZW50IHN0YXJ0LlxuXG4gICAgICB3aGlsZSAoaSA8IHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSA8IHN0YXJ0KSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gLy8gSWYgfGl8IGlzIGV2ZW4sIHxzdGFydHwgZmFsbHMgYWZ0ZXIgYW4gZXhpc3RpbmcgcmFuZ2UuICBPdGhlcndpc2UsXG4gICAgICAvLyB8c3RhcnR8IGZhbGxzIGJldHdlZW4gYW4gZXhpc3RpbmcgcmFuZ2UsIGFuZCB0aGUgdW5jYWNoZWQgcmVnaW9uXG4gICAgICAvLyBzdGFydHMgd2hlbiB3ZSBlbmNvdW50ZXIgdGhlIG5leHQgbm9kZSBpbiB8cGVha0NhY2hlUmFuZ2VzfCBvclxuICAgICAgLy8gfGVuZHwsIHdoaWNoZXZlciBjb21lcyBmaXJzdC5cblxuXG4gICAgICBpZiAoaSAlIDIgPT0gMCkge1xuICAgICAgICB1bmNhY2hlZFJhbmdlcy5wdXNoKHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkgPCB0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGggJiYgdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV0gPD0gZW5kKSB7XG4gICAgICAgIHVuY2FjaGVkUmFuZ2VzLnB1c2godGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV0pO1xuICAgICAgICBpKys7XG4gICAgICB9IC8vIElmIHxpfCBpcyBldmVuLCB8ZW5kfCBpcyBhZnRlciBhbGwgZXhpc3RpbmcgcmFuZ2VzLlxuXG5cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIHVuY2FjaGVkUmFuZ2VzLnB1c2goZW5kKTtcbiAgICAgIH0gLy8gRmlsdGVyIG91dCB0aGUgMC1sZW5ndGggcmFuZ2VzLlxuXG5cbiAgICAgIHVuY2FjaGVkUmFuZ2VzID0gdW5jYWNoZWRSYW5nZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBwb3MsIGFycikge1xuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zICsgMV07XG4gICAgICAgIH0gZWxzZSBpZiAocG9zID09IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyAtIDFdICYmIGl0ZW0gIT0gYXJyW3BvcyArIDFdO1xuICAgICAgfSk7IC8vIE1lcmdlIHRoZSB0d28gcmFuZ2VzIHRvZ2V0aGVyLCB1bmNhY2hlZFJhbmdlcyB3aWxsIGVpdGhlciBjb250YWluXG4gICAgICAvLyB3aG9sbHkgbmV3IHBvaW50cywgb3IgZHVwbGljYXRlcyBvZiBwb2ludHMgaW4gcGVha0NhY2hlUmFuZ2VzLiAgSWZcbiAgICAgIC8vIGR1cGxpY2F0ZXMgYXJlIGRldGVjdGVkLCByZW1vdmUgYm90aCBhbmQgZXh0ZW5kIHRoZSByYW5nZS5cblxuICAgICAgdGhpcy5wZWFrQ2FjaGVSYW5nZXMgPSB0aGlzLnBlYWtDYWNoZVJhbmdlcy5jb25jYXQodW5jYWNoZWRSYW5nZXMpO1xuICAgICAgdGhpcy5wZWFrQ2FjaGVSYW5nZXMgPSB0aGlzLnBlYWtDYWNoZVJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgcG9zLCBhcnIpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyArIDFdO1xuICAgICAgICB9IGVsc2UgaWYgKHBvcyA9PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgLSAxXSAmJiBpdGVtICE9IGFycltwb3MgKyAxXTtcbiAgICAgIH0pOyAvLyBQdXNoIHRoZSB1bmNhY2hlZCByYW5nZXMgaW50byBhbiBhcnJheSBvZiBhcnJheXMgZm9yIGVhc2Ugb2ZcbiAgICAgIC8vIGl0ZXJhdGlvbiBpbiB0aGUgZnVuY3Rpb25zIHRoYXQgY2FsbCB0aGlzLlxuXG4gICAgICB2YXIgdW5jYWNoZWRSYW5nZVBhaXJzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1bmNhY2hlZFJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB1bmNhY2hlZFJhbmdlUGFpcnMucHVzaChbdW5jYWNoZWRSYW5nZXNbaV0sIHVuY2FjaGVkUmFuZ2VzW2kgKyAxXV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5jYWNoZWRSYW5nZVBhaXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGVzdGluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyLjxBcnJheVtdPn0gQXJyYXkgd2l0aCBhcnJheXMgb2YgbnVtYmVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVSYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGVSYW5nZXMoKSB7XG4gICAgICB2YXIgcGVha0NhY2hlUmFuZ2VQYWlycyA9IFtdO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwZWFrQ2FjaGVSYW5nZVBhaXJzLnB1c2goW3RoaXMucGVha0NhY2hlUmFuZ2VzW2ldLCB0aGlzLnBlYWtDYWNoZVJhbmdlc1tpICsgMV1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlYWtDYWNoZVJhbmdlUGFpcnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBlYWtDYWNoZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGVha0NhY2hlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvYWJzTWF4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvYWJzTWF4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gYWJzTWF4O1xuXG52YXIgX21heCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXggKi8gXCIuL3NyYy91dGlsL21heC5qc1wiKSk7XG5cbnZhciBfbWluID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21pbiAqLyBcIi4vc3JjL3V0aWwvbWluLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEdldCB0aGUgbGFyZ2VzdCBhYnNvbHV0ZSB2YWx1ZSBpbiBhbiBhcnJheVxyXG4gKlxyXG4gKiBAcGFyYW0gICB7QXJyYXl9IHZhbHVlcyBBcnJheSBvZiBudW1iZXJzXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IExhcmdlc3QgbnVtYmVyIGZvdW5kXHJcbiAqIEBleGFtcGxlIGNvbnNvbGUubG9nKG1heChbLTMsIDIsIDFdKSwgbWF4KFstMywgMiwgNF0pKTsgLy8gbG9ncyAzIDRcclxuICogQHNpbmNlIDQuMy4wXHJcbiAqL1xuZnVuY3Rpb24gYWJzTWF4KHZhbHVlcykge1xuICB2YXIgbWF4ID0gKDAsIF9tYXguZGVmYXVsdCkodmFsdWVzKTtcbiAgdmFyIG1pbiA9ICgwLCBfbWluLmRlZmF1bHQpKHZhbHVlcyk7XG4gIHJldHVybiAtbWluID4gbWF4ID8gLW1pbiA6IG1heDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvY2xhbXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2NsYW1wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbGFtcDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIGxpbWl0ZWQgdG8gdGhlIGdpdmVuIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVGhlIG51bWJlciB0byBiZSBsaW1pdGVkIHRvIGEgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBsaW1pdCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGxpbWl0IHJhbmdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIG51bWJlciBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbCksIG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2ZldGNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9mZXRjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hGaWxlO1xuXG52YXIgX29ic2VydmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29ic2VydmVyICovIFwiLi9zcmMvdXRpbC9vYnNlcnZlci5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFByb2dyZXNzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBQcm9ncmVzc0hhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYnNlcnZlcn0gaW5zdGFuY2UgVGhlIGBmZXRjaEZpbGVgIG9ic2VydmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29udGVudExlbmd0aCBDb250ZW50IGxlbmd0aC5cbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgUmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvZ3Jlc3NIYW5kbGVyKGluc3RhbmNlLCBjb250ZW50TGVuZ3RoLCByZXNwb25zZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0hhbmRsZXIpO1xuXG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHRoaXMuaW5zdGFuY2UuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgdGhpcy50b3RhbCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIG9uY2UsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBgUmVhZGFibGVTdHJlYW1gYFxuICAgKiBpcyBjb25zdHJ1Y3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyIENvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICogICAgIHVzZWQgdG8gY29udHJvbCB0aGUgc3RyZWFtLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQcm9ncmVzc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByZWFkID0gZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgLy8gaW5zdGFuY2UuX3JlYWRlci5yZWFkKCkgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlc1xuICAgICAgICAvLyB3aGVuIGEgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWRcbiAgICAgICAgX3RoaXMuaW5zdGFuY2UuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBkb25lID0gX3JlZi5kb25lLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgICAgICAgICAvLyByZXN1bHQgb2JqZWN0cyBjb250YWluIHR3byBwcm9wZXJ0aWVzOlxuICAgICAgICAgIC8vIGRvbmUgIC0gdHJ1ZSBpZiB0aGUgc3RyZWFtIGhhcyBhbHJlYWR5IGdpdmVuIHlvdSBhbGwgaXRzIGRhdGEuXG4gICAgICAgICAgLy8gdmFsdWUgLSBzb21lIGRhdGEuIEFsd2F5cyB1bmRlZmluZWQgd2hlbiBkb25lIGlzIHRydWUuXG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBvblByb2dyZXNzIGNhbGxlZCB3aGVuIGNvbnRlbnQtbGVuZ3RoPTBcbiAgICAgICAgICAgIGlmIChfdGhpcy50b3RhbCA9PT0gMCkge1xuICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5vblByb2dyZXNzLmNhbGwoX3RoaXMuaW5zdGFuY2UsIHtcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IF90aGlzLmxvYWRlZCxcbiAgICAgICAgICAgICAgICB0b3RhbDogX3RoaXMudG90YWwsXG4gICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IC8vIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuXG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuICAgICAgICAgIF90aGlzLmluc3RhbmNlLm9uUHJvZ3Jlc3MuY2FsbChfdGhpcy5pbnN0YW5jZSwge1xuICAgICAgICAgICAgbG9hZGVkOiBfdGhpcy5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogX3RoaXMudG90YWwsXG4gICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiAhKF90aGlzLnRvdGFsID09PSAwKVxuICAgICAgICAgIH0pOyAvLyBlbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuXG5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmVhZCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9ncmVzc0hhbmRsZXI7XG59KCk7XG4vKipcbiAqIExvYWQgYSBmaWxlIHVzaW5nIGBmZXRjaGAuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUmVxdWVzdCBvcHRpb25zIHRvIHVzZS4gU2VlIGV4YW1wbGUgYmVsb3cuXG4gKiBAcmV0dXJucyB7T2JzZXJ2ZXJ9IE9ic2VydmVyIGluc3RhbmNlXG4gKiBAZXhhbXBsZVxuICogLy8gZGVmYXVsdCBvcHRpb25zXG4gKiBsZXQgb3B0aW9ucyA9IHtcbiAqICAgICB1cmw6IHVuZGVmaW5lZCxcbiAqICAgICBtZXRob2Q6ICdHRVQnLFxuICogICAgIG1vZGU6ICdjb3JzJyxcbiAqICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAqICAgICBjYWNoZTogJ2RlZmF1bHQnLFxuICogICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICogICAgIHJlcXVlc3RIZWFkZXJzOiBbXSxcbiAqICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gKiAgICAgcmVmZXJyZXI6ICdjbGllbnQnXG4gKiB9O1xuICpcbiAqIC8vIG92ZXJyaWRlIHNvbWUgb3B0aW9uc1xuICogb3B0aW9ucy51cmwgPSAnLi4vbWVkaWEvZGVtby53YXYnO1xuXG4gKiAvLyBhdmFpbGFibGUgdHlwZXM6ICdhcnJheWJ1ZmZlcicsICdibG9iJywgJ2pzb24nIG9yICd0ZXh0J1xuICogb3B0aW9ucy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICpcbiAqIC8vIG1ha2UgZmV0Y2ggY2FsbFxuICogbGV0IHJlcXVlc3QgPSB1dGlsLmZldGNoRmlsZShvcHRpb25zKTtcbiAqXG4gKiAvLyBsaXN0ZW4gZm9yIGV2ZW50c1xuICogcmVxdWVzdC5vbigncHJvZ3Jlc3MnLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygncHJvZ3Jlc3MnLCBlKTtcbiAqIH0pO1xuICpcbiAqIHJlcXVlc3Qub24oJ3N1Y2Nlc3MnLCBkYXRhID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnc3VjY2VzcyEnLCBkYXRhKTtcbiAqIH0pO1xuICpcbiAqIHJlcXVlc3Qub24oJ2Vycm9yJywgZSA9PiB7XG4gKiAgICAgY29uc29sZS53YXJuKCdmZXRjaEZpbGUgZXJyb3I6ICcsIGUpO1xuICogfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBmZXRjaEZpbGUob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoIG9wdGlvbnMgbWlzc2luZycpO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zLnVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2ggdXJsIG1pc3NpbmcnKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBfb2JzZXJ2ZXIuZGVmYXVsdCgpO1xuICB2YXIgZmV0Y2hIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgdmFyIGZldGNoUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9wdGlvbnMudXJsKTsgLy8gYWRkIGFiaWxpdHkgdG8gYWJvcnRcblxuICBpbnN0YW5jZS5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpOyAvLyBjaGVjayBpZiBoZWFkZXJzIGhhdmUgdG8gYmUgYWRkZWRcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcXVlc3RIZWFkZXJzKSB7XG4gICAgLy8gYWRkIGN1c3RvbSByZXF1ZXN0IGhlYWRlcnNcbiAgICBvcHRpb25zLnJlcXVlc3RIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgZmV0Y2hIZWFkZXJzLmFwcGVuZChoZWFkZXIua2V5LCBoZWFkZXIudmFsdWUpO1xuICAgIH0pO1xuICB9IC8vIHBhcnNlIGZldGNoIG9wdGlvbnNcblxuXG4gIHZhciByZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZSB8fCAnanNvbic7XG4gIHZhciBmZXRjaE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICBoZWFkZXJzOiBmZXRjaEhlYWRlcnMsXG4gICAgbW9kZTogb3B0aW9ucy5tb2RlIHx8ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogb3B0aW9ucy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nLFxuICAgIGNhY2hlOiBvcHRpb25zLmNhY2hlIHx8ICdkZWZhdWx0JyxcbiAgICByZWRpcmVjdDogb3B0aW9ucy5yZWRpcmVjdCB8fCAnZm9sbG93JyxcbiAgICByZWZlcnJlcjogb3B0aW9ucy5yZWZlcnJlciB8fCAnY2xpZW50JyxcbiAgICBzaWduYWw6IGluc3RhbmNlLmNvbnRyb2xsZXIuc2lnbmFsXG4gIH07XG4gIGZldGNoKGZldGNoUmVxdWVzdCwgZmV0Y2hPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIC8vIHN0b3JlIHJlc3BvbnNlIHJlZmVyZW5jZVxuICAgIGluc3RhbmNlLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdmFyIHByb2dyZXNzQXZhaWxhYmxlID0gdHJ1ZTtcblxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgLy8gUmVhZGFibGVTdHJlYW0gaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtXG4gICAgICBwcm9ncmVzc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgIH0gLy8gU2VydmVyIG11c3Qgc2VuZCBDT1JTIGhlYWRlciBcIkFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzOiBjb250ZW50LWxlbmd0aFwiXG5cblxuICAgIHZhciBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cbiAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgLy8gQ29udGVudC1MZW5ndGggc2VydmVyIHJlc3BvbnNlIGhlYWRlciBtaXNzaW5nLlxuICAgICAgLy8gRG9uJ3QgZXZhbHVhdGUgZG93bmxvYWQgcHJvZ3Jlc3MgaWYgd2UgY2FuJ3QgY29tcGFyZSBhZ2FpbnN0IGEgdG90YWwgc2l6ZVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQ09SUyNBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc1xuICAgICAgcHJvZ3Jlc3NBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXByb2dyZXNzQXZhaWxhYmxlKSB7XG4gICAgICAvLyBub3QgYWJsZSB0byBjaGVjayBkb3dubG9hZCBwcm9ncmVzcyBzbyBza2lwIGl0XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSAvLyBmaXJlIHByb2dyZXNzIGV2ZW50IHdoZW4gZHVyaW5nIGxvYWRcblxuXG4gICAgaW5zdGFuY2Uub25Qcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpbnN0YW5jZS5maXJlRXZlbnQoJ3Byb2dyZXNzJywgZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobmV3IFJlYWRhYmxlU3RyZWFtKG5ldyBQcm9ncmVzc0hhbmRsZXIoaW5zdGFuY2UsIGNvbnRlbnRMZW5ndGgsIHJlc3BvbnNlKSksIGZldGNoT3B0aW9ucyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgdmFyIGVyck1zZztcblxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcblxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXJyTXNnID0gJ1Vua25vd24gcmVzcG9uc2VUeXBlOiAnICsgcmVzcG9uc2VUeXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXJyTXNnKSB7XG4gICAgICBlcnJNc2cgPSAnSFRUUCBlcnJvciBzdGF0dXM6ICcgKyByZXNwb25zZS5zdGF0dXM7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaW5zdGFuY2UuZmlyZUV2ZW50KCdzdWNjZXNzJywgcmVzcG9uc2UpO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpbnN0YW5jZS5maXJlRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuICB9KTsgLy8gcmV0dXJuIHRoZSBmZXRjaCByZXF1ZXN0XG5cbiAgaW5zdGFuY2UuZmV0Y2hSZXF1ZXN0ID0gZmV0Y2hSZXF1ZXN0O1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2ZyYW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9mcmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnJhbWU7XG5cbnZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lICovIFwiLi9zcmMvdXRpbC9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBjeWNsZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqXG4gKiBAcmV0dXJuIHtmdW5jfSBUaGUgZnVuY3Rpb24gd3JhcHBlZCB3aXRoaW4gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqL1xuZnVuY3Rpb24gZnJhbWUoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvZ2V0LWlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvZ2V0LWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0SWQ7XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIHByZWZpeGVkIElEXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBQcmVmaXggdG8gdXNlLiBEZWZhdWx0IGlzIGAnd2F2ZXN1cmZlcl8nYC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFJhbmRvbSBwcmVmaXhlZCBJRFxuICogQGV4YW1wbGVcbiAqIGNvbnNvbGUubG9nKGdldElkKCkpOyAvLyBsb2dzICd3YXZlc3VyZmVyX2I1cG9yczRydTZnJ1xuICpcbiAqIGxldCBwcmVmaXggPSAnZm9vLSc7XG4gKiBjb25zb2xlLmxvZyhnZXRJZChwcmVmaXgpKTsgLy8gbG9ncyAnZm9vLWI1cG9yczRydTZnJ1xuICovXG5mdW5jdGlvbiBnZXRJZChwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHJlZml4ID0gJ3dhdmVzdXJmZXJfJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXggKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDMyKS5zdWJzdHJpbmcoMik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJZFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldElkLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1heFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21heC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtaW5cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9taW4uZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWJzTWF4XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWJzTWF4LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9ic2VydmVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfb2JzZXJ2ZXIuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3R5bGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdHlsZS5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJhbWVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mcmFtZS5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWJvdW5jZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2RlYm91bmNlLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByZXZlbnRDbGlja1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3ByZXZlbnRDbGljay5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmZXRjaEZpbGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mZXRjaC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbGFtcFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NsYW1wLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpdGhPcmllbnRhdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX29yaWVudGF0aW9uLmRlZmF1bHQ7XG4gIH1cbn0pKTtcblxudmFyIF9nZXRJZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtaWQgKi8gXCIuL3NyYy91dGlsL2dldC1pZC5qc1wiKSk7XG5cbnZhciBfbWF4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21heCAqLyBcIi4vc3JjL3V0aWwvbWF4LmpzXCIpKTtcblxudmFyIF9taW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWluICovIFwiLi9zcmMvdXRpbC9taW4uanNcIikpO1xuXG52YXIgX2Fic01heCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hYnNNYXggKi8gXCIuL3NyYy91dGlsL2Fic01heC5qc1wiKSk7XG5cbnZhciBfb2JzZXJ2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JzZXJ2ZXIgKi8gXCIuL3NyYy91dGlsL29ic2VydmVyLmpzXCIpKTtcblxudmFyIF9zdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHlsZSAqLyBcIi4vc3JjL3V0aWwvc3R5bGUuanNcIikpO1xuXG52YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZSAqLyBcIi4vc3JjL3V0aWwvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanNcIikpO1xuXG52YXIgX2ZyYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYW1lICovIFwiLi9zcmMvdXRpbC9mcmFtZS5qc1wiKSk7XG5cbnZhciBfZGVib3VuY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGRlYm91bmNlICovIFwiLi9ub2RlX21vZHVsZXMvZGVib3VuY2UvaW5kZXguanNcIikpO1xuXG52YXIgX3ByZXZlbnRDbGljayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmV2ZW50LWNsaWNrICovIFwiLi9zcmMvdXRpbC9wcmV2ZW50LWNsaWNrLmpzXCIpKTtcblxudmFyIF9mZXRjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mZXRjaCAqLyBcIi4vc3JjL3V0aWwvZmV0Y2guanNcIikpO1xuXG52YXIgX2NsYW1wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NsYW1wICovIFwiLi9zcmMvdXRpbC9jbGFtcC5qc1wiKSk7XG5cbnZhciBfb3JpZW50YXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb3JpZW50YXRpb24gKi8gXCIuL3NyYy91dGlsL29yaWVudGF0aW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9tYXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9tYXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXg7XG5cbi8qKlxuICogR2V0IHRoZSBsYXJnZXN0IHZhbHVlXG4gKlxuICogQHBhcmFtICAge0FycmF5fSB2YWx1ZXMgQXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge051bWJlcn0gTGFyZ2VzdCBudW1iZXIgZm91bmRcbiAqIEBleGFtcGxlIGNvbnNvbGUubG9nKG1heChbMSwgMiwgM10pKTsgLy8gbG9ncyAzXG4gKi9cbmZ1bmN0aW9uIG1heCh2YWx1ZXMpIHtcbiAgdmFyIGxhcmdlc3QgPSAtSW5maW5pdHk7XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIGlmICh2YWx1ZXNbaV0gPiBsYXJnZXN0KSB7XG4gICAgICBsYXJnZXN0ID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsYXJnZXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9taW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9taW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtaW47XG5cbi8qKlxuICogR2V0IHRoZSBzbWFsbGVzdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSAgIHtBcnJheX0gdmFsdWVzIEFycmF5IG9mIG51bWJlcnNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFNtYWxsZXN0IG51bWJlciBmb3VuZFxuICogQGV4YW1wbGUgY29uc29sZS5sb2cobWluKFsxLCAyLCAzXSkpOyAvLyBsb2dzIDFcbiAqL1xuZnVuY3Rpb24gbWluKHZhbHVlcykge1xuICB2YXIgc21hbGxlc3QgPSBOdW1iZXIoSW5maW5pdHkpO1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAodmFsdWVzW2ldIDwgc21hbGxlc3QpIHtcbiAgICAgIHNtYWxsZXN0ID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzbWFsbGVzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvb2JzZXJ2ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL29ic2VydmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaXN0ZW5lckRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB1biBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG4gKi9cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzc1xuICovXG52YXIgT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogSW5zdGFudGlhdGUgT2JzZXJ2ZXJcbiAgICovXG4gIGZ1bmN0aW9uIE9ic2VydmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYnNlcnZlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0b2RvIEluaXRpYWxpc2UgdGhlIGhhbmRsZXJzIGhlcmUgYWxyZWFkeSBhbmQgcmVtb3ZlIHRoZSBjb25kaXRpb25hbFxuICAgICAqIGFzc2lnbm1lbnQgaW4gYG9uKClgXG4gICAgICovXG4gICAgdGhpcy5fZGlzYWJsZWRFdmVudEVtaXNzaW9ucyA9IFtdO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggYSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gdHJpZ2dlciB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgKiBAcmV0dXJuIHtMaXN0ZW5lckRlc2NyaXB0b3J9IFRoZSBldmVudCBkZXNjcmlwdG9yXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgZm4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5oYW5kbGVycykge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdO1xuXG4gICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlcnMucHVzaChmbik7IC8vIFJldHVybiBhbiBldmVudCBkZXNjcmlwdG9yXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGV2ZW50LFxuICAgICAgICBjYWxsYmFjazogZm4sXG4gICAgICAgIHVuOiBmdW5jdGlvbiB1bihlLCBmbikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy51bihlLCBmbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50IHRoZSBsaXN0ZW5lciB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbW92ZWQgbGlzdGVucyB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSByZW1vdmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bihldmVudCwgZm4pIHtcbiAgICAgIGlmICghdGhpcy5oYW5kbGVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICBmb3IgKGkgPSBoYW5kbGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09IGZuKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5BbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5BbGwoKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgaGFuZGxlciB0byBhbiBldmVudC4gVGhlIGhhbmRsZXIgaXMgZXhlY3V0ZWQgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgVGhlIGNhbGxiYWNrIHRoYXQgaXMgb25seSB0byBiZSBjYWxsZWQgb25jZVxuICAgICAqIEByZXR1cm4ge0xpc3RlbmVyRGVzY3JpcHRvcn0gVGhlIGV2ZW50IGRlc2NyaXB0b3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlcikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuICAgICAgICBoYW5kbGVyLmFwcGx5KF90aGlzMiwgYXJncyk7XG4gICAgICAgIC8qICBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi51bihldmVudCwgZm4pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgZmlyaW5nIGEgbGlzdCBvZiBldmVudHMgYnkgbmFtZS4gV2hlbiBzcGVjaWZpZWQsIGV2ZW50IGhhbmRsZXJzIGZvciBhbnkgZXZlbnQgdHlwZVxuICAgICAqIHBhc3NlZCBpbiBoZXJlIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZSBlbWlzc2lvbnMgZm9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkaXNhYmxlIHNlZWsgYW5kIGludGVyYWN0aW9uIGV2ZW50c1xuICAgICAqIHdhdmVzdXJmZXIuc2V0RGlzYWJsZWRFdmVudEVtaXNzaW9ucyhbJ3NlZWsnLCAnaW50ZXJhY3Rpb24nXSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXNhYmxlZEV2ZW50RW1pc3Npb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERpc2FibGVkRXZlbnRFbWlzc2lvbnMoZXZlbnROYW1lcykge1xuICAgICAgdGhpcy5fZGlzYWJsZWRFdmVudEVtaXNzaW9ucyA9IGV2ZW50TmFtZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBsdWdpbnMgYm9ycm93IHBhcnQgb2YgdGhpcyBjbGFzcyB3aXRob3V0IGNhbGxpbmcgdGhlIGNvbnN0cnVjdG9yLFxuICAgICAqIHNvIHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCBhYm91dCBfZGlzYWJsZWRFdmVudEVtaXNzaW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzRGlzYWJsZWRFdmVudEVtaXNzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0Rpc2FibGVkRXZlbnRFbWlzc2lvbihldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnMgJiYgdGhpcy5fZGlzYWJsZWRFdmVudEVtaXNzaW9ucy5pbmNsdWRlcyhldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGZpcmUgYW4gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgdG8gZmlyZSBtYW51YWxseVxuICAgICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCB0byBjYWxsIHRoZSBsaXN0ZW5lcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpcmVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYW5kbGVycyB8fCB0aGlzLl9pc0Rpc2FibGVkRXZlbnRFbWlzc2lvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE9ic2VydmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvb3JpZW50YXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL29yaWVudGF0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoT3JpZW50YXRpb247XG52YXIgdmVydGljYWxQcm9wTWFwID0ge1xuICB3aWR0aDogJ2hlaWdodCcsXG4gIGhlaWdodDogJ3dpZHRoJyxcbiAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3dZJyxcbiAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3dYJyxcbiAgY2xpZW50V2lkdGg6ICdjbGllbnRIZWlnaHQnLFxuICBjbGllbnRIZWlnaHQ6ICdjbGllbnRXaWR0aCcsXG4gIGNsaWVudFg6ICdjbGllbnRZJyxcbiAgY2xpZW50WTogJ2NsaWVudFgnLFxuICBzY3JvbGxXaWR0aDogJ3Njcm9sbEhlaWdodCcsXG4gIHNjcm9sbExlZnQ6ICdzY3JvbGxUb3AnLFxuICBvZmZzZXRMZWZ0OiAnb2Zmc2V0VG9wJyxcbiAgb2Zmc2V0VG9wOiAnb2Zmc2V0TGVmdCcsXG4gIG9mZnNldEhlaWdodDogJ29mZnNldFdpZHRoJyxcbiAgb2Zmc2V0V2lkdGg6ICdvZmZzZXRIZWlnaHQnLFxuICBsZWZ0OiAndG9wJyxcbiAgcmlnaHQ6ICdib3R0b20nLFxuICB0b3A6ICdsZWZ0JyxcbiAgYm90dG9tOiAncmlnaHQnLFxuICBib3JkZXJSaWdodFN0eWxlOiAnYm9yZGVyQm90dG9tU3R5bGUnLFxuICBib3JkZXJSaWdodFdpZHRoOiAnYm9yZGVyQm90dG9tV2lkdGgnLFxuICBib3JkZXJSaWdodENvbG9yOiAnYm9yZGVyQm90dG9tQ29sb3InXG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgaG9yaXpvbnRhbGx5LW9yaWVudGVkIHByb3BlcnR5IG5hbWUgdG8gYSB2ZXJ0aWNhbCBvbmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgQSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2x9IHZlcnRpY2FsIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgb3JpZW50ZWQgdmVydGljYWxseVxuICogQHJldHVybnMge3N0cmluZ30gcHJvcCwgY29udmVydGVkIGFwcHJvcHJpYXRlbHlcbiAqL1xuXG5mdW5jdGlvbiBtYXBQcm9wKHByb3AsIHZlcnRpY2FsKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVydGljYWxQcm9wTWFwLCBwcm9wKSkge1xuICAgIHJldHVybiB2ZXJ0aWNhbCA/IHZlcnRpY2FsUHJvcE1hcFtwcm9wXSA6IHByb3A7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn1cblxudmFyIGlzUHJveHkgPSBTeW1ib2woXCJpc1Byb3h5XCIpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFwcHJvcHJpYXRlbHkgb3JpZW50ZWQgb2JqZWN0IGJhc2VkIG9uIHZlcnRpY2FsLlxuICogSWYgdmVydGljYWwgaXMgdHJ1ZSwgYXR0cmlidXRlIGdldHRpbmcgYW5kIHNldHRpbmcgd2lsbCBiZSBtYXBwZWQgdGhyb3VnaFxuICogdmVydGljYWxQcm9wTWFwLCBzbyB0aGF0IGUuZy4gZ2V0dGluZyB0aGUgb2JqZWN0J3MgLndpZHRoIHdpbGwgZ2l2ZSBpdHNcbiAqIC5oZWlnaHQgaW5zdGVhZC5cbiAqIENlcnRhaW4gbWV0aG9kcyBvZiBhbiBvcmllbnRlZCBvYmplY3Qgd2lsbCByZXR1cm4gb3JpZW50ZWQgb2JqZWN0cyBhcyB3ZWxsLlxuICogT3JpZW50ZWQgb2JqZWN0cyBjYW4ndCBiZSBhZGRlZCB0byB0aGUgRE9NIGRpcmVjdGx5IHNpbmNlIHRoZXkgYXJlIFByb3h5IG9iamVjdHNcbiAqIGFuZCB0aHVzIGZhaWwgdHlwZWNoZWNrcy4gVXNlIGRvbUVsZW1lbnQgdG8gZ2V0IHRoZSBhY3R1YWwgZWxlbWVudCBmb3IgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdG8gYmUgd3JhcHBlZCBhbmQgb3JpZW50ZWRcbiAqIEBwYXJhbSB7Ym9vbH0gdmVydGljYWwgV2hldGhlciB0aGUgZWxlbWVudCBpcyBvcmllbnRlZCB2ZXJ0aWNhbGx5XG4gKiBAcmV0dXJucyB7UHJveHl9IEFuIG9yaWVudGVkIG9iamVjdCB3aXRoIGF0dHIgdHJhbnNsYXRpb24gdmlhIHZlcnRpY2FsQXR0ck1hcFxuICogQHNpbmNlIDUuMC4wXG4gKi9cblxuZnVuY3Rpb24gd2l0aE9yaWVudGF0aW9uKHRhcmdldCwgdmVydGljYWwpIHtcbiAgaWYgKHRhcmdldFtpc1Byb3h5XSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG9iaiwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHByb3AgPT09IGlzUHJveHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnZG9tRWxlbWVudCcpIHtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aE9yaWVudGF0aW9uKG9iai5zdHlsZSwgdmVydGljYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhPcmllbnRhdGlvbihvYmouY2FudmFzLCB2ZXJ0aWNhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhPcmllbnRhdGlvbihvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmFwcGx5KG9iaiwgYXJndW1lbnRzKSwgdmVydGljYWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2dldENvbnRleHQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoT3JpZW50YXRpb24ob2JqLmdldENvbnRleHQuYXBwbHkob2JqLCBhcmd1bWVudHMpLCB2ZXJ0aWNhbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbWFwUHJvcChwcm9wLCB2ZXJ0aWNhbCldO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmJpbmQob2JqKSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBvYmpbbWFwUHJvcChwcm9wLCB2ZXJ0aWNhbCldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3ByZXZlbnQtY2xpY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvcHJldmVudC1jbGljay5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwcmV2ZW50Q2xpY2s7XG5cbi8qKlxuICogU3RvcHMgcHJvcGFnYXRpb24gb2YgY2xpY2sgZXZlbnQgYW5kIHJlbW92ZXMgZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBjbGljayBldmVudFxuICovXG5mdW5jdGlvbiBwcmV2ZW50Q2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcHJldmVudENsaWNrSGFuZGxlciwgdHJ1ZSk7XG59XG4vKipcbiAqIFN0YXJ0cyBsaXN0ZW5pbmcgZm9yIGNsaWNrIGV2ZW50IGFuZCBwcmV2ZW50IHByb3BhZ2F0aW9uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBWYWx1ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXZlbnRDbGljayh2YWx1ZXMpIHtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXZlbnRDbGlja0hhbmRsZXIsIHRydWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBmdW5jdGlvbiBmb3IgdGhlIGJyb3dzZXIsIG9yIGEgc2hpbSB3aXRoXG4gKiBgc2V0VGltZW91dGAgaWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBmb3VuZFxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBBdmFpbGFibGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgZnVuY3Rpb24gZm9yIHRoZSBicm93c2VyXG4gKi9cbnZhciBfZGVmYXVsdCA9ICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufSkuYmluZCh3aW5kb3cpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3N0eWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9zdHlsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gc3R5bGU7XG5cbi8qKlxuICogQXBwbHkgYSBtYXAgb2Ygc3R5bGVzIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0aGF0IHRoZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIFRoZSBtYXAgb2YgcHJvcE5hbWU6IGF0dHJpYnV0ZSwgYm90aCBhcmUgdXNlZCBhcy1pc1xuICpcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBlbFxuICovXG5mdW5jdGlvbiBzdHlsZShlbCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChlbC5zdHlsZVtwcm9wXSAhPT0gc3R5bGVzW3Byb3BdKSB7XG4gICAgICBlbC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy93YXZlc3VyZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvd2F2ZXN1cmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiKSk7XG5cbnZhciBfZHJhd2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RyYXdlci5tdWx0aWNhbnZhcyAqLyBcIi4vc3JjL2RyYXdlci5tdWx0aWNhbnZhcy5qc1wiKSk7XG5cbnZhciBfd2ViYXVkaW8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vd2ViYXVkaW8gKi8gXCIuL3NyYy93ZWJhdWRpby5qc1wiKSk7XG5cbnZhciBfbWVkaWFlbGVtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lZGlhZWxlbWVudCAqLyBcIi4vc3JjL21lZGlhZWxlbWVudC5qc1wiKSk7XG5cbnZhciBfcGVha2NhY2hlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BlYWtjYWNoZSAqLyBcIi4vc3JjL3BlYWtjYWNoZS5qc1wiKSk7XG5cbnZhciBfbWVkaWFlbGVtZW50V2ViYXVkaW8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVkaWFlbGVtZW50LXdlYmF1ZGlvICovIFwiLi9zcmMvbWVkaWFlbGVtZW50LXdlYmF1ZGlvLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qXG4gKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgYSBCU0QtMy1DbGF1c2UgTGljZW5zZS5cbiAqL1xuXG4vKiogQGV4dGVybmFsIHtIVE1MRWxlbWVudH0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50ICovXG5cbi8qKiBAZXh0ZXJuYWwge09mZmxpbmVBdWRpb0NvbnRleHR9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9PZmZsaW5lQXVkaW9Db250ZXh0ICovXG5cbi8qKiBAZXh0ZXJuYWwge0ZpbGV9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlICovXG5cbi8qKiBAZXh0ZXJuYWwge0Jsb2J9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iICovXG5cbi8qKiBAZXh0ZXJuYWwge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAqL1xuXG4vKiogQGV4dGVybmFsIHtNZWRpYVN0cmVhbUNvbnN0cmFpbnRzfSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1Db25zdHJhaW50cyAqL1xuXG4vKiogQGV4dGVybmFsIHtBdWRpb05vZGV9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXYXZlc3VyZmVyUGFyYW1zXG4gKiBAcHJvcGVydHkge0F1ZGlvQ29udGV4dH0gYXVkaW9Db250ZXh0PW51bGwgVXNlIHlvdXIgb3duIHByZXZpb3VzbHlcbiAqIGluaXRpYWxpemVkIEF1ZGlvQ29udGV4dCBvciBsZWF2ZSBibGFuay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhdWRpb1JhdGU9MSBTcGVlZCBhdCB3aGljaCB0byBwbGF5IGF1ZGlvLiBMb3dlciBudW1iZXIgaXNcbiAqIHNsb3dlci5cbiAqIEBwcm9wZXJ0eSB7U2NyaXB0UHJvY2Vzc29yTm9kZX0gYXVkaW9TY3JpcHRQcm9jZXNzb3I9bnVsbCBVc2UgeW91ciBvd24gcHJldmlvdXNseVxuICogaW5pdGlhbGl6ZWQgU2NyaXB0UHJvY2Vzc29yTm9kZSBvciBsZWF2ZSBibGFuay5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXV0b0NlbnRlcj10cnVlIElmIGEgc2Nyb2xsYmFyIGlzIHByZXNlbnQsIGNlbnRlciB0aGVcbiAqIHdhdmVmb3JtIG9uIGN1cnJlbnQgcHJvZ3Jlc3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhdXRvQ2VudGVyUmF0ZT01IElmIGF1dG9DZW50ZXIgaXMgYWN0aXZlLCByYXRlIGF0IHdoaWNoIHRoZVxuICogd2F2ZWZvcm0gaXMgY2VudGVyZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXV0b0NlbnRlckltbWVkaWF0ZWx5PWZhbHNlIElmIGF1dG9DZW50ZXIgaXMgYWN0aXZlLCBpbW1lZGlhdGVseVxuICogY2VudGVyIHdhdmVmb3JtIG9uIGN1cnJlbnQgcHJvZ3Jlc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZW5kPSdXZWJBdWRpbycgYCdXZWJBdWRpbyd8J01lZGlhRWxlbWVudCd8J01lZGlhRWxlbWVudFdlYkF1ZGlvJ2AgSW4gbW9zdCBjYXNlc1xuICogeW91IGRvbid0IGhhdmUgdG8gc2V0IHRoaXMgbWFudWFsbHkuIE1lZGlhRWxlbWVudCBpcyBhIGZhbGxiYWNrIGZvciB1bnN1cHBvcnRlZCBicm93c2Vycy5cbiAqIE1lZGlhRWxlbWVudFdlYkF1ZGlvIGFsbG93cyB0byB1c2UgV2ViQXVkaW8gQVBJIGFsc28gd2l0aCBiaWcgYXVkaW8gZmlsZXMsIGxvYWRpbmcgYXVkaW8gbGlrZSB3aXRoXG4gKiBNZWRpYUVsZW1lbnQgYmFja2VuZCAoSFRNTDUgYXVkaW8gdGFnKS4gWW91IGhhdmUgdG8gdXNlIHRoZSBzYW1lIG1ldGhvZHMgb2YgTWVkaWFFbGVtZW50IGJhY2tlbmQgZm9yIGxvYWRpbmcgYW5kXG4gKiBwbGF5YmFjaywgZ2l2aW5nIGFsc28gcGVha3MsIHNvIHRoZSBhdWRpbyBkYXRhIGFyZSBub3QgZGVjb2RlZC4gSW4gdGhpcyB3YXkgeW91IGNhbiB1c2UgV2ViQXVkaW8gZmVhdHVyZXMsIGxpa2UgZmlsdGVycyxcbiAqIGFsc28gd2l0aCBhdWRpbyB3aXRoIGJpZyBkdXJhdGlvbi4gRm9yIGV4YW1wbGU6XG4gKiBgIHdhdmVzdXJmZXIubG9hZCh1cmwgfCBIVE1MTWVkaWFFbGVtZW50LCBwZWFrcywgcHJlbG9hZCwgZHVyYXRpb24pO1xuICogICB3YXZlc3VyZmVyLnBsYXkoKTtcbiAqICAgd2F2ZXN1cmZlci5zZXRGaWx0ZXIoY3VzdG9tRmlsdGVyKTtcbiAqIGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3I9bnVsbCBDaGFuZ2UgYmFja2dyb3VuZCBjb2xvciBvZiB0aGVcbiAqIHdhdmVmb3JtIGNvbnRhaW5lci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYXJIZWlnaHQ9MSBUaGUgaGVpZ2h0IG9mIHRoZSB3YXZlIGJhcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmFyUmFkaXVzPTAgVGhlIHJhZGl1cyBvZiB0aGUgd2F2ZSBiYXJzLiBNYWtlcyBiYXJzIHJvdW5kZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYXJHYXA9bnVsbCBUaGUgb3B0aW9uYWwgc3BhY2luZyBiZXR3ZWVuIGJhcnMgb2YgdGhlIHdhdmUsXG4gKiBpZiBub3QgcHJvdmlkZWQgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGxlZ2FjeSBmb3JtYXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmFyV2lkdGg9bnVsbCBEcmF3IHRoZSB3YXZlZm9ybSB1c2luZyBiYXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJhck1pbkhlaWdodD1udWxsIElmIHNwZWNpZmllZCwgZHJhdyBhdCBsZWFzdCBhIGJhciBvZiB0aGlzIGhlaWdodCxcbiAqIGVsaW1pbmF0aW5nIHdhdmVmb3JtIGdhcHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2xvc2VBdWRpb0NvbnRleHQ9ZmFsc2UgQ2xvc2UgYW5kIG51bGxpZnkgYWxsIGF1ZGlvXG4gKiBjb250ZXh0cyB3aGVuIHRoZSBkZXN0cm95IG1ldGhvZCBpcyBjYWxsZWQuXG4gKiBAcHJvcGVydHkgeyFzdHJpbmd8SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBDU1Mgc2VsZWN0b3Igb3IgSFRNTCBlbGVtZW50IHdoZXJlXG4gKiB0aGUgd2F2ZWZvcm0gc2hvdWxkIGJlIGRyYXduLiBUaGlzIGlzIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJzb3JDb2xvcj0nIzMzMycgVGhlIGZpbGwgY29sb3Igb2YgdGhlIGN1cnNvciBpbmRpY2F0aW5nXG4gKiB0aGUgcGxheWhlYWQgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gY3Vyc29yV2lkdGg9MSBNZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge29iamVjdH0gZHJhd2luZ0NvbnRleHRBdHRyaWJ1dGVzPXtkZXN5bmNocm9uaXplZDogZmFsc2V9IERyYXdpbmcgY29udGV4dFxuICogYXR0cmlidXRlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbj1udWxsIE9wdGlvbmFsIGF1ZGlvIGxlbmd0aCBzbyBwcmUtcmVuZGVyZWQgcGVha3NcbiAqIGNhbiBiZSBkaXNwbGF5IGltbWVkaWF0ZWx5IGZvciBleGFtcGxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBmaWxsUGFyZW50PXRydWUgV2hldGhlciB0byBmaWxsIHRoZSBlbnRpcmUgY29udGFpbmVyIG9yXG4gKiBkcmF3IG9ubHkgYWNjb3JkaW5nIHRvIGBtaW5QeFBlclNlY2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZvcmNlRGVjb2RlPWZhbHNlIEZvcmNlIGRlY29kaW5nIG9mIGF1ZGlvIHVzaW5nIHdlYiBhdWRpb1xuICogd2hlbiB6b29taW5nIHRvIGdldCBhIG1vcmUgZGV0YWlsZWQgd2F2ZWZvcm0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0PTEyOCBUaGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybS4gTWVhc3VyZWQgaW5cbiAqIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlkZVNjcm9sbGJhcj1mYWxzZSBXaGV0aGVyIHRvIGhpZGUgdGhlIGhvcml6b250YWxcbiAqIHNjcm9sbGJhciB3aGVuIG9uZSB3b3VsZCBub3JtYWxseSBiZSBzaG93bi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW50ZXJhY3Q9dHJ1ZSBXaGV0aGVyIHRoZSBtb3VzZSBpbnRlcmFjdGlvbiB3aWxsIGJlXG4gKiBlbmFibGVkIGF0IGluaXRpYWxpemF0aW9uLiBZb3UgY2FuIHN3aXRjaCB0aGlzIHBhcmFtZXRlciBhdCBhbnkgdGltZSBsYXRlclxuICogb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGxvb3BTZWxlY3Rpb249dHJ1ZSAoVXNlIHdpdGggcmVnaW9ucyBwbHVnaW4pIEVuYWJsZVxuICogbG9vcGluZyBvZiBzZWxlY3RlZCByZWdpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4Q2FudmFzV2lkdGg9NDAwMCBNYXhpbXVtIHdpZHRoIG9mIGEgc2luZ2xlIGNhbnZhcyBpblxuICogcGl4ZWxzLCBleGNsdWRpbmcgYSBzbWFsbCBvdmVybGFwICgyICogYHBpeGVsUmF0aW9gLCByb3VuZGVkIHVwIHRvIHRoZSBuZXh0XG4gKiBldmVuIGludGVnZXIpLiBJZiB0aGUgd2F2ZWZvcm0gaXMgbG9uZ2VyIHRoYW4gdGhpcyB2YWx1ZSwgYWRkaXRpb25hbCBjYW52YXNlc1xuICogd2lsbCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgd2F2ZWZvcm0sIHdoaWNoIGlzIHVzZWZ1bCBmb3IgdmVyeSBsYXJnZSB3YXZlZm9ybXNcbiAqIHRoYXQgbWF5IGJlIHRvbyB3aWRlIGZvciBicm93c2VycyB0byBkcmF3IG9uIGEgc2luZ2xlIGNhbnZhcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWVkaWFDb250cm9scz1mYWxzZSAoVXNlIHdpdGggYmFja2VuZCBgTWVkaWFFbGVtZW50YCBvciBgTWVkaWFFbGVtZW50V2ViQXVkaW9gKVxuICogdGhpcyBlbmFibGVzIHRoZSBuYXRpdmUgY29udHJvbHMgZm9yIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVkaWFUeXBlPSdhdWRpbycgKFVzZSB3aXRoIGJhY2tlbmQgYE1lZGlhRWxlbWVudGAgb3IgYE1lZGlhRWxlbWVudFdlYkF1ZGlvYClcbiAqIGAnYXVkaW8nfCd2aWRlbydgICgndmlkZW8nIG9ubHkgZm9yIGBNZWRpYUVsZW1lbnRgKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblB4UGVyU2VjPTIwIE1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBwZXIgc2Vjb25kIG9mXG4gKiBhdWRpby5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9ybWFsaXplPWZhbHNlIElmIHRydWUsIG5vcm1hbGl6ZSBieSB0aGUgbWF4aW11bSBwZWFrXG4gKiBpbnN0ZWFkIG9mIDEuMC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFydGlhbFJlbmRlcj1mYWxzZSBVc2UgdGhlIFBlYWtDYWNoZSB0byBpbXByb3ZlXG4gKiByZW5kZXJpbmcgc3BlZWQgb2YgbGFyZ2Ugd2F2ZWZvcm1zXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbz13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBUaGUgcGl4ZWwgcmF0aW8gdXNlZCB0b1xuICogY2FsY3VsYXRlIGRpc3BsYXlcbiAqIEBwcm9wZXJ0eSB7UGx1Z2luRGVmaW5pdGlvbltdfSBwbHVnaW5zPVtdIEFuIGFycmF5IG9mIHBsdWdpbiBkZWZpbml0aW9ucyB0b1xuICogcmVnaXN0ZXIgZHVyaW5nIGluc3RhbnRpYXRpb24sIHRoZXkgd2lsbCBiZSBkaXJlY3RseSBpbml0aWFsaXNlZCB1bmxlc3MgdGhleVxuICogYXJlIGFkZGVkIHdpdGggdGhlIGBkZWZlckluaXRgIHByb3BlcnR5IHNldCB0byB0cnVlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb2dyZXNzQ29sb3I9JyM1NTUnIFRoZSBmaWxsIGNvbG9yIG9mIHRoZSBwYXJ0IG9mIHRoZVxuICogd2F2ZWZvcm0gYmVoaW5kIHRoZSBjdXJzb3IuIFdoZW4gYHByb2dyZXNzQ29sb3JgIGFuZCBgd2F2ZUNvbG9yYCBhcmUgdGhlIHNhbWVcbiAqIHRoZSBwcm9ncmVzcyB3YXZlIGlzIG5vdCByZW5kZXJlZCBhdCBhbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveT10cnVlIFNldCB0byBmYWxzZSB0byBrZWVwIHRoZVxuICogbWVkaWEgZWxlbWVudCBpbiB0aGUgRE9NIHdoZW4gdGhlIHBsYXllciBpcyBkZXN0cm95ZWQuIFRoaXMgaXMgdXNlZnVsIHdoZW5cbiAqIHJldXNpbmcgYW4gZXhpc3RpbmcgbWVkaWEgZWxlbWVudCB2aWEgdGhlIGBsb2FkTWVkaWFFbGVtZW50YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge09iamVjdH0gcmVuZGVyZXI9TXVsdGlDYW52YXMgQ2FuIGJlIHVzZWQgdG8gaW5qZWN0IGEgY3VzdG9tXG4gKiByZW5kZXJlci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxudW1iZXJ9IHJlc3BvbnNpdmU9ZmFsc2UgSWYgc2V0IHRvIGB0cnVlYCByZXNpemUgdGhlXG4gKiB3YXZlZm9ybSwgd2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWQuIFRoaXMgaXMgZGVib3VuY2VkIHdpdGggYSBgMTAwbXNgXG4gKiB0aW1lb3V0IGJ5IGRlZmF1bHQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIGl0IHJlcHJlc2VudHMgdGhhdCB0aW1lb3V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBydGw9ZmFsc2UgSWYgc2V0IHRvIGB0cnVlYCwgcmVuZGVycyB3YXZlZm9ybSBmcm9tXG4gKiByaWdodC10by1sZWZ0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBzY3JvbGxQYXJlbnQ9ZmFsc2UgV2hldGhlciB0byBzY3JvbGwgdGhlIGNvbnRhaW5lciB3aXRoIGFcbiAqIGxlbmd0aHkgd2F2ZWZvcm0uIE90aGVyd2lzZSB0aGUgd2F2ZWZvcm0gaXMgc2hydW5rIHRvIHRoZSBjb250YWluZXIgd2lkdGhcbiAqIChzZWUgZmlsbFBhcmVudCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2tpcExlbmd0aD0yIE51bWJlciBvZiBzZWNvbmRzIHRvIHNraXAgd2l0aCB0aGVcbiAqIHNraXBGb3J3YXJkKCkgYW5kIHNraXBCYWNrd2FyZCgpIG1ldGhvZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNwbGl0Q2hhbm5lbHM9ZmFsc2UgUmVuZGVyIHdpdGggc2VwYXJhdGUgd2F2ZWZvcm1zIGZvclxuICogdGhlIGNoYW5uZWxzIG9mIHRoZSBhdWRpb1xuICogQHByb3BlcnR5IHtTcGxpdENoYW5uZWxPcHRpb25zfSBzcGxpdENoYW5uZWxzT3B0aW9ucz17fSBPcHRpb25zIGZvciBzcGxpdENoYW5uZWwgcmVuZGVyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZlcnRpY2FsPWZhbHNlIFJlbmRlciB0aGUgd2F2ZWZvcm0gdmVydGljYWxseSBpbnN0ZWFkIG9mIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB3YXZlQ29sb3I9JyM5OTknIFRoZSBmaWxsIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBhZnRlciB0aGVcbiAqIGN1cnNvci5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB4aHI9e30gWEhSIG9wdGlvbnMuIEZvciBleGFtcGxlOlxuICogYGxldCB4aHIgPSB7XG4gKiAgICAgY2FjaGU6ICdkZWZhdWx0JyxcbiAqICAgICBtb2RlOiAnY29ycycsXG4gKiAgICAgbWV0aG9kOiAnR0VUJyxcbiAqICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAqICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gKiAgICAgcmVmZXJyZXI6ICdjbGllbnQnLFxuICogICAgIHJlcXVlc3RIZWFkZXJzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICAgIGtleTogJ0F1dGhvcml6YXRpb24nLFxuICogICAgICAgICAgICAgdmFsdWU6ICdteS10b2tlbidcbiAqICAgICAgICAgfVxuICogICAgIF1cbiAqIH07YFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGx1Z2luRGVmaW5pdGlvblxuICogQGRlc2MgVGhlIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGEgcGx1Z2luXG4gKiBAZXhhbXBsZSB3YXZlc3VyZmVyLmFkZFBsdWdpbihwbHVnaW5EZWZpbml0aW9uKTtcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHRoZSBwbHVnaW4gaW5zdGFuY2Ugd2lsbCBiZVxuICogYWRkZWQgYXMgYSBwcm9wZXJ0eSB0byB0aGUgd2F2ZXN1cmZlciBpbnN0YW5jZSB1bmRlciB0aGlzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P09iamVjdH0gc3RhdGljUHJvcHMgVGhlIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlXG4gKiB3YXZlc3VyZmVyIGluc3RhbmNlIGFzIHN0YXRpYyBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZWZlckluaXQgRG9uJ3QgaW5pdGlhbGlzZSBwbHVnaW5cbiAqIGF1dG9tYXRpY2FsbHlcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXJhbXM9e30gVGhlIHBsdWdpbiBwYXJhbWV0ZXJzLCB0aGV5IGFyZSB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gKiBwYXNzZWQgdG8gdGhlIHBsdWdpbiBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICogQHByb3BlcnR5IHtQbHVnaW5DbGFzc30gaW5zdGFuY2UgVGhlIHBsdWdpbiBpbnN0YW5jZSBmYWN0b3J5LCBpcyBjYWxsZWQgd2l0aFxuICogdGhlIGRlcGVuZGVuY3kgc3BlY2lmaWVkIGluIGV4dGVuZHMuIFJldHVybnMgdGhlIHBsdWdpbiBjbGFzcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNwbGl0Q2hhbm5lbE9wdGlvbnNcbiAqIEBkZXNjIHBhcmFtZXRlcnMgYXBwbGllZCB3aGVuIHNwbGl0Q2hhbm5lbHMgb3B0aW9uIGlzIHRydWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3ZlcmxheT1mYWxzZSBkZXRlcm1pbmVzIHdoZXRoZXIgY2hhbm5lbHMgYXJlIHJlbmRlcmVkIG9uIHRvcCBvZiBlYWNoIG90aGVyIG9yIG9uIHNlcGFyYXRlIHRyYWNrc1xuICogQHByb3BlcnR5IHtvYmplY3R9IGNoYW5uZWxDb2xvcnM9e30gb2JqZWN0IGRlc2NyaWJpbmcgY29sb3IgZm9yIGVhY2ggY2hhbm5lbC4gRXhhbXBsZTpcbiAqIHtcbiAqICAgICAwOiB7XG4gKiAgICAgICAgIHByb2dyZXNzQ29sb3I6ICdncmVlbicsXG4gKiAgICAgICAgIHdhdmVDb2xvcjogJ3BpbmsnXG4gKiAgICAgfSxcbiAqICAgICAxOiB7XG4gKiAgICAgICAgIHByb2dyZXNzQ29sb3I6ICdvcmFuZ2UnLFxuICogICAgICAgICB3YXZlQ29sb3I6ICdwdXJwbGUnXG4gKiAgICAgfVxuICogfVxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gZmlsdGVyQ2hhbm5lbHM9W10gaW5kZXhlcyBvZiBjaGFubmVscyB0byBiZSBoaWRkZW4gZnJvbSByZW5kZXJpbmdcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVsYXRpdmVOb3JtYWxpemF0aW9uPWZhbHNlIGRldGVybWluZXMgd2hldGhlclxuICogbm9ybWFsaXphdGlvbiBpcyBkb25lIHBlciBjaGFubmVsIG9yIG1haW50YWlucyBwcm9wb3J0aW9uYWxpdHkgYmV0d2VlblxuICogY2hhbm5lbHMuIE9ubHkgYXBwbGllZCB3aGVuIG5vcm1hbGl6ZSBhbmQgc3BsaXRDaGFubmVscyBhcmUgYm90aCB0cnVlLlxuICogQHNpbmNlIDQuMy4wXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlIFBsdWdpbkNsYXNzXG4gKlxuICogQGRlc2MgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHdoaWNoIGlzIGltcGxlbWVudGVkIGJ5IGFsbCBwbHVnaW4gY2xhc3Nlcy4gTm90ZVxuICogdGhhdCB0aGlzIG9ubHkgdHVybnMgaW50byBhbiBvYnNlcnZlciBhZnRlciBiZWluZyBwYXNzZWQgdGhyb3VnaFxuICogYHdhdmVzdXJmZXIuYWRkUGx1Z2luYC5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cbnZhciBQbHVnaW5DbGFzcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIHBsdWdpblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zPXt9IFRoZSBwbHVnaW4gcGFyYW1zIChzcGVjaWZpYyB0byB0aGUgcGx1Z2luKVxuICAgKiBAcGFyYW0ge09iamVjdH0gd3MgVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBsdWdpbkNsYXNzKHBhcmFtcywgd3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luQ2xhc3MpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBwbHVnaW5cbiAgICpcbiAgICogU3RhcnQgZG9pbmcgc29tZXRoaW5nLiBUaGlzIGlzIGNhbGxlZCBieVxuICAgKiBgd2F2ZXN1cmZlci5pbml0UGx1Z2luKHBsdWdpbk5hbWUpYFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQbHVnaW5DbGFzcywgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUGx1Z2luIGRlZmluaXRpb24gZmFjdG9yeVxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gY3JlYXRlIGEgcGx1Z2luIGRlZmluaXRpb24gd2hpY2ggY2FuIGJlXG4gICAgICogdXNlZCBieSB3YXZlc3VyZmVyIHRvIGNvcnJlY3RseSBpbnN0YW50aWF0ZSB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIGBQbHVnaW5EZWZpbml0aW9uYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zPXt9IFRoZSBwbHVnaW4gcGFyYW1zIChzcGVjaWZpYyB0byB0aGUgcGx1Z2luKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwYXJhbXMpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge31cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBwbHVnaW4gaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIFN0b3AgZG9pbmcgc29tZXRoaW5nLiBUaGlzIGlzIGNhbGxlZCBieVxuICAgICAqIGB3YXZlc3VyZmVyLmRlc3Ryb3lQbHVnaW4ocGx1Z2luTmFtZSlgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsdWdpbkNsYXNzO1xufSgpO1xuLyoqXG4gKiBXYXZlU3VyZmVyIGNvcmUgbGlicmFyeSBjbGFzc1xuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJhbXMgPSB7XG4gKiAgIGNvbnRhaW5lcjogJyN3YXZlZm9ybScsXG4gKiAgIHdhdmVDb2xvcjogJ3Zpb2xldCcsXG4gKiAgIHByb2dyZXNzQ29sb3I6ICdwdXJwbGUnXG4gKiB9O1xuICpcbiAqIC8vIGluaXRpYWxpc2UgbGlrZSB0aGlzXG4gKiBjb25zdCB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUocGFyYW1zKTtcbiAqXG4gKiAvLyBvciBsaWtlIHRoaXMgLi4uXG4gKiBjb25zdCB3YXZlc3VyZmVyID0gbmV3IFdhdmVTdXJmZXIocGFyYW1zKTtcbiAqIHdhdmVzdXJmZXIuaW5pdCgpO1xuICpcbiAqIC8vIGxvYWQgYXVkaW8gZmlsZVxuICogd2F2ZXN1cmZlci5sb2FkKCdleGFtcGxlL21lZGlhL2RlbW8ud2F2Jyk7XG4gKi9cblxuXG52YXIgV2F2ZVN1cmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3V0aWwkT2JzZXJ2ZXIpIHtcbiAgX2luaGVyaXRzKFdhdmVTdXJmZXIsIF91dGlsJE9ic2VydmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdhdmVTdXJmZXIpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgSW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciB3YXZlc3VyZmVyXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHdhdmVzdXJmZXIgPSBuZXcgV2F2ZVN1cmZlcihwYXJhbXMpO1xuICAgKiBAcmV0dXJucyB7dGhpc30gV2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gV2F2ZVN1cmZlcihwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2F2ZVN1cmZlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgcmVsZXZhbnQgcGFyYW1ldGVycyAob3IgZGVmYXVsdHMpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIF90aGlzLmRlZmF1bHRQYXJhbXMgPSB7XG4gICAgICBhdWRpb0NvbnRleHQ6IG51bGwsXG4gICAgICBhdWRpb1NjcmlwdFByb2Nlc3NvcjogbnVsbCxcbiAgICAgIGF1ZGlvUmF0ZTogMSxcbiAgICAgIGF1dG9DZW50ZXI6IHRydWUsXG4gICAgICBhdXRvQ2VudGVyUmF0ZTogNSxcbiAgICAgIGF1dG9DZW50ZXJJbW1lZGlhdGVseTogZmFsc2UsXG4gICAgICBiYWNrZW5kOiAnV2ViQXVkaW8nLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICAgICAgYmFySGVpZ2h0OiAxLFxuICAgICAgYmFyUmFkaXVzOiAwLFxuICAgICAgYmFyR2FwOiBudWxsLFxuICAgICAgYmFyTWluSGVpZ2h0OiBudWxsLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgY3Vyc29yQ29sb3I6ICcjMzMzJyxcbiAgICAgIGN1cnNvcldpZHRoOiAxLFxuICAgICAgZHJhZ1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGRyYXdpbmdDb250ZXh0QXR0cmlidXRlczoge1xuICAgICAgICAvLyBCb29sZWFuIHRoYXQgaGludHMgdGhlIHVzZXIgYWdlbnQgdG8gcmVkdWNlIHRoZSBsYXRlbmN5XG4gICAgICAgIC8vIGJ5IGRlc3luY2hyb25pemluZyB0aGUgY2FudmFzIHBhaW50IGN5Y2xlIGZyb20gdGhlIGV2ZW50XG4gICAgICAgIC8vIGxvb3BcbiAgICAgICAgZGVzeW5jaHJvbml6ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZHVyYXRpb246IG51bGwsXG4gICAgICBmaWxsUGFyZW50OiB0cnVlLFxuICAgICAgZm9yY2VEZWNvZGU6IGZhbHNlLFxuICAgICAgaGVpZ2h0OiAxMjgsXG4gICAgICBoaWRlU2Nyb2xsYmFyOiBmYWxzZSxcbiAgICAgIGludGVyYWN0OiB0cnVlLFxuICAgICAgbG9vcFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIG1heENhbnZhc1dpZHRoOiA0MDAwLFxuICAgICAgbWVkaWFDb250YWluZXI6IG51bGwsXG4gICAgICBtZWRpYUNvbnRyb2xzOiBmYWxzZSxcbiAgICAgIG1lZGlhVHlwZTogJ2F1ZGlvJyxcbiAgICAgIG1pblB4UGVyU2VjOiAyMCxcbiAgICAgIG5vcm1hbGl6ZTogZmFsc2UsXG4gICAgICBwYXJ0aWFsUmVuZGVyOiBmYWxzZSxcbiAgICAgIHBpeGVsUmF0aW86IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IHNjcmVlbi5kZXZpY2VYRFBJIC8gc2NyZWVuLmxvZ2ljYWxYRFBJLFxuICAgICAgcGx1Z2luczogW10sXG4gICAgICBwcm9ncmVzc0NvbG9yOiAnIzU1NScsXG4gICAgICByZW1vdmVNZWRpYUVsZW1lbnRPbkRlc3Ryb3k6IHRydWUsXG4gICAgICByZW5kZXJlcjogX2RyYXdlci5kZWZhdWx0LFxuICAgICAgcmVzcG9uc2l2ZTogZmFsc2UsXG4gICAgICBydGw6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50OiBmYWxzZSxcbiAgICAgIHNraXBMZW5ndGg6IDIsXG4gICAgICBzcGxpdENoYW5uZWxzOiBmYWxzZSxcbiAgICAgIHNwbGl0Q2hhbm5lbHNPcHRpb25zOiB7XG4gICAgICAgIG92ZXJsYXk6IGZhbHNlLFxuICAgICAgICBjaGFubmVsQ29sb3JzOiB7fSxcbiAgICAgICAgZmlsdGVyQ2hhbm5lbHM6IFtdLFxuICAgICAgICByZWxhdGl2ZU5vcm1hbGl6YXRpb246IGZhbHNlXG4gICAgICB9LFxuICAgICAgdmVydGljYWw6IGZhbHNlLFxuICAgICAgd2F2ZUNvbG9yOiAnIzk5OScsXG4gICAgICB4aHI6IHt9XG4gICAgfTtcbiAgICBfdGhpcy5iYWNrZW5kcyA9IHtcbiAgICAgIE1lZGlhRWxlbWVudDogX21lZGlhZWxlbWVudC5kZWZhdWx0LFxuICAgICAgV2ViQXVkaW86IF93ZWJhdWRpby5kZWZhdWx0LFxuICAgICAgTWVkaWFFbGVtZW50V2ViQXVkaW86IF9tZWRpYWVsZW1lbnRXZWJhdWRpby5kZWZhdWx0XG4gICAgfTtcbiAgICBfdGhpcy51dGlsID0gdXRpbDtcbiAgICBfdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpcy5kZWZhdWx0UGFyYW1zLCBwYXJhbXMpO1xuICAgIF90aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF90aGlzLmRlZmF1bHRQYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMsIHBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucyk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5jb250YWluZXIgPSAnc3RyaW5nJyA9PSB0eXBlb2YgcGFyYW1zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMucGFyYW1zLmNvbnRhaW5lcikgOiBfdGhpcy5wYXJhbXMuY29udGFpbmVyO1xuXG4gICAgaWYgKCFfdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLnBhcmFtcy5tZWRpYUNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF90aGlzLm1lZGlhQ29udGFpbmVyID0gX3RoaXMuY29udGFpbmVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzLnBhcmFtcy5tZWRpYUNvbnRhaW5lciA9PSAnc3RyaW5nJykge1xuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfdGhpcy5tZWRpYUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMucGFyYW1zLm1lZGlhQ29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfdGhpcy5tZWRpYUNvbnRhaW5lciA9IF90aGlzLnBhcmFtcy5tZWRpYUNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLm1lZGlhQ29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhIENvbnRhaW5lciBlbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5wYXJhbXMubWF4Q2FudmFzV2lkdGggPD0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhDYW52YXNXaWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgfSBlbHNlIGlmIChfdGhpcy5wYXJhbXMubWF4Q2FudmFzV2lkdGggJSAyID09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWF4Q2FudmFzV2lkdGggbXVzdCBiZSBhbiBldmVuIG51bWJlcicpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5wYXJhbXMucnRsID09PSB0cnVlKSB7XG4gICAgICBpZiAoX3RoaXMucGFyYW1zLnZlcnRpY2FsID09PSB0cnVlKSB7XG4gICAgICAgIHV0aWwuc3R5bGUoX3RoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlWCgxODBkZWcpJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuc3R5bGUoX3RoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlWSgxODBkZWcpJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3RoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgX3RoaXMuc2V0QmFja2dyb3VuZENvbG9yKF90aGlzLnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBVc2VkIHRvIHNhdmUgdGhlIGN1cnJlbnQgdm9sdW1lIHdoZW4gbXV0aW5nIHNvIHdlIGNhblxuICAgICAqIHJlc3RvcmUgb25jZSB1bm11dGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX3RoaXMuc2F2ZWRWb2x1bWUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIFRoZSBjdXJyZW50IG11dGVkIHN0YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBfdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgV2lsbCBob2xkIGEgbGlzdCBvZiBldmVudCBkZXNjcmlwdG9ycyB0aGF0IG5lZWQgdG8gYmVcbiAgICAgKiBjYW5jZWxlZCBvbiBzdWJzZXF1ZW50IGxvYWRzIG9mIGF1ZGlvXG4gICAgICogQHR5cGUge09iamVjdFtdfVxuICAgICAqL1xuXG4gICAgX3RoaXMudG1wRXZlbnRzID0gW107XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgSG9sZHMgYW55IHJ1bm5pbmcgYXVkaW8gZG93bmxvYWRzXG4gICAgICogQHR5cGUge09ic2VydmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMuY3VycmVudFJlcXVlc3QgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuYXJyYXlidWZmZXIgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuZHJhd2VyID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmJhY2tlbmQgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGVha0NhY2hlID0gbnVsbDsgLy8gY2FjaGUgY29uc3RydWN0b3Igb2JqZWN0c1xuXG4gICAgaWYgKHR5cGVvZiBfdGhpcy5wYXJhbXMucmVuZGVyZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZXIgcGFyYW1ldGVyIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgVGhlIHVuaW5pdGlhbGlzZWQgRHJhd2VyIGNsYXNzXG4gICAgICovXG5cblxuICAgIF90aGlzLkRyYXdlciA9IF90aGlzLnBhcmFtcy5yZW5kZXJlcjtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBUaGUgdW5pbml0aWFsaXNlZCBCYWNrZW5kIGNsYXNzXG4gICAgICovXG4gICAgLy8gQmFjayBjb21wYXRcblxuICAgIGlmIChfdGhpcy5wYXJhbXMuYmFja2VuZCA9PSAnQXVkaW9FbGVtZW50Jykge1xuICAgICAgX3RoaXMucGFyYW1zLmJhY2tlbmQgPSAnTWVkaWFFbGVtZW50JztcbiAgICB9XG5cbiAgICBpZiAoKF90aGlzLnBhcmFtcy5iYWNrZW5kID09ICdXZWJBdWRpbycgfHwgX3RoaXMucGFyYW1zLmJhY2tlbmQgPT09ICdNZWRpYUVsZW1lbnRXZWJBdWRpbycpICYmICFfd2ViYXVkaW8uZGVmYXVsdC5wcm90b3R5cGUuc3VwcG9ydHNXZWJBdWRpby5jYWxsKG51bGwpKSB7XG4gICAgICBfdGhpcy5wYXJhbXMuYmFja2VuZCA9ICdNZWRpYUVsZW1lbnQnO1xuICAgIH1cblxuICAgIF90aGlzLkJhY2tlbmQgPSBfdGhpcy5iYWNrZW5kc1tfdGhpcy5wYXJhbXMuYmFja2VuZF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgbWFwIG9mIHBsdWdpbiBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgaW5pdGlhbGlzZWRcbiAgICAgKi9cblxuICAgIF90aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdCA9IHt9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcmVhZHkgc3RhdHVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY29uc3QgaXNSZWFkeSA9IHdhdmVzdXJmZXIuaXNSZWFkeTtcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgX3RoaXMuaXNSZWFkeSA9IGZhbHNlOyAvLyByZXNwb25zaXZlIGRlYm91bmNlZCBldmVudCBsaXN0ZW5lci4gSWYgdGhpcy5wYXJhbXMucmVzcG9uc2l2ZSBpcyBub3RcbiAgICAvLyBzZXQsIHRoaXMgaXMgbmV2ZXIgY2FsbGVkLiBVc2UgMTAwbXMgb3IgdGhpcy5wYXJhbXMucmVzcG9uc2l2ZSBhc1xuICAgIC8vIHRpbWVvdXQgZm9yIHRoZSBkZWJvdW5jZSBmdW5jdGlvbi5cblxuICAgIHZhciBwcmV2V2lkdGggPSAwO1xuICAgIF90aGlzLl9vblJlc2l6ZSA9IHV0aWwuZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByZXZXaWR0aCAhPSBfdGhpcy5kcmF3ZXIud3JhcHBlci5jbGllbnRXaWR0aCAmJiAhX3RoaXMucGFyYW1zLnNjcm9sbFBhcmVudCkge1xuICAgICAgICBwcmV2V2lkdGggPSBfdGhpcy5kcmF3ZXIud3JhcHBlci5jbGllbnRXaWR0aDtcblxuICAgICAgICBfdGhpcy5kcmF3ZXIuZmlyZUV2ZW50KCdyZWRyYXcnKTtcbiAgICAgIH1cbiAgICB9LCB0eXBlb2YgX3RoaXMucGFyYW1zLnJlc3BvbnNpdmUgPT09ICdudW1iZXInID8gX3RoaXMucGFyYW1zLnJlc3BvbnNpdmUgOiAxMDApO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSB3YXZlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB3YXZlc3VyZmVyID0gbmV3IFdhdmVTdXJmZXIocGFyYW1zKTtcbiAgICogd2F2ZXN1cmZlci5pbml0KCk7XG4gICAqIEByZXR1cm4ge3RoaXN9IFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFdhdmVTdXJmZXIsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zKHRoaXMucGFyYW1zLnBsdWdpbnMpO1xuICAgICAgdGhpcy5jcmVhdGVEcmF3ZXIoKTtcbiAgICAgIHRoaXMuY3JlYXRlQmFja2VuZCgpO1xuICAgICAgdGhpcy5jcmVhdGVQZWFrQ2FjaGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW5kIGluaXRpYWxpc2UgYXJyYXkgb2YgcGx1Z2lucyAoaWYgYHBsdWdpbi5kZWZlckluaXRgIGlzIGZhbHNleSksXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4gdGhlIGluaXQgZnVuY3Rpb24gb2Ygd2F2ZXN1cmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9uW119IHBsdWdpbnMgQW4gYXJyYXkgb2YgcGx1Z2luIGRlZmluaXRpb25zXG4gICAgICogQGVtaXRzIHtXYXZlU3VyZmVyI3BsdWdpbnMtcmVnaXN0ZXJlZH0gQ2FsbGVkIHdpdGggdGhlIGFycmF5IG9mIHBsdWdpbiBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm4ge3RoaXN9IFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlclBsdWdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBmaXJzdCBpbnN0YW50aWF0ZSBhbGwgdGhlIHBsdWdpbnNcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuYWRkUGx1Z2luKHBsdWdpbik7XG4gICAgICB9KTsgLy8gbm93IHJ1biB0aGUgaW5pdCBmdW5jdGlvbnNcblxuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgLy8gY2FsbCBpbml0IGZ1bmN0aW9uIG9mIHRoZSBwbHVnaW4gaWYgZGVmZXJJbml0IGlzIGZhbHNleVxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgeW91IHdvdWxkIG1hbnVhbGx5IHVzZSBpbml0UGx1Z2lucygpXG4gICAgICAgIGlmICghcGx1Z2luLmRlZmVySW5pdCkge1xuICAgICAgICAgIF90aGlzMi5pbml0UGx1Z2luKHBsdWdpbi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGx1Z2lucy1yZWdpc3RlcmVkJywgcGx1Z2lucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbWFwIG9mIHBsdWdpbiBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgaW5pdGlhbGlzZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuZ2V0UGx1Z2lucygpO1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggcGx1Z2luIG5hbWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBY3RpdmVQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZVBsdWdpbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHBsdWdpbiBvYmplY3QgdG8gd2F2ZXN1cmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBwbHVnaW4gQSBwbHVnaW4gZGVmaW5pdGlvblxuICAgICAqIEBlbWl0cyB7V2F2ZVN1cmZlciNwbHVnaW4tYWRkZWR9IENhbGxlZCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdGhhdCB3YXMgYWRkZWRcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLmFkZFBsdWdpbihXYXZlU3VyZmVyLm1pbmltYXAoKSk7XG4gICAgICogQHJldHVybiB7dGhpc30gVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFBsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKCFwbHVnaW4ubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiBkb2VzIG5vdCBoYXZlIGEgbmFtZSEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwbHVnaW4uaW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChwbHVnaW4ubmFtZSwgXCIgZG9lcyBub3QgaGF2ZSBhbiBpbnN0YW5jZSBwcm9wZXJ0eSFcIikpO1xuICAgICAgfSAvLyBzdGF0aWNQcm9wcyBwcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIHdhdmVzdXJmZXIgaW5zdGFuY2VcblxuXG4gICAgICBpZiAocGx1Z2luLnN0YXRpY1Byb3BzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHBsdWdpbi5zdGF0aWNQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luU3RhdGljUHJvcCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFByb3BlcnRpZXMgZGVmaW5lZCBpbiBhIHBsdWdpbiBkZWZpbml0aW9uJ3MgYHN0YXRpY1Byb3BzYCBwcm9wZXJ0eSBhcmUgYWRkZWQgYXNcbiAgICAgICAgICAgKiBzdGF0aWNQcm9wcyBwcm9wZXJ0aWVzIG9mIHRoZSBXYXZlU3VyZmVyIGluc3RhbmNlXG4gICAgICAgICAgICovXG4gICAgICAgICAgX3RoaXMzW3BsdWdpblN0YXRpY1Byb3BdID0gcGx1Z2luLnN0YXRpY1Byb3BzW3BsdWdpblN0YXRpY1Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIEluc3RhbmNlID0gcGx1Z2luLmluc3RhbmNlOyAvLyB0dXJuIHRoZSBwbHVnaW4gaW5zdGFuY2UgaW50byBhbiBvYnNlcnZlclxuXG4gICAgICB2YXIgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModXRpbC5PYnNlcnZlci5wcm90b3R5cGUpO1xuICAgICAgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBJbnN0YW5jZS5wcm90b3R5cGVba2V5XSA9IHV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlW2tleV07XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogSW5zdGFudGlhdGVkIHBsdWdpbiBjbGFzc2VzIGFyZSBhZGRlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSB3YXZlc3VyZmVyXG4gICAgICAgKiBpbnN0YW5jZVxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuXG4gICAgICB0aGlzW3BsdWdpbi5uYW1lXSA9IG5ldyBJbnN0YW5jZShwbHVnaW4ucGFyYW1zIHx8IHt9LCB0aGlzKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbHVnaW4tYWRkZWQnLCBwbHVnaW4ubmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBhIHBsdWdpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBwbHVnaW4gbmFtZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3BsdWdpbi1pbml0aWFsaXNlZFxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuaW5pdFBsdWdpbignbWluaW1hcCcpO1xuICAgICAqIEByZXR1cm4ge3RoaXN9IFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGx1Z2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQbHVnaW4obmFtZSkge1xuICAgICAgaWYgKCF0aGlzW25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQobmFtZSwgXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHlldCFcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbbmFtZV0pIHtcbiAgICAgICAgLy8gZGVzdHJveSBhbnkgYWxyZWFkeSBpbml0aWFsaXNlZCBwbHVnaW5zXG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpbihuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tuYW1lXS5pbml0KCk7XG4gICAgICB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtuYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGx1Z2luLWluaXRpYWxpc2VkJywgbmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhIHBsdWdpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBwbHVnaW4gbmFtZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3BsdWdpbi1kZXN0cm95ZWRcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLmRlc3Ryb3lQbHVnaW4oJ21pbmltYXAnKTtcbiAgICAgKiBAcmV0dXJucyB7dGhpc30gVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lQbHVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveVBsdWdpbihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChuYW1lLCBcIiBoYXMgbm90IGJlZW4gYWRkZWQgeWV0IGFuZCBjYW5ub3QgYmUgZGVzdHJveWVkIVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChuYW1lLCBcIiBpcyBub3QgYWN0aXZlIGFuZCBjYW5ub3QgYmUgZGVzdHJveWVkIVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lXS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQobmFtZSwgXCIgZG9lcyBub3QgaGF2ZSBhIGRlc3Ryb3kgZnVuY3Rpb24hXCIpKTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tuYW1lXS5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbbmFtZV07XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGx1Z2luLWRlc3Ryb3llZCcsIG5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYWxsIGluaXRpYWxpc2VkIHBsdWdpbnMuIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXG4gICAgICogd2F2ZXN1cmZlciBpcyByZW1vdmVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveUFsbFBsdWdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveUFsbFBsdWdpbnMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5kZXN0cm95UGx1Z2luKG5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZHJhd2VyIGFuZCBkcmF3IHRoZSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNkcmF3ZXItY3JlYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlRHJhd2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURyYXdlcigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRyYXdlciA9IG5ldyB0aGlzLkRyYXdlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5wYXJhbXMpO1xuICAgICAgdGhpcy5kcmF3ZXIuaW5pdCgpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ2RyYXdlci1jcmVhdGVkJywgdGhpcy5kcmF3ZXIpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25SZXNpemUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYXdlci5vbigncmVkcmF3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUuZHJhd0J1ZmZlcigpO1xuXG4gICAgICAgIF90aGlzNS5kcmF3ZXIucHJvZ3Jlc3MoX3RoaXM1LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSk7XG4gICAgICB9KTsgLy8gQ2xpY2stdG8tc2Vla1xuXG4gICAgICB0aGlzLmRyYXdlci5vbignY2xpY2snLCBmdW5jdGlvbiAoZSwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5zZWVrVG8ocHJvZ3Jlc3MpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pOyAvLyBSZWxheSB0aGUgc2Nyb2xsIGV2ZW50IGZyb20gdGhlIGRyYXdlclxuXG4gICAgICB0aGlzLmRyYXdlci5vbignc2Nyb2xsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzNS5wYXJhbXMucGFydGlhbFJlbmRlcikge1xuICAgICAgICAgIF90aGlzNS5kcmF3QnVmZmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUuZmlyZUV2ZW50KCdzY3JvbGwnLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGJhY2tlbmRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjYmFja2VuZC1jcmVhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVCYWNrZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJhY2tlbmQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuYmFja2VuZCkge1xuICAgICAgICB0aGlzLmJhY2tlbmQuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhY2tlbmQgPSBuZXcgdGhpcy5CYWNrZW5kKHRoaXMucGFyYW1zKTtcbiAgICAgIHRoaXMuYmFja2VuZC5pbml0KCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnYmFja2VuZC1jcmVhdGVkJywgdGhpcy5iYWNrZW5kKTtcbiAgICAgIHRoaXMuYmFja2VuZC5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczYuZHJhd2VyLnByb2dyZXNzKF90aGlzNi5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpO1xuXG4gICAgICAgIF90aGlzNi5maXJlRXZlbnQoJ2ZpbmlzaCcpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJhY2tlbmQub24oJ3BsYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuZmlyZUV2ZW50KCdwbGF5Jyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYmFja2VuZC5vbigncGF1c2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuZmlyZUV2ZW50KCdwYXVzZScpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJhY2tlbmQub24oJ2F1ZGlvcHJvY2VzcycsIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIF90aGlzNi5kcmF3ZXIucHJvZ3Jlc3MoX3RoaXM2LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSk7XG5cbiAgICAgICAgX3RoaXM2LmZpcmVFdmVudCgnYXVkaW9wcm9jZXNzJywgdGltZSk7XG4gICAgICB9KTsgLy8gb25seSBuZWVkZWQgZm9yIE1lZGlhRWxlbWVudCBhbmQgTWVkaWFFbGVtZW50V2ViQXVkaW8gYmFja2VuZFxuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuYmFja2VuZCA9PT0gJ01lZGlhRWxlbWVudCcgfHwgdGhpcy5wYXJhbXMuYmFja2VuZCA9PT0gJ01lZGlhRWxlbWVudFdlYkF1ZGlvJykge1xuICAgICAgICB0aGlzLmJhY2tlbmQub24oJ3NlZWsnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2LmRyYXdlci5wcm9ncmVzcyhfdGhpczYuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFja2VuZC5vbigndm9sdW1lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuZXdWb2x1bWUgPSBfdGhpczYuZ2V0Vm9sdW1lKCk7XG5cbiAgICAgICAgICBfdGhpczYuZmlyZUV2ZW50KCd2b2x1bWUnLCBuZXdWb2x1bWUpO1xuXG4gICAgICAgICAgaWYgKF90aGlzNi5iYWNrZW5kLmlzTXV0ZWQgIT09IF90aGlzNi5pc011dGVkKSB7XG4gICAgICAgICAgICBfdGhpczYuaXNNdXRlZCA9IF90aGlzNi5iYWNrZW5kLmlzTXV0ZWQ7XG5cbiAgICAgICAgICAgIF90aGlzNi5maXJlRXZlbnQoJ211dGUnLCBfdGhpczYuaXNNdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBwZWFrIGNhY2hlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUGVha0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBlYWtDYWNoZSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5wYXJ0aWFsUmVuZGVyKSB7XG4gICAgICAgIHRoaXMucGVha0NhY2hlID0gbmV3IF9wZWFrY2FjaGUuZGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpbyBjbGlwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBjb25zdCBkdXJhdGlvbiA9IHdhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IER1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXREdXJhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNvbnN0IGN1cnJlbnRUaW1lID0gd2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpO1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gUGxheWJhY2sgcG9zaXRpb24gaW4gc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VycmVudFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldEN1cnJlbnRUaW1lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBwbGF5IHRpbWUgaW4gc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzIEEgcG9zaXRpdmUgbnVtYmVyIGluIHNlY29uZHMuIEUuZy4gMTAgbWVhbnMgMTBcbiAgICAgKiBzZWNvbmRzLCA2MCBtZWFucyAxIG1pbnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VycmVudFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgICAgaWYgKHNlY29uZHMgPj0gdGhpcy5nZXREdXJhdGlvbigpKSB7XG4gICAgICAgIHRoaXMuc2Vla1RvKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWVrVG8oc2Vjb25kcyAvIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwbGF5YmFjayBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBPcHRpb25hbCBzdGFydCBhbmQgZW5kXG4gICAgICogbWVhc3VyZWQgaW4gc2Vjb25kcyBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIHJhbmdlIG9mIGF1ZGlvIHRvIHBsYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHN0YXJ0IFBvc2l0aW9uIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBlbmQgUG9zaXRpb24gdG8gZW5kIGF0XG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjaW50ZXJhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXN1bHQgb2YgdGhlIGJhY2tlbmQgcGxheSBtZXRob2RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHBsYXkgZnJvbSBzZWNvbmQgMSB0byA1XG4gICAgICogd2F2ZXN1cmZlci5wbGF5KDEsIDUpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB0aGlzLmZpcmVFdmVudCgnaW50ZXJhY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcucGxheShzdGFydCwgZW5kKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5wbGF5KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBwb2ludCBpbiBzZWNvbmRzIGZvciBwbGF5YmFjayB0byBzdG9wIGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFBvc2l0aW9uIChpbiBzZWNvbmRzKSB0byBzdG9wIGF0XG4gICAgICogQHZlcnNpb24gMy4zLjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXlFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheUVuZChwb3NpdGlvbikge1xuICAgICAgdGhpcy5iYWNrZW5kLnNldFBsYXlFbmQocG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbmQgcGF1c2VzIHBsYXliYWNrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnBhdXNlKCk7XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzdWx0IG9mIHRoZSBiYWNrZW5kIHBhdXNlIG1ldGhvZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHBsYXliYWNrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnBsYXlQYXVzZSgpO1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc3VsdCBvZiB0aGUgYmFja2VuZCBwbGF5IG9yIHBhdXNlIG1ldGhvZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXlQYXVzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKSA/IHRoaXMucGxheSgpIDogdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3RhdGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNvbnN0IGlzUGxheWluZyA9IHdhdmVzdXJmZXIuaXNQbGF5aW5nKCk7XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgcGF1c2VkLCB0cnVlIGlmIHBsYXlpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzUGxheWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BsYXlpbmcoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIGJhY2t3YXJkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHNlY29uZHMgQW1vdW50IHRvIHNraXAgYmFjaywgaWYgbm90IHNwZWNpZmllZCBgc2tpcExlbmd0aGBcbiAgICAgKiBpcyB1c2VkXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5za2lwQmFja3dhcmQoKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNraXBCYWNrd2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwQmFja3dhcmQoc2Vjb25kcykge1xuICAgICAgdGhpcy5za2lwKC1zZWNvbmRzIHx8IC10aGlzLnBhcmFtcy5za2lwTGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBmb3J3YXJkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHNlY29uZHMgQW1vdW50IHRvIHNraXAgYmFjaywgaWYgbm90IHNwZWNpZmllZCBgc2tpcExlbmd0aGBcbiAgICAgKiBpcyB1c2VkXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5za2lwRm9yd2FyZCgpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2tpcEZvcndhcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcEZvcndhcmQoc2Vjb25kcykge1xuICAgICAgdGhpcy5za2lwKHNlY29uZHMgfHwgdGhpcy5wYXJhbXMuc2tpcExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgYSBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uICh1c2UgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAqIHRvIGdvIGJhY2t3YXJkcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IEFtb3VudCB0byBza2lwIGJhY2sgb3IgZm9yd2FyZHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdvIGJhY2sgMiBzZWNvbmRzXG4gICAgICogd2F2ZXN1cmZlci5za2lwKC0yKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNraXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcChvZmZzZXQpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKSB8fCAxO1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRDdXJyZW50VGltZSgpIHx8IDA7XG4gICAgICBwb3NpdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGR1cmF0aW9uLCBwb3NpdGlvbiArIChvZmZzZXQgfHwgMCkpKTtcbiAgICAgIHRoaXMuc2Vla0FuZENlbnRlcihwb3NpdGlvbiAvIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Vla3MgdG8gYSBwb3NpdGlvbiBhbmQgY2VudGVycyB0aGUgdmlld1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzIEJldHdlZW4gMCAoPWJlZ2lubmluZykgYW5kIDEgKD1lbmQpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBzZWVrIGFuZCBnbyB0byB0aGUgbWlkZGxlIG9mIHRoZSBhdWRpb1xuICAgICAqIHdhdmVzdXJmZXIuc2Vla1RvKDAuNSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWVrQW5kQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWtBbmRDZW50ZXIocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuc2Vla1RvKHByb2dyZXNzKTtcbiAgICAgIHRoaXMuZHJhd2VyLnJlY2VudGVyKHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Vla3MgdG8gYSBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzIEJldHdlZW4gMCAoPWJlZ2lubmluZykgYW5kIDEgKD1lbmQpXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjaW50ZXJhY3Rpb25cbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNzZWVrXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBzZWVrIHRvIHRoZSBtaWRkbGUgb2YgdGhlIGF1ZGlvXG4gICAgICogd2F2ZXN1cmZlci5zZWVrVG8oMC41KTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlZWtUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVrVG8ocHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAvLyByZXR1cm4gYW4gZXJyb3IgaWYgcHJvZ3Jlc3MgaXMgbm90IGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHByb2dyZXNzKSB8fCBwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2FsbGluZyB3YXZlc3VyZmVyLnNlZWtUbywgcGFyYW1ldGVyIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpcmVFdmVudCgnaW50ZXJhY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczguc2Vla1RvKHByb2dyZXNzKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzV2ViQXVkaW9CYWNrZW5kID0gdGhpcy5wYXJhbXMuYmFja2VuZCA9PT0gJ1dlYkF1ZGlvJztcbiAgICAgIHZhciBwYXVzZWQgPSB0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKTtcblxuICAgICAgaWYgKGlzV2ViQXVkaW9CYWNrZW5kICYmICFwYXVzZWQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLnBhdXNlKCk7XG4gICAgICB9IC8vIGF2b2lkIHNtYWxsIHNjcm9sbHMgd2hpbGUgcGF1c2VkIHNlZWtpbmdcblxuXG4gICAgICB2YXIgb2xkU2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50O1xuICAgICAgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmJhY2tlbmQuc2Vla1RvKHByb2dyZXNzICogdGhpcy5nZXREdXJhdGlvbigpKTtcbiAgICAgIHRoaXMuZHJhd2VyLnByb2dyZXNzKHByb2dyZXNzKTtcblxuICAgICAgaWYgKGlzV2ViQXVkaW9CYWNrZW5kICYmICFwYXVzZWQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ID0gb2xkU2Nyb2xsUGFyZW50O1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3NlZWsnLCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBnb2VzIHRvIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnN0b3AoKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuc2Vla1RvKDApO1xuICAgICAgdGhpcy5kcmF3ZXIucHJvZ3Jlc3MoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIElEIG9mIHRoZSBhdWRpbyBkZXZpY2UgdG8gdXNlIGZvciBvdXRwdXQgYW5kIHJldHVybnMgYSBQcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIFN0cmluZyB2YWx1ZSByZXByZXNlbnRpbmcgdW5kZXJseWluZyBvdXRwdXRcbiAgICAgKiBkZXZpY2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAgd2hlbiB0aGVyZSBhcmVcbiAgICAgKiBubyBlcnJvcnMgZGV0ZWN0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTaW5rSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGxheWJhY2sgdm9sdW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZvbHVtZSBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgMCBiZWluZyBub1xuICAgICAqIHZvbHVtZSBhbmQgMSBiZWluZyBmdWxsIHZvbHVtZS5cbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciN2b2x1bWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWb2x1bWUobmV3Vm9sdW1lKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuc2V0Vm9sdW1lKG5ld1ZvbHVtZSk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgndm9sdW1lJywgbmV3Vm9sdW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGF5YmFjayB2b2x1bWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCAwIGJlaW5nIG5vXG4gICAgICogdm9sdW1lIGFuZCAxIGJlaW5nIGZ1bGwgdm9sdW1lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZvbHVtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGxheWJhY2sgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRlIEEgcG9zaXRpdmUgbnVtYmVyLiBFLmcuIDAuNSBtZWFucyBoYWxmIHRoZSBub3JtYWxcbiAgICAgKiBzcGVlZCwgMiBtZWFucyBkb3VibGUgc3BlZWQgYW5kIHNvIG9uLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0UGxheWJhY2tSYXRlKDIpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuc2V0UGxheWJhY2tSYXRlKHJhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYXliYWNrIHJhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWJhY2tSYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRQbGF5YmFja1JhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSB2b2x1bWUgb24gYW5kIG9mZi4gSWYgbm90IGN1cnJlbnRseSBtdXRlZCBpdCB3aWxsIHNhdmUgdGhlXG4gICAgICogY3VycmVudCB2b2x1bWUgdmFsdWUgYW5kIHR1cm4gdGhlIHZvbHVtZSBvZmYuIElmIGN1cnJlbnRseSBtdXRlZCB0aGVuIGl0XG4gICAgICogd2lsbCByZXN0b3JlIHRoZSB2b2x1bWUgdG8gdGhlIHNhdmVkIHZhbHVlLCBhbmQgdGhlbiByZXN0IHRoZSBzYXZlZFxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci50b2dnbGVNdXRlKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVNdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGUoKSB7XG4gICAgICB0aGlzLnNldE11dGUoIXRoaXMuaXNNdXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIG11dGVkIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11dGUgU3BlY2lmeSBgdHJ1ZWAgdG8gbXV0ZSBhdWRpby5cbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciN2b2x1bWVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNtdXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB1bm11dGVcbiAgICAgKiB3YXZlc3VyZmVyLnNldE11dGUoZmFsc2UpO1xuICAgICAqIGNvbnNvbGUubG9nKHdhdmVzdXJmZXIuZ2V0TXV0ZSgpKSAvLyBsb2dzIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE11dGUobXV0ZSkge1xuICAgICAgLy8gaWdub3JlIGFsbCBtdXRpbmcgcmVxdWVzdHMgaWYgdGhlIGF1ZGlvIGlzIGFscmVhZHkgaW4gdGhhdCBzdGF0ZVxuICAgICAgaWYgKG11dGUgPT09IHRoaXMuaXNNdXRlZCkge1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgnbXV0ZScsIHRoaXMuaXNNdXRlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2VuZC5zZXRNdXRlKSB7XG4gICAgICAgIC8vIEJhY2tlbmRzIHN1Y2ggYXMgdGhlIE1lZGlhRWxlbWVudCBiYWNrZW5kIGhhdmUgdGhlaXIgb3duIGhhbmRsaW5nXG4gICAgICAgIC8vIG9mIG11dGUsIGxldCB0aGVtIGhhbmRsZSBpdC5cbiAgICAgICAgdGhpcy5iYWNrZW5kLnNldE11dGUobXV0ZSk7XG4gICAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobXV0ZSkge1xuICAgICAgICAgIC8vIElmIGN1cnJlbnRseSBub3QgbXV0ZWQgdGhlbiBzYXZlIGN1cnJlbnQgdm9sdW1lLFxuICAgICAgICAgIC8vIHR1cm4gb2ZmIHRoZSB2b2x1bWUgYW5kIHVwZGF0ZSB0aGUgbXV0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdGhpcy5zYXZlZFZvbHVtZSA9IHRoaXMuYmFja2VuZC5nZXRWb2x1bWUoKTtcbiAgICAgICAgICB0aGlzLmJhY2tlbmQuc2V0Vm9sdW1lKDApO1xuICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3ZvbHVtZScsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGN1cnJlbnRseSBtdXRlZCB0aGVuIHJlc3RvcmUgdG8gdGhlIHNhdmVkIHZvbHVtZVxuICAgICAgICAgIC8vIGFuZCB1cGRhdGUgdGhlIG11dGUgcHJvcGVydGllc1xuICAgICAgICAgIHRoaXMuYmFja2VuZC5zZXRWb2x1bWUodGhpcy5zYXZlZFZvbHVtZSk7XG4gICAgICAgICAgdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3ZvbHVtZScsIHRoaXMuc2F2ZWRWb2x1bWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdtdXRlJywgdGhpcy5pc011dGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IG11dGUgc3RhdHVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY29uc3QgaXNNdXRlZCA9IHdhdmVzdXJmZXIuZ2V0TXV0ZSgpO1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IEN1cnJlbnQgbXV0ZSBzdGF0dXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE11dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXV0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTXV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBjdXJyZW50IHNldCBmaWx0ZXJzIGFzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogRmlsdGVycyBtdXN0IGJlIHNldCB3aXRoIHNldEZpbHRlcnMgbWV0aG9kIGZpcnN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gTGlzdCBvZiBlbmFibGVkIGZpbHRlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsdGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZmlsdGVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBgc2Nyb2xsUGFyZW50YCBhbmQgcmVkcmF3c1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci50b2dnbGVTY3JvbGwoKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTY3JvbGwoKSB7XG4gICAgICB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgPSAhdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50O1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBtb3VzZSBpbnRlcmFjdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci50b2dnbGVJbnRlcmFjdGlvbigpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlSW50ZXJhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlSW50ZXJhY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhcmFtcy5pbnRlcmFjdCA9ICF0aGlzLnBhcmFtcy5pbnRlcmFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBhZnRlciB0aGUgY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRXYXZlQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2F2ZUNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLndhdmVDb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBhZnRlciB0aGUgY3Vyc29yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldFdhdmVDb2xvcignI2RkZCcpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0V2F2ZUNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdhdmVDb2xvcihjb2xvcikge1xuICAgICAgdGhpcy5wYXJhbXMud2F2ZUNvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBiZWhpbmQgdGhlIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvZ3Jlc3NDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9ncmVzc0NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnByb2dyZXNzQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gYmVoaW5kIHRoZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0UHJvZ3Jlc3NDb2xvcignIzQwMCcpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvZ3Jlc3NDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9ncmVzc0NvbG9yKGNvbG9yKSB7XG4gICAgICB0aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhY2tncm91bmRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRCYWNrZ3JvdW5kQ29sb3IoJyNGRjAwRkYnKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpIHtcbiAgICAgIHRoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgdXRpbC5zdHlsZSh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIGN1cnNvciBpbmRpY2F0aW5nIHRoZSBwbGF5aGVhZFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJzb3JDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJzb3JDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5jdXJzb3JDb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSBjdXJzb3IgaW5kaWNhdGluZyB0aGUgcGxheWhlYWRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRDdXJzb3JDb2xvcignIzIyMicpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3Vyc29yQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3Vyc29yQ29sb3IoY29sb3IpIHtcbiAgICAgIHRoaXMucGFyYW1zLmN1cnNvckNvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLmRyYXdlci51cGRhdGVDdXJzb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQgbWVhc3VyZWQgaW4gcGl4ZWxzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG1lYXN1cmVkIGluIHBpeGVscy5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldEhlaWdodCgyMDApO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgIHRoaXMucGFyYW1zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZHJhd2VyLnNldEhlaWdodChoZWlnaHQgKiB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIGNoYW5uZWxzIGZyb20gYmVpbmcgZHJhd24gb24gdGhlIHdhdmVmb3JtIGlmIHNwbGl0dGluZyBjaGFubmVscy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB3ZSB3YW50IHRvIGRyYXcgb25seSB0aGUgcGVha3MgZm9yIHRoZSByaWdodCBzdGVyZW8gY2hhbm5lbDpcbiAgICAgKlxuICAgICAqIGNvbnN0IHdhdmVzdXJmZXIgPSBuZXcgV2F2ZVN1cmZlci5jcmVhdGUoey4uLnNwbGl0Q2hhbm5lbHM6IHRydWV9KTtcbiAgICAgKiB3YXZlc3VyZmVyLmxvYWQoJ3N0ZXJlb19hdWRpby5tcDMnKTtcbiAgICAgKlxuICAgICAqIHdhdmVzdXJmZXIuc2V0RmlsdGVyZWRDaGFubmVsKFswXSk7IDwtLSBoaWRlIGxlZnQgY2hhbm5lbCBwZWFrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGNoYW5uZWxJbmRpY2VzIENoYW5uZWxzIHRvIGJlIGZpbHRlcmVkIG91dCBmcm9tIGRyYXdpbmcuXG4gICAgICogQHZlcnNpb24gNC4wLjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbHRlcmVkQ2hhbm5lbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsdGVyZWRDaGFubmVscyhjaGFubmVsSW5kaWNlcykge1xuICAgICAgdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMuZmlsdGVyQ2hhbm5lbHMgPSBjaGFubmVsSW5kaWNlcztcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvcnJlY3QgcGVha3MgZm9yIGN1cnJlbnQgd2F2ZSB2aWV3LXBvcnQgYW5kIHJlbmRlciB3YXZlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3JlZHJhd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0J1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QnVmZmVyKCkge1xuICAgICAgdmFyIG5vbWluYWxXaWR0aCA9IE1hdGgucm91bmQodGhpcy5nZXREdXJhdGlvbigpICogdGhpcy5wYXJhbXMubWluUHhQZXJTZWMgKiB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHZhciBwYXJlbnRXaWR0aCA9IHRoaXMuZHJhd2VyLmdldFdpZHRoKCk7XG4gICAgICB2YXIgd2lkdGggPSBub21pbmFsV2lkdGg7IC8vIGFsd2F5cyBzdGFydCBhdCAwIGFmdGVyIHpvb21pbmcgZm9yIHNjcm9sbGluZyA6IGlzc3VlIHJlZHJhdyBsZWZ0IHBhcnRcblxuICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1heChzdGFydCArIHBhcmVudFdpZHRoLCB3aWR0aCk7IC8vIEZpbGwgY29udGFpbmVyXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5maWxsUGFyZW50ICYmICghdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50IHx8IG5vbWluYWxXaWR0aCA8IHBhcmVudFdpZHRoKSkge1xuICAgICAgICB3aWR0aCA9IHBhcmVudFdpZHRoO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVha3M7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5wYXJ0aWFsUmVuZGVyKSB7XG4gICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLnBlYWtDYWNoZS5hZGRSYW5nZVRvUGVha0NhY2hlKHdpZHRoLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld1Jhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBlYWtzID0gdGhpcy5iYWNrZW5kLmdldFBlYWtzKHdpZHRoLCBuZXdSYW5nZXNbaV1bMF0sIG5ld1Jhbmdlc1tpXVsxXSk7XG4gICAgICAgICAgdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKHBlYWtzLCB3aWR0aCwgbmV3UmFuZ2VzW2ldWzBdLCBuZXdSYW5nZXNbaV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWFrcyA9IHRoaXMuYmFja2VuZC5nZXRQZWFrcyh3aWR0aCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMuZHJhd2VyLmRyYXdQZWFrcyhwZWFrcywgd2lkdGgsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpcmVFdmVudCgncmVkcmF3JywgcGVha3MsIHdpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbGx5IHpvb21zIHRoZSB3YXZlZm9ybSBpbiBhbmQgb3V0LiBJdCBhbHNvIGNoYW5nZXMgdGhlIHBhcmFtZXRlclxuICAgICAqIGBtaW5QeFBlclNlY2AgYW5kIGVuYWJsZXMgdGhlIGBzY3JvbGxQYXJlbnRgIG9wdGlvbi4gQ2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICAgKiB3aXRoIGEgZmFsc2V5IHBhcmFtZXRlciB3aWxsIHJlc2V0IHRoZSB6b29tIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBweFBlclNlYyBOdW1iZXIgb2YgaG9yaXpvbnRhbCBwaXhlbHMgcGVyIHNlY29uZCBvZlxuICAgICAqIGF1ZGlvLCBpZiBub25lIGlzIHNldCB0aGUgd2F2ZWZvcm0gcmV0dXJucyB0byB1bnpvb21lZCBzdGF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3pvb21cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnpvb20oMjApO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHB4UGVyU2VjKSB7XG4gICAgICBpZiAoIXB4UGVyU2VjKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLm1pblB4UGVyU2VjID0gdGhpcy5kZWZhdWx0UGFyYW1zLm1pblB4UGVyU2VjO1xuICAgICAgICB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyYW1zLm1pblB4UGVyU2VjID0gcHhQZXJTZWM7XG4gICAgICAgIHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgICAgdGhpcy5kcmF3ZXIucHJvZ3Jlc3ModGhpcy5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpO1xuICAgICAgdGhpcy5kcmF3ZXIucmVjZW50ZXIodGhpcy5nZXRDdXJyZW50VGltZSgpIC8gdGhpcy5nZXREdXJhdGlvbigpKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCd6b29tJywgcHhQZXJTZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYnVmZmVyIGFuZCBsb2FkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5YnVmZmVyIEJ1ZmZlciB0byBwcm9jZXNzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFycmF5QnVmZmVyKGFycmF5YnVmZmVyKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdGhpcy5kZWNvZGVBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlciwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFfdGhpczkuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICBfdGhpczkubG9hZERlY29kZWRCdWZmZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXJlY3RseSBsb2FkIGFuIGV4dGVybmFsbHkgZGVjb2RlZCBBdWRpb0J1ZmZlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHByb2Nlc3NcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNyZWFkeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZERlY29kZWRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZERlY29kZWRCdWZmZXIoYnVmZmVyKSB7XG4gICAgICB0aGlzLmJhY2tlbmQubG9hZChidWZmZXIpO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlYWR5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIGF1ZGlvIGRhdGEgZnJvbSBhIEJsb2Igb3IgRmlsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmxvYnxGaWxlfSBibG9iIEF1ZGlvIGRhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZEJsb2JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEJsb2IoYmxvYikge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICAvLyBDcmVhdGUgZmlsZSByZWFkZXJcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAub25Qcm9ncmVzcyhlKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5sb2FkQXJyYXlCdWZmZXIoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5maXJlRXZlbnQoJ2Vycm9yJywgJ0Vycm9yIHJlYWRpbmcgZmlsZScpO1xuICAgICAgfSk7XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgICB0aGlzLmVtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIGF1ZGlvIGFuZCByZS1yZW5kZXJzIHRoZSB3YXZlZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxNZWRpYUVsZW1lbnR9IHVybCBUaGUgdXJsIG9mIHRoZSBhdWRpbyBmaWxlIG9yIHRoZVxuICAgICAqIGF1ZGlvIGVsZW1lbnQgd2l0aCB0aGUgYXVkaW9cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIFdhdmVzdXJmZXIgZG9lcyBub3QgaGF2ZSB0byBkZWNvZGVcbiAgICAgKiB0aGUgYXVkaW8gdG8gcmVuZGVyIHRoZSB3YXZlZm9ybSBpZiB0aGlzIGlzIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gcHJlbG9hZCAoVXNlIHdpdGggYmFja2VuZCBgTWVkaWFFbGVtZW50YCBhbmQgYE1lZGlhRWxlbWVudFdlYkF1ZGlvYClcbiAgICAgKiBgJ25vbmUnfCdtZXRhZGF0YSd8J2F1dG8nYCBQcmVsb2FkIGF0dHJpYnV0ZSBmb3IgdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8uIFRoaXMgaXMgdXNlZCB0b1xuICAgICAqIHJlbmRlciB0aGUgcGVha3MgZGF0YSBpbiB0aGUgY29ycmVjdCBzaXplIGZvciB0aGUgYXVkaW8gZHVyYXRpb24gKGFzXG4gICAgICogYmVmaXRzIHRoZSBjdXJyZW50IGBtaW5QeFBlclNlY2AgYW5kIHpvb20gdmFsdWUpIHdpdGhvdXQgaGF2aW5nIHRvIGRlY29kZVxuICAgICAqIHRoZSBhdWRpby5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGB1cmxgIGFyZ3VtZW50IGlzIGVtcHR5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdXNlcyBmZXRjaCBvciBtZWRpYSBlbGVtZW50IHRvIGxvYWQgZmlsZSAoZGVwZW5kaW5nIG9uIGJhY2tlbmQpXG4gICAgICogd2F2ZXN1cmZlci5sb2FkKCdodHRwOi8vZXhhbXBsZS5jb20vZGVtby53YXYnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldHRpbmcgcHJlbG9hZCBhdHRyaWJ1dGUgd2l0aCBtZWRpYSBlbGVtZW50IGJhY2tlbmQgYW5kIHN1cHBseWluZ1xuICAgICAqIC8vIHBlYWtzXG4gICAgICogd2F2ZXN1cmZlci5sb2FkKFxuICAgICAqICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9kZW1vLndhdicsXG4gICAgICogICBbMC4wMjE4LCAwLjAxODMsIDAuMDE2NSwgMC4wMTk4LCAwLjIxMzcsIDAuMjg4OF0sXG4gICAgICogICB0cnVlXG4gICAgICogKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIHBlYWtzLCBwcmVsb2FkLCBkdXJhdGlvbikge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cmwgcGFyYW1ldGVyIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtcHR5KCk7XG5cbiAgICAgIGlmIChwcmVsb2FkKSB7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHByZWxvYWQgYXR0cmlidXRlIHdpbGwgYmUgdXNhYmxlIGFuZCBpZiBub3QgbG9nXG4gICAgICAgIC8vIGEgd2FybmluZyBsaXN0aW5nIHRoZSByZWFzb25zIHdoeSBub3QgYW5kIG51bGxpZnkgdGhlIHZhcmlhYmxlXG4gICAgICAgIHZhciBwcmVsb2FkSWdub3JlUmVhc29ucyA9IHtcbiAgICAgICAgICBcIlByZWxvYWQgaXMgbm90ICdhdXRvJywgJ25vbmUnIG9yICdtZXRhZGF0YSdcIjogWydhdXRvJywgJ21ldGFkYXRhJywgJ25vbmUnXS5pbmRleE9mKHByZWxvYWQpID09PSAtMSxcbiAgICAgICAgICAnUGVha3MgYXJlIG5vdCBwcm92aWRlZCc6ICFwZWFrcyxcbiAgICAgICAgICBcIkJhY2tlbmQgaXMgbm90IG9mIHR5cGUgJ01lZGlhRWxlbWVudCcgb3IgJ01lZGlhRWxlbWVudFdlYkF1ZGlvJ1wiOiBbJ01lZGlhRWxlbWVudCcsICdNZWRpYUVsZW1lbnRXZWJBdWRpbyddLmluZGV4T2YodGhpcy5wYXJhbXMuYmFja2VuZCkgPT09IC0xLFxuICAgICAgICAgICdVcmwgaXMgbm90IG9mIHR5cGUgc3RyaW5nJzogdHlwZW9mIHVybCAhPT0gJ3N0cmluZydcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFjdGl2ZVJlYXNvbnMgPSBPYmplY3Qua2V5cyhwcmVsb2FkSWdub3JlUmVhc29ucykuZmlsdGVyKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICByZXR1cm4gcHJlbG9hZElnbm9yZVJlYXNvbnNbcmVhc29uXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByZWxvYWQgcGFyYW1ldGVyIG9mIHdhdmVzdXJmZXIubG9hZCB3aWxsIGJlIGlnbm9yZWQgYmVjYXVzZTpcXG5cXHQtICcgKyBhY3RpdmVSZWFzb25zLmpvaW4oJ1xcblxcdC0gJykpOyAvLyBzdG9wIGludmFsaWQgdmFsdWVzIGZyb20gYmVpbmcgdXNlZFxuXG4gICAgICAgICAgcHJlbG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbG9hZEJ1ZmZlcih1cmwsIHBlYWtzLCBkdXJhdGlvbikgcmVxdWlyZXMgdGhhdCB1cmwgaXMgYSBzdHJpbmdcbiAgICAgIC8vIGJ1dCB1c2VycyBjYW4gcGFzcyBpbiBhIEhUTUxNZWRpYUVsZW1lbnQgdG8gV2F2ZVN1cmZlclxuXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5iYWNrZW5kID09PSAnV2ViQXVkaW8nICYmIHVybCBpbnN0YW5jZW9mIEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgdXJsID0gdXJsLnNyYztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLnBhcmFtcy5iYWNrZW5kKSB7XG4gICAgICAgIGNhc2UgJ1dlYkF1ZGlvJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkQnVmZmVyKHVybCwgcGVha3MsIGR1cmF0aW9uKTtcblxuICAgICAgICBjYXNlICdNZWRpYUVsZW1lbnQnOlxuICAgICAgICBjYXNlICdNZWRpYUVsZW1lbnRXZWJBdWRpbyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZE1lZGlhRWxlbWVudCh1cmwsIHBlYWtzLCBwcmVsb2FkLCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIGF1ZGlvIHVzaW5nIFdlYiBBdWRpbyBidWZmZXIgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjd2F2ZWZvcm0tcmVhZHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCBvZiBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBQZWFrcyBkYXRhXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBkdXJhdGlvbiBPcHRpb25hbCBkdXJhdGlvbiBvZiBhdWRpbyBmaWxlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRCdWZmZXIodXJsLCBwZWFrcywgZHVyYXRpb24pIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgX3RoaXMxMS50bXBFdmVudHMucHVzaChfdGhpczExLm9uY2UoJ3JlYWR5JywgYWN0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMxMS5nZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTEubG9hZEFycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChwZWFrcykge1xuICAgICAgICB0aGlzLmJhY2tlbmQuc2V0UGVha3MocGVha3MsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCd3YXZlZm9ybS1yZWFkeScpO1xuICAgICAgICB0aGlzLnRtcEV2ZW50cy5wdXNoKHRoaXMub25jZSgnaW50ZXJhY3Rpb24nLCBsb2FkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgY3JlYXRlIGEgbWVkaWEgZWxlbWVudCwgb3IgbG9hZCBhbiBleGlzdGluZyBtZWRpYSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciN3YXZlZm9ybS1yZWFkeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxNZWRpYUVsZW1lbnR9IHVybE9yRWx0IEVpdGhlciBhIHBhdGggdG8gYSBtZWRpYSBmaWxlLCBvciBhblxuICAgICAqIGV4aXN0aW5nIEhUTUw1IEF1ZGlvL1ZpZGVvIEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIEFycmF5IG9mIHBlYWtzLiBSZXF1aXJlZCB0byBieXBhc3Mgd2ViIGF1ZGlvXG4gICAgICogZGVwZW5kZW5jeVxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IHByZWxvYWQgU2V0IHRvIHRydWUgaWYgdGhlIHByZWxvYWQgYXR0cmlidXRlIG9mIHRoZVxuICAgICAqIGF1ZGlvIGVsZW1lbnQgc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGR1cmF0aW9uIE9wdGlvbmFsIGR1cmF0aW9uIG9mIGF1ZGlvIGZpbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRNZWRpYUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZE1lZGlhRWxlbWVudCh1cmxPckVsdCwgcGVha3MsIHByZWxvYWQsIGR1cmF0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSB1cmxPckVsdDtcblxuICAgICAgaWYgKHR5cGVvZiB1cmxPckVsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLmxvYWQodXJsLCB0aGlzLm1lZGlhQ29udGFpbmVyLCBwZWFrcywgcHJlbG9hZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWx0ID0gdXJsT3JFbHQ7XG4gICAgICAgIHRoaXMuYmFja2VuZC5sb2FkRWx0KGVsdCwgcGVha3MpOyAvLyBJZiBwZWFrcyBhcmUgbm90IHByb3ZpZGVkLFxuICAgICAgICAvLyB1cmwgPSBlbGVtZW50LnNyYyBzbyB3ZSBjYW4gZ2V0IHBlYWtzIHdpdGggd2ViIGF1ZGlvXG5cbiAgICAgICAgdXJsID0gZWx0LnNyYztcbiAgICAgIH1cblxuICAgICAgdGhpcy50bXBFdmVudHMucHVzaCh0aGlzLmJhY2tlbmQub25jZSgnY2FucGxheScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWdub3JlIHdoZW4gYmFja2VuZCB3YXMgYWxyZWFkeSBkZXN0cm95ZWRcbiAgICAgICAgaWYgKCFfdGhpczEyLmJhY2tlbmQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgX3RoaXMxMi5kcmF3QnVmZmVyKCk7XG5cbiAgICAgICAgICBfdGhpczEyLmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgX3RoaXMxMi5maXJlRXZlbnQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLmJhY2tlbmQub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczEyLmZpcmVFdmVudCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSkpOyAvLyBJZiBwZWFrcyBhcmUgcHJvdmlkZWQsIHJlbmRlciB0aGVtIGFuZCBmaXJlIHRoZSBgd2F2ZWZvcm0tcmVhZHlgIGV2ZW50LlxuXG4gICAgICBpZiAocGVha3MpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLnNldFBlYWtzKHBlYWtzLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgnd2F2ZWZvcm0tcmVhZHknKTtcbiAgICAgIH0gLy8gSWYgbm8gcHJlLWRlY29kZWQgcGVha3MgYXJlIHByb3ZpZGVkLCBvciBhcmUgcHJvdmlkZWQgd2l0aFxuICAgICAgLy8gZm9yY2VEZWNvZGUgZmxhZywgYXR0ZW1wdCB0byBkb3dubG9hZCB0aGUgYXVkaW8gZmlsZSBhbmQgZGVjb2RlIGl0XG4gICAgICAvLyB3aXRoIFdlYiBBdWRpby5cblxuXG4gICAgICBpZiAoKCFwZWFrcyB8fCB0aGlzLnBhcmFtcy5mb3JjZURlY29kZSkgJiYgdGhpcy5iYWNrZW5kLnN1cHBvcnRzV2ViQXVkaW8oKSkge1xuICAgICAgICB0aGlzLmdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gICAgICAgICAgX3RoaXMxMi5kZWNvZGVBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlciwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgX3RoaXMxMi5iYWNrZW5kLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgICAgICAgICAgX3RoaXMxMi5iYWNrZW5kLnNldFBlYWtzKG51bGwpO1xuXG4gICAgICAgICAgICBfdGhpczEyLmRyYXdCdWZmZXIoKTtcblxuICAgICAgICAgICAgX3RoaXMxMi5maXJlRXZlbnQoJ3dhdmVmb3JtLXJlYWR5Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXJyYXkgYnVmZmVyIGFuZCBwYXNzIGRhdGEgdG8gYSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBkZWNvZGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBjb21wbGV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlQXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYXJyYXlidWZmZXIgPSBhcnJheWJ1ZmZlcjtcbiAgICAgIHRoaXMuYmFja2VuZC5kZWNvZGVBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlciwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gT25seSB1c2UgdGhlIGRlY29kZWQgZGF0YSBpZiB3ZSBoYXZlbid0IGJlZW4gZGVzdHJveWVkIG9yXG4gICAgICAgIC8vIGFub3RoZXIgZGVjb2RlIHN0YXJ0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGlmICghX3RoaXMxMy5pc0Rlc3Ryb3llZCAmJiBfdGhpczEzLmFycmF5YnVmZmVyID09IGFycmF5YnVmZmVyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgX3RoaXMxMy5hcnJheWJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTMuZmlyZUV2ZW50KCdlcnJvcicsICdFcnJvciBkZWNvZGluZyBhdWRpb2J1ZmZlcicpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgYW4gYXJyYXkgYnVmZmVyIHVzaW5nIGZldGNoIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBmaWxlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge3V0aWwuZmV0Y2hGaWxlfSBmZXRjaCBjYWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFycmF5QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHVybCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgfSwgdGhpcy5wYXJhbXMueGhyKTtcbiAgICAgIHZhciByZXF1ZXN0ID0gdXRpbC5mZXRjaEZpbGUob3B0aW9ucyk7XG4gICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgIHRoaXMudG1wRXZlbnRzLnB1c2gocmVxdWVzdC5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczE0Lm9uUHJvZ3Jlc3MoZSk7XG4gICAgICB9KSwgcmVxdWVzdC5vbignc3VjY2VzcycsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICBfdGhpczE0LmN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pLCByZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMTQuZmlyZUV2ZW50KCdlcnJvcicsIGUpO1xuXG4gICAgICAgIF90aGlzMTQuY3VycmVudFJlcXVlc3QgPSBudWxsO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGlsZSB0aGUgYXVkaW8gZmlsZSBpcyBsb2FkaW5nXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgUHJvZ3Jlc3MgZXZlbnRcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNsb2FkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZSkge1xuICAgICAgdmFyIHBlcmNlbnRDb21wbGV0ZTtcblxuICAgICAgaWYgKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICBwZXJjZW50Q29tcGxldGUgPSBlLmxvYWRlZCAvIGUudG90YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHByb3hpbWF0ZSBwcm9ncmVzcyB3aXRoIGFuIGFzeW1wdG90aWNcbiAgICAgICAgLy8gZnVuY3Rpb24sIGFuZCBhc3N1bWUgZG93bmxvYWRzIGluIHRoZSAxLTMgTUIgcmFuZ2UuXG4gICAgICAgIHBlcmNlbnRDb21wbGV0ZSA9IGUubG9hZGVkIC8gKGUubG9hZGVkICsgMTAwMDAwMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdsb2FkaW5nJywgTWF0aC5yb3VuZChwZXJjZW50Q29tcGxldGUgKiAxMDApLCBlLnRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgUENNIGRhdGEgaW50byBhIEpTT04gYXJyYXkgYW5kIG9wdGlvbmFsbHkgb3BlbnMgaW4gYSBuZXcgd2luZG93XG4gICAgICogYXMgdmFsaWQgSlNPTiBCbG9iIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aD0xMDI0IFRoZSBzY2FsZSBpbiB3aGljaCB0byBleHBvcnQgdGhlIHBlYWtzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFjY3VyYWN5PTEwMDAwXG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gbm9XaW5kb3cgU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBvcGVuaW5nIGEgbmV3XG4gICAgICogd2luZG93IHdpdGggdGhlIEpTT05cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFycmF5IG9mIHBlYWtzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHBvcnRQQ01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0UENNKGxlbmd0aCwgYWNjdXJhY3ksIG5vV2luZG93LCBzdGFydCwgZW5kKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfHwgMTAyNDtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGFjY3VyYWN5ID0gYWNjdXJhY3kgfHwgMTAwMDA7XG4gICAgICBub1dpbmRvdyA9IG5vV2luZG93IHx8IGZhbHNlO1xuICAgICAgdmFyIHBlYWtzID0gdGhpcy5iYWNrZW5kLmdldFBlYWtzKGxlbmd0aCwgc3RhcnQsIGVuZCk7XG4gICAgICB2YXIgYXJyID0gW10ubWFwLmNhbGwocGVha3MsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsICogYWNjdXJhY3kpIC8gYWNjdXJhY3k7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghbm9XaW5kb3cpIHtcbiAgICAgICAgICB2YXIgYmxvYkpTT04gPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoYXJyKV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG9ialVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYkpTT04pO1xuICAgICAgICAgIHdpbmRvdy5vcGVuKG9ialVSTCk7XG4gICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShhcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmUgd2F2ZWZvcm0gaW1hZ2UgYXMgZGF0YSBVUkkuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgaXMgYCdpbWFnZS9wbmcnYC4gT3RoZXIgc3VwcG9ydGVkIHR5cGVzIGFyZVxuICAgICAqIGAnaW1hZ2UvanBlZydgIGFuZCBgJ2ltYWdlL3dlYnAnYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQ9J2ltYWdlL3BuZycgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgaW1hZ2UgZm9ybWF0LlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCB0eXBlIGlzIGAnaW1hZ2UvcG5nJ2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHk9MSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaW5kaWNhdGluZyB0aGUgaW1hZ2VcbiAgICAgKiBxdWFsaXR5IHRvIHVzZSBmb3IgaW1hZ2UgZm9ybWF0cyB0aGF0IHVzZSBsb3NzeSBjb21wcmVzc2lvbiBzdWNoIGFzXG4gICAgICogYCdpbWFnZS9qcGVnJ2BgIGFuZCBgJ2ltYWdlL3dlYnAnYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBJbWFnZSBkYXRhIHR5cGUgdG8gcmV0dXJuLiBFaXRoZXIgJ2RhdGFVUkwnIChkZWZhdWx0KVxuICAgICAqIG9yICdibG9iJy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW118UHJvbWlzZX0gV2hlbiB1c2luZyBgJ2RhdGFVUkwnYCB0eXBlIHRoaXMgcmV0dXJuc1xuICAgICAqIGEgc2luZ2xlIGRhdGEgVVJMIG9yIGFuIGFycmF5IG9mIGRhdGEgVVJMcywgb25lIGZvciBlYWNoIGNhbnZhcy4gV2hlbiB1c2luZ1xuICAgICAqIGAnYmxvYidgIHR5cGUgdGhpcyByZXR1cm5zIGEgYFByb21pc2VgIHJlc29sdmluZyB3aXRoIGFuIGFycmF5IG9mIGBCbG9iYFxuICAgICAqIGluc3RhbmNlcywgb25lIGZvciBlYWNoIGNhbnZhcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4cG9ydEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSkge1xuICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0ID0gJ2ltYWdlL3BuZyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghcXVhbGl0eSkge1xuICAgICAgICBxdWFsaXR5ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHR5cGUgPSAnZGF0YVVSTCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRyYXdlci5nZXRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYW55IGZldGNoIHJlcXVlc3QgY3VycmVudGx5IGluIHByb2dyZXNzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxBamF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFqYXgoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdCAmJiB0aGlzLmN1cnJlbnRSZXF1ZXN0LmNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgcmVxdWVzdCBoYXMgYSBQcm9ncmVzc0hhbmRsZXIsIHRoZW4gaXRzIFJlYWRhYmxlU3RyZWFtIG1pZ2h0IG5lZWQgdG8gYmUgY2FuY2VsbGVkIHRvb1xuICAgICAgICAvLyBTZWU6IFdhdmVzdXJmZXIgaXNzdWUgIzIwNDJcbiAgICAgICAgLy8gU2VlIEZpcmVmb3ggYnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTgzODE1XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXF1ZXN0Ll9yZWFkZXIpIHtcbiAgICAgICAgICAvLyBJZ25vcmluZyBleGNlcHRpb25zIHRocm93biBieSBjYWxsIHRvIGNhbmNlbCgpXG4gICAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdC5fcmVhZGVyLmNhbmNlbCgpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyVG1wRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVG1wRXZlbnRzKCkge1xuICAgICAgdGhpcy50bXBFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS51bigpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgZW1wdHkgd2F2ZWZvcm0uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIGlmICghdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmFja2VuZC5kaXNjb25uZWN0U291cmNlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5jYW5jZWxBamF4KCk7XG4gICAgICB0aGlzLmNsZWFyVG1wRXZlbnRzKCk7IC8vIGVtcHR5IGRyYXdlclxuXG4gICAgICB0aGlzLmRyYXdlci5wcm9ncmVzcygwKTtcbiAgICAgIHRoaXMuZHJhd2VyLnNldFdpZHRoKDApO1xuICAgICAgdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKHtcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmRyYXdlci5nZXRXaWR0aCgpXG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50cywgZWxlbWVudHMgYW5kIGRpc2Nvbm5lY3QgV2ViQXVkaW8gbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNkZXN0cm95XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lBbGxQbHVnaW5zKCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnZGVzdHJveScpO1xuICAgICAgdGhpcy5jYW5jZWxBamF4KCk7XG4gICAgICB0aGlzLmNsZWFyVG1wRXZlbnRzKCk7XG4gICAgICB0aGlzLnVuQWxsKCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLmRlc3Ryb3koKTsgLy8gY2xlYXJzIG1lbW9yeSB1c2FnZVxuXG4gICAgICAgIHRoaXMuYmFja2VuZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRyYXdlcikge1xuICAgICAgICB0aGlzLmRyYXdlci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLmFycmF5YnVmZmVyID0gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgdGhpcyBjbGFzcywgY2FsbCBpdHMgYGluaXRgIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBUaGUgd2F2ZXN1cmZlciBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBXYXZlU3VyZmVyIGluc3RhbmNlXG4gICAgICogQGV4YW1wbGUgY29uc3Qgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHBhcmFtcyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHBhcmFtcykge1xuICAgICAgdmFyIHdhdmVzdXJmZXIgPSBuZXcgV2F2ZVN1cmZlcihwYXJhbXMpO1xuICAgICAgcmV0dXJuIHdhdmVzdXJmZXIuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGlicmFyeSB2ZXJzaW9uIG51bWJlciBpcyBhdmFpbGFibGUgYXMgYSBzdGF0aWMgcHJvcGVydHkgb2YgdGhlXG4gICAgICogV2F2ZVN1cmZlciBjbGFzc1xuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnNvbGUubG9nKCdVc2luZyB3YXZlc3VyZmVyLmpzICcgKyBXYXZlU3VyZmVyLlZFUlNJT04pO1xuICAgICAqL1xuXG4gIH1dKTtcblxuICByZXR1cm4gV2F2ZVN1cmZlcjtcbn0odXRpbC5PYnNlcnZlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdhdmVTdXJmZXI7XG5XYXZlU3VyZmVyLlZFUlNJT04gPSBcIjUuMS4wXCI7XG5XYXZlU3VyZmVyLnV0aWwgPSB1dGlsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3dlYmF1ZGlvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3dlYmF1ZGlvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyB1c2luZyBjb25zdGFudHMgdG8gcHJldmVudCBzb21lb25lIHdyaXRpbmcgdGhlIHN0cmluZyB3cm9uZ1xudmFyIFBMQVlJTkcgPSAncGxheWluZyc7XG52YXIgUEFVU0VEID0gJ3BhdXNlZCc7XG52YXIgRklOSVNIRUQgPSAnZmluaXNoZWQnO1xuLyoqXG4gKiBXZWJBdWRpbyBiYWNrZW5kXG4gKlxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICovXG5cbnZhciBXZWJBdWRpbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3V0aWwkT2JzZXJ2ZXIpIHtcbiAgX2luaGVyaXRzKFdlYkF1ZGlvLCBfdXRpbCRPYnNlcnZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXZWJBdWRpbyk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgYmFja2VuZFxuICAgKlxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBXYXZlc3VyZmVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIFdlYkF1ZGlvKHBhcmFtcykge1xuICAgIHZhciBfdGhpcyRzdGF0ZUJlaGF2aW9ycywgX3RoaXMkc3RhdGVzO1xuXG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkF1ZGlvKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5hdWRpb0NvbnRleHQgPSBudWxsO1xuICAgIF90aGlzLm9mZmxpbmVBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgIF90aGlzLnN0YXRlQmVoYXZpb3JzID0gKF90aGlzJHN0YXRlQmVoYXZpb3JzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZUJlaGF2aW9ycywgUExBWUlORywge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hZGRPbkF1ZGlvUHJvY2VzcygpO1xuICAgICAgfSxcbiAgICAgIGdldFBsYXllZFBlcmNlbnRzOiBmdW5jdGlvbiBnZXRQbGF5ZWRQZXJjZW50cygpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5nZXREdXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VGltZSgpIC8gZHVyYXRpb24gfHwgMDtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VGltZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9zaXRpb24gKyB0aGlzLmdldFBsYXllZFRpbWUoKTtcbiAgICAgIH1cbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlQmVoYXZpb3JzLCBQQVVTRUQsIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT25BdWRpb1Byb2Nlc3MoKTtcbiAgICAgIH0sXG4gICAgICBnZXRQbGF5ZWRQZXJjZW50czogZnVuY3Rpb24gZ2V0UGxheWVkUGVyY2VudHMoKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKSAvIGR1cmF0aW9uIHx8IDA7XG4gICAgICB9LFxuICAgICAgZ2V0Q3VycmVudFRpbWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVCZWhhdmlvcnMsIEZJTklTSEVELCB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB0aGlzLnJlbW92ZU9uQXVkaW9Qcm9jZXNzKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdmaW5pc2gnKTtcbiAgICAgIH0sXG4gICAgICBnZXRQbGF5ZWRQZXJjZW50czogZnVuY3Rpb24gZ2V0UGxheWVkUGVyY2VudHMoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRUaW1lOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9KSwgX3RoaXMkc3RhdGVCZWhhdmlvcnMpO1xuICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAvKiogYWM6IEF1ZGlvIENvbnRleHQgaW5zdGFuY2UgKi9cblxuICAgIF90aGlzLmFjID0gcGFyYW1zLmF1ZGlvQ29udGV4dCB8fCAoX3RoaXMuc3VwcG9ydHNXZWJBdWRpbygpID8gX3RoaXMuZ2V0QXVkaW9Db250ZXh0KCkgOiB7fSk7XG4gICAgLyoqQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmxhc3RQbGF5ID0gX3RoaXMuYWMuY3VycmVudFRpbWU7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnNjaGVkdWxlZFBhdXNlID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnN0YXRlcyA9IChfdGhpcyRzdGF0ZXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlcywgUExBWUlORywgT2JqZWN0LmNyZWF0ZShfdGhpcy5zdGF0ZUJlaGF2aW9yc1tQTEFZSU5HXSkpLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVzLCBQQVVTRUQsIE9iamVjdC5jcmVhdGUoX3RoaXMuc3RhdGVCZWhhdmlvcnNbUEFVU0VEXSkpLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVzLCBGSU5JU0hFRCwgT2JqZWN0LmNyZWF0ZShfdGhpcy5zdGF0ZUJlaGF2aW9yc1tGSU5JU0hFRF0pKSwgX3RoaXMkc3RhdGVzKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5maWx0ZXJzID0gW107XG4gICAgLyoqIGdhaW5Ob2RlOiBhbGxvd3MgdG8gY29udHJvbCBhdWRpbyB2b2x1bWUgKi9cblxuICAgIF90aGlzLmdhaW5Ob2RlID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLm1lcmdlZFBlYWtzID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLm9mZmxpbmVBYyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wZWFrcyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuICAgIC8qKiBhbmFseXNlcjogcHJvdmlkZXMgYXVkaW8gYW5hbHlzaXMgaW5mb3JtYXRpb24gKi9cblxuICAgIF90aGlzLmFuYWx5c2VyID0gbnVsbDtcbiAgICAvKiogc2NyaXB0Tm9kZTogYWxsb3dzIHByb2Nlc3NpbmcgYXVkaW8gKi9cblxuICAgIF90aGlzLnNjcmlwdE5vZGUgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc291cmNlID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnNwbGl0UGVha3MgPSBbXTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnN0YXRlID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmV4cGxpY2l0RHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBiYWNrZW5kIHdhcyBkZXN0cm95ZWQuXG4gICAgICovXG5cbiAgICBfdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIGJhY2tlbmQsIGNhbGxlZCBpbiBgd2F2ZXN1cmZlci5jcmVhdGVCYWNrZW5kKClgXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFdlYkF1ZGlvLCBbe1xuICAgIGtleTogXCJzdXBwb3J0c1dlYkF1ZGlvXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqIHNjcmlwdEJ1ZmZlclNpemU6IHNpemUgb2YgdGhlIHByb2Nlc3NpbmcgYnVmZmVyICovXG5cbiAgICAvKiogYXVkaW9Db250ZXh0OiBhbGxvd3MgdG8gcHJvY2VzcyBhdWRpbyB3aXRoIFdlYkF1ZGlvIEFQSSAqL1xuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCB0aGlzIGJhY2tlbmRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGlzIGJhY2tlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdXBwb3J0c1dlYkF1ZGlvKCkge1xuICAgICAgcmV0dXJuICEhKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXVkaW8gY29udGV4dCB1c2VkIGJ5IHRoaXMgYmFja2VuZCBvciBjcmVhdGUgb25lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBdWRpb0NvbnRleHR9IEV4aXN0aW5nIGF1ZGlvIGNvbnRleHQsIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdWRpb0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXVkaW9Db250ZXh0KCkge1xuICAgICAgaWYgKCF3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dCkge1xuICAgICAgICB3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb2ZmbGluZSBhdWRpbyBjb250ZXh0IHVzZWQgYnkgdGhpcyBiYWNrZW5kIG9yIGNyZWF0ZSBvbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGUgcmF0ZSB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHtPZmZsaW5lQXVkaW9Db250ZXh0fSBFeGlzdGluZyBvZmZsaW5lIGF1ZGlvIGNvbnRleHQsIG9yIGNyZWF0ZXNcbiAgICAgKiBhIG5ldyBvbmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE9mZmxpbmVBdWRpb0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dChzYW1wbGVSYXRlKSB7XG4gICAgICBpZiAoIXdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICB3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0KSgxLCAyLCBzYW1wbGVSYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5jcmVhdGVWb2x1bWVOb2RlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVNjcmlwdE5vZGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlQW5hbHlzZXJOb2RlKCk7XG4gICAgICB0aGlzLnNldFN0YXRlKFBBVVNFRCk7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpO1xuICAgICAgdGhpcy5zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdEZpbHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdEZpbHRlcnMoKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICBmaWx0ZXIgJiYgZmlsdGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG51bGw7IC8vIFJlY29ubmVjdCBkaXJlY3QgcGF0aFxuXG4gICAgICAgIHRoaXMuYW5hbHlzZXIuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZSBUaGUgbmV3IHN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzW3N0YXRlXSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdO1xuICAgICAgICB0aGlzLnN0YXRlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5wYWNrZWQgYHNldEZpbHRlcnMoKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uQXVkaW9Ob2RlfSBmaWx0ZXJzIE9uZSBvciBtb3JlIGZpbHRlcnMgdG8gc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsdGVyKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZpbHRlcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGZpbHRlcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0RmlsdGVycyhmaWx0ZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGN1c3RvbSBXZWIgQXVkaW8gbm9kZXMgaW50byB0aGUgZ3JhcGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXVkaW9Ob2RlW119IGZpbHRlcnMgUGFja2VkIGZpbHRlcnMgYXJyYXlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGxvd3Bhc3MgPSB3YXZlc3VyZmVyLmJhY2tlbmQuYWMuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICogd2F2ZXN1cmZlci5iYWNrZW5kLnNldEZpbHRlcihsb3dwYXNzKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsdGVycyhmaWx0ZXJzKSB7XG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgZmlsdGVyc1xuICAgICAgdGhpcy5kaXNjb25uZWN0RmlsdGVycygpOyAvLyBJbnNlcnQgZmlsdGVycyBpZiBmaWx0ZXIgYXJyYXkgbm90IGVtcHR5XG5cbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7IC8vIERpc2Nvbm5lY3QgZGlyZWN0IHBhdGggYmVmb3JlIGluc2VydGluZyBmaWx0ZXJzXG5cbiAgICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7IC8vIENvbm5lY3QgZWFjaCBmaWx0ZXIgaW4gdHVyblxuXG4gICAgICAgIGZpbHRlcnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgcHJldi5jb25uZWN0KGN1cnIpO1xuICAgICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgICB9LCB0aGlzLmFuYWx5c2VyKS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQ3JlYXRlIFNjcmlwdFByb2Nlc3Nvck5vZGUgdG8gcHJvY2VzcyBhdWRpbyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU2NyaXB0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTY3JpcHROb2RlKCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLmF1ZGlvU2NyaXB0UHJvY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuc2NyaXB0Tm9kZSA9IHRoaXMucGFyYW1zLmF1ZGlvU2NyaXB0UHJvY2Vzc29yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYWMuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgdGhpcy5zY3JpcHROb2RlID0gdGhpcy5hYy5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoV2ViQXVkaW8uc2NyaXB0QnVmZmVyU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zY3JpcHROb2RlID0gdGhpcy5hYy5jcmVhdGVKYXZhU2NyaXB0Tm9kZShXZWJBdWRpby5zY3JpcHRCdWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcmlwdE5vZGUuY29ubmVjdCh0aGlzLmFjLmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRPbkF1ZGlvUHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPbkF1ZGlvUHJvY2VzcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnNjcmlwdE5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lID0gX3RoaXMyLmdldEN1cnJlbnRUaW1lKCk7XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gX3RoaXMyLmdldER1cmF0aW9uKCkpIHtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoRklOSVNIRUQpO1xuXG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgncGF1c2UnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lID49IF90aGlzMi5zY2hlZHVsZWRQYXVzZSkge1xuICAgICAgICAgIF90aGlzMi5wYXVzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzMi5zdGF0ZSA9PT0gX3RoaXMyLnN0YXRlc1tQTEFZSU5HXSkge1xuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2F1ZGlvcHJvY2VzcycsIHRpbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU9uQXVkaW9Qcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU9uQXVkaW9Qcm9jZXNzKCkge1xuICAgICAgdGhpcy5zY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhbmFseXNlciBub2RlIHRvIHBlcmZvcm0gYXVkaW8gYW5hbHlzaXMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUFuYWx5c2VyTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVBbmFseXNlck5vZGUoKSB7XG4gICAgICB0aGlzLmFuYWx5c2VyID0gdGhpcy5hYy5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgdGhpcy5hbmFseXNlci5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGdhaW4gbm9kZSBuZWVkZWQgdG8gY29udHJvbCB0aGUgcGxheWJhY2sgdm9sdW1lLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVWb2x1bWVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVZvbHVtZU5vZGUoKSB7XG4gICAgICAvLyBDcmVhdGUgZ2FpbiBub2RlIHVzaW5nIHRoZSBBdWRpb0NvbnRleHRcbiAgICAgIGlmICh0aGlzLmFjLmNyZWF0ZUdhaW4pIHtcbiAgICAgICAgdGhpcy5nYWluTm9kZSA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nYWluTm9kZSA9IHRoaXMuYWMuY3JlYXRlR2Fpbk5vZGUoKTtcbiAgICAgIH0gLy8gQWRkIHRoZSBnYWluIG5vZGUgdG8gdGhlIGdyYXBoXG5cblxuICAgICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpbmsgaWQgZm9yIHRoZSBtZWRpYSBwbGF5ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCBTdHJpbmcgdmFsdWUgcmVwcmVzZW50aW5nIGF1ZGlvIGRldmljZSBpZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAgd2hlbiB0aGVyZVxuICAgICAqIGFyZSBubyBlcnJvcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTaW5rSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2lua0lkKGRldmljZUlkKSB7XG4gICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3ZWJhdWRpbyBBUEkgZG9lc24ndCBjdXJyZW50bHkgc3VwcG9ydCBzZXR0aW5nIHRoZSBkZXZpY2VcbiAgICAgICAgICogb3V0cHV0LiBIZXJlIHdlIGNyZWF0ZSBhbiBIVE1MQXVkaW9FbGVtZW50LCBjb25uZWN0IHRoZVxuICAgICAgICAgKiB3ZWJhdWRpbyBzdHJlYW0gdG8gdGhhdCBlbGVtZW50IGFuZCBzZXRTaW5rSWQgdGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXVkaW8gPSBuZXcgd2luZG93LkF1ZGlvKCk7XG5cbiAgICAgICAgaWYgKCFhdWRpby5zZXRTaW5rSWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzZXRTaW5rSWQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXInKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdWRpby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5hYy5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoZGVzdCk7XG4gICAgICAgIGF1ZGlvLnNyY09iamVjdCA9IGRlc3Quc3RyZWFtO1xuICAgICAgICByZXR1cm4gYXVkaW8uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgZGV2aWNlSWQ6ICcgKyBkZXZpY2VJZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF1ZGlvIHZvbHVtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZvbHVtZSh2YWx1ZSkge1xuICAgICAgdGhpcy5nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZhbHVlLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZvbHVtZVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSBBIGZsb2F0aW5nIHBvaW50IHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nYWluTm9kZS5nYWluLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXJyYXkgYnVmZmVyIGFuZCBwYXNzIGRhdGEgdG8gYSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheWJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGRlY29kZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGNvbXBsZXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycmJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZXJyb3IuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVBcnJheUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlciwgY2FsbGJhY2ssIGVycmJhY2spIHtcbiAgICAgIGlmICghdGhpcy5vZmZsaW5lQWMpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lQWMgPSB0aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQodGhpcy5hYyAmJiB0aGlzLmFjLnNhbXBsZVJhdGUgPyB0aGlzLmFjLnNhbXBsZVJhdGUgOiA0NDEwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnd2Via2l0QXVkaW9Db250ZXh0JyBpbiB3aW5kb3cpIHtcbiAgICAgICAgLy8gU2FmYXJpOiBubyBzdXBwb3J0IGZvciBQcm9taXNlLWJhc2VkIGRlY29kZUF1ZGlvRGF0YSBlbmFibGVkXG4gICAgICAgIC8vIEVuYWJsZSBpdCBpbiBTYWZhcmkgdXNpbmcgdGhlIEV4cGVyaW1lbnRhbCBGZWF0dXJlcyA+IE1vZGVybiBXZWJBdWRpbyBBUEkgb3B0aW9uXG4gICAgICAgIHRoaXMub2ZmbGluZUFjLmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlciwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0sIGVycmJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lQWMuZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGVycmJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBwcmUtZGVjb2RlZCBwZWFrc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBQZWFrcyBkYXRhXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBkdXJhdGlvbiBFeHBsaWNpdCBkdXJhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGVha3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGVha3MocGVha3MsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmV4cGxpY2l0RHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZWFrcyA9IHBlYWtzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlbmRlcmVkIGxlbmd0aCAoZGlmZmVyZW50IGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgYXVkaW8pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSByZW5kZXJlZCBsZW5ndGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgICAvLyBObyByZXNpemUsIHdlIGNhbiBwcmVzZXJ2ZSB0aGUgY2FjaGVkIHBlYWtzLlxuICAgICAgaWYgKHRoaXMubWVyZ2VkUGVha3MgJiYgbGVuZ3RoID09IDIgKiB0aGlzLm1lcmdlZFBlYWtzLmxlbmd0aCAtIDEgKyAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcGxpdFBlYWtzID0gW107XG4gICAgICB0aGlzLm1lcmdlZFBlYWtzID0gW107IC8vIFNldCB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBzcGFyc2UgYXJyYXkgc28gdGhlIHBlYWsgYXJyYXlzIGFyZVxuICAgICAgLy8gYXBwcm9wcmlhdGVseSBzaXplZCBmb3Igb3RoZXIgY2FsY3VsYXRpb25zLlxuXG4gICAgICB2YXIgY2hhbm5lbHMgPSB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgOiAxO1xuICAgICAgdmFyIGM7XG5cbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjaGFubmVsczsgYysrKSB7XG4gICAgICAgIHRoaXMuc3BsaXRQZWFrc1tjXSA9IFtdO1xuICAgICAgICB0aGlzLnNwbGl0UGVha3NbY11bMiAqIChsZW5ndGggLSAxKV0gPSAwO1xuICAgICAgICB0aGlzLnNwbGl0UGVha3NbY11bMiAqIChsZW5ndGggLSAxKSArIDFdID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZXJnZWRQZWFrc1syICogKGxlbmd0aCAtIDEpXSA9IDA7XG4gICAgICB0aGlzLm1lcmdlZFBlYWtzWzIgKiAobGVuZ3RoIC0gMSkgKyAxXSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG1heCBhbmQgbWluIHZhbHVlIG9mIHRoZSB3YXZlZm9ybSB3aGVuIGJyb2tlbiBpbnRvIDxsZW5ndGg+IHN1YnJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggSG93IG1hbnkgc3VicmFuZ2VzIHRvIGJyZWFrIHRoZSB3YXZlZm9ybSBpbnRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdCBGaXJzdCBzYW1wbGUgaW4gdGhlIHJlcXVpcmVkIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0IExhc3Qgc2FtcGxlIGluIHRoZSByZXF1aXJlZCByYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBBcnJheSBvZiAyKjxsZW5ndGg+IHBlYWtzIG9yIGFycmF5IG9mIGFycmF5cyBvZlxuICAgICAqIHBlYWtzIGNvbnNpc3Rpbmcgb2YgKG1heCwgbWluKSB2YWx1ZXMgZm9yIGVhY2ggc3VicmFuZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQZWFrcyhsZW5ndGgsIGZpcnN0LCBsYXN0KSB7XG4gICAgICBpZiAodGhpcy5wZWFrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWFrcztcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGZpcnN0ID0gZmlyc3QgfHwgMDtcbiAgICAgIGxhc3QgPSBsYXN0IHx8IGxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnNldExlbmd0aChsZW5ndGgpO1xuXG4gICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzID8gdGhpcy5zcGxpdFBlYWtzIDogdGhpcy5tZXJnZWRQZWFrcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZvbGxvd2luZyBzbmlwcGV0IGZpeGVzIGEgYnVmZmVyaW5nIGRhdGEgaXNzdWUgb24gdGhlIFNhZmFyaVxuICAgICAgICogYnJvd3NlciB3aGljaCByZXR1cm5lZCB1bmRlZmluZWQgSXQgY3JlYXRlcyB0aGUgbWlzc2luZyBidWZmZXIgYmFzZWRcbiAgICAgICAqIG9uIDEgY2hhbm5lbCwgNDA5NiBzYW1wbGVzIGFuZCB0aGUgc2FtcGxlUmF0ZSBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgKiB3ZWJhdWRpbyBjb250ZXh0IDQwOTYgc2FtcGxlcyBzZWVtZWQgdG8gYmUgdGhlIGJlc3QgZml0IGZvciByZW5kZXJpbmdcbiAgICAgICAqIHdpbGwgcmV2aWV3IHRoaXMgY29kZSBvbmNlIGEgc3RhYmxlIHZlcnNpb24gb2YgU2FmYXJpIFRQIGlzIG91dFxuICAgICAgICovXG5cblxuICAgICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0J1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKDEsIDQwOTYsIHRoaXMuc2FtcGxlUmF0ZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyLmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNhbXBsZVNpemUgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLyBsZW5ndGg7XG4gICAgICB2YXIgc2FtcGxlU3RlcCA9IH5+KHNhbXBsZVNpemUgLyAxMCkgfHwgMTtcbiAgICAgIHZhciBjaGFubmVscyA9IHRoaXMuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICB2YXIgYztcblxuICAgICAgZm9yIChjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgdmFyIHBlYWtzID0gdGhpcy5zcGxpdFBlYWtzW2NdO1xuICAgICAgICB2YXIgY2hhbiA9IHRoaXMuYnVmZmVyLmdldENoYW5uZWxEYXRhKGMpO1xuICAgICAgICB2YXIgaSA9IHZvaWQgMDtcblxuICAgICAgICBmb3IgKGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB+fihpICogc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgdmFyIGVuZCA9IH5+KHN0YXJ0ICsgc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgbWF4IGFuZCBtaW4gdG8gdGhlIGZpcnN0IHNhbXBsZSBvZiB0aGlzXG4gICAgICAgICAgICogc3VicmFuZ2UsIHNvIHRoYXQgZXZlbiBpZiB0aGUgc2FtcGxlcyBhcmUgZW50aXJlbHlcbiAgICAgICAgICAgKiBvbiBvbmUgc2lkZSBvZiB6ZXJvLCB3ZSBzdGlsbCByZXR1cm4gdGhlIHRydWUgbWF4IGFuZFxuICAgICAgICAgICAqIG1pbiB2YWx1ZXMgaW4gdGhlIHN1YnJhbmdlLlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgdmFyIG1pbiA9IGNoYW5bc3RhcnRdO1xuICAgICAgICAgIHZhciBtYXggPSBtaW47XG4gICAgICAgICAgdmFyIGogPSB2b2lkIDA7XG5cbiAgICAgICAgICBmb3IgKGogPSBzdGFydDsgaiA8IGVuZDsgaiArPSBzYW1wbGVTdGVwKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuW2pdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZWFrc1syICogaV0gPSBtYXg7XG4gICAgICAgICAgcGVha3NbMiAqIGkgKyAxXSA9IG1pbjtcblxuICAgICAgICAgIGlmIChjID09IDAgfHwgbWF4ID4gdGhpcy5tZXJnZWRQZWFrc1syICogaV0pIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VkUGVha3NbMiAqIGldID0gbWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09IDAgfHwgbWluIDwgdGhpcy5tZXJnZWRQZWFrc1syICogaSArIDFdKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlZFBlYWtzWzIgKiBpICsgMV0gPSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzID8gdGhpcy5zcGxpdFBlYWtzIDogdGhpcy5tZXJnZWRQZWFrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBmcm9tIDAgdG8gMVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBQb3NpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWVkUGVyY2VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWVkUGVyY2VudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXRQbGF5ZWRQZXJjZW50cy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RTb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdFNvdXJjZSgpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYWxsIHJlZmVyZW5jZXMgd2l0aCBXZWJBdWRpbywgZGlzY29ubmVjdGluZyBhdWRpbyBub2RlcyBhbmQgY2xvc2luZyBBdWRpbyBDb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95V2ViQXVkaW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveVdlYkF1ZGlvKCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0RmlsdGVycygpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0U291cmNlKCk7XG4gICAgICB0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKTsgLy8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCBpZiBjbG9zZUF1ZGlvQ29udGV4dCBvcHRpb24gaXMgc2V0IHRvIHRydWVcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmNsb3NlQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydHMgQXVkaW9Db250ZXh0LmNsb3NlKClcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFjLmNsb3NlID09PSAnZnVuY3Rpb24nICYmIHRoaXMuYWMuc3RhdGUgIT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICB0aGlzLmFjLmNsb3NlKCk7XG4gICAgICAgIH0gLy8gY2xlYXIgdGhlIHJlZmVyZW5jZSB0byB0aGUgYXVkaW9jb250ZXh0XG5cblxuICAgICAgICB0aGlzLmFjID0gbnVsbDsgLy8gY2xlYXIgdGhlIGFjdHVhbCBhdWRpb2NvbnRleHQsIGVpdGhlciBwYXNzZWQgYXMgcGFyYW0gb3IgdGhlXG4gICAgICAgIC8vIGdsb2JhbCBzaW5nbGV0b25cblxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgIHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmFtcy5hdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9IC8vIGNsZWFyIHRoZSBvZmZsaW5lQXVkaW9Db250ZXh0XG5cblxuICAgICAgICB3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHdhdmVzdXJmZXIgaXMgZGVzdHJveWVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAoIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5BbGwoKTtcbiAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVzdHJveVdlYkF1ZGlvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRlZCBhIGRlY29kZWQgYXVkaW8gYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYnVmZmVyIERlY29kZWQgYXVkaW8gYnVmZmVyIHRvIGxvYWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChidWZmZXIpIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLmxhc3RQbGF5ID0gdGhpcy5hYy5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoKTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU291cmNlKCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0U291cmNlKCk7XG4gICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuYWMuY3JlYXRlQnVmZmVyU291cmNlKCk7IC8vIGFkanVzdCBmb3Igb2xkIGJyb3dzZXJzXG5cbiAgICAgIHRoaXMuc291cmNlLnN0YXJ0ID0gdGhpcy5zb3VyY2Uuc3RhcnQgfHwgdGhpcy5zb3VyY2Uubm90ZUdyYWluT247XG4gICAgICB0aGlzLnNvdXJjZS5zdG9wID0gdGhpcy5zb3VyY2Uuc3RvcCB8fCB0aGlzLnNvdXJjZS5ub3RlT2ZmO1xuICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wbGF5YmFja1JhdGUpO1xuICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogc29tZSBicm93c2VycyByZXF1aXJlIGFuIGV4cGxpY2l0IGNhbGwgdG8gI3Jlc3VtZSBiZWZvcmUgdGhleSB3aWxsIHBsYXkgYmFjayBhdWRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdW1lQXVkaW9Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZUF1ZGlvQ29udGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLmFjLnN0YXRlID09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIHRoaXMuYWMucmVzdW1lICYmIHRoaXMuYWMucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuaXNQbGF5aW5nKClgIGFuZCBgd2F2ZXN1cmZlci5wbGF5UGF1c2UoKWBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoaXMgYmFja2VuZCBpcyBjdXJyZW50bHkgcGF1c2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1BhdXNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlc1tQTEFZSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpYFxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBEdXJhdGlvbiBvZiBsb2FkZWQgYnVmZmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV4cGxpY2l0RHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXREdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLnNlZWtUbygpYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFBvc2l0aW9uIHRvIHN0YXJ0IGF0IGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFBvc2l0aW9uIHRvIGVuZCBhdCBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gT2JqZWN0IGNvbnRhaW5pbmcgc3RhcnQgYW5kIGVuZFxuICAgICAqIHBvc2l0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Vla1RvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWtUbyhzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2hlZHVsZWRQYXVzZSA9IG51bGw7XG5cbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5nZXRDdXJyZW50VGltZSgpO1xuXG4gICAgICAgIGlmIChzdGFydCA+PSB0aGlzLmdldER1cmF0aW9uKCkpIHtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICB0aGlzLmxhc3RQbGF5ID0gdGhpcy5hYy5jdXJyZW50VGltZTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzW0ZJTklTSEVEXSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFBBVVNFRCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGxheWJhY2sgcG9zaXRpb24gaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGxheWJhY2sgcG9zaXRpb24gaW4gc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWVkVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5ZWRUaW1lKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmFjLmN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UGxheSkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIGxvYWRlZCBhdWRpbyByZWdpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0IGluIHNlY29uZHMsIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIGNsaXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBXaGVuIHRvIHN0b3AgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIGNsaXAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG5lZWQgdG8gcmUtY3JlYXRlIHNvdXJjZSBvbiBlYWNoIHBsYXliYWNrXG5cblxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoKTtcbiAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0aGlzLnNlZWtUbyhzdGFydCwgZW5kKTtcbiAgICAgIHN0YXJ0ID0gYWRqdXN0ZWRUaW1lLnN0YXJ0O1xuICAgICAgZW5kID0gYWRqdXN0ZWRUaW1lLmVuZDtcbiAgICAgIHRoaXMuc2NoZWR1bGVkUGF1c2UgPSBlbmQ7XG4gICAgICB0aGlzLnNvdXJjZS5zdGFydCgwLCBzdGFydCk7XG4gICAgICB0aGlzLnJlc3VtZUF1ZGlvQ29udGV4dCgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShQTEFZSU5HKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbGF5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgbG9hZGVkIGF1ZGlvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlZFBhdXNlID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiArPSB0aGlzLmdldFBsYXllZFRpbWUoKTtcbiAgICAgIHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLnN0b3AoMCk7XG4gICAgICB0aGlzLnNldFN0YXRlKFBBVVNFRCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGF1c2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgcmVsYXRpdmUgdG8gdGhlIGF1ZGlvLWNsaXAnc1xuICAgICAqIGR1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCB0aW1lIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0Q3VycmVudFRpbWUuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLiAoMD1ubyBwbGF5YmFjaywgMT1ub3JtYWwgcGxheWJhY2spXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5YmFja1JhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXVkaW8gc291cmNlIHBsYXliYWNrIHJhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHBsYXliYWNrIHJhdGUgdG8gdXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheWJhY2tSYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlIHx8IDE7XG4gICAgICB0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUodGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBwb2ludCBpbiBzZWNvbmRzIGZvciBwbGF5YmFjayB0byBzdG9wIGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBQb3NpdGlvbiB0byBlbmQgYXRcbiAgICAgKiBAdmVyc2lvbiAzLjMuMFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5RW5kKGVuZCkge1xuICAgICAgdGhpcy5zY2hlZHVsZWRQYXVzZSA9IGVuZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViQXVkaW87XG59KHV0aWwuT2JzZXJ2ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJBdWRpbztcbldlYkF1ZGlvLnNjcmlwdEJ1ZmZlclNpemUgPSAyNTY7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZGVib3VuY2UvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZGVib3VuY2UvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy4gVGhlIGZ1bmN0aW9uIGFsc28gaGFzIGEgcHJvcGVydHkgJ2NsZWFyJyBcbiAqIHRoYXQgaXMgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGNsZWFyIHRoZSB0aW1lciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2NoZWR1bGVkIGV4ZWN1dGlvbnMuIFxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSl7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgaWYgKG51bGwgPT0gd2FpdCkgd2FpdCA9IDEwMDtcblxuICBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRlYm91bmNlZCA9IGZ1bmN0aW9uKCl7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZGVib3VuY2VkLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgXG4gIGRlYm91bmNlZC5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG5cbi8vIEFkZHMgY29tcGF0aWJpbGl0eSBmb3IgRVMgbW9kdWxlc1xuZGVib3VuY2UuZGVib3VuY2UgPSBkZWJvdW5jZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvd2F2ZXN1cmZlci5qc1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXZlc3VyZmVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5qcyIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyBjdXJzb3IgcGx1Z2luIDUuMS4wICgyMDIxLTA2LTIwKVxuICogaHR0cHM6Ly93YXZlc3VyZmVyLWpzLm9yZ1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiV2F2ZVN1cmZlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJXYXZlU3VyZmVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIldhdmVTdXJmZXJcIl0gPSByb290W1wiV2F2ZVN1cmZlclwiXSB8fCB7fSwgcm9vdFtcIldhdmVTdXJmZXJcIl1bXCJjdXJzb3JcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvcGx1Z2luL2N1cnNvci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9jdXJzb3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXJzb3JQbHVnaW5QYXJhbXNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRlZmVySW5pdCBTZXQgdG8gdHJ1ZSB0byBzdG9wIGF1dG8gaW5pdCBpbiBgYWRkUGx1Z2luKClgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZGVPbkJsdXI9dHJ1ZSBIaWRlIHRoZSBjdXJzb3Igd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZVxuICogd2F2ZWZvcm1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB3aWR0aD0nMXB4JyBUaGUgd2lkdGggb2YgdGhlIGN1cnNvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbG9yPSdibGFjaycgVGhlIGNvbG9yIG9mIHRoZSBjdXJzb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcGFjaXR5PScwLjI1JyBUaGUgb3BhY2l0eSBvZiB0aGUgY3Vyc29yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGU9J3NvbGlkJyBUaGUgYm9yZGVyIHN0eWxlIG9mIHRoZSBjdXJzb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6SW5kZXg9MyBUaGUgei1pbmRleCBvZiB0aGUgY3Vyc29yIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjdXN0b21TdHlsZSBBbiBvYmplY3Qgd2l0aCBjdXN0b20gc3R5bGVzIHdoaWNoIGFyZSBhcHBsaWVkXG4gKiB0byB0aGUgY3Vyc29yIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd1RpbWU9ZmFsc2UgU2hvdyB0aGUgdGltZSBvbiB0aGUgY3Vyc29yLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGN1c3RvbVNob3dUaW1lU3R5bGUgQW4gb2JqZWN0IHdpdGggY3VzdG9tIHN0eWxlcyB3aGljaCBhcmVcbiAqIGFwcGxpZWQgdG8gdGhlIGN1cnNvciB0aW1lIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZm9sbG93Q3Vyc29yWT1mYWxzZSBVc2UgYHRydWVgIHRvIG1ha2UgdGhlIHRpbWUgb25cbiAqIHRoZSBjdXJzb3IgZm9sbG93IHRoZSB4IGFuZCB0aGUgeS1wb3NpdGlvbiBvZiB0aGUgbW91c2UuIFVzZSBgZmFsc2VgIHRvIG1ha2UgdGhlXG4gKiBpdCBvbmx5IGZvbGxvdyB0aGUgeC1wb3NpdGlvbiBvZiB0aGUgbW91c2UuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBmb3JtYXRUaW1lQ2FsbGJhY2sgRm9ybWF0cyB0aGUgdGltZXN0YW1wIG9uIHRoZSBjdXJzb3IuXG4gKi9cblxuLyoqXG4gKiBEaXNwbGF5cyBhIHRoaW4gbGluZSBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnNvciBvbiB0aGUgd2F2ZWZvcm0uXG4gKlxuICogQGltcGxlbWVudHMge1BsdWdpbkNsYXNzfVxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICogQGV4YW1wbGVcbiAqIC8vIGVzNlxuICogaW1wb3J0IEN1cnNvclBsdWdpbiBmcm9tICd3YXZlc3VyZmVyLmN1cnNvci5qcyc7XG4gKlxuICogLy8gY29tbW9uanNcbiAqIHZhciBDdXJzb3JQbHVnaW4gPSByZXF1aXJlKCd3YXZlc3VyZmVyLmN1cnNvci5qcycpO1xuICpcbiAqIC8vIGlmIHlvdSBhcmUgdXNpbmcgPHNjcmlwdD4gdGFnc1xuICogdmFyIEN1cnNvclBsdWdpbiA9IHdpbmRvdy5XYXZlU3VyZmVyLmN1cnNvcjtcbiAqXG4gKiAvLyAuLi4gaW5pdGlhbGlzaW5nIHdhdmVzdXJmZXIgd2l0aCB0aGUgcGx1Z2luXG4gKiB2YXIgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHtcbiAqICAgLy8gd2F2ZXN1cmZlciBvcHRpb25zIC4uLlxuICogICBwbHVnaW5zOiBbXG4gKiAgICAgQ3Vyc29yUGx1Z2luLmNyZWF0ZSh7XG4gKiAgICAgICAvLyBwbHVnaW4gb3B0aW9ucyAuLi5cbiAqICAgICB9KVxuICogICBdXG4gKiB9KTtcbiAqL1xudmFyIEN1cnNvclBsdWdpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIHBsdWdpbiBjbGFzcy4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIGBDdXJzb3JQbHVnaW4uY3JlYXRlYFxuICAgKiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0N1cnNvclBsdWdpblBhcmFtc30gcGFyYW1zIFBsdWdpbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB3cyBXYXZlc3VyZmVyIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBDdXJzb3JQbHVnaW4ocGFyYW1zLCB3cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Vyc29yUGx1Z2luKTtcblxuICAgIHRoaXMuZGVmYXVsdFBhcmFtcyA9IHtcbiAgICAgIGhpZGVPbkJsdXI6IHRydWUsXG4gICAgICB3aWR0aDogJzFweCcsXG4gICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgIG9wYWNpdHk6ICcwLjI1JyxcbiAgICAgIHN0eWxlOiAnc29saWQnLFxuICAgICAgekluZGV4OiA0LFxuICAgICAgY3VzdG9tU3R5bGU6IHt9LFxuICAgICAgY3VzdG9tU2hvd1RpbWVTdHlsZToge30sXG4gICAgICBzaG93VGltZTogZmFsc2UsXG4gICAgICBmb2xsb3dDdXJzb3JZOiBmYWxzZSxcbiAgICAgIGZvcm1hdFRpbWVDYWxsYmFjazogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLl9vbk1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgYmJveCA9IF90aGlzLndhdmVzdXJmZXIuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCAtIGJib3gubGVmdDtcblxuICAgICAgdmFyIGZsaXAgPSBiYm94LnJpZ2h0IDwgZS5jbGllbnRYICsgX3RoaXMub3V0ZXJXaWR0aChfdGhpcy5kaXNwbGF5VGltZSk7XG5cbiAgICAgIGlmIChfdGhpcy5wYXJhbXMuc2hvd1RpbWUgJiYgX3RoaXMucGFyYW1zLmZvbGxvd0N1cnNvclkpIHtcbiAgICAgICAgLy8gZm9sbG93IHktcG9zaXRpb24gb2YgdGhlIG1vdXNlXG4gICAgICAgIHkgPSBlLmNsaWVudFkgLSAoYmJveC50b3AgKyBiYm94LmhlaWdodCAvIDIpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVDdXJzb3JQb3NpdGlvbih4LCB5LCBmbGlwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNob3dDdXJzb3IoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3VzZWxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhpZGVDdXJzb3IoKTtcbiAgICB9O1xuXG4gICAgdGhpcy53YXZlc3VyZmVyID0gd3M7XG4gICAgdGhpcy5zdHlsZSA9IHdzLnV0aWwuc3R5bGU7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnNvciBIVE1MIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHs/SFRNTEVsZW1lbnR9XG4gICAgICovXG5cbiAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIHRpbWUgbmV4dCB0byB0aGUgY3Vyc29yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7P0hUTUxFbGVtZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy5zaG93VGltZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIGh0bWwgY29udGFpbmVyIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSB0aW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7P0hUTUxFbGVtZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy5kaXNwbGF5VGltZSA9IG51bGw7XG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRQYXJhbXMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIHBsdWdpbiAodXNlZCBieSB0aGUgUGx1Z2luIEFQSSlcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ3Vyc29yUGx1Z2luLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSB0aGlzLndhdmVzdXJmZXIuY29udGFpbmVyO1xuICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXJzb3InKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IHRoaXMucGFyYW1zLnpJbmRleCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHdpZHRoOiAnMCcsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgYm9yZGVyUmlnaHRTdHlsZTogdGhpcy5wYXJhbXMuc3R5bGUsXG4gICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRoaXMucGFyYW1zLndpZHRoLFxuICAgICAgICBib3JkZXJSaWdodENvbG9yOiB0aGlzLnBhcmFtcy5jb2xvcixcbiAgICAgICAgb3BhY2l0eTogdGhpcy5wYXJhbXMub3BhY2l0eSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LCB0aGlzLnBhcmFtcy5jdXN0b21TdHlsZSkpKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnNob3dUaW1lKSB7XG4gICAgICAgIHRoaXMuc2hvd1RpbWUgPSB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzaG93VGl0bGUnKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgekluZGV4OiB0aGlzLnBhcmFtcy56SW5kZXgsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIG9wYWNpdHk6IHRoaXMucGFyYW1zLm9wYWNpdHksXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgIH0sIHRoaXMucGFyYW1zLmN1c3RvbVN0eWxlKSkpO1xuICAgICAgICB0aGlzLmRpc3BsYXlUaW1lID0gdGhpcy5zaG93VGltZS5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lJyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgbWFyZ2luOiAnYXV0bycsXG4gICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicgLy8gaW5pdGlhbCB2YWx1ZSB3aWxsIGJlIGhpZGRlbiBqdXN0IGZvciBtZWFzdXJpbmcgcHVycG9zZVxuXG4gICAgICAgIH0sIHRoaXMucGFyYW1zLmN1c3RvbVNob3dUaW1lU3R5bGUpKSk7IC8vIGluaXRpYWwgdmFsdWUgdG8gbWVhc3VyZSBkaXNwbGF5IHdpZHRoXG5cbiAgICAgICAgdGhpcy5kaXNwbGF5VGltZS5pbm5lckhUTUwgPSB0aGlzLmZvcm1hdFRpbWUoMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlbW92ZSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5oaWRlT25CbHVyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBlbGVtZW50cyBhcmUgaGlkZGVuIGluaXRpYWxseVxuICAgICAgICB0aGlzLmhpZGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9vbk1vdXNlZW50ZXIpO1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uTW91c2VsZWF2ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHBsdWdpbiAodXNlZCBieSB0aGUgUGx1Z2luIEFQSSlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5zaG93VGltZSkge1xuICAgICAgICB0aGlzLmN1cnNvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2hvd1RpbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnNvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Vyc29yKTtcbiAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlbW92ZSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5oaWRlT25CbHVyKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZWVudGVyKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbk1vdXNlbGVhdmUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhwb3MgVGhlIHggb2Zmc2V0IG9mIHRoZSBjdXJzb3IgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlwb3MgVGhlIHkgb2Zmc2V0IG9mIHRoZSBjdXJzb3IgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGlwIEZsYWcgdG8gZmxpcCBkdXJhdGlvbiB0ZXh0IGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ3Vyc29yUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yUG9zaXRpb24oeHBvcywgeXBvcykge1xuICAgICAgdmFyIGZsaXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLmN1cnNvciwge1xuICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdCh4cG9zLCBcInB4XCIpXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnNob3dUaW1lKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci53aWR0aCAvIHRoaXMud2F2ZXN1cmZlci5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICAgICAgdmFyIHNjcm9sbFdpZHRoID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci5nZXRTY3JvbGxYKCk7XG4gICAgICAgIHZhciBzY3JvbGxUaW1lID0gZHVyYXRpb24gLyB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndpZHRoICogc2Nyb2xsV2lkdGg7XG4gICAgICAgIHZhciB0aW1lVmFsdWUgPSBNYXRoLm1heCgwLCB4cG9zIC8gZWxlbWVudFdpZHRoICogZHVyYXRpb24pICsgc2Nyb2xsVGltZTtcbiAgICAgICAgdmFyIGZvcm1hdFZhbHVlID0gdGhpcy5mb3JtYXRUaW1lKHRpbWVWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGZsaXApIHtcbiAgICAgICAgICB2YXIgdGV4dE9mZnNldCA9IHRoaXMub3V0ZXJXaWR0aCh0aGlzLmRpc3BsYXlUaW1lKTtcbiAgICAgICAgICB4cG9zIC09IHRleHRPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlKHRoaXMuc2hvd1RpbWUsIHtcbiAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdCh4cG9zLCBcInB4XCIpLFxuICAgICAgICAgIHRvcDogXCJcIi5jb25jYXQoeXBvcywgXCJweFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmRpc3BsYXlUaW1lLCB7XG4gICAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlUaW1lLmlubmVySFRNTCA9IFwiXCIuY29uY2F0KGZvcm1hdFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgY3Vyc29yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93Q3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dDdXJzb3IoKSB7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMuY3Vyc29yLCB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5zaG93VGltZSkge1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMuc2hvd1RpbWUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGN1cnNvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZUN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQ3Vyc29yKCkge1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLmN1cnNvciwge1xuICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuc2hvd1RpbWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLnNob3dUaW1lLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIHRpbWVzdGFtcCBmb3IgYGN1cnNvclRpbWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnNvclRpbWUgVGltZSBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIHRpbWVzdGFtcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRUaW1lKGN1cnNvclRpbWUpIHtcbiAgICAgIGN1cnNvclRpbWUgPSBpc05hTihjdXJzb3JUaW1lKSA/IDAgOiBjdXJzb3JUaW1lO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuZm9ybWF0VGltZUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5mb3JtYXRUaW1lQ2FsbGJhY2soY3Vyc29yVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbY3Vyc29yVGltZV0ubWFwKGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5mbG9vcih0aW1lICUgMzYwMCAvIDYwKSwgLy8gbWludXRlc1xuICAgICAgICAoJzAwJyArIE1hdGguZmxvb3IodGltZSAlIDYwKSkuc2xpY2UoLTIpLCAvLyBzZWNvbmRzXG4gICAgICAgICgnMDAwJyArIE1hdGguZmxvb3IodGltZSAlIDEgKiAxMDAwKSkuc2xpY2UoLTMpIC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICBdLmpvaW4oJzonKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3V0ZXIgd2lkdGggb2YgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IERPTSBFbGVtZW50XG4gICAgICogQHJldHVybnMge251bWJlcn0gb3V0ZXIgd2lkdGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm91dGVyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCArIHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBDdXJzb3IgcGx1Z2luIGRlZmluaXRpb24gZmFjdG9yeVxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gY3JlYXRlIGEgcGx1Z2luIGRlZmluaXRpb24gd2hpY2ggY2FuIGJlXG4gICAgICogdXNlZCBieSB3YXZlc3VyZmVyIHRvIGNvcnJlY3RseSBpbnN0YW50aWF0ZSB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7Q3Vyc29yUGx1Z2luUGFyYW1zfSBwYXJhbXMgcGFyYW1ldGVycyB1c2UgdG8gaW5pdGlhbGlzZSB0aGVcbiAgICAgKiBwbHVnaW5cbiAgICAgKiBAcmV0dXJuIHtQbHVnaW5EZWZpbml0aW9ufSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwbHVnaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocGFyYW1zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnY3Vyc29yJyxcbiAgICAgICAgZGVmZXJJbml0OiBwYXJhbXMgJiYgcGFyYW1zLmRlZmVySW5pdCA/IHBhcmFtcy5kZWZlckluaXQgOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHN0YXRpY1Byb3BzOiB7fSxcbiAgICAgICAgaW5zdGFuY2U6IEN1cnNvclBsdWdpblxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0N1cnNvclBsdWdpblBhcmFtc31cbiAgICAgKi9cblxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnNvclBsdWdpbjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3Vyc29yUGx1Z2luO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wbHVnaW4vY3Vyc29yL2luZGV4LmpzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVzdXJmZXIuY3Vyc29yLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIuY3Vyc29yLmpzIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIHJlZ2lvbnMgcGx1Z2luIDUuMS4wICgyMDIxLTA2LTIwKVxuICogaHR0cHM6Ly93YXZlc3VyZmVyLWpzLm9yZ1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiV2F2ZVN1cmZlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJXYXZlU3VyZmVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIldhdmVTdXJmZXJcIl0gPSByb290W1wiV2F2ZVN1cmZlclwiXSB8fCB7fSwgcm9vdFtcIldhdmVTdXJmZXJcIl1bXCJyZWdpb25zXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9yZWdpb25zL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9yZWdpb25zL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlZ2lvbi5qcyAqLyBcIi4vc3JjL3BsdWdpbi9yZWdpb25zL3JlZ2lvbi5qc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogUmVnaW9ucyBhcmUgdmlzdWFsIG92ZXJsYXlzIG9uIHdhdmVmb3JtIHRoYXQgY2FuIGJlIHVzZWQgdG8gcGxheSBhbmQgbG9vcFxuICogcG9ydGlvbnMgb2YgYXVkaW8uIFJlZ2lvbnMgY2FuIGJlIGRyYWdnZWQgYW5kIHJlc2l6ZWQuXG4gKlxuICogVmlzdWFsIGN1c3RvbWl6YXRpb24gaXMgcG9zc2libGUgdmlhIENTUyAodXNpbmcgdGhlIHNlbGVjdG9yc1xuICogYC53YXZlc3VyZmVyLXJlZ2lvbmAgYW5kIGAud2F2ZXN1cmZlci1oYW5kbGVgKS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7UGx1Z2luQ2xhc3N9XG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVzNlxuICogaW1wb3J0IFJlZ2lvbnNQbHVnaW4gZnJvbSAnd2F2ZXN1cmZlci5yZWdpb25zLmpzJztcbiAqXG4gKiAvLyBjb21tb25qc1xuICogdmFyIFJlZ2lvbnNQbHVnaW4gPSByZXF1aXJlKCd3YXZlc3VyZmVyLnJlZ2lvbnMuanMnKTtcbiAqXG4gKiAvLyBpZiB5b3UgYXJlIHVzaW5nIDxzY3JpcHQ+IHRhZ3NcbiAqIHZhciBSZWdpb25zUGx1Z2luID0gd2luZG93LldhdmVTdXJmZXIucmVnaW9ucztcbiAqXG4gKiAvLyAuLi4gaW5pdGlhbGlzaW5nIHdhdmVzdXJmZXIgd2l0aCB0aGUgcGx1Z2luXG4gKiB2YXIgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHtcbiAqICAgLy8gd2F2ZXN1cmZlciBvcHRpb25zIC4uLlxuICogICBwbHVnaW5zOiBbXG4gKiAgICAgUmVnaW9uc1BsdWdpbi5jcmVhdGUoe1xuICogICAgICAgLy8gcGx1Z2luIG9wdGlvbnMgLi4uXG4gKiAgICAgfSlcbiAqICAgXVxuICogfSk7XG4gKi9cbnZhciBSZWdpb25zUGx1Z2luID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnaW9uc1BsdWdpbihwYXJhbXMsIHdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWdpb25zUGx1Z2luKTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMud2F2ZXN1cmZlciA9IHdzO1xuICAgIHRoaXMudXRpbCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgd3MudXRpbCksIHt9LCB7XG4gICAgICBnZXRSZWdpb25TbmFwVG9HcmlkVmFsdWU6IGZ1bmN0aW9uIGdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKHZhbHVlLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWF4UmVnaW9ucyA9IHBhcmFtcy5tYXhSZWdpb25zO1xuICAgIHRoaXMucmVnaW9uc01pbkxlbmd0aCA9IHBhcmFtcy5yZWdpb25zTWluTGVuZ3RoIHx8IG51bGw7IC8vIHR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZSBpbnRvIGFuIG9ic2VydmVyXG5cbiAgICB2YXIgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy51dGlsLk9ic2VydmVyLnByb3RvdHlwZSk7XG4gICAgb2JzZXJ2ZXJQcm90b3R5cGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX3JlZ2lvbi5SZWdpb24ucHJvdG90eXBlW2tleV0gPSBfdGhpcy51dGlsLk9ic2VydmVyLnByb3RvdHlwZVtrZXldO1xuICAgIH0pO1xuICAgIHRoaXMud2F2ZXN1cmZlci5SZWdpb24gPSBfcmVnaW9uLlJlZ2lvbjsgLy8gQnkgZGVmYXVsdCwgc2Nyb2xsIHRoZSBjb250YWluZXIgaWYgdGhlIHVzZXIgZHJhZ3MgYSByZWdpb25cbiAgICAvLyB3aXRoaW4gNSUgb2YgaXRzIGVkZ2VcblxuICAgIHZhciBzY3JvbGxXaWR0aFByb3BvcnRpb24gPSAwLjA1O1xuXG4gICAgdGhpcy5fb25CYWNrZW5kQ3JlYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLndyYXBwZXIgPSBfdGhpcy53YXZlc3VyZmVyLmRyYXdlci53cmFwcGVyO1xuICAgICAgX3RoaXMub3JpZW50YXRpb24gPSBfdGhpcy53YXZlc3VyZmVyLmRyYXdlci5vcmllbnRhdGlvbjtcblxuICAgICAgaWYgKF90aGlzLnBhcmFtcy5yZWdpb25zKSB7XG4gICAgICAgIF90aGlzLnBhcmFtcy5yZWdpb25zLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICAgIHJlZ2lvbi5lZGdlU2Nyb2xsV2lkdGggPSBfdGhpcy5wYXJhbXMuZWRnZVNjcm9sbFdpZHRoIHx8IF90aGlzLndyYXBwZXIuY2xpZW50V2lkdGggKiBzY3JvbGxXaWR0aFByb3BvcnRpb247XG5cbiAgICAgICAgICBfdGhpcy5hZGQocmVnaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTsgLy8gSWQtYmFzZWQgaGFzaCBvZiByZWdpb25zXG5cblxuICAgIHRoaXMubGlzdCA9IHt9O1xuXG4gICAgdGhpcy5fb25SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLndyYXBwZXIgPSBfdGhpcy53YXZlc3VyZmVyLmRyYXdlci53cmFwcGVyO1xuICAgICAgX3RoaXMudmVydGljYWwgPSBfdGhpcy53YXZlc3VyZmVyLmRyYXdlci5wYXJhbXMudmVydGljYWw7XG5cbiAgICAgIGlmIChfdGhpcy5wYXJhbXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICBfdGhpcy5lbmFibGVEcmFnU2VsZWN0aW9uKF90aGlzLnBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKF90aGlzLmxpc3QpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIF90aGlzLmxpc3RbaWRdLnVwZGF0ZVJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZWdpb25zUGx1Z2luLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAvLyBDaGVjayBpZiB3cyBpcyByZWFkeVxuICAgICAgaWYgKHRoaXMud2F2ZXN1cmZlci5pc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX29uQmFja2VuZENyZWF0ZWQoKTtcblxuICAgICAgICB0aGlzLl9vblJlYWR5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIub25jZSgncmVhZHknLCB0aGlzLl9vblJlYWR5KTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLm9uY2UoJ2JhY2tlbmQtY3JlYXRlZCcsIHRoaXMuX29uQmFja2VuZENyZWF0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ3JlYWR5JywgdGhpcy5fb25SZWFkeSk7XG4gICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ2JhY2tlbmQtY3JlYXRlZCcsIHRoaXMuX29uQmFja2VuZENyZWF0ZWQpO1xuICAgICAgdGhpcy5kaXNhYmxlRHJhZ1NlbGVjdGlvbigpO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGVjayB0byBzZWUgaWYgYWRkaW5nIGEgbmV3IHJlZ2lvbiB3b3VsZCBleGNlZWQgbWF4UmVnaW9uc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgd2Ugc2hvdWxkIHByb2NlZWQgYW5kIGNyZWF0ZSBhIHJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3b3VsZEV4Y2VlZE1heFJlZ2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd291bGRFeGNlZWRNYXhSZWdpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF4UmVnaW9ucyAmJiBPYmplY3Qua2V5cyh0aGlzLmxpc3QpLmxlbmd0aCA+PSB0aGlzLm1heFJlZ2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlZ2lvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBSZWdpb24gcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge1JlZ2lvbn0gVGhlIGNyZWF0ZWQgcmVnaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHBhcmFtcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLndvdWxkRXhjZWVkTWF4UmVnaW9ucygpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5taW5MZW5ndGggJiYgdGhpcy5yZWdpb25zTWluTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgICBtaW5MZW5ndGg6IHRoaXMucmVnaW9uc01pbkxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lvbiA9IG5ldyB0aGlzLndhdmVzdXJmZXIuUmVnaW9uKHBhcmFtcywgdGhpcy51dGlsLCB0aGlzLndhdmVzdXJmZXIpO1xuICAgICAgdGhpcy5saXN0W3JlZ2lvbi5pZF0gPSByZWdpb247XG4gICAgICByZWdpb24ub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5saXN0W3JlZ2lvbi5pZF07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWdpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgcmVnaW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBfdGhpczMubGlzdFtpZF0ucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRHJhZ1NlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVEcmFnU2VsZWN0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBzbG9wID0gcGFyYW1zLnNsb3AgfHwgMjtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmNvbnRhaW5lcjtcbiAgICAgIHZhciBzY3JvbGwgPSBwYXJhbXMuc2Nyb2xsICE9PSBmYWxzZSAmJiB0aGlzLndhdmVzdXJmZXIucGFyYW1zLnNjcm9sbFBhcmVudDtcbiAgICAgIHZhciBzY3JvbGxTcGVlZCA9IHBhcmFtcy5zY3JvbGxTcGVlZCB8fCAxO1xuICAgICAgdmFyIHNjcm9sbFRocmVzaG9sZCA9IHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQgfHwgMTA7XG4gICAgICB2YXIgZHJhZztcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgdmFyIG1heFNjcm9sbDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciByZWdpb247XG4gICAgICB2YXIgdG91Y2hJZDtcbiAgICAgIHZhciBweE1vdmUgPSAwO1xuICAgICAgdmFyIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgIHZhciB3cmFwcGVyUmVjdDsgLy8gU2Nyb2xsIHdoZW4gdGhlIHVzZXIgaXMgZHJhZ2dpbmcgd2l0aGluIHRoZSB0aHJlc2hvbGRcblxuICAgICAgdmFyIGVkZ2VTY3JvbGwgPSBmdW5jdGlvbiBlZGdlU2Nyb2xsKGUpIHtcbiAgICAgICAgaWYgKCFyZWdpb24gfHwgIXNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG5cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IF90aGlzNC53cmFwcGVyLnNjcm9sbExlZnQgKyBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgX3RoaXM0LndyYXBwZXIuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQgPSBNYXRoLm1pbihtYXhTY3JvbGwsIE1hdGgubWF4KDAsIHNjcm9sbExlZnQpKTsgLy8gVXBkYXRlIHJhbmdlXG5cbiAgICAgICAgdmFyIGVuZCA9IF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlKTtcblxuICAgICAgICByZWdpb24udXBkYXRlKHtcbiAgICAgICAgICBzdGFydDogTWF0aC5taW4oZW5kICogZHVyYXRpb24sIHN0YXJ0ICogZHVyYXRpb24pLFxuICAgICAgICAgIGVuZDogTWF0aC5tYXgoZW5kICogZHVyYXRpb24sIHN0YXJ0ICogZHVyYXRpb24pXG4gICAgICAgIH0pOyAvLyBDaGVjayB0aGF0IHRoZXJlIGlzIG1vcmUgdG8gc2Nyb2xsIGFuZCByZXBlYXRcblxuICAgICAgICBpZiAoc2Nyb2xsTGVmdCA8IG1heFNjcm9sbCAmJiBzY3JvbGxMZWZ0ID4gMCkge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWRnZVNjcm9sbChlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGV2ZW50RG93biA9IGZ1bmN0aW9uIGV2ZW50RG93bihlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkdXJhdGlvbiA9IF90aGlzNC53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgIHRvdWNoSWQgPSBlLnRhcmdldFRvdWNoZXMgPyBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciA6IG51bGw7IC8vIFN0b3JlIGZvciBzY3JvbGwgY2FsY3VsYXRpb25zXG5cbiAgICAgICAgbWF4U2Nyb2xsID0gX3RoaXM0LndyYXBwZXIuc2Nyb2xsV2lkdGggLSBfdGhpczQud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgd3JhcHBlclJlY3QgPSBfdGhpczQudXRpbC53aXRoT3JpZW50YXRpb24oX3RoaXM0LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIF90aGlzNC52ZXJ0aWNhbCk7XG4gICAgICAgIGRyYWcgPSB0cnVlO1xuICAgICAgICBzdGFydCA9IF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChlLCB0cnVlKTtcbiAgICAgICAgcmVnaW9uID0gbnVsbDtcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudERvd24pO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuICAgICAgdGhpcy5vbignZGlzYWJsZS1kcmFnLXNlbGVjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50RG93bik7XG5cbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnREb3duKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZXZlbnRVcCA9IGZ1bmN0aW9uIGV2ZW50VXAoZSkge1xuICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZyA9IGZhbHNlO1xuICAgICAgICBweE1vdmUgPSAwO1xuICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgIGlmIChyZWdpb24pIHtcbiAgICAgICAgICBfdGhpczQudXRpbC5wcmV2ZW50Q2xpY2soKTtcblxuICAgICAgICAgIHJlZ2lvbi5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBlKTtcblxuICAgICAgICAgIF90aGlzNC53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXVwZGF0ZS1lbmQnLCByZWdpb24sIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaW9uID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZXZlbnRVcCk7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcbiAgICAgIHRoaXMub24oJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG5cbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcblxuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG5cbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGV2ZW50VXApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBldmVudE1vdmUgPSBmdW5jdGlvbiBldmVudE1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFkcmFnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrcHhNb3ZlIDw9IHNsb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcyAmJiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgIT0gdG91Y2hJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBhdXRvLWNyZWF0ZSBhIHJlZ2lvbiBkdXJpbmcgbW91c2UgZHJhZywgdW5sZXNzIHJlZ2lvbi1jb3VudCB3b3VsZCBleGNlZWQgXCJtYXhSZWdpb25zXCJcblxuXG4gICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgcmVnaW9uID0gX3RoaXM0LmFkZChwYXJhbXMgfHwge30pO1xuXG4gICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGV2ZW50KTtcblxuICAgICAgICB2YXIgc3RhcnRVcGRhdGUgPSBfdGhpczQud2F2ZXN1cmZlci5yZWdpb25zLnV0aWwuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKHN0YXJ0ICogZHVyYXRpb24pO1xuXG4gICAgICAgIHZhciBlbmRVcGRhdGUgPSBfdGhpczQud2F2ZXN1cmZlci5yZWdpb25zLnV0aWwuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKGVuZCAqIGR1cmF0aW9uKTtcblxuICAgICAgICByZWdpb24udXBkYXRlKHtcbiAgICAgICAgICBzdGFydDogTWF0aC5taW4oZW5kVXBkYXRlLCBzdGFydFVwZGF0ZSksXG4gICAgICAgICAgZW5kOiBNYXRoLm1heChlbmRVcGRhdGUsIHN0YXJ0VXBkYXRlKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb3JpZW50ZWRFdmVudCA9IF90aGlzNC51dGlsLndpdGhPcmllbnRhdGlvbihldmVudCwgX3RoaXM0LnZlcnRpY2FsKTsgLy8gSWYgc2Nyb2xsaW5nIGlzIGVuYWJsZWRcblxuXG4gICAgICAgIGlmIChzY3JvbGwgJiYgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgX3RoaXM0LndyYXBwZXIuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAvLyBDaGVjayB0aHJlc2hvbGQgYmFzZWQgb24gbW91c2VcbiAgICAgICAgICB2YXIgeCA9IG9yaWVudGVkRXZlbnQuY2xpZW50WCAtIHdyYXBwZXJSZWN0LmxlZnQ7XG5cbiAgICAgICAgICBpZiAoeCA8PSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeCA+PSB3cmFwcGVyUmVjdC5yaWdodCAtIHNjcm9sbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gJiYgZWRnZVNjcm9sbChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudE1vdmUpO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudE1vdmUpO1xuXG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci5vbigncmVnaW9uLWNyZWF0ZWQnLCBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICAgIGlmIChfdGhpczQucmVnaW9uc01pbkxlbmd0aCkge1xuICAgICAgICAgIHJlZ2lvbi5taW5MZW5ndGggPSBfdGhpczQucmVnaW9uc01pbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVEcmFnU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVEcmFnU2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgcmVnaW9uXG4gICAgICpcbiAgICAgKiBUaGUgc21hbGxlc3QgcmVnaW9uIHRoYXQgY29udGFpbnMgdGhlIGN1cnJlbnQgdGltZS4gSWYgc2V2ZXJhbCBzdWNoXG4gICAgICogcmVnaW9ucyBleGlzdCwgdGFrZSB0aGUgZmlyc3QuIFJldHVybiBgbnVsbGAgaWYgbm9uZSBleGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSZWdpb259IFRoZSBjdXJyZW50IHJlZ2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VycmVudFJlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50UmVnaW9uKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciB0aW1lID0gdGhpcy53YXZlc3VyZmVyLmdldEN1cnJlbnRUaW1lKCk7XG4gICAgICB2YXIgbWluID0gbnVsbDtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGN1ciA9IF90aGlzNS5saXN0W2lkXTtcblxuICAgICAgICBpZiAoY3VyLnN0YXJ0IDw9IHRpbWUgJiYgY3VyLmVuZCA+PSB0aW1lKSB7XG4gICAgICAgICAgaWYgKCFtaW4gfHwgY3VyLmVuZCAtIGN1ci5zdGFydCA8IG1pbi5lbmQgLSBtaW4uc3RhcnQpIHtcbiAgICAgICAgICAgIG1pbiA9IGN1cjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggdGhlIHZhbHVlIHRvIHRoZSBncmlkLCBpZiByZXF1aXJlZFxuICAgICAqXG4gICAgICogSWYgdGhlIHJlZ2lvbnMgcGx1Z2luIHBhcmFtcyBoYXZlIGEgc25hcFRvR3JpZEludGVydmFsIHNldCwgcmV0dXJuIHRoZVxuICAgICAqIHZhbHVlIG1hdGNoaW5nIHRoZSBuZWFyZXN0IGdyaWQgaW50ZXJ2YWwuIElmIG5vIHNuYXBUb0dyaWRJbnRlcnZhbCBpcyBzZXQsXG4gICAgICogdGhlIHBhc3NlZCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSB0byBzbmFwIHRvIHRoZSBncmlkLCBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIHRoZSByZWdpb25zIHBsdWdpbiBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLnNuYXBUb0dyaWRJbnRlcnZhbCkge1xuICAgICAgICAvLyB0aGUgcmVnaW9ucyBzaG91bGQgc25hcCB0byBhIGdyaWRcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcmFtcy5zbmFwVG9HcmlkT2Zmc2V0IHx8IDA7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSAtIG9mZnNldCkgLyBwYXJhbXMuc25hcFRvR3JpZEludGVydmFsKSAqIHBhcmFtcy5zbmFwVG9HcmlkSW50ZXJ2YWwgKyBvZmZzZXQ7XG4gICAgICB9IC8vIG5vIHNuYXAtdG8tZ3JpZFxuXG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBSZWdpb25zIHBsdWdpbiBkZWZpbml0aW9uIGZhY3RvcnlcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHBsdWdpbiBkZWZpbml0aW9uIHdoaWNoIGNhbiBiZVxuICAgICAqIHVzZWQgYnkgd2F2ZXN1cmZlciB0byBjb3JyZWN0bHkgaW5zdGFudGlhdGUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnaW9uc1BsdWdpblBhcmFtc30gcGFyYW1zIHBhcmFtZXRlcnMgdXNlIHRvIGluaXRpYWxpc2UgdGhlIHBsdWdpblxuICAgICAqIEByZXR1cm4ge1BsdWdpbkRlZmluaXRpb259IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsdWdpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdyZWdpb25zJyxcbiAgICAgICAgZGVmZXJJbml0OiBwYXJhbXMgJiYgcGFyYW1zLmRlZmVySW5pdCA/IHBhcmFtcy5kZWZlckluaXQgOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHN0YXRpY1Byb3BzOiB7XG4gICAgICAgICAgYWRkUmVnaW9uOiBmdW5jdGlvbiBhZGRSZWdpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdC5yZWdpb25zKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5pdFBsdWdpbigncmVnaW9ucycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25zLmFkZChvcHRpb25zKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyUmVnaW9uczogZnVuY3Rpb24gY2xlYXJSZWdpb25zKCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpb25zICYmIHRoaXMucmVnaW9ucy5jbGVhcigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5hYmxlRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24gZW5hYmxlRHJhZ1NlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0LnJlZ2lvbnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbml0UGx1Z2luKCdyZWdpb25zJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVnaW9ucy5lbmFibGVEcmFnU2VsZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzYWJsZURyYWdTZWxlY3Rpb246IGZ1bmN0aW9uIGRpc2FibGVEcmFnU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpb25zLmRpc2FibGVEcmFnU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZTogUmVnaW9uc1BsdWdpblxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVnaW9uc1BsdWdpbjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVnaW9uc1BsdWdpbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wbHVnaW4vcmVnaW9ucy9yZWdpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9yZWdpb25zL3JlZ2lvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlJlZ2lvbiA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqICBAc2luY2UgNC4wLjBcbiAqXG4gKiAoU2luZ2xlKSBSZWdpb24gcGx1Z2luIGNsYXNzXG4gKlxuICogTXVzdCBiZSB0dXJuZWQgaW50byBhbiBvYnNlcnZlciBiZWZvcmUgaW5zdGFudGlhdGluZy4gVGhpcyBpcyBkb25lIGluXG4gKiBgUmVnaW9uc1BsdWdpbmAgKG1haW4gcGx1Z2luIGNsYXNzKS5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cbnZhciBSZWdpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWdpb24ocGFyYW1zLCByZWdpb25zVXRpbHMsIHdzKSB7XG4gICAgdmFyIF9wYXJhbXMkc2hvd1Rvb2x0aXAsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWdpb24pO1xuXG4gICAgdGhpcy53YXZlc3VyZmVyID0gd3M7XG4gICAgdGhpcy53cmFwcGVyID0gd3MuZHJhd2VyLndyYXBwZXI7XG4gICAgdGhpcy51dGlsID0gd3MudXRpbDtcbiAgICB0aGlzLnN0eWxlID0gdGhpcy51dGlsLnN0eWxlO1xuICAgIHRoaXMucmVnaW9uc1V0aWwgPSByZWdpb25zVXRpbHM7XG4gICAgdGhpcy52ZXJ0aWNhbCA9IHdzLmRyYXdlci5wYXJhbXMudmVydGljYWw7XG4gICAgdGhpcy5pZCA9IHBhcmFtcy5pZCA9PSBudWxsID8gd3MudXRpbC5nZXRJZCgpIDogcGFyYW1zLmlkO1xuICAgIHRoaXMuc3RhcnQgPSBOdW1iZXIocGFyYW1zLnN0YXJ0KSB8fCAwO1xuICAgIHRoaXMuZW5kID0gcGFyYW1zLmVuZCA9PSBudWxsID8gLy8gc21hbGwgbWFya2VyLWxpa2UgcmVnaW9uXG4gICAgdGhpcy5zdGFydCArIDQgLyB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggKiB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKSA6IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICB0aGlzLnJlc2l6ZSA9IHBhcmFtcy5yZXNpemUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBCb29sZWFuKHBhcmFtcy5yZXNpemUpO1xuICAgIHRoaXMuZHJhZyA9IHBhcmFtcy5kcmFnID09PSB1bmRlZmluZWQgPyB0cnVlIDogQm9vbGVhbihwYXJhbXMuZHJhZyk7IC8vIHJlZmxlY3QgcmVzaXplIGFuZCBkcmFnIHN0YXRlIG9mIHJlZ2lvbiBmb3IgcmVnaW9uLXVwZGF0ZWQgbGlzdGVuZXJcblxuICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ocGFyYW1zLmxvb3ApO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgJ3JnYmEoMCwgMCwgMCwgMC4xKSc7IC8vIFRoZSBsZWZ0IGFuZCByaWdodCBoYW5kbGVTdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgdG8gJ25vbmUnIGZvclxuICAgIC8vIG5vIHN0eWxpbmcgb3IgY2FuIGJlIGFzc2lnbmVkIGFuIG9iamVjdCBjb250YWluaW5nIENTUyBwcm9wZXJ0aWVzLlxuXG4gICAgdGhpcy5oYW5kbGVTdHlsZSA9IHBhcmFtcy5oYW5kbGVTdHlsZSB8fCB7XG4gICAgICBsZWZ0OiB7fSxcbiAgICAgIHJpZ2h0OiB7fVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVMZWZ0RWwgPSBudWxsO1xuICAgIHRoaXMuaGFuZGxlUmlnaHRFbCA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1zLmRhdGEgfHwge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMgfHwge307XG4gICAgdGhpcy5zaG93VG9vbHRpcCA9IChfcGFyYW1zJHNob3dUb29sdGlwID0gcGFyYW1zLnNob3dUb29sdGlwKSAhPT0gbnVsbCAmJiBfcGFyYW1zJHNob3dUb29sdGlwICE9PSB2b2lkIDAgPyBfcGFyYW1zJHNob3dUb29sdGlwIDogdHJ1ZTtcbiAgICB0aGlzLm1heExlbmd0aCA9IHBhcmFtcy5tYXhMZW5ndGg7IC8vIEl0IGFzc3VtZXMgdGhlIG1pbkxlbmd0aCBwYXJhbWV0ZXIgdmFsdWUsIG9yIHRoZSByZWdpb25zTWluTGVuZ3RoIHBhcmFtZXRlciB2YWx1ZSwgaWYgdGhlIGZpcnN0IG9uZSBub3QgcHJvdmlkZWRcblxuICAgIHRoaXMubWluTGVuZ3RoID0gcGFyYW1zLm1pbkxlbmd0aDtcblxuICAgIHRoaXMuX29uUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZVJlbmRlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNjcm9sbCA9IHBhcmFtcy5zY3JvbGwgIT09IGZhbHNlICYmIHdzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IHBhcmFtcy5zY3JvbGxTcGVlZCB8fCAxO1xuICAgIHRoaXMuc2Nyb2xsVGhyZXNob2xkID0gcGFyYW1zLnNjcm9sbFRocmVzaG9sZCB8fCAxMDsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb250ZXh0IG1lbnUgaXMgcHJldmVudGVkIGZyb20gYmVpbmcgb3BlbmVkLlxuXG4gICAgdGhpcy5wcmV2ZW50Q29udGV4dE1lbnUgPSBwYXJhbXMucHJldmVudENvbnRleHRNZW51ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IEJvb2xlYW4ocGFyYW1zLnByZXZlbnRDb250ZXh0TWVudSk7IC8vIHNlbGVjdCBjaGFubmVsIElEIHRvIHNldCByZWdpb25cblxuICAgIHZhciBjaGFubmVsSWR4ID0gcGFyYW1zLmNoYW5uZWxJZHggPT0gbnVsbCA/IC0xIDogcGFyc2VJbnQocGFyYW1zLmNoYW5uZWxJZHgpO1xuICAgIHRoaXMucmVnaW9uSGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMubWFyZ2luVG9wID0gJzBweCc7XG5cbiAgICBpZiAoY2hhbm5lbElkeCAhPT0gLTEpIHtcbiAgICAgIHZhciBjaGFubmVsQ291bnQgPSB0aGlzLndhdmVzdXJmZXIuYmFja2VuZC5idWZmZXIgIT0gbnVsbCA/IHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzIDogLTE7XG5cbiAgICAgIGlmIChjaGFubmVsQ291bnQgPj0gMCAmJiBjaGFubmVsSWR4IDwgY2hhbm5lbENvdW50KSB7XG4gICAgICAgIHRoaXMucmVnaW9uSGVpZ2h0ID0gTWF0aC5mbG9vcigxIC8gY2hhbm5lbENvdW50ICogMTAwKSArICclJztcbiAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLndhdmVzdXJmZXIuZ2V0SGVpZ2h0KCkgKiBjaGFubmVsSWR4ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdFRpbWVDYWxsYmFjayA9IHBhcmFtcy5mb3JtYXRUaW1lQ2FsbGJhY2s7XG4gICAgdGhpcy5lZGdlU2Nyb2xsV2lkdGggPSBwYXJhbXMuZWRnZVNjcm9sbFdpZHRoO1xuICAgIHRoaXMuYmluZEluT3V0KCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLndhdmVzdXJmZXIub24oJ3pvb20nLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgdGhpcy53YXZlc3VyZmVyLm9uKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLWNyZWF0ZWQnLCB0aGlzKTtcbiAgfVxuICAvKiBVcGRhdGUgcmVnaW9uIHBhcmFtcy4gKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhSZWdpb24sIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IE51bWJlcihwYXJhbXMuc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5kID0gTnVtYmVyKHBhcmFtcy5lbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmxvb3AgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvb3AgPSBCb29sZWFuKHBhcmFtcy5sb29wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jb2xvciAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuaGFuZGxlU3R5bGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmhhbmRsZVN0eWxlID0gcGFyYW1zLmhhbmRsZVN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yZXNpemUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlc1Jlc2l6ZSh0aGlzLnJlc2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuZHJhZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZHJhZyA9IEJvb2xlYW4ocGFyYW1zLmRyYWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLm1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5tYXhMZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLm1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gTnVtYmVyKHBhcmFtcy5taW5MZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBwYXJhbXMuYXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVSZW5kZXIoKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi11cGRhdGVkJywgdGhpcyk7XG4gICAgfVxuICAgIC8qIFJlbW92ZSBhIHNpbmdsZSByZWdpb24uICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50LmRvbUVsZW1lbnQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgncmVtb3ZlJyk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci51bignem9vbScsIHRoaXMuX29uUmVkcmF3KTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCdyZWRyYXcnLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1yZW1vdmVkJywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIGF1ZGlvIHJlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgT3B0aW9uYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXlpbmcgYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShzdGFydCkge1xuICAgICAgdmFyIHMgPSBzdGFydCB8fCB0aGlzLnN0YXJ0O1xuICAgICAgdGhpcy53YXZlc3VyZmVyLnBsYXkocywgdGhpcy5lbmQpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1wbGF5JywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIGF1ZGlvIHJlZ2lvbiBpbiBhIGxvb3AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IE9wdGlvbmFsIG9mZnNldCB0byBzdGFydCBwbGF5aW5nIGF0XG4gICAgICogKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlMb29wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXlMb29wKHN0YXJ0KSB7XG4gICAgICB0aGlzLmxvb3AgPSB0cnVlO1xuICAgICAgdGhpcy5wbGF5KHN0YXJ0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGxvb3Bpbmcgb24vb2ZmLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCBUcnVlIGlmIHNob3VsZCBwbGF5IGluIGxvb3BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldExvb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9vcChsb29wKSB7XG4gICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgIH1cbiAgICAvKiBSZW5kZXIgYSByZWdpb24gYXMgYSBET00gZWxlbWVudC4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLnV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWdpb24nKSksIHRoaXMudmVydGljYWwpO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9ICd3YXZlc3VyZmVyLXJlZ2lvbic7XG5cbiAgICAgIGlmICh0aGlzLnNob3dUb29sdGlwKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IHRoaXMuZm9ybWF0VGltZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCB0aGlzLmlkKTtcblxuICAgICAgZm9yICh2YXIgYXR0cm5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVnaW9uLScgKyBhdHRybmFtZSwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3R5bGUodGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgIGhlaWdodDogdGhpcy5yZWdpb25IZWlnaHQsXG4gICAgICAgIHRvcDogdGhpcy5tYXJnaW5Ub3BcbiAgICAgIH0pO1xuICAgICAgLyogUmVzaXplIGhhbmRsZXMgKi9cblxuICAgICAgaWYgKHRoaXMucmVzaXplKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTGVmdEVsID0gdGhpcy51dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGFuZGxlJykpLCB0aGlzLnZlcnRpY2FsKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSaWdodEVsID0gdGhpcy51dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGFuZGxlJykpLCB0aGlzLnZlcnRpY2FsKTtcbiAgICAgICAgdGhpcy5oYW5kbGVMZWZ0RWwuY2xhc3NOYW1lID0gJ3dhdmVzdXJmZXItaGFuZGxlIHdhdmVzdXJmZXItaGFuZGxlLXN0YXJ0JztcbiAgICAgICAgdGhpcy5oYW5kbGVSaWdodEVsLmNsYXNzTmFtZSA9ICd3YXZlc3VyZmVyLWhhbmRsZSB3YXZlc3VyZmVyLWhhbmRsZS1lbmQnOyAvLyBEZWZhdWx0IENTUyBwcm9wZXJ0aWVzIGZvciBib3RoIGhhbmRsZXMuXG5cbiAgICAgICAgdmFyIGNzcyA9IHtcbiAgICAgICAgICBjdXJzb3I6IHRoaXMudmVydGljYWwgPyAncm93LXJlc2l6ZScgOiAnY29sLXJlc2l6ZScsXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAnMHB4JyxcbiAgICAgICAgICB3aWR0aDogJzJweCcsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAxKSdcbiAgICAgICAgfTsgLy8gTWVyZ2UgQ1NTIHByb3BlcnRpZXMgcGVyIGhhbmRsZS5cblxuICAgICAgICB2YXIgaGFuZGxlTGVmdENzcyA9IHRoaXMuaGFuZGxlU3R5bGUubGVmdCAhPT0gJ25vbmUnID8gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgbGVmdDogJzBweCdcbiAgICAgICAgfSwgY3NzLCB0aGlzLmhhbmRsZVN0eWxlLmxlZnQpIDogbnVsbDtcbiAgICAgICAgdmFyIGhhbmRsZVJpZ2h0Q3NzID0gdGhpcy5oYW5kbGVTdHlsZS5yaWdodCAhPT0gJ25vbmUnID8gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgcmlnaHQ6ICcwcHgnXG4gICAgICAgIH0sIGNzcywgdGhpcy5oYW5kbGVTdHlsZS5yaWdodCkgOiBudWxsO1xuXG4gICAgICAgIGlmIChoYW5kbGVMZWZ0Q3NzKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmhhbmRsZUxlZnRFbCwgaGFuZGxlTGVmdENzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlUmlnaHRDc3MpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKHRoaXMuaGFuZGxlUmlnaHRFbCwgaGFuZGxlUmlnaHRDc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUmVuZGVyKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRUaW1lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1hdFRpbWVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRUaW1lQ2FsbGJhY2soc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoc3RhcnQgPT0gZW5kID8gW3N0YXJ0XSA6IFtzdGFydCwgZW5kXSkubWFwKGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5mbG9vcih0aW1lICUgMzYwMCAvIDYwKSwgLy8gbWludXRlc1xuICAgICAgICAoJzAwJyArIE1hdGguZmxvb3IodGltZSAlIDYwKSkuc2xpY2UoLTIpIC8vIHNlY29uZHNcbiAgICAgICAgXS5qb2luKCc6Jyk7XG4gICAgICB9KS5qb2luKCctJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud2lkdGggLyB0aGlzLndhdmVzdXJmZXIucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgfVxuICAgIC8qIFVwZGF0ZSBlbGVtZW50J3MgcG9zaXRpb24sIHdpZHRoLCBjb2xvci4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVSZW5kZXIoKSB7XG4gICAgICAvLyBkdXJhdGlvbiB2YXJpZXMgZHVyaW5nIGxvYWRpbmcgcHJvY2Vzcywgc28gZG9uJ3Qgb3ZlcndyaXRlIGltcG9ydGFudCBkYXRhXG4gICAgICB2YXIgZHVyID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICB2YXIgc3RhcnRMaW1pdGVkID0gdGhpcy5zdGFydDtcbiAgICAgIHZhciBlbmRMaW1pdGVkID0gdGhpcy5lbmQ7XG5cbiAgICAgIGlmIChzdGFydExpbWl0ZWQgPCAwKSB7XG4gICAgICAgIHN0YXJ0TGltaXRlZCA9IDA7XG4gICAgICAgIGVuZExpbWl0ZWQgPSBlbmRMaW1pdGVkIC0gc3RhcnRMaW1pdGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kTGltaXRlZCA+IGR1cikge1xuICAgICAgICBlbmRMaW1pdGVkID0gZHVyO1xuICAgICAgICBzdGFydExpbWl0ZWQgPSBkdXIgLSAoZW5kTGltaXRlZCAtIHN0YXJ0TGltaXRlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIGVuZExpbWl0ZWQgPSBNYXRoLm1heChzdGFydExpbWl0ZWQgKyB0aGlzLm1pbkxlbmd0aCwgZW5kTGltaXRlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIGVuZExpbWl0ZWQgPSBNYXRoLm1pbihzdGFydExpbWl0ZWQgKyB0aGlzLm1heExlbmd0aCwgZW5kTGltaXRlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlZnQgYW5kIHdpZHRoIHZhbHVlcyBvZiB0aGUgcmVnaW9uIHN1Y2ggdGhhdFxuICAgICAgICAvLyBubyBnYXBzIGFwcGVhciBiZXR3ZWVuIHJlZ2lvbnMuXG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5yb3VuZChzdGFydExpbWl0ZWQgLyBkdXIgKiB3aWR0aCk7XG4gICAgICAgIHZhciByZWdpb25XaWR0aCA9IE1hdGgucm91bmQoZW5kTGltaXRlZCAvIGR1ciAqIHdpZHRoKSAtIGxlZnQ7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgbGVmdDogbGVmdCArICdweCcsXG4gICAgICAgICAgd2lkdGg6IHJlZ2lvbldpZHRoICsgJ3B4JyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgY3Vyc29yOiB0aGlzLmRyYWcgPyAnbW92ZScgOiAnZGVmYXVsdCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYXR0cm5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1yZWdpb24tJyArIGF0dHJuYW1lLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cm5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dUb29sdGlwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnRpdGxlID0gdGhpcy5mb3JtYXRUaW1lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBCaW5kIGF1ZGlvIGV2ZW50cy4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJpbmRJbk91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kSW5PdXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5maXJlZEluID0gZmFsc2U7XG4gICAgICB0aGlzLmZpcmVkT3V0ID0gZmFsc2U7XG5cbiAgICAgIHZhciBvblByb2Nlc3MgPSBmdW5jdGlvbiBvblByb2Nlc3ModGltZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLnJvdW5kKF90aGlzMi5zdGFydCAqIDEwKSAvIDEwO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5yb3VuZChfdGhpczIuZW5kICogMTApIC8gMTA7XG4gICAgICAgIHRpbWUgPSBNYXRoLnJvdW5kKHRpbWUgKiAxMCkgLyAxMDtcblxuICAgICAgICBpZiAoIV90aGlzMi5maXJlZE91dCAmJiBfdGhpczIuZmlyZWRJbiAmJiAoc3RhcnQgPiB0aW1lIHx8IGVuZCA8PSB0aW1lKSkge1xuICAgICAgICAgIF90aGlzMi5maXJlZE91dCA9IHRydWU7XG4gICAgICAgICAgX3RoaXMyLmZpcmVkSW4gPSBmYWxzZTtcblxuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ291dCcpO1xuXG4gICAgICAgICAgX3RoaXMyLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tb3V0JywgX3RoaXMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMyLmZpcmVkSW4gJiYgc3RhcnQgPD0gdGltZSAmJiBlbmQgPiB0aW1lKSB7XG4gICAgICAgICAgX3RoaXMyLmZpcmVkSW4gPSB0cnVlO1xuICAgICAgICAgIF90aGlzMi5maXJlZE91dCA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnaW4nKTtcblxuICAgICAgICAgIF90aGlzMi53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLWluJywgX3RoaXMyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy53YXZlc3VyZmVyLmJhY2tlbmQub24oJ2F1ZGlvcHJvY2VzcycsIG9uUHJvY2Vzcyk7XG4gICAgICB0aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi53YXZlc3VyZmVyLmJhY2tlbmQudW4oJ2F1ZGlvcHJvY2VzcycsIG9uUHJvY2Vzcyk7XG4gICAgICB9KTtcbiAgICAgIC8qIExvb3AgcGxheWJhY2suICovXG5cbiAgICAgIHRoaXMub24oJ291dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5sb29wKSB7XG4gICAgICAgICAgdmFyIHJlYWxUaW1lID0gX3RoaXMyLndhdmVzdXJmZXIuZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgICAgICAgIGlmIChyZWFsVGltZSA+PSBfdGhpczIuc3RhcnQgJiYgcmVhbFRpbWUgPD0gX3RoaXMyLmVuZCkge1xuICAgICAgICAgICAgX3RoaXMyLndhdmVzdXJmZXIucGxheShfdGhpczIuc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEJpbmQgRE9NIGV2ZW50cy4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJldmVudENvbnRleHRNZW51ID0gdGhpcy5wcmV2ZW50Q29udGV4dE1lbnU7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ21vdXNlZW50ZXInLCBlKTtcblxuICAgICAgICBfdGhpczMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1tb3VzZWVudGVyJywgX3RoaXMzLCBlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdtb3VzZWxlYXZlJywgZSk7XG5cbiAgICAgICAgX3RoaXMzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tbW91c2VsZWF2ZScsIF90aGlzMywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdjbGljaycsIGUpO1xuXG4gICAgICAgIF90aGlzMy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLWNsaWNrJywgX3RoaXMzLCBlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ2RibGNsaWNrJywgZSk7XG5cbiAgICAgICAgX3RoaXMzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tZGJsY2xpY2snLCBfdGhpczMsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAocHJldmVudENvbnRleHRNZW51KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnY29udGV4dG1lbnUnLCBlKTtcblxuICAgICAgICBfdGhpczMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jb250ZXh0bWVudScsIF90aGlzMywgZSk7XG4gICAgICB9KTtcbiAgICAgIC8qIERyYWcgb3IgcmVzaXplIG9uIG1vdXNlbW92ZS4gKi9cblxuICAgICAgaWYgKHRoaXMuZHJhZyB8fCB0aGlzLnJlc2l6ZSkge1xuICAgICAgICB0aGlzLmJpbmREcmFnRXZlbnRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmREcmFnRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmREcmFnRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmNvbnRhaW5lcjtcbiAgICAgIHZhciBzY3JvbGxTcGVlZCA9IHRoaXMuc2Nyb2xsU3BlZWQ7XG4gICAgICB2YXIgc2Nyb2xsVGhyZXNob2xkID0gdGhpcy5zY3JvbGxUaHJlc2hvbGQ7XG4gICAgICB2YXIgc3RhcnRUaW1lO1xuICAgICAgdmFyIHRvdWNoSWQ7XG4gICAgICB2YXIgZHJhZztcbiAgICAgIHZhciBtYXhTY3JvbGw7XG4gICAgICB2YXIgcmVzaXplO1xuICAgICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBzY3JvbGxEaXJlY3Rpb247XG4gICAgICB2YXIgd3JhcHBlclJlY3Q7XG4gICAgICB2YXIgcmVnaW9uTGVmdEhhbGZUaW1lO1xuICAgICAgdmFyIHJlZ2lvblJpZ2h0SGFsZlRpbWU7IC8vIFNjcm9sbCB3aGVuIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHdpdGhpbiB0aGUgdGhyZXNob2xkXG5cbiAgICAgIHZhciBlZGdlU2Nyb2xsID0gZnVuY3Rpb24gZWRnZVNjcm9sbChldmVudCkge1xuICAgICAgICB2YXIgb3JpZW50ZWRFdmVudCA9IF90aGlzNC51dGlsLndpdGhPcmllbnRhdGlvbihldmVudCwgX3RoaXM0LnZlcnRpY2FsKTtcblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczQud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICAgIGlmICghc2Nyb2xsRGlyZWN0aW9uIHx8ICFkcmFnICYmICFyZXNpemUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IG9yaWVudGVkRXZlbnQuY2xpZW50WDtcbiAgICAgICAgdmFyIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlID0gMDtcbiAgICAgICAgdmFyIHJlZ2lvbkhhbGZUaW1lV2lkdGggPSAwO1xuICAgICAgICB2YXIgYWRqdXN0bWVudCA9IDA7IC8vIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBtb3VzZSBwb3NpdGlvblxuXG4gICAgICAgIHZhciB0aW1lID0gX3RoaXM0LnJlZ2lvbnNVdGlsLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZShfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZXZlbnQpICogZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChkcmFnKSB7XG4gICAgICAgICAgLy8gQ29uc2lkZXJpbmcgdGhlIHBvaW50IG9mIGNvbnRhY3Qgd2l0aCB0aGUgcmVnaW9uIHdoaWxlIGVkZ2VzY3JvbGxpbmdcbiAgICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcmVnaW9uSGFsZlRpbWVXaWR0aCA9IHJlZ2lvbkxlZnRIYWxmVGltZSAqIF90aGlzNC53YXZlc3VyZmVyLnBhcmFtcy5taW5QeFBlclNlYztcbiAgICAgICAgICAgIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlID0geCAtIHdyYXBwZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2lvbkhhbGZUaW1lV2lkdGggPSByZWdpb25SaWdodEhhbGZUaW1lICogX3RoaXM0LndhdmVzdXJmZXIucGFyYW1zLm1pblB4UGVyU2VjO1xuICAgICAgICAgICAgZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UgPSB3cmFwcGVyUmVjdC5yaWdodCAtIHg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvbnNpZGVyaW5nIG1pbkxlbmd0aCB3aGlsZSBlZGdlc2Nyb2xsXG4gICAgICAgICAgdmFyIG1pbkxlbmd0aCA9IF90aGlzNC5taW5MZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIW1pbkxlbmd0aCkge1xuICAgICAgICAgICAgbWluTGVuZ3RoID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzaXplID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICBpZiAodGltZSA+IF90aGlzNC5lbmQgLSBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGltZSA9IF90aGlzNC5lbmQgLSBtaW5MZW5ndGg7XG4gICAgICAgICAgICAgIGFkanVzdG1lbnQgPSBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzaXplID09PSAnZW5kJykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPCBfdGhpczQuc3RhcnQgKyBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGltZSA9IF90aGlzNC5zdGFydCArIG1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgYWRqdXN0bWVudCA9IHNjcm9sbFNwZWVkICogc2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRG9uJ3QgZWRnZXNjcm9sbCBpZiByZWdpb24gaGFzIHJlYWNoZWQgbWluIG9yIG1heCBsaW1pdFxuXG5cbiAgICAgICAgdmFyIHdyYXBwZXJTY3JvbGxMZWZ0ID0gX3RoaXM0LndyYXBwZXIuc2Nyb2xsTGVmdDtcblxuICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdyYXBwZXJTY3JvbGxMZWZ0KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdyYXBwZXJTY3JvbGxMZWZ0IC0gcmVnaW9uSGFsZlRpbWVXaWR0aCArIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlKSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdyYXBwZXJTY3JvbGxMZWZ0KSA9PT0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE1hdGgucm91bmQod3JhcHBlclNjcm9sbExlZnQgKyByZWdpb25IYWxmVGltZVdpZHRoIC0gZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UpID49IG1heFNjcm9sbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgc2Nyb2xsIHBvc2l0aW9uXG5cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdyYXBwZXJTY3JvbGxMZWZ0IC0gYWRqdXN0bWVudCArIHNjcm9sbFNwZWVkICogc2Nyb2xsRGlyZWN0aW9uO1xuXG4gICAgICAgIGlmIChzY3JvbGxEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRMZWZ0ID0gTWF0aC5tYXgoMCArIHJlZ2lvbkhhbGZUaW1lV2lkdGggLSBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSwgc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgX3RoaXM0LndyYXBwZXIuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQgPSBjYWxjdWxhdGVkTGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZFJpZ2h0ID0gTWF0aC5taW4obWF4U2Nyb2xsIC0gcmVnaW9uSGFsZlRpbWVXaWR0aCArIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlLCBzY3JvbGxMZWZ0KTtcbiAgICAgICAgICBfdGhpczQud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IGNhbGN1bGF0ZWRSaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IHRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIHN0YXJ0VGltZSA9IHRpbWU7IC8vIENvbnRpbnVlIGRyYWdnaW5nIG9yIHJlc2l6aW5nXG5cbiAgICAgICAgZHJhZyA/IF90aGlzNC5vbkRyYWcoZGVsdGEpIDogX3RoaXM0Lm9uUmVzaXplKGRlbHRhLCByZXNpemUpOyAvLyBSZXBlYXRcblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlZGdlU2Nyb2xsKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25Eb3duID0gZnVuY3Rpb24gb25Eb3duKGV2ZW50KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IF90aGlzNC53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdG91Y2hJZCA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgOiBudWxsOyAvLyBzdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbiwgaWYgdGhpcyByZWdpb24gaXMgcmVzaXphYmxlIG9yIGRyYWdnYWJsZVxuICAgICAgICAvLyBhbmQgdGhlIGV2ZW50IGlzIHRoZXJlZm9yZSBoYW5kbGVkIGhlcmUuXG5cbiAgICAgICAgaWYgKF90aGlzNC5kcmFnIHx8IF90aGlzNC5yZXNpemUpIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgc2VsZWN0ZWQgc3RhcnRUaW1lIHdlIGJlZ3VuIGRyYWdnaW5nIG9yIHJlc2l6aW5nXG5cblxuICAgICAgICBzdGFydFRpbWUgPSBfdGhpczQucmVnaW9uc1V0aWwuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChldmVudCwgdHJ1ZSkgKiBkdXJhdGlvbik7IC8vIFN0b3JlIHRoZSBzZWxlY3RlZCBwb2ludCBvZiBjb250YWN0IHdoZW4gd2UgYmVnaW4gZHJhZ2dpbmdcblxuICAgICAgICByZWdpb25MZWZ0SGFsZlRpbWUgPSBzdGFydFRpbWUgLSBfdGhpczQuc3RhcnQ7XG4gICAgICAgIHJlZ2lvblJpZ2h0SGFsZlRpbWUgPSBfdGhpczQuZW5kIC0gc3RhcnRUaW1lOyAvLyBTdG9yZSBmb3Igc2Nyb2xsIGNhbGN1bGF0aW9uc1xuXG4gICAgICAgIG1heFNjcm9sbCA9IF90aGlzNC53cmFwcGVyLnNjcm9sbFdpZHRoIC0gX3RoaXM0LndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICAgIHdyYXBwZXJSZWN0ID0gX3RoaXM0LnV0aWwud2l0aE9yaWVudGF0aW9uKF90aGlzNC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBfdGhpczQudmVydGljYWwpO1xuICAgICAgICBfdGhpczQuaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICBfdGhpczQuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaGFuZGxlJykge1xuICAgICAgICAgIF90aGlzNC5pc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXNpemUgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd3YXZlc3VyZmVyLWhhbmRsZS1zdGFydCcpID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNC5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICBkcmFnID0gdHJ1ZTtcbiAgICAgICAgICByZXNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uVXAgPSBmdW5jdGlvbiBvblVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnIHx8IHJlc2l6ZSkge1xuICAgICAgICAgIF90aGlzNC5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXM0LmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBkcmFnID0gZmFsc2U7XG4gICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICByZXNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXM0LnV0aWwucHJldmVudENsaWNrKCk7XG5cbiAgICAgICAgICBfdGhpczQuZmlyZUV2ZW50KCd1cGRhdGUtZW5kJywgZXZlbnQpO1xuXG4gICAgICAgICAgX3RoaXM0LndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tdXBkYXRlLWVuZCcsIF90aGlzNCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25Nb3ZlID0gZnVuY3Rpb24gb25Nb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IF90aGlzNC53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgICAgdmFyIG9yaWVudGVkRXZlbnQgPSBfdGhpczQudXRpbC53aXRoT3JpZW50YXRpb24oZXZlbnQsIF90aGlzNC52ZXJ0aWNhbCk7XG5cbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMgJiYgZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyICE9IHRvdWNoSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRyYWcgJiYgIXJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciB0aW1lID0gX3RoaXM0LnJlZ2lvbnNVdGlsLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZShfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZXZlbnQpICogZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChkcmFnKSB7XG4gICAgICAgICAgLy8gVG8gbWFpbnRhaW4gcmVsYXRpdmUgY3Vyc29yIHN0YXJ0IHBvaW50IHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgdmFyIG1heEVuZCA9IF90aGlzNC53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgICAgICBpZiAodGltZSA+IG1heEVuZCAtIHJlZ2lvblJpZ2h0SGFsZlRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBtYXhFbmQgLSByZWdpb25SaWdodEhhbGZUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aW1lIC0gcmVnaW9uTGVmdEhhbGZUaW1lIDwgMCkge1xuICAgICAgICAgICAgdGltZSA9IHJlZ2lvbkxlZnRIYWxmVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgICAgLy8gVG8gbWFpbnRhaW4gcmVsYXRpdmUgY3Vyc29yIHN0YXJ0IHBvaW50IHdoaWxlIHJlc2l6aW5nXG4gICAgICAgICAgLy8gd2UgaGF2ZSB0byBoYW5kbGUgZm9yIG1pbkxlbmd0aFxuICAgICAgICAgIHZhciBtaW5MZW5ndGggPSBfdGhpczQubWluTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCFtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIG1pbkxlbmd0aCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc2l6ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBfdGhpczQuZW5kIC0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBfdGhpczQuZW5kIC0gbWluTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZSA8IDApIHtcbiAgICAgICAgICAgICAgdGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNpemUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBpZiAodGltZSA8IF90aGlzNC5zdGFydCArIG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICB0aW1lID0gX3RoaXM0LnN0YXJ0ICsgbWluTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBzdGFydFRpbWUgPSB0aW1lOyAvLyBEcmFnXG5cbiAgICAgICAgaWYgKF90aGlzNC5kcmFnICYmIGRyYWcpIHtcbiAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlZCB8fCAhIWRlbHRhO1xuXG4gICAgICAgICAgX3RoaXM0Lm9uRHJhZyhkZWx0YSk7XG4gICAgICAgIH0gLy8gUmVzaXplXG5cblxuICAgICAgICBpZiAoX3RoaXM0LnJlc2l6ZSAmJiByZXNpemUpIHtcbiAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlZCB8fCAhIWRlbHRhO1xuXG4gICAgICAgICAgX3RoaXM0Lm9uUmVzaXplKGRlbHRhLCByZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNC5zY3JvbGwgJiYgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgX3RoaXM0LndyYXBwZXIuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAvLyBUcmlnZ2VyaW5nIGVkZ2VzY3JvbGwgZnJvbSB3aXRoaW4gZWRnZVNjcm9sbFdpZHRoXG4gICAgICAgICAgdmFyIHggPSBvcmllbnRlZEV2ZW50LmNsaWVudFg7IC8vIENoZWNrIGRpcmVjdGlvblxuXG4gICAgICAgICAgaWYgKHggPCB3cmFwcGVyUmVjdC5sZWZ0ICsgX3RoaXM0LmVkZ2VTY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmICh4ID4gd3JhcHBlclJlY3QucmlnaHQgLSBfdGhpczQuZWRnZVNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGVkZ2VTY3JvbGwoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG93bik7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG93bik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25VcCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25VcCk7XG4gICAgICB0aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblVwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Nb3ZlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53YXZlc3VyZmVyLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25VcCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblVwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGRlbHRhKSB7XG4gICAgICB2YXIgbWF4RW5kID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgIGlmICh0aGlzLmVuZCArIGRlbHRhID4gbWF4RW5kKSB7XG4gICAgICAgIGRlbHRhID0gbWF4RW5kIC0gdGhpcy5lbmQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ICsgZGVsdGEgPCAwKSB7XG4gICAgICAgIGRlbHRhID0gdGhpcy5zdGFydCAqIC0xO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ICsgZGVsdGEsXG4gICAgICAgIGVuZDogdGhpcy5lbmQgKyBkZWx0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogb25SZXNpemUoLTUsICdzdGFydCcpIC8vIE1vdmVzIHRoZSBzdGFydCBwb2ludCA1IHNlY29uZHMgYmFja1xuICAgICAqIG9uUmVzaXplKDAuNSwgJ2VuZCcpIC8vIE1vdmVzIHRoZSBlbmQgcG9pbnQgMC41IHNlY29uZHMgZm9yd2FyZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIEhvdyBtdWNoIHRvIGFkZCBvciBzdWJ0cmFjdCwgZ2l2ZW4gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gJ3N0YXJ0ICdvciAnZW5kJ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25SZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXNpemUoZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY2hhbmdpbmcgdGhlIHN0YXJ0IGJ5IHRoZSBnaXZlbiBkZWx0YSB3b3VsZCByZXN1bHQgaW4gdGhlIHJlZ2lvbiBiZWluZyBzbWFsbGVyIHRoYW4gbWluTGVuZ3RoXG4gICAgICAgIC8vIElnbm9yZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbWFraW5nIHRoZSByZWdpb24gd2lkZXIgcmF0aGVyIHRoYW4gc2hyaW5raW5nIGl0XG4gICAgICAgIGlmIChkZWx0YSA+IDAgJiYgdGhpcy5lbmQgLSAodGhpcy5zdGFydCArIGRlbHRhKSA8IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgICAgZGVsdGEgPSB0aGlzLmVuZCAtIHRoaXMubWluTGVuZ3RoIC0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgdGhpcy5zdGFydCArIGRlbHRhIDwgMCkge1xuICAgICAgICAgIGRlbHRhID0gdGhpcy5zdGFydCAqIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbih0aGlzLnN0YXJ0ICsgZGVsdGEsIHRoaXMuZW5kKSxcbiAgICAgICAgICBlbmQ6IE1hdGgubWF4KHRoaXMuc3RhcnQgKyBkZWx0YSwgdGhpcy5lbmQpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY2hhbmdpbmcgdGhlIGVuZCBieSB0aGUgZ2l2ZW4gZGVsdGEgd291bGQgcmVzdWx0IGluIHRoZSByZWdpb24gYmVpbmcgc21hbGxlciB0aGFuIG1pbkxlbmd0aFxuICAgICAgICAvLyBJZ25vcmUgY2FzZXMgd2hlcmUgd2UgYXJlIG1ha2luZyB0aGUgcmVnaW9uIHdpZGVyIHJhdGhlciB0aGFuIHNocmlua2luZyBpdFxuICAgICAgICBpZiAoZGVsdGEgPCAwICYmIHRoaXMuZW5kICsgZGVsdGEgLSB0aGlzLnN0YXJ0IDwgdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICBkZWx0YSA9IHRoaXMuc3RhcnQgKyB0aGlzLm1pbkxlbmd0aCAtIHRoaXMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbHRhID4gMCAmJiB0aGlzLmVuZCArIGRlbHRhID4gZHVyYXRpb24pIHtcbiAgICAgICAgICBkZWx0YSA9IGR1cmF0aW9uIC0gdGhpcy5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhcnQ6IE1hdGgubWluKHRoaXMuZW5kICsgZGVsdGEsIHRoaXMuc3RhcnQpLFxuICAgICAgICAgIGVuZDogTWF0aC5tYXgodGhpcy5lbmQgKyBkZWx0YSwgdGhpcy5zdGFydClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUhhbmRsZXNSZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlSGFuZGxlc1Jlc2l6ZShyZXNpemUpIHtcbiAgICAgIHZhciBjdXJzb3JTdHlsZTtcblxuICAgICAgaWYgKHJlc2l6ZSkge1xuICAgICAgICBjdXJzb3JTdHlsZSA9IHRoaXMudmVydGljYWwgPyAncm93LXJlc2l6ZScgOiAnY29sLXJlc2l6ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3JTdHlsZSA9ICdhdXRvJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYW5kbGVMZWZ0RWwgJiYgdGhpcy5zdHlsZSh0aGlzLmhhbmRsZUxlZnRFbCwge1xuICAgICAgICBjdXJzb3I6IGN1cnNvclN0eWxlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFuZGxlUmlnaHRFbCAmJiB0aGlzLnN0eWxlKHRoaXMuaGFuZGxlUmlnaHRFbCwge1xuICAgICAgICBjdXJzb3I6IGN1cnNvclN0eWxlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVnaW9uO1xufSgpO1xuXG5leHBvcnRzLlJlZ2lvbiA9IFJlZ2lvbjtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3BsdWdpbi9yZWdpb25zL2luZGV4LmpzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVzdXJmZXIucmVnaW9ucy5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9