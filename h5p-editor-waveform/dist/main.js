/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2);

var _WaveformInit = __webpack_require__(3);

var _WaveformInit2 = _interopRequireDefault(_WaveformInit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Load library
H5P = H5P || {};
H5PEditor.widgets.waveformInit = H5PEditor.WaveformInit = _WaveformInit2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _h5pParent = __webpack_require__(4);

var _h5pParent2 = _interopRequireDefault(_h5pParent);

var _globals = __webpack_require__(6);

var _wavesurfer = __webpack_require__(7);

var _wavesurfer2 = _interopRequireDefault(_wavesurfer);

var _wavesurferCursor = __webpack_require__(8);

var _wavesurferCursor2 = _interopRequireDefault(_wavesurferCursor);

var _wavesurferRegions = __webpack_require__(9);

var _wavesurferRegions2 = _interopRequireDefault(_wavesurferRegions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WaveformInit = function WaveformInit(parent, field, params, setValue) {
  this.parent = parent;
  this.field = field;
  this.params = params;
  this.setValue = setValue;

  this.id = null;
  this.crAudioIndex = 0;
  this.container = null;
  this.audioParams = this.parent.parent.parent.params.params;
  this.startTime = this.parent.params.startDuration != undefined ? this.parent.params.startDuration : 0;
  this.endTime = this.parent.params.endDuration != undefined ? this.parent.params.endDuration : 0.2;
  this.audioDuration;
};

WaveformInit.prototype = Object.create(_h5pParent2.default.prototype);
WaveformInit.prototype.constructor = WaveformInit;

WaveformInit.pageBasedWordIndicesUsedInSentence = {};

/**
 * Initialize the waveform editor.
 * @param {*} $wrapper 
 */
WaveformInit.prototype.init = function () {
  var _this = this;

  var self = this;
  if (!self.container || self.container && self.container.length == 0) return;
  var wavesurfer = _wavesurfer2.default.create({
    container: self.container[0],
    waveColor: 'green',
    progressColor: 'grey',
    fillParent: true,
    responsive: true,
    barHeight: 8,
    plugins: [_wavesurferRegions2.default.create({
      regionsMinLength: 0.1,
      maxRegions: 1,
      regions: [{
        start: self.startTime,
        end: self.endTime,
        loop: false,
        color: 'rgba(250, 203, 110, 0.5)'
      }],
      dragSelection: {
        slop: 5
      }
    })]
  });

  (0, _globals.jQuery)('.wavesurfer-handle').css("width", "4px");
  (0, _globals.jQuery)('.wavesurfer-handle').css("background-color", "#707070");

  this.region = undefined;

  self.crAudioIndex = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields.length;
  // let path = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex- 1].params.files ? H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].params.files[0].path : undefined;
  var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[0].parent.params.subContentId;
  var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
  // let id =  self.parent.parent.parent.params.subContentId;
  if (path != undefined && id != undefined) {
    var file = H5P.getPath(path, id);
    _globals.jQuery.get(file).done(function () {
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    }).fail(function () {
      var id = H5PEditor.contentId;
      var file = H5P.getPath(path, id);
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    });
  }

  wavesurfer.on('ready', function () {
    _this.region = Object.values(wavesurfer.regions.list)[0];
    var width = self.parent.parent.parent.parent.cp.width + self.parent.parent.parent.parent.cp.width * 0.25;
    self.audioDuration = wavesurfer.getDuration();
    // wavesurfer.params.minPxPerSec = width / wavesurfer.getDuration();
    // wavesurfer.drawBuffer();

    // let regionId = self.id + "playRegion"
    // let $playRegionButton = '<button id = '+ regionId +' class = "playRegion">Play</button>'
    // $('#' + self.id).find('.wavesurfer-region').append($playRegionButton)
    // $('#' + regionId).on('click', function (e) {
    //   e.stopPropagation()
    //   if (region != undefined) {
    //     region.play()
    //   }
    // })
  });

  setTimeout(function () {
    if (self.container[0]) {
      // Add event listeners to start and end duration for this wavesurfer instance
      var waveform = self.container[0];
      var waveformParent = waveform.parentElement.parentElement;

      var startDurationField = waveformParent.querySelector('.field-name-startDuration');
      var endDurationField = waveformParent.querySelector('.field-name-endDuration');

      if (startDurationField && endDurationField) {
        var startDurationFieldInput = startDurationField.querySelector('input');
        var endDurationFieldInput = endDurationField.querySelector('input');

        // Add focusout event handlers
        startDurationFieldInput.addEventListener("focusout", function (e) {
          _this.startDurationValueChangeHandler(e.target.value);
        });

        endDurationFieldInput.addEventListener("focusout", function (e) {
          _this.endDurationValueChangeHandler(e.target.value);
        });

        // Set values of start duration and end duration based on previous
        // waveform if it exists
        var waveformElements = document.getElementsByClassName("waveform");
        for (var i = 0; i < waveformElements.length; i++) {
          if (waveformElements[i].id === self.container[0].id && i > 0) {
            var previousWaveformContent = waveformElements[i - 1].parentElement.parentElement;
            var previousEndDurationField = previousWaveformContent.querySelector('.field-name-endDuration');
            if (previousEndDurationField) {
              var previousEndDurationInput = previousEndDurationField.querySelector('input');

              startDurationFieldInput.value = parseFloat(previousEndDurationInput.value) + 0.001;
              endDurationFieldInput.value = parseFloat(previousEndDurationInput.value) + 0.001 + 0.1;

              _this.startDurationValueChangeHandler(startDurationFieldInput.value);
              _this.endDurationValueChangeHandler(endDurationFieldInput.value);
            }
          }
        }
      }

      // Add audio loader observer on this wavesurfer instance
      var filesField = document.getElementsByClassName("field-name-files")[0];
      if (filesField) {
        var filesListElement = filesField.querySelector('ul');

        var observerConfig = { attributes: true, childList: true, subtree: true };

        var observer = new MutationObserver(function (mutationsList, observer) {
          var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].parent.params.subContentId;
          var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
          if (path != undefined && id != undefined) {
            var _file = H5P.getPath(path, id);
            _globals.jQuery.get(_file).done(function () {
              setTimeout(function () {
                wavesurfer.load(_file);
              }, 1000);
            }).fail(function () {
              var id = H5PEditor.contentId;
              var file = H5P.getPath(path, id);
              setTimeout(function () {
                wavesurfer.load(file);
              }, 1000);
            });
          }
          if (_this.region != undefined) {
            var $startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
            var $endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
            $startinput.val(0);
            $endinput.val(0.2);
            _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + 0);
            _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + 0.2);
            var params = {
              start: 0,
              end: 0.2
            };
            _this.region.update(params);
          }
        });

        observer.observe(filesListElement, observerConfig);
      }
    }
  }, 2000);

  wavesurfer.on('region-updated', function (event) {
    _this.start = event.start;
    _this.end = event.end;
    _this.$startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
    _this.$endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
    _this.$startinput.val(_this.start.toFixed(4));
    _this.$endinput.val(_this.end.toFixed(4));
    _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + _this.start.toFixed(4));
    _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + _this.end.toFixed(4));
  });

  if (this.id != null) {
    var regionId = this.id + "playRegion";
    var $playRegionButton = (0, _globals.jQuery)('<button id = ' + regionId + ' class = "playRegion">Play</button>');
    (0, _globals.jQuery)(self.container).parent('div').append($playRegionButton);
    (0, _globals.jQuery)($playRegionButton).on('click', function () {
      if (_this.region != undefined) {
        _this.region.play();
      }
    });
  }
};

WaveformInit.prototype.startDurationValueChangeHandler = function (value) {
  if (this.region != undefined) {
    if (!isNaN(value)) {
      if (parseFloat(value) > this.audioDuration) {
        value = 0.0;
      }
      var inputStartTime = parseFloat(value);
      var inputEndTime = this.region.end <= parseFloat(value) ? parseFloat(value) + 0.2 : this.region.end;
      var params = {
        start: inputStartTime.toFixed(4),
        end: inputEndTime.toFixed(4)
      };
      this.region.update(params);
    } else {
      (0, _globals.jQuery)(this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
    }
  }
};

WaveformInit.prototype.endDurationValueChangeHandler = function (value) {
  if (this.region != undefined) {
    if (!isNaN(value)) {
      if (parseFloat(value) > this.audioDuration) {
        value = self.audioDuration - 0.05;
      }
      var inputStartTime = parseFloat(value) <= this.region.start ? 0 : this.region.start;
      var inputEndTime = parseFloat(value);
      var params = {
        start: inputStartTime.toFixed(4),
        end: inputEndTime.toFixed(4)
      };
      this.region.update(params);
    } else {
      (0, _globals.jQuery)(this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
    }
  }
};

/**
 * Append the field to the wrapper.
 * @public
 * @param {H5P.jQuery} $wrapper
 */
WaveformInit.prototype.appendTo = function ($wrapper) {
  var self = this;
  var id = ns.getNextFieldId(this.field);
  var html = H5PEditor.createFieldMarkup(this.field, '<div class="waveform" id="' + id + '" class="h5p-color-picker">', id);
  self.$item = H5PEditor.$(html);
  this.setId(id);
  var wordText = this.parent.params.text != undefined ? this.parent.params.text : '';
  $wrapper.append('<h1 class="test">Select word(s)</h1>');
  // $wrapper.append('<label class="h5peditor-label"><input id="field-words-125" type="checkbox">Will Do Animation</label>')
  //let checkBoxElementForWord=$wrapper.append(this.getSentence(self.parent.parent.parent.parent.cp.slides,self.parent.parent.parent.parent.cp.currentSlideIndex))
  var slides = self.parent.parent.parent.parent.cp.slides;
  var slideIndex = this.parent.parent.parent.params.params.currIndex;
  var paramText = this.parent.params.text;
  var checkBoxElementForWord = $wrapper.append(this.getSentence(slides, slideIndex, paramText));
  self.$item.appendTo($wrapper);
  self.container = self.$item.find('#' + this.id);
  console.log(checkBoxElementForWord);
  (0, _globals.jQuery)(checkBoxElementForWord).on('change', function (event) {
    console.log(event.target);
    console.log(event.target.id);
    console.log(event.target.value);
    var isAlreadyUsed = self.checkIfWordIsUsedInOtherWaveform(slideIndex, event.target.id);
    if ((0, _globals.jQuery)('#' + event.target.id).is(':checked')) {
      if (isAlreadyUsed) {
        var input = document.getElementById(event.target.id).find('input');
        input.checked = false;
      } else {
        wordText = wordText + ' ' + event.target.value + ' ';
        (0, _globals.jQuery)('#' + event.target.id).attr('checked', true);
        this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
        this.$word.val(wordText.trim().replace(/  +/g, ' '));
        (0, _globals.jQuery)(this.$word).attr('checked', true);
        self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
        WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].push({ 'index': event.target.id.split('_')[1], 'id': event.target.id });
      }
    } else {
      (0, _globals.jQuery)('#' + event.target.id).attr('checked', false);
      var tempWordText = wordText.replace(event.target.value, '');
      wordText = tempWordText;
      this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
      self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
      (0, _globals.jQuery)(this.$word).attr('checked', false);
      this.$word.val(wordText.trim().replace(/  +/g, ' '));
      WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()] = WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].filter(function (obj) {
        return obj.id === event.target.id;
      });
    }
    console.log(WaveformInit.pageBasedWordIndicesUsedInSentence);
  });
  self.setValue(self.findField("text", self.parent.field.fields), "" + this.parent.params.text);
  self.init();
};

WaveformInit.prototype.checkIfWordIsUsedInOtherWaveform = function (slideIndex, inputId) {
  var slideCheckboxInfo = WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()];
  var wordIndex = parseInt(inputId.split('_')[1]);
  if (slideCheckboxInfo !== null && slideCheckboxInfo !== undefined) {
    for (var i = 0; i < slideCheckboxInfo.length; i++) {
      if (parseInt(slideCheckboxInfo[i].index) === wordIndex) {
        return true;
      }
    }
  } else {
    WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()] = [];
  }
  return false;
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.setId = function (id) {
  this.id = id;
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.validate = function () {
  // this.hide();
  // return (this.params !== undefined && this.params.length !== 0);
};

WaveformInit.prototype.getSentence = function (slides, slideIndex, prevData) {
  var sentenceWords = [];
  var splittedPrevData = prevData != undefined ? prevData.split(' ') : [];
  var alreadyFoundSplittedPrevDataWord = false;

  for (var i = 0; i < slides[slideIndex].elements.length; i++) {
    if (slides[slideIndex].elements[i].action.library.split(' ')[0] == "H5P.CRAdvancedText") {
      var checkBoxWord = '';
      sentenceWords = (0, _globals.jQuery)(slides[slideIndex].elements[i].action.params.text)[0].innerText.split(' ');
      for (var j = 0; j < sentenceWords.length; j++) {
        var def = splittedPrevData.indexOf(sentenceWords[j]) !== -1 ? true : false;
        if (sentenceWords[j].replace(/  +/g, ' ') != '') {
          if (def && !alreadyFoundSplittedPrevDataWord && !this.checkIfWordIsUsedInOtherWaveform(slideIndex, this.id + j)) {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + "_" + j + ' type="checkbox" value="' + sentenceWords[j] + '"checked>' + sentenceWords[j] + '</label>';
            alreadyFoundSplittedPrevDataWord = true;
            WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].push({ "index": j, "id": this.id + j });
          } else {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + "_" + j + ' type="checkbox" value="' + sentenceWords[j] + '">' + sentenceWords[j] + '</label>';
          }
        }
      }
    }
  }
  console.log(WaveformInit.pageBasedWordIndicesUsedInSentence);
  return checkBoxWord;
};

WaveformInit.prototype.remove = function () {};
exports.default = WaveformInit;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Child = __webpack_require__(5);
var EventDispatcher = H5P.EventDispatcher;

/**
 * @class
 */
function Parent(constructor, parameters) {
  var self = this;
  EventDispatcher.call(self);

  self.children = [];

  /**
   * Update the internal indexes of the children.
   *
   * @private
   * @param {number} from Where to start
   */
  var updateIndexes = function updateIndexes(from) {
    for (var i = from; i < self.children.length; i++) {
      self.children[i].index = i;
    }
  };

  /**
   * Give a new child to this parent.
   *
   * @param {*} childParameters Launch parameters
   */
  self.addChild = function (childParameters, index) {
    if (index === undefined) {
      index = self.children.length;
    }

    // Create a new child with the current instance as its parent
    var instance = new Child(index, self);

    if (index === self.children.length) {
      // Added at the end
      self.children.push(instance);
    } else {
      // Inserted at a specific location
      self.children.splice(index, 0, instance);
      updateIndexes(index);
    }

    // Run original constructor
    constructor.call(instance, childParameters);

    return instance;
  };

  /**
   * Remova a new child from its parent.
   *
   * @param {number} index
   */
  self.removeChild = function (index) {
    // Remove from array
    self.children.splice(index, 1);

    // Update internal indexes
    updateIndexes(index);
  };

  /**
   * Move the child into a new position
   *
   * @param {number} oldIndex
   * @param {number} newIndex
   */
  self.moveChild = function (oldIndex, newIndex) {
    var child = self.children.splice(oldIndex, 1)[0];
    self.children.splice(newIndex, 0, child);

    updateIndexes(newIndex < oldIndex ? newIndex : oldIndex);
  };

  if (parameters) {
    for (var i = 0; i < parameters.length; i++) {
      self.addChild(parameters[i]);
    }
  }
}

Parent.prototype = Object.create(EventDispatcher.prototype);
Parent.prototype.constructor = Parent;

module.exports = Parent;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @class
 */
function Child(index, parent) {
  var self = this;

  self.index = index;
  self.parent = parent;
}

module.exports = Child;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var jQuery = exports.jQuery = H5P.jQuery;
var EventDispatcher = exports.EventDispatcher = H5P.EventDispatcher;
var JoubelUI = exports.JoubelUI = H5P.JoubelUI;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/var __webpack_modules__ = {

        /***/"./src/drawer.canvasentry.js":
        /*!***********************************!*\
          !*** ./src/drawer.canvasentry.js ***!
          \***********************************/
        /***/function srcDrawerCanvasentryJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _style = _interopRequireDefault(__webpack_require__( /*! ./util/style */"./src/util/style.js"));

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./util/get-id */"./src/util/get-id.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * The `CanvasEntry` class represents an element consisting of a wave `canvas`
           * and an (optional) progress wave `canvas`.
           *
           * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
           * render a waveform, depending on the zoom level.
           */
          var CanvasEntry = /*#__PURE__*/function () {
            function CanvasEntry() {
              _classCallCheck(this, CanvasEntry);

              /**
               * The wave node
               *
               * @type {HTMLCanvasElement}
               */
              this.wave = null;
              /**
               * The wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.waveCtx = null;
              /**
               * The (optional) progress wave node
               *
               * @type {HTMLCanvasElement}
               */

              this.progress = null;
              /**
               * The (optional) progress wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.progressCtx = null;
              /**
               * Start of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.start = 0;
              /**
               * End of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.end = 1;
              /**
               * Unique identifier for this entry
               *
               * @type {string}
               */

              this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
              /**
               * Canvas 2d context attributes
               *
               * @type {object}
               */

              this.canvasContextAttributes = {};
            }
            /**
             * Store the wave canvas element and create the 2D rendering context
             *
             * @param {HTMLCanvasElement} element The wave `canvas` element.
             */

            _createClass(CanvasEntry, [{
              key: "initWave",
              value: function initWave(element) {
                this.wave = element;
                this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Store the progress wave canvas element and create the 2D rendering
               * context
               *
               * @param {HTMLCanvasElement} element The progress wave `canvas` element.
               */

            }, {
              key: "initProgress",
              value: function initProgress(element) {
                this.progress = element;
                this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Update the dimensions
               *
               * @param {number} elementWidth Width of the entry
               * @param {number} totalWidth Total width of the multi canvas renderer
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(elementWidth, totalWidth, width, height) {
                // where the canvas starts and ends in the waveform, represented as a
                // decimal between 0 and 1
                this.start = this.wave.offsetLeft / totalWidth || 0;
                this.end = this.start + elementWidth / totalWidth; // set wave canvas dimensions

                this.wave.width = width;
                this.wave.height = height;
                var elementSize = {
                  width: elementWidth + 'px'
                };
                (0, _style.default)(this.wave, elementSize);

                if (this.hasProgressCanvas) {
                  // set progress canvas dimensions
                  this.progress.width = width;
                  this.progress.height = height;
                  (0, _style.default)(this.progress, elementSize);
                }
              }
              /**
               * Clear the wave and progress rendering contexts
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                // wave
                this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height); // progress

                if (this.hasProgressCanvas) {
                  this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
                }
              }
              /**
               * Set the fill styles for wave and progress
               *
               * @param {string} waveColor Fill color for the wave canvas
               * @param {?string} progressColor Fill color for the progress canvas
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(waveColor, progressColor) {
                this.waveCtx.fillStyle = waveColor;

                if (this.hasProgressCanvas) {
                  this.progressCtx.fillStyle = progressColor;
                }
              }
              /**
               * Set the canvas transforms for wave and progress
               *
               * @param {boolean} vertical Whether to render vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(vertical) {
                if (vertical) {
                  // Reflect the waveform across the line y = -x
                  this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);

                  if (this.hasProgressCanvas) {
                    this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);
                  }
                }
              }
              /**
               * Draw a rectangle for wave and progress
               *
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRects",
              value: function fillRects(x, y, width, height, radius) {
                this.fillRectToContext(this.waveCtx, x, y, width, height, radius);

                if (this.hasProgressCanvas) {
                  this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
                }
              }
              /**
               * Draw the actual rectangle on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRectToContext",
              value: function fillRectToContext(ctx, x, y, width, height, radius) {
                if (!ctx) {
                  return;
                }

                if (radius) {
                  this.drawRoundedRect(ctx, x, y, width, height, radius);
                } else {
                  ctx.fillRect(x, y, width, height);
                }
              }
              /**
               * Draw a rounded rectangle on Canvas
               *
               * @param {CanvasRenderingContext2D} ctx Canvas context
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               *
               * @return {void}
               * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
               */

            }, {
              key: "drawRoundedRect",
              value: function drawRoundedRect(ctx, x, y, width, height, radius) {
                if (height === 0) {
                  return;
                } // peaks are float values from -1 to 1. Use absolute height values in
                // order to correctly calculate rounded rectangle coordinates


                if (height < 0) {
                  height *= -1;
                  y -= height;
                }

                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Render the actual wave and progress lines
               *
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLines",
              value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
                this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);

                if (this.hasProgressCanvas) {
                  this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
                }
              }
              /**
               * Render the actual waveform line on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLineToContext",
              value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
                if (!ctx) {
                  return;
                }

                var length = peaks.length / 2;
                var first = Math.round(length * this.start); // use one more peak value to make sure we join peaks at ends -- unless,
                // of course, this is the last canvas

                var last = Math.round(length * this.end) + 1;
                var canvasStart = first;
                var canvasEnd = last;
                var scale = this.wave.width / (canvasEnd - canvasStart - 1); // optimization

                var halfOffset = halfH + offsetY;
                var absmaxHalf = absmax / halfH;
                ctx.beginPath();
                ctx.moveTo((canvasStart - first) * scale, halfOffset);
                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
                var i, peak, h;

                for (i = canvasStart; i < canvasEnd; i++) {
                  peak = peaks[2 * i] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
                } // draw the bottom edge going backwards, to make a single
                // closed hull to fill


                var j = canvasEnd - 1;

                for (j; j >= canvasStart; j--) {
                  peak = peaks[2 * j + 1] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
                }

                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Destroys this entry
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.waveCtx = null;
                this.wave = null;
                this.progressCtx = null;
                this.progress = null;
              }
              /**
               * Return image data of the wave `canvas` element
               *
               * When using a `type` of `'blob'`, this will return a `Promise` that
               * resolves with a `Blob` instance.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|Promise} When using the default `'dataURL'` `type` this
               * returns a data URL. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with a `Blob` instance.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                var _this = this;

                if (type === 'blob') {
                  return new Promise(function (resolve) {
                    _this.wave.toBlob(resolve, format, quality);
                  });
                } else if (type === 'dataURL') {
                  return this.wave.toDataURL(format, quality);
                }
              }
            }]);

            return CanvasEntry;
          }();

          exports.default = CanvasEntry;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.js":
        /*!***********************!*\
          !*** ./src/drawer.js ***!
          \***********************/
        /***/function srcDrawerJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * Parent class for renderers
           *
           * @extends {Observer}
           */
          var Drawer = /*#__PURE__*/function (_util$Observer) {
            _inherits(Drawer, _util$Observer);

            var _super = _createSuper(Drawer);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function Drawer(container, params) {
              var _this;

              _classCallCheck(this, Drawer);

              _this = _super.call(this);
              _this.container = util.withOrientation(container, params.vertical);
              /**
               * @type {WavesurferParams}
               */

              _this.params = params;
              /**
               * The width of the renderer
               * @type {number}
               */

              _this.width = 0;
              /**
               * The height of the renderer
               * @type {number}
               */

              _this.height = params.height * _this.params.pixelRatio;
              _this.lastPos = 0;
              /**
               * The `<wave>` element which is added to the container
               * @type {HTMLElement}
               */

              _this.wrapper = null;
              return _this;
            }
            /**
             * Alias of `util.style`
             *
             * @param {HTMLElement} el The element that the styles will be applied to
             * @param {Object} styles The map of propName: attribute, both are used as-is
             * @return {HTMLElement} el
             */

            _createClass(Drawer, [{
              key: "style",
              value: function style(el, styles) {
                return util.style(el, styles);
              }
              /**
               * Create the wrapper `<wave>` element, style it and set up the events for
               * interaction
               */

            }, {
              key: "createWrapper",
              value: function createWrapper() {
                this.wrapper = util.withOrientation(this.container.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.wrapper, {
                  display: 'block',
                  position: 'relative',
                  userSelect: 'none',
                  webkitUserSelect: 'none',
                  height: this.params.height + 'px'
                });

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: '100%',
                    overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
                    overflowY: 'hidden'
                  });
                }

                this.setupWrapperEvents();
              }
              /**
               * Handle click event
               *
               * @param {Event} e Click event
               * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
               * @return {number} Playback position from 0 to 1
               */

            }, {
              key: "handleEvent",
              value: function handleEvent(e, noPrevent) {
                !noPrevent && e.preventDefault();
                var clientX = util.withOrientation(e.targetTouches ? e.targetTouches[0] : e, this.params.vertical).clientX;
                var bbox = this.wrapper.getBoundingClientRect();
                var nominalWidth = this.width;
                var parentWidth = this.getWidth();
                var progressPixels = this.getProgressPixels(bbox, clientX);
                var progress;

                if (!this.params.fillParent && nominalWidth < parentWidth) {
                  progress = progressPixels * (this.params.pixelRatio / nominalWidth) || 0;
                } else {
                  progress = (progressPixels + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
                }

                return util.clamp(progress, 0, 1);
              }
            }, {
              key: "getProgressPixels",
              value: function getProgressPixels(wrapperBbox, clientX) {
                if (this.params.rtl) {
                  return wrapperBbox.right - clientX;
                } else {
                  return clientX - wrapperBbox.left;
                }
              }
            }, {
              key: "setupWrapperEvents",
              value: function setupWrapperEvents() {
                var _this2 = this;

                this.wrapper.addEventListener('click', function (e) {
                  var orientedEvent = util.withOrientation(e, _this2.params.vertical);
                  var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

                  if (scrollbarHeight !== 0) {
                    // scrollbar is visible.  Check if click was on it
                    var bbox = _this2.wrapper.getBoundingClientRect();

                    if (orientedEvent.clientY >= bbox.bottom - scrollbarHeight) {
                      // ignore mousedown as it was on the scrollbar
                      return;
                    }
                  }

                  if (_this2.params.interact) {
                    _this2.fireEvent('click', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('dblclick', function (e) {
                  if (_this2.params.interact) {
                    _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('scroll', function (e) {
                  return _this2.fireEvent('scroll', e);
                });
              }
              /**
               * Draw peaks on the canvas
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} length The width of the area that should be drawn
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawPeaks",
              value: function drawPeaks(peaks, length, start, end) {
                if (!this.setWidth(length)) {
                  this.clearWave();
                }

                this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
              }
              /**
               * Scroll to the beginning
               */

            }, {
              key: "resetScroll",
              value: function resetScroll() {
                if (this.wrapper !== null) {
                  this.wrapper.scrollLeft = 0;
                }
              }
              /**
               * Recenter the view-port at a certain percent of the waveform
               *
               * @param {number} percent Value from 0 to 1 on the waveform
               */

            }, {
              key: "recenter",
              value: function recenter(percent) {
                var position = this.wrapper.scrollWidth * percent;
                this.recenterOnPosition(position, true);
              }
              /**
               * Recenter the view-port on a position, either scroll there immediately or
               * in steps of 5 pixels
               *
               * @param {number} position X-offset in pixels
               * @param {boolean} immediate Set to true to immediately scroll somewhere
               */

            }, {
              key: "recenterOnPosition",
              value: function recenterOnPosition(position, immediate) {
                var scrollLeft = this.wrapper.scrollLeft;
                var half = ~~(this.wrapper.clientWidth / 2);
                var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
                var target = position - half;
                var offset = target - scrollLeft;

                if (maxScroll == 0) {
                  // no need to continue if scrollbar is not there
                  return;
                } // if the cursor is currently visible...


                if (!immediate && -half <= offset && offset < half) {
                  // set rate at which waveform is centered
                  var rate = this.params.autoCenterRate; // make rate depend on width of view and length of waveform

                  rate /= half;
                  rate *= maxScroll;
                  offset = Math.max(-rate, Math.min(rate, offset));
                  target = scrollLeft + offset;
                } // limit target to valid range (0 to maxScroll)


                target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

                if (target != scrollLeft) {
                  this.wrapper.scrollLeft = target;
                }
              }
              /**
               * Get the current scroll position in pixels
               *
               * @return {number} Horizontal scroll position in pixels
               */

            }, {
              key: "getScrollX",
              value: function getScrollX() {
                var x = 0;

                if (this.wrapper) {
                  var pixelRatio = this.params.pixelRatio;
                  x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
                  // scroll beyond the limits of the container
                  // Calculate and floor the scrollable extent to make sure an out
                  // of bounds value is not returned
                  // Ticket #1312

                  if (this.params.scrollParent) {
                    var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
                    x = Math.min(maxScroll, Math.max(0, x));
                  }
                }

                return x;
              }
              /**
               * Get the width of the container
               *
               * @return {number} The width of the container
               */

            }, {
              key: "getWidth",
              value: function getWidth() {
                return Math.round(this.container.clientWidth * this.params.pixelRatio);
              }
              /**
               * Set the width of the container
               *
               * @param {number} width The new width of the container
               * @return {boolean} Whether the width of the container was updated or not
               */

            }, {
              key: "setWidth",
              value: function setWidth(width) {
                if (this.width == width) {
                  return false;
                }

                this.width = width;

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: ''
                  });
                } else {
                  var newWidth = ~~(this.width / this.params.pixelRatio) + 'px';
                  this.style(this.wrapper, {
                    width: newWidth
                  });
                }

                this.updateSize();
                return true;
              }
              /**
               * Set the height of the container
               *
               * @param {number} height The new height of the container.
               * @return {boolean} Whether the height of the container was updated or not
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                if (height == this.height) {
                  return false;
                }

                this.height = height;
                this.style(this.wrapper, {
                  height: ~~(this.height / this.params.pixelRatio) + 'px'
                });
                this.updateSize();
                return true;
              }
              /**
               * Called by wavesurfer when progress should be rendered
               *
               * @param {number} progress From 0 to 1
               */

            }, {
              key: "progress",
              value: function progress(_progress) {
                var minPxDelta = 1 / this.params.pixelRatio;
                var pos = Math.round(_progress * this.width) * minPxDelta;

                if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
                  this.lastPos = pos;

                  if (this.params.scrollParent && this.params.autoCenter) {
                    var newPos = ~~(this.wrapper.scrollWidth * _progress);
                    this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
                  }

                  this.updateProgress(pos);
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.unAll();

                if (this.wrapper) {
                  if (this.wrapper.parentNode == this.container.domElement) {
                    this.container.removeChild(this.wrapper.domElement);
                  }

                  this.wrapper = null;
                }
              }
              /* Renderer-specific methods */

              /**
               * Called after cursor related params have changed.
               *
               * @abstract
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {}
              /**
               * Called when the size of the container changes so the renderer can adjust
               *
               * @abstract
               */

            }, {
              key: "updateSize",
              value: function updateSize() {}
              /**
               * Draw a waveform with bars
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {}
              /**
               * Draw a waveform
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {}
              /**
               * Clear the waveform
               *
               * @abstract
               */

            }, {
              key: "clearWave",
              value: function clearWave() {}
              /**
               * Render the new progress
               *
               * @abstract
               * @param {number} position X-Offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {}
            }]);

            return Drawer;
          }(util.Observer);

          exports.default = Drawer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.multicanvas.js":
        /*!***********************************!*\
          !*** ./src/drawer.multicanvas.js ***!
          \***********************************/
        /***/function srcDrawerMulticanvasJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer */"./src/drawer.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer2 = _interopRequireDefault(__webpack_require__( /*! ./drawer.canvasentry */"./src/drawer.canvasentry.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MultiCanvas renderer for wavesurfer. Is currently the default and sole
           * builtin renderer.
           *
           * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
           * on the zoom level.
           */
          var MultiCanvas = /*#__PURE__*/function (_Drawer) {
            _inherits(MultiCanvas, _Drawer);

            var _super = _createSuper(MultiCanvas);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function MultiCanvas(container, params) {
              var _this;

              _classCallCheck(this, MultiCanvas);

              _this = _super.call(this, container, params);
              /**
               * @type {number}
               */

              _this.maxCanvasWidth = params.maxCanvasWidth;
              /**
               * @type {number}
               */

              _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
              /**
               * Whether or not the progress wave is rendered. If the `waveColor`
               * and `progressColor` are the same color it is not.
               *
               * @type {boolean}
               */

              _this.hasProgressCanvas = params.waveColor != params.progressColor;
              /**
               * @type {number}
               */

              _this.halfPixel = 0.5 / params.pixelRatio;
              /**
               * List of `CanvasEntry` instances.
               *
               * @type {Array}
               */

              _this.canvases = [];
              /**
               * @type {HTMLElement}
               */

              _this.progressWave = null;
              /**
               * Class used to generate entries.
               *
               * @type {function}
               */

              _this.EntryClass = _drawer2.default;
              /**
               * Canvas 2d context attributes.
               *
               * @type {object}
               */

              _this.canvasContextAttributes = params.drawingContextAttributes;
              /**
               * Overlap added between entries to prevent vertical white stripes
               * between `canvas` elements.
               *
               * @type {number}
               */

              _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
              /**
               * The radius of the wave bars. Makes bars rounded
               *
               * @type {number}
               */

              _this.barRadius = params.barRadius || 0;
              /**
               * Whether to render the waveform vertically. Defaults to false.
               *
               * @type {boolean}
               */

              _this.vertical = params.vertical;
              return _this;
            }
            /**
             * Initialize the drawer
             */

            _createClass(MultiCanvas, [{
              key: "init",
              value: function init() {
                this.createWrapper();
                this.createElements();
              }
              /**
               * Create the canvas elements and style them
               *
               */

            }, {
              key: "createElements",
              value: function createElements() {
                this.progressWave = util.withOrientation(this.wrapper.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.progressWave, {
                  position: 'absolute',
                  zIndex: 3,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  overflow: 'hidden',
                  width: '0',
                  display: 'none',
                  boxSizing: 'border-box',
                  borderRightStyle: 'solid',
                  pointerEvents: 'none'
                });
                this.addCanvas();
                this.updateCursor();
              }
              /**
               * Update cursor style
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {
                this.style(this.progressWave, {
                  borderRightWidth: this.params.cursorWidth + 'px',
                  borderRightColor: this.params.cursorColor
                });
              }
              /**
               * Adjust to the updated size by adding or removing canvases
               */

            }, {
              key: "updateSize",
              value: function updateSize() {
                var _this2 = this;

                var totalWidth = Math.round(this.width / this.params.pixelRatio);
                var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap)); // add required canvases

                while (this.canvases.length < requiredCanvases) {
                  this.addCanvas();
                } // remove older existing canvases, if any


                while (this.canvases.length > requiredCanvases) {
                  this.removeCanvas();
                }

                var canvasWidth = this.maxCanvasWidth + this.overlap;
                var lastCanvas = this.canvases.length - 1;
                this.canvases.forEach(function (entry, i) {
                  if (i == lastCanvas) {
                    canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
                  }

                  _this2.updateDimensions(entry, canvasWidth, _this2.height);

                  entry.clearWave();
                });
              }
              /**
               * Add a canvas to the canvas list
               *
               */

            }, {
              key: "addCanvas",
              value: function addCanvas() {
                var entry = new this.EntryClass();
                entry.canvasContextAttributes = this.canvasContextAttributes;
                entry.hasProgressCanvas = this.hasProgressCanvas;
                entry.halfPixel = this.halfPixel;
                var leftOffset = this.maxCanvasElementWidth * this.canvases.length; // wave

                var wave = util.withOrientation(this.wrapper.appendChild(document.createElement('canvas')), this.params.vertical);
                this.style(wave, {
                  position: 'absolute',
                  zIndex: 2,
                  left: leftOffset + 'px',
                  top: 0,
                  bottom: 0,
                  height: '100%',
                  pointerEvents: 'none'
                });
                entry.initWave(wave); // progress

                if (this.hasProgressCanvas) {
                  var progress = util.withOrientation(this.progressWave.appendChild(document.createElement('canvas')), this.params.vertical);
                  this.style(progress, {
                    position: 'absolute',
                    left: leftOffset + 'px',
                    top: 0,
                    bottom: 0,
                    height: '100%'
                  });
                  entry.initProgress(progress);
                }

                this.canvases.push(entry);
              }
              /**
               * Pop single canvas from the list
               *
               */

            }, {
              key: "removeCanvas",
              value: function removeCanvas() {
                var lastEntry = this.canvases[this.canvases.length - 1]; // wave

                lastEntry.wave.parentElement.removeChild(lastEntry.wave.domElement); // progress

                if (this.hasProgressCanvas) {
                  lastEntry.progress.parentElement.removeChild(lastEntry.progress.domElement);
                } // cleanup


                if (lastEntry) {
                  lastEntry.destroy();
                  lastEntry = null;
                }

                this.canvases.pop();
              }
              /**
               * Update the dimensions of a canvas element
               *
               * @param {CanvasEntry} entry Target entry
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(entry, width, height) {
                var elementWidth = Math.round(width / this.params.pixelRatio);
                var totalWidth = Math.round(this.width / this.params.pixelRatio); // update canvas dimensions

                entry.updateDimensions(elementWidth, totalWidth, width, height); // style element

                this.style(this.progressWave, {
                  display: 'block'
                });
              }
              /**
               * Clear the whole multi-canvas
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                var _this3 = this;

                util.frame(function () {
                  _this3.canvases.forEach(function (entry) {
                    return entry.clearWave();
                  });
                })();
              }
              /**
               * Draw a waveform with bars
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0. Must be an integer.
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {
                var _this4 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
                  var absmax = _ref.absmax,
                      hasMinVals = _ref.hasMinVals,
                      height = _ref.height,
                      offsetY = _ref.offsetY,
                      halfH = _ref.halfH,
                      peaks = _ref.peaks,
                      ch = _ref.channelIndex;

                  // if drawBars was called within ws.empty we don't pass a start and
                  // don't want anything to happen
                  if (start === undefined) {
                    return;
                  } // Skip every other value if there are negatives.


                  var peakIndexScale = hasMinVals ? 2 : 1;
                  var length = peaks.length / peakIndexScale;
                  var bar = _this4.params.barWidth * _this4.params.pixelRatio;
                  var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
                  var step = bar + gap;
                  var scale = length / _this4.width;
                  var first = start;
                  var last = end;
                  var i = first;

                  for (i; i < last; i += step) {
                    var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
                    var h = Math.round(peak / absmax * halfH);
                    /* in case of silences, allow the user to specify that we
                     * always draw *something* (normally a 1px high bar) */

                    if (h == 0 && _this4.params.barMinHeight) {
                      h = _this4.params.barMinHeight;
                    }

                    _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius, ch);
                  }
                });
              }
              /**
               * Draw a waveform
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered (If this isn't set only a flat line is rendered)
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {
                var _this5 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
                  var absmax = _ref2.absmax,
                      hasMinVals = _ref2.hasMinVals,
                      height = _ref2.height,
                      offsetY = _ref2.offsetY,
                      halfH = _ref2.halfH,
                      peaks = _ref2.peaks,
                      channelIndex = _ref2.channelIndex;

                  if (!hasMinVals) {
                    var reflectedPeaks = [];
                    var len = peaks.length;
                    var i = 0;

                    for (i; i < len; i++) {
                      reflectedPeaks[2 * i] = peaks[i];
                      reflectedPeaks[2 * i + 1] = -peaks[i];
                    }

                    peaks = reflectedPeaks;
                  } // if drawWave was called within ws.empty we don't pass a start and
                  // end and simply want a flat line


                  if (start !== undefined) {
                    _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
                  } // always draw a median line


                  _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius, channelIndex);
                });
              }
              /**
               * Tell the canvas entries to render their portion of the waveform
               *
               * @param {number[]} peaks Peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               * @param {channelIndex} channelIndex The channel index of the line drawn
               */

            }, {
              key: "drawLine",
              value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
                var _this6 = this;

                var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                    waveColor = _ref3.waveColor,
                    progressColor = _ref3.progressColor;

                this.canvases.forEach(function (entry, i) {
                  _this6.setFillStyles(entry, waveColor, progressColor);

                  _this6.applyCanvasTransforms(entry, _this6.params.vertical);

                  entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
                });
              }
              /**
               * Draw a rectangle on the multi-canvas
               *
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               * @param {channelIndex} channelIndex The channel index of the bar drawn
               */

            }, {
              key: "fillRect",
              value: function fillRect(x, y, width, height, radius, channelIndex) {
                var startCanvas = Math.floor(x / this.maxCanvasWidth);
                var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
                var i = startCanvas;

                for (i; i < endCanvas; i++) {
                  var entry = this.canvases[i];
                  var leftOffset = i * this.maxCanvasWidth;
                  var intersection = {
                    x1: Math.max(x, i * this.maxCanvasWidth),
                    y1: y,
                    x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
                    y2: y + height
                  };

                  if (intersection.x1 < intersection.x2) {
                    var _ref4 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                        waveColor = _ref4.waveColor,
                        progressColor = _ref4.progressColor;

                    this.setFillStyles(entry, waveColor, progressColor);
                    this.applyCanvasTransforms(entry, this.params.vertical);
                    entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
                  }
                }
              }
              /**
               * Returns whether to hide the channel from being drawn based on params.
               *
               * @param {number} channelIndex The index of the current channel.
               * @returns {bool} True to hide the channel, false to draw.
               */

            }, {
              key: "hideChannel",
              value: function hideChannel(channelIndex) {
                return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
              }
              /**
               * Performs preparation tasks and calculations which are shared by `drawBars`
               * and `drawWave`
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
               * split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered. If this isn't set only a flat line is rendered
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @param {function} fn The render function to call, e.g. `drawWave`
               * @param {number} drawIndex The index of the current channel after filtering.
               * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
               * @returns {void}
               */

            }, {
              key: "prepareDraw",
              value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
                var _this7 = this;

                return util.frame(function () {
                  // Split channels and call this function with the channelIndex set
                  if (peaks[0] instanceof Array) {
                    var channels = peaks;

                    if (_this7.params.splitChannels) {
                      var filteredChannels = channels.filter(function (c, i) {
                        return !_this7.hideChannel(i);
                      });

                      if (!_this7.params.splitChannelsOptions.overlay) {
                        _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
                      }

                      var overallAbsMax;

                      if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
                        // calculate maximum peak across channels to use for normalization
                        overallAbsMax = util.max(channels.map(function (channelPeaks) {
                          return util.absMax(channelPeaks);
                        }));
                      }

                      return channels.forEach(function (channelPeaks, i) {
                        return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
                      });
                    }

                    peaks = channels[0];
                  } // Return and do not draw channel peaks if hidden.


                  if (_this7.hideChannel(channelIndex)) {
                    return;
                  } // calculate maximum modulation value, either from the barHeight
                  // parameter or if normalize=true from the largest value in the peak
                  // set


                  var absmax = 1 / _this7.params.barHeight;

                  if (_this7.params.normalize) {
                    absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
                  } // Bar wave draws the bottom only as a reflection of the top,
                  // so we don't need negative values


                  var hasMinVals = [].some.call(peaks, function (val) {
                    return val < 0;
                  });
                  var height = _this7.params.height * _this7.params.pixelRatio;
                  var halfH = height / 2;
                  var offsetY = height * drawIndex || 0; // Override offsetY if overlay is true

                  if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.overlay) {
                    offsetY = 0;
                  }

                  return fn({
                    absmax: absmax,
                    hasMinVals: hasMinVals,
                    height: height,
                    offsetY: offsetY,
                    halfH: halfH,
                    peaks: peaks,
                    channelIndex: channelIndex
                  });
                })();
              }
              /**
               * Set the fill styles for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {string} waveColor Wave color to draw this entry
               * @param {string} progressColor Progress color to draw this entry
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(entry) {
                var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
                var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
                entry.setFillStyles(waveColor, progressColor);
              }
              /**
               * Set the canvas transforms for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {boolean} vertical Whether to render the waveform vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(entry) {
                var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                entry.applyCanvasTransforms(vertical);
              }
              /**
               * Return image data of the multi-canvas
               *
               * When using a `type` of `'blob'`, this will return a `Promise`.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|string[]|Promise} When using the default `'dataURL'`
               * `type` this returns a single data URL or an array of data URLs,
               * one for each canvas. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with an array of `Blob` instances, one for each
               * canvas.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                if (type === 'blob') {
                  return Promise.all(this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  }));
                } else if (type === 'dataURL') {
                  var images = this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  });
                  return images.length > 1 ? images : images[0];
                }
              }
              /**
               * Render the new progress
               *
               * @param {number} position X-offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {
                this.style(this.progressWave, {
                  width: position + 'px'
                });
              }
            }]);

            return MultiCanvas;
          }(_drawer.default);

          exports.default = MultiCanvas;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement-webaudio.js":
        /*!**************************************!*\
          !*** ./src/mediaelement-webaudio.js ***!
          \**************************************/
        /***/function srcMediaelementWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
           * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
           * buffer the entire file in one request, and you still get the filtering and scripting functionality
           * of the webaudio API.
           * Note that in order to use range requests and prevent buffering, you must provide peak data.
           *
           * @since 3.2.0
           */
          var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
            _inherits(MediaElementWebAudio, _MediaElement);

            var _super = _createSuper(MediaElementWebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElementWebAudio(params) {
              var _this;

              _classCallCheck(this, MediaElementWebAudio);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /** @private */

              _this.sourceMediaElement = null;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElementWebAudio, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
              }
              /**
               * Private method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);

                this.createMediaElementSource(media);
              }
              /**
               * Create MediaElementSource node
               *
               * @since 3.2.0
               * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
               */

            }, {
              key: "createMediaElementSource",
              value: function createMediaElementSource(mediaElement) {
                this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
                this.sourceMediaElement.connect(this.analyser);
              }
            }, {
              key: "play",
              value: function play(start, end) {
                this.resumeAudioContext();
                return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);

                this.destroyWebAudio();
              }
            }]);

            return MediaElementWebAudio;
          }(_mediaelement.default);

          exports.default = MediaElementWebAudio;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement.js":
        /*!*****************************!*\
          !*** ./src/mediaelement.js ***!
          \*****************************/
        /***/function srcMediaelementJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElement backend
           */
          var MediaElement = /*#__PURE__*/function (_WebAudio) {
            _inherits(MediaElement, _WebAudio);

            var _super = _createSuper(MediaElement);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElement(params) {
              var _this;

              _classCallCheck(this, MediaElement);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /**
               * Initially a dummy media element to catch errors. Once `_load` is
               * called, this will contain the actual `HTMLMediaElement`.
               * @private
               */

              _this.media = {
                currentTime: 0,
                duration: 0,
                paused: true,
                playbackRate: 1,
                play: function play() {},
                pause: function pause() {},
                volume: 0
              };
              /** @private */

              _this.mediaType = params.mediaType.toLowerCase();
              /** @private */

              _this.elementPosition = params.elementPosition;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** @private */

              _this.volume = 1;
              /** @private */

              _this.isMuted = false;
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.onPlayEnd = null;
              /** @private */

              _this.mediaListeners = {};
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElement, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
              }
              /**
               * Attach event listeners to media element.
               */

            }, {
              key: "_setupMediaListeners",
              value: function _setupMediaListeners() {
                var _this2 = this;

                this.mediaListeners.error = function () {
                  _this2.fireEvent('error', 'Error loading media element');
                };

                this.mediaListeners.canplay = function () {
                  _this2.fireEvent('canplay');
                };

                this.mediaListeners.ended = function () {
                  _this2.fireEvent('finish');
                }; // listen to and relay play, pause and seeked events to enable
                // playback control from the external media element


                this.mediaListeners.play = function () {
                  _this2.fireEvent('play');
                };

                this.mediaListeners.pause = function () {
                  _this2.fireEvent('pause');
                };

                this.mediaListeners.seeked = function (event) {
                  _this2.fireEvent('seek');
                };

                this.mediaListeners.volumechange = function (event) {
                  _this2.isMuted = _this2.media.muted;

                  if (_this2.isMuted) {
                    _this2.volume = 0;
                  } else {
                    _this2.volume = _this2.media.volume;
                  }

                  _this2.fireEvent('volume');
                }; // reset event listeners


                Object.keys(this.mediaListeners).forEach(function (id) {
                  _this2.media.removeEventListener(id, _this2.mediaListeners[id]);

                  _this2.media.addEventListener(id, _this2.mediaListeners[id]);
                });
              }
              /**
               * Create a timer to provide a more precise `audioprocess` event.
               */

            }, {
              key: "createTimer",
              value: function createTimer() {
                var _this3 = this;

                var onAudioProcess = function onAudioProcess() {
                  if (_this3.isPaused()) {
                    return;
                  }

                  _this3.fireEvent('audioprocess', _this3.getCurrentTime()); // Call again in the next frame


                  util.frame(onAudioProcess)();
                };

                this.on('play', onAudioProcess); // Update the progress one more time to prevent it from being stuck in
                // case of lower framerates

                this.on('pause', function () {
                  _this3.fireEvent('audioprocess', _this3.getCurrentTime());
                });
              }
              /**
               * Create media element with url as its source,
               * and append to container element.
               *
               * @param {string} url Path to media file
               * @param {HTMLElement} container HTML element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `url` argument is not a valid media
               * element.
               */

            }, {
              key: "load",
              value: function load(url, container, peaks, preload) {
                var media = document.createElement(this.mediaType);
                media.controls = this.params.mediaControls;
                media.autoplay = this.params.autoplay || false;
                media.preload = preload == null ? 'auto' : preload;
                media.src = url;
                media.style.width = '100%';
                var prevMedia = container.querySelector(this.mediaType);

                if (prevMedia) {
                  container.removeChild(prevMedia);
                }

                container.appendChild(media);

                this._load(media, peaks, preload);
              }
              /**
               * Load existing media element.
               *
               * @param {HTMLMediaElement} elt HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               */

            }, {
              key: "loadElt",
              value: function loadElt(elt, peaks) {
                elt.controls = this.params.mediaControls;
                elt.autoplay = this.params.autoplay || false;

                this._load(elt, peaks, elt.preload);
              }
              /**
               * Method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `media` argument is not a valid media
               * element.
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                // verify media element is valid
                if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
                  throw new Error('media parameter is not a valid media element');
                } // load must be called manually on iOS, otherwise peaks won't draw
                // until a user interaction triggers load --> 'ready' event
                //
                // note that we avoid calling media.load here when given peaks and preload == 'none'
                // as this almost always triggers some browser fetch of the media.


                if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
                  // Resets the media element and restarts the media resource. Any
                  // pending events are discarded. How much media data is fetched is
                  // still affected by the preload attribute.
                  media.load();
                }

                this.media = media;

                this._setupMediaListeners();

                this.peaks = peaks;
                this.onPlayEnd = null;
                this.buffer = null;
                this.isMuted = media.muted;
                this.setPlaybackRate(this.playbackRate);
                this.setVolume(this.volume);
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Media paused or not
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return !this.media || this.media.paused;
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                var duration = (this.buffer || this.media).duration;

                if (duration >= Infinity) {
                  // streaming audio
                  duration = this.media.seekable.end(0);
                }

                return duration;
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} Current time
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.media && this.media.currentTime;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Current position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.getCurrentTime() / this.getDuration() || 0;
              }
              /**
               * Get the audio source playback rate.
               *
               * @return {number} Playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate || this.media.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value Playback rate
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.media.playbackRate = this.playbackRate;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               */

            }, {
              key: "seekTo",
              value: function seekTo(start) {
                if (start != null) {
                  this.media.currentTime = start;
                }

                this.clearPlayEnd();
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop, relative to the beginning of a clip.
               * @emits MediaElement#play
               * @return {Promise} Result
               */

            }, {
              key: "play",
              value: function play(start, end) {
                this.seekTo(start);
                var promise = this.media.play();
                end && this.setPlayEnd(end);
                return promise;
              }
              /**
               * Pauses the loaded audio.
               *
               * @emits MediaElement#pause
               * @return {Promise} Result
               */

            }, {
              key: "pause",
              value: function pause() {
                var promise;

                if (this.media) {
                  promise = this.media.pause();
                }

                this.clearPlayEnd();
                return promise;
              }
              /**
               * Set the play end
               *
               * @param {number} end Where to end
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                var _this4 = this;

                this.clearPlayEnd();

                this._onPlayEnd = function (time) {
                  if (time >= end) {
                    _this4.pause();

                    _this4.seekTo(end);
                  }
                };

                this.on('audioprocess', this._onPlayEnd);
              }
              /** @private */

            }, {
              key: "clearPlayEnd",
              value: function clearPlayEnd() {
                if (this._onPlayEnd) {
                  this.un('audioprocess', this._onPlayEnd);
                  this._onPlayEnd = null;
                }
              }
              /**
               * Compute the max and min value of the waveform when broken into
               * <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
               * arrays of peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.buffer) {
                  return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
                }

                return this.peaks || [];
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  if (!this.media.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  return this.media.setSinkId(deviceId);
                }

                return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.volume;
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.volume = value; // no need to change when it's already at that volume

                if (this.media.volume !== this.volume) {
                  this.media.volume = this.volume;
                }
              }
              /**
               * Enable or disable muted audio
               *
               * @since 4.0.0
               * @param {boolean} muted Specify `true` to mute audio.
               */

            }, {
              key: "setMute",
              value: function setMute(muted) {
                // This causes a volume change to be emitted too through the
                // volumechange event listener.
                this.isMuted = this.media.muted = muted;
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                var _this5 = this;

                this.pause();
                this.unAll();
                this.destroyed = true; // cleanup media event listeners

                Object.keys(this.mediaListeners).forEach(function (id) {
                  if (_this5.media) {
                    _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
                  }
                });

                if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
                  this.media.parentNode.removeChild(this.media);
                }

                this.media = null;
              }
            }]);

            return MediaElement;
          }(_webaudio.default);

          exports.default = MediaElement;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/peakcache.js":
        /*!**************************!*\
          !*** ./src/peakcache.js ***!
          \**************************/
        /***/function srcPeakcacheJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Caches the decoded peaks data to improve rendering speed for large audio
           *
           * Is used if the option parameter `partialRender` is set to `true`
           */
          var PeakCache = /*#__PURE__*/function () {
            /**
             * Instantiate cache
             */
            function PeakCache() {
              _classCallCheck(this, PeakCache);

              this.clearPeakCache();
            }
            /**
             * Empty the cache
             */

            _createClass(PeakCache, [{
              key: "clearPeakCache",
              value: function clearPeakCache() {
                /**
                 * Flat array with entries that are always in pairs to mark the
                 * beginning and end of each subrange.  This is a convenience so we can
                 * iterate over the pairs for easy set difference operations.
                 * @private
                 */
                this.peakCacheRanges = [];
                /**
                 * Length of the entire cachable region, used for resetting the cache
                 * when this changes (zoom events, for instance).
                 * @private
                 */

                this.peakCacheLength = -1;
              }
              /**
               * Add a range of peaks to the cache
               *
               * @param {number} length The length of the range
               * @param {number} start The x offset of the start of the range
               * @param {number} end The x offset of the end of the range
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "addRangeToPeakCache",
              value: function addRangeToPeakCache(length, start, end) {
                if (length != this.peakCacheLength) {
                  this.clearPeakCache();
                  this.peakCacheLength = length;
                } // Return ranges that weren't in the cache before the call.


                var uncachedRanges = [];
                var i = 0; // Skip ranges before the current start.

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
                  i++;
                } // If |i| is even, |start| falls after an existing range.  Otherwise,
                // |start| falls between an existing range, and the uncached region
                // starts when we encounter the next node in |peakCacheRanges| or
                // |end|, whichever comes first.


                if (i % 2 == 0) {
                  uncachedRanges.push(start);
                }

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
                  uncachedRanges.push(this.peakCacheRanges[i]);
                  i++;
                } // If |i| is even, |end| is after all existing ranges.


                if (i % 2 == 0) {
                  uncachedRanges.push(end);
                } // Filter out the 0-length ranges.


                uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Merge the two ranges together, uncachedRanges will either contain
                // wholly new points, or duplicates of points in peakCacheRanges.  If
                // duplicates are detected, remove both and extend the range.

                this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
                this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
                  return a - b;
                }).filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Push the uncached ranges into an array of arrays for ease of
                // iteration in the functions that call this.

                var uncachedRangePairs = [];

                for (i = 0; i < uncachedRanges.length; i += 2) {
                  uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
                }

                return uncachedRangePairs;
              }
              /**
               * For testing
               *
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "getCacheRanges",
              value: function getCacheRanges() {
                var peakCacheRangePairs = [];
                var i;

                for (i = 0; i < this.peakCacheRanges.length; i += 2) {
                  peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
                }

                return peakCacheRangePairs;
              }
            }]);

            return PeakCache;
          }();

          exports.default = PeakCache;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/absMax.js":
        /*!****************************!*\
          !*** ./src/util/absMax.js ***!
          \****************************/
        /***/function srcUtilAbsMaxJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = absMax;

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Get the largest absolute value in an array
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
           * @since 4.3.0
           */
          function absMax(values) {
            var max = (0, _max.default)(values);
            var min = (0, _min.default)(values);
            return -min > max ? -min : max;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/clamp.js":
        /*!***************************!*\
          !*** ./src/util/clamp.js ***!
          \***************************/
        /***/function srcUtilClampJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = clamp;

          /**
           * Returns a number limited to the given range.
           *
           * @param {number} val The number to be limited to a range
           * @param {number} min The lower boundary of the limit range
           * @param {number} max The upper boundary of the limit range
           * @returns {number} A number in the range [min, max]
           */
          function clamp(val, min, max) {
            return Math.min(Math.max(min, val), max);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/fetch.js":
        /*!***************************!*\
          !*** ./src/util/fetch.js ***!
          \***************************/
        /***/function srcUtilFetchJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = fetchFile;

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          var ProgressHandler = /*#__PURE__*/function () {
            /**
             * Instantiate ProgressHandler
             *
             * @param {Observer} instance The `fetchFile` observer instance.
             * @param {Number} contentLength Content length.
             * @param {Response} response Response object.
             */
            function ProgressHandler(instance, contentLength, response) {
              _classCallCheck(this, ProgressHandler);

              this.instance = instance;
              this.instance._reader = response.body.getReader();
              this.total = parseInt(contentLength, 10);
              this.loaded = 0;
            }
            /**
             * A method that is called once, immediately after the `ReadableStream``
             * is constructed.
             *
             * @param {ReadableStreamDefaultController} controller Controller instance
             *     used to control the stream.
             */

            _createClass(ProgressHandler, [{
              key: "start",
              value: function start(controller) {
                var _this = this;

                var read = function read() {
                  // instance._reader.read() returns a promise that resolves
                  // when a value has been received
                  _this.instance._reader.read().then(function (_ref) {
                    var done = _ref.done,
                        value = _ref.value;

                    // result objects contain two properties:
                    // done  - true if the stream has already given you all its data.
                    // value - some data. Always undefined when done is true.
                    if (done) {
                      // ensure onProgress called when content-length=0
                      if (_this.total === 0) {
                        _this.instance.onProgress.call(_this.instance, {
                          loaded: _this.loaded,
                          total: _this.total,
                          lengthComputable: false
                        });
                      } // no more data needs to be consumed, close the stream


                      controller.close();
                      return;
                    }

                    _this.loaded += value.byteLength;

                    _this.instance.onProgress.call(_this.instance, {
                      loaded: _this.loaded,
                      total: _this.total,
                      lengthComputable: !(_this.total === 0)
                    }); // enqueue the next data chunk into our target stream


                    controller.enqueue(value);
                    read();
                  }).catch(function (error) {
                    controller.error(error);
                  });
                };

                read();
              }
            }]);

            return ProgressHandler;
          }();
          /**
           * Load a file using `fetch`.
           *
           * @param {object} options Request options to use. See example below.
           * @returns {Observer} Observer instance
           * @example
           * // default options
           * let options = {
           *     url: undefined,
           *     method: 'GET',
           *     mode: 'cors',
           *     credentials: 'same-origin',
           *     cache: 'default',
           *     responseType: 'json',
           *     requestHeaders: [],
           *     redirect: 'follow',
           *     referrer: 'client'
           * };
           *
           * // override some options
           * options.url = '../media/demo.wav';
          
           * // available types: 'arraybuffer', 'blob', 'json' or 'text'
           * options.responseType = 'arraybuffer';
           *
           * // make fetch call
           * let request = util.fetchFile(options);
           *
           * // listen for events
           * request.on('progress', e => {
           *     console.log('progress', e);
           * });
           *
           * request.on('success', data => {
           *     console.log('success!', data);
           * });
           *
           * request.on('error', e => {
           *     console.warn('fetchFile error: ', e);
           * });
           */

          function fetchFile(options) {
            if (!options) {
              throw new Error('fetch options missing');
            } else if (!options.url) {
              throw new Error('fetch url missing');
            }

            var instance = new _observer.default();
            var fetchHeaders = new Headers();
            var fetchRequest = new Request(options.url); // add ability to abort

            instance.controller = new AbortController(); // check if headers have to be added

            if (options && options.requestHeaders) {
              // add custom request headers
              options.requestHeaders.forEach(function (header) {
                fetchHeaders.append(header.key, header.value);
              });
            } // parse fetch options


            var responseType = options.responseType || 'json';
            var fetchOptions = {
              method: options.method || 'GET',
              headers: fetchHeaders,
              mode: options.mode || 'cors',
              credentials: options.credentials || 'same-origin',
              cache: options.cache || 'default',
              redirect: options.redirect || 'follow',
              referrer: options.referrer || 'client',
              signal: instance.controller.signal
            };
            fetch(fetchRequest, fetchOptions).then(function (response) {
              // store response reference
              instance.response = response;
              var progressAvailable = true;

              if (!response.body) {
                // ReadableStream is not yet supported in this browser
                // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
                progressAvailable = false;
              } // Server must send CORS header "Access-Control-Expose-Headers: content-length"


              var contentLength = response.headers.get('content-length');

              if (contentLength === null) {
                // Content-Length server response header missing.
                // Don't evaluate download progress if we can't compare against a total size
                // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
                progressAvailable = false;
              }

              if (!progressAvailable) {
                // not able to check download progress so skip it
                return response;
              } // fire progress event when during load


              instance.onProgress = function (e) {
                instance.fireEvent('progress', e);
              };

              return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
            }).then(function (response) {
              var errMsg;

              if (response.ok) {
                switch (responseType) {
                  case 'arraybuffer':
                    return response.arrayBuffer();

                  case 'json':
                    return response.json();

                  case 'blob':
                    return response.blob();

                  case 'text':
                    return response.text();

                  default:
                    errMsg = 'Unknown responseType: ' + responseType;
                    break;
                }
              }

              if (!errMsg) {
                errMsg = 'HTTP error status: ' + response.status;
              }

              throw new Error(errMsg);
            }).then(function (response) {
              instance.fireEvent('success', response);
            }).catch(function (error) {
              instance.fireEvent('error', error);
            }); // return the fetch request

            instance.fetchRequest = fetchRequest;
            return instance;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/frame.js":
        /*!***************************!*\
          !*** ./src/util/frame.js ***!
          \***************************/
        /***/function srcUtilFrameJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = frame;

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Create a function which will be called at the next requestAnimationFrame
           * cycle
           *
           * @param {function} func The function to call
           *
           * @return {func} The function wrapped within a requestAnimationFrame
           */
          function frame(func) {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return (0, _requestAnimationFrame.default)(function () {
                return func.apply(void 0, args);
              });
            };
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/get-id.js":
        /*!****************************!*\
          !*** ./src/util/get-id.js ***!
          \****************************/
        /***/function srcUtilGetIdJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = getId;

          /**
           * Get a random prefixed ID
           *
           * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
           * @returns {String} Random prefixed ID
           * @example
           * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
           *
           * let prefix = 'foo-';
           * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
           */
          function getId(prefix) {
            if (prefix === undefined) {
              prefix = 'wavesurfer_';
            }

            return prefix + Math.random().toString(32).substring(2);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/index.js":
        /*!***************************!*\
          !*** ./src/util/index.js ***!
          \***************************/
        /***/function srcUtilIndexJs(__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          Object.defineProperty(exports, "getId", {
            enumerable: true,
            get: function get() {
              return _getId.default;
            }
          });
          Object.defineProperty(exports, "max", {
            enumerable: true,
            get: function get() {
              return _max.default;
            }
          });
          Object.defineProperty(exports, "min", {
            enumerable: true,
            get: function get() {
              return _min.default;
            }
          });
          Object.defineProperty(exports, "absMax", {
            enumerable: true,
            get: function get() {
              return _absMax.default;
            }
          });
          Object.defineProperty(exports, "Observer", {
            enumerable: true,
            get: function get() {
              return _observer.default;
            }
          });
          Object.defineProperty(exports, "style", {
            enumerable: true,
            get: function get() {
              return _style.default;
            }
          });
          Object.defineProperty(exports, "requestAnimationFrame", {
            enumerable: true,
            get: function get() {
              return _requestAnimationFrame.default;
            }
          });
          Object.defineProperty(exports, "frame", {
            enumerable: true,
            get: function get() {
              return _frame.default;
            }
          });
          Object.defineProperty(exports, "debounce", {
            enumerable: true,
            get: function get() {
              return _debounce.default;
            }
          });
          Object.defineProperty(exports, "preventClick", {
            enumerable: true,
            get: function get() {
              return _preventClick.default;
            }
          });
          Object.defineProperty(exports, "fetchFile", {
            enumerable: true,
            get: function get() {
              return _fetch.default;
            }
          });
          Object.defineProperty(exports, "clamp", {
            enumerable: true,
            get: function get() {
              return _clamp.default;
            }
          });
          Object.defineProperty(exports, "withOrientation", {
            enumerable: true,
            get: function get() {
              return _orientation.default;
            }
          });

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./get-id */"./src/util/get-id.js"));

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          var _absMax = _interopRequireDefault(__webpack_require__( /*! ./absMax */"./src/util/absMax.js"));

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          var _style = _interopRequireDefault(__webpack_require__( /*! ./style */"./src/util/style.js"));

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          var _frame = _interopRequireDefault(__webpack_require__( /*! ./frame */"./src/util/frame.js"));

          var _debounce = _interopRequireDefault(__webpack_require__( /*! debounce */"./node_modules/debounce/index.js"));

          var _preventClick = _interopRequireDefault(__webpack_require__( /*! ./prevent-click */"./src/util/prevent-click.js"));

          var _fetch = _interopRequireDefault(__webpack_require__( /*! ./fetch */"./src/util/fetch.js"));

          var _clamp = _interopRequireDefault(__webpack_require__( /*! ./clamp */"./src/util/clamp.js"));

          var _orientation = _interopRequireDefault(__webpack_require__( /*! ./orientation */"./src/util/orientation.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /***/
        },

        /***/"./src/util/max.js":
        /*!*************************!*\
          !*** ./src/util/max.js ***!
          \*************************/
        /***/function srcUtilMaxJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = max;

          /**
           * Get the largest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([1, 2, 3])); // logs 3
           */
          function max(values) {
            var largest = -Infinity;
            Object.keys(values).forEach(function (i) {
              if (values[i] > largest) {
                largest = values[i];
              }
            });
            return largest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/min.js":
        /*!*************************!*\
          !*** ./src/util/min.js ***!
          \*************************/
        /***/function srcUtilMinJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = min;

          /**
           * Get the smallest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Smallest number found
           * @example console.log(min([1, 2, 3])); // logs 1
           */
          function min(values) {
            var smallest = Number(Infinity);
            Object.keys(values).forEach(function (i) {
              if (values[i] < smallest) {
                smallest = values[i];
              }
            });
            return smallest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/observer.js":
        /*!******************************!*\
          !*** ./src/util/observer.js ***!
          \******************************/
        /***/function srcUtilObserverJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} ListenerDescriptor
           * @property {string} name The name of the event
           * @property {function} callback The callback
           * @property {function} un The function to call to remove the listener
           */

          /**
           * Observer class
           */
          var Observer = /*#__PURE__*/function () {
            /**
             * Instantiate Observer
             */
            function Observer() {
              _classCallCheck(this, Observer);

              /**
               * @private
               * @todo Initialise the handlers here already and remove the conditional
               * assignment in `on()`
               */
              this._disabledEventEmissions = [];
              this.handlers = null;
            }
            /**
             * Attach a handler function for an event.
             *
             * @param {string} event Name of the event to listen to
             * @param {function} fn The callback to trigger when the event is fired
             * @return {ListenerDescriptor} The event descriptor
             */

            _createClass(Observer, [{
              key: "on",
              value: function on(event, fn) {
                var _this = this;

                if (!this.handlers) {
                  this.handlers = {};
                }

                var handlers = this.handlers[event];

                if (!handlers) {
                  handlers = this.handlers[event] = [];
                }

                handlers.push(fn); // Return an event descriptor

                return {
                  name: event,
                  callback: fn,
                  un: function un(e, fn) {
                    return _this.un(e, fn);
                  }
                };
              }
              /**
               * Remove an event handler.
               *
               * @param {string} event Name of the event the listener that should be
               * removed listens to
               * @param {function} fn The callback that should be removed
               */

            }, {
              key: "un",
              value: function un(event, fn) {
                if (!this.handlers) {
                  return;
                }

                var handlers = this.handlers[event];
                var i;

                if (handlers) {
                  if (fn) {
                    for (i = handlers.length - 1; i >= 0; i--) {
                      if (handlers[i] == fn) {
                        handlers.splice(i, 1);
                      }
                    }
                  } else {
                    handlers.length = 0;
                  }
                }
              }
              /**
               * Remove all event handlers.
               */

            }, {
              key: "unAll",
              value: function unAll() {
                this.handlers = null;
              }
              /**
               * Attach a handler to an event. The handler is executed at most once per
               * event type.
               *
               * @param {string} event The event to listen to
               * @param {function} handler The callback that is only to be called once
               * @return {ListenerDescriptor} The event descriptor
               */

            }, {
              key: "once",
              value: function once(event, handler) {
                var _this2 = this;

                var fn = function fn() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  /*  eslint-disable no-invalid-this */
                  handler.apply(_this2, args);
                  /*  eslint-enable no-invalid-this */

                  setTimeout(function () {
                    _this2.un(event, fn);
                  }, 0);
                };

                return this.on(event, fn);
              }
              /**
               * Disable firing a list of events by name. When specified, event handlers for any event type
               * passed in here will not be called.
               *
               * @since 4.0.0
               * @param {string[]} eventNames an array of event names to disable emissions for
               * @example
               * // disable seek and interaction events
               * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
               */

            }, {
              key: "setDisabledEventEmissions",
              value: function setDisabledEventEmissions(eventNames) {
                this._disabledEventEmissions = eventNames;
              }
              /**
               * plugins borrow part of this class without calling the constructor,
               * so we have to be careful about _disabledEventEmissions
               */

            }, {
              key: "_isDisabledEventEmission",
              value: function _isDisabledEventEmission(event) {
                return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
              }
              /**
               * Manually fire an event
               *
               * @param {string} event The event to fire manually
               * @param {...any} args The arguments with which to call the listeners
               */

            }, {
              key: "fireEvent",
              value: function fireEvent(event) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }

                if (!this.handlers || this._isDisabledEventEmission(event)) {
                  return;
                }

                var handlers = this.handlers[event];
                handlers && handlers.forEach(function (fn) {
                  fn.apply(void 0, args);
                });
              }
            }]);

            return Observer;
          }();

          exports.default = Observer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/orientation.js":
        /*!*********************************!*\
          !*** ./src/util/orientation.js ***!
          \*********************************/
        /***/function srcUtilOrientationJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = withOrientation;
          var verticalPropMap = {
            width: 'height',
            height: 'width',
            overflowX: 'overflowY',
            overflowY: 'overflowX',
            clientWidth: 'clientHeight',
            clientHeight: 'clientWidth',
            clientX: 'clientY',
            clientY: 'clientX',
            scrollWidth: 'scrollHeight',
            scrollLeft: 'scrollTop',
            offsetLeft: 'offsetTop',
            offsetTop: 'offsetLeft',
            offsetHeight: 'offsetWidth',
            offsetWidth: 'offsetHeight',
            left: 'top',
            right: 'bottom',
            top: 'left',
            bottom: 'right',
            borderRightStyle: 'borderBottomStyle',
            borderRightWidth: 'borderBottomWidth',
            borderRightColor: 'borderBottomColor'
          };
          /**
           * Convert a horizontally-oriented property name to a vertical one.
           *
           * @param {string} prop A property name
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {string} prop, converted appropriately
           */

          function mapProp(prop, vertical) {
            if (Object.prototype.hasOwnProperty.call(verticalPropMap, prop)) {
              return vertical ? verticalPropMap[prop] : prop;
            } else {
              return prop;
            }
          }

          var isProxy = Symbol("isProxy");
          /**
           * Returns an appropriately oriented object based on vertical.
           * If vertical is true, attribute getting and setting will be mapped through
           * verticalPropMap, so that e.g. getting the object's .width will give its
           * .height instead.
           * Certain methods of an oriented object will return oriented objects as well.
           * Oriented objects can't be added to the DOM directly since they are Proxy objects
           * and thus fail typechecks. Use domElement to get the actual element for this.
           *
           * @param {object} target The object to be wrapped and oriented
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {Proxy} An oriented object with attr translation via verticalAttrMap
           * @since 5.0.0
           */

          function withOrientation(target, vertical) {
            if (target[isProxy]) {
              return target;
            } else {
              return new Proxy(target, {
                get: function get(obj, prop, receiver) {
                  if (prop === isProxy) {
                    return true;
                  } else if (prop === 'domElement') {
                    return obj;
                  } else if (prop === 'style') {
                    return withOrientation(obj.style, vertical);
                  } else if (prop === 'canvas') {
                    return withOrientation(obj.canvas, vertical);
                  } else if (prop === 'getBoundingClientRect') {
                    return function () {
                      return withOrientation(obj.getBoundingClientRect.apply(obj, arguments), vertical);
                    };
                  } else if (prop === 'getContext') {
                    return function () {
                      return withOrientation(obj.getContext.apply(obj, arguments), vertical);
                    };
                  } else {
                    var value = obj[mapProp(prop, vertical)];
                    return typeof value == 'function' ? value.bind(obj) : value;
                  }
                },
                set: function set(obj, prop, value) {
                  obj[mapProp(prop, vertical)] = value;
                  return true;
                }
              });
            }
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/prevent-click.js":
        /*!***********************************!*\
          !*** ./src/util/prevent-click.js ***!
          \***********************************/
        /***/function srcUtilPreventClickJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = preventClick;

          /**
           * Stops propagation of click event and removes event listener
           *
           * @private
           * @param {object} event The click event
           */
          function preventClickHandler(event) {
            event.stopPropagation();
            document.body.removeEventListener('click', preventClickHandler, true);
          }
          /**
           * Starts listening for click event and prevent propagation
           *
           * @param {object} values Values
           */

          function preventClick(values) {
            document.body.addEventListener('click', preventClickHandler, true);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/request-animation-frame.js":
        /*!*********************************************!*\
          !*** ./src/util/request-animation-frame.js ***!
          \*********************************************/
        /***/function srcUtilRequestAnimationFrameJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          /* eslint-disable valid-jsdoc */

          /**
           * Returns the `requestAnimationFrame` function for the browser, or a shim with
           * `setTimeout` if the function is not found
           *
           * @return {function} Available `requestAnimationFrame` function for the browser
           */
          var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
            return setTimeout(callback, 1000 / 60);
          }).bind(window);

          exports.default = _default;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/style.js":
        /*!***************************!*\
          !*** ./src/util/style.js ***!
          \***************************/
        /***/function srcUtilStyleJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = style;

          /**
           * Apply a map of styles to an element
           *
           * @param {HTMLElement} el The element that the styles will be applied to
           * @param {Object} styles The map of propName: attribute, both are used as-is
           *
           * @return {HTMLElement} el
           */
          function style(el, styles) {
            Object.keys(styles).forEach(function (prop) {
              if (el.style[prop] !== styles[prop]) {
                el.style[prop] = styles[prop];
              }
            });
            return el;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/wavesurfer.js":
        /*!***************************!*\
          !*** ./src/wavesurfer.js ***!
          \***************************/
        /***/function srcWavesurferJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer.multicanvas */"./src/drawer.multicanvas.js"));

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          var _peakcache = _interopRequireDefault(__webpack_require__( /*! ./peakcache */"./src/peakcache.js"));

          var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__( /*! ./mediaelement-webaudio */"./src/mediaelement-webaudio.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /*
           * This work is licensed under a BSD-3-Clause License.
           */

          /** @external {HTMLElement} https://developer.mozilla.org/en/docs/Web/API/HTMLElement */

          /** @external {OfflineAudioContext} https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext */

          /** @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File */

          /** @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob */

          /** @external {CanvasRenderingContext2D} https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D */

          /** @external {MediaStreamConstraints} https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints */

          /** @external {AudioNode} https://developer.mozilla.org/de/docs/Web/API/AudioNode */

          /**
           * @typedef {Object} WavesurferParams
           * @property {AudioContext} audioContext=null Use your own previously
           * initialized AudioContext or leave blank.
           * @property {number} audioRate=1 Speed at which to play audio. Lower number is
           * slower.
           * @property {ScriptProcessorNode} audioScriptProcessor=null Use your own previously
           * initialized ScriptProcessorNode or leave blank.
           * @property {boolean} autoCenter=true If a scrollbar is present, center the
           * waveform on current progress
           * @property {number} autoCenterRate=5 If autoCenter is active, rate at which the
           * waveform is centered
           * @property {boolean} autoCenterImmediately=false If autoCenter is active, immediately
           * center waveform on current progress
           * @property {string} backend='WebAudio' `'WebAudio'|'MediaElement'|'MediaElementWebAudio'` In most cases
           * you don't have to set this manually. MediaElement is a fallback for unsupported browsers.
           * MediaElementWebAudio allows to use WebAudio API also with big audio files, loading audio like with
           * MediaElement backend (HTML5 audio tag). You have to use the same methods of MediaElement backend for loading and
           * playback, giving also peaks, so the audio data are not decoded. In this way you can use WebAudio features, like filters,
           * also with audio with big duration. For example:
           * ` wavesurfer.load(url | HTMLMediaElement, peaks, preload, duration);
           *   wavesurfer.play();
           *   wavesurfer.setFilter(customFilter);
           * `
           * @property {string} backgroundColor=null Change background color of the
           * waveform container.
           * @property {number} barHeight=1 The height of the wave bars.
           * @property {number} barRadius=0 The radius of the wave bars. Makes bars rounded
           * @property {number} barGap=null The optional spacing between bars of the wave,
           * if not provided will be calculated in legacy format.
           * @property {number} barWidth=null Draw the waveform using bars.
           * @property {number} barMinHeight=null If specified, draw at least a bar of this height,
           * eliminating waveform gaps
           * @property {boolean} closeAudioContext=false Close and nullify all audio
           * contexts when the destroy method is called.
           * @property {!string|HTMLElement} container CSS selector or HTML element where
           * the waveform should be drawn. This is the only required parameter.
           * @property {string} cursorColor='#333' The fill color of the cursor indicating
           * the playhead position.
           * @property {number} cursorWidth=1 Measured in pixels.
           * @property {object} drawingContextAttributes={desynchronized: false} Drawing context
           * attributes.
           * @property {number} duration=null Optional audio length so pre-rendered peaks
           * can be display immediately for example.
           * @property {boolean} fillParent=true Whether to fill the entire container or
           * draw only according to `minPxPerSec`.
           * @property {boolean} forceDecode=false Force decoding of audio using web audio
           * when zooming to get a more detailed waveform.
           * @property {number} height=128 The height of the waveform. Measured in
           * pixels.
           * @property {boolean} hideScrollbar=false Whether to hide the horizontal
           * scrollbar when one would normally be shown.
           * @property {boolean} interact=true Whether the mouse interaction will be
           * enabled at initialization. You can switch this parameter at any time later
           * on.
           * @property {boolean} loopSelection=true (Use with regions plugin) Enable
           * looping of selected regions
           * @property {number} maxCanvasWidth=4000 Maximum width of a single canvas in
           * pixels, excluding a small overlap (2 * `pixelRatio`, rounded up to the next
           * even integer). If the waveform is longer than this value, additional canvases
           * will be used to render the waveform, which is useful for very large waveforms
           * that may be too wide for browsers to draw on a single canvas.
           * @property {boolean} mediaControls=false (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * this enables the native controls for the media element
           * @property {string} mediaType='audio' (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * `'audio'|'video'` ('video' only for `MediaElement`)
           * @property {number} minPxPerSec=20 Minimum number of pixels per second of
           * audio.
           * @property {boolean} normalize=false If true, normalize by the maximum peak
           * instead of 1.0.
           * @property {boolean} partialRender=false Use the PeakCache to improve
           * rendering speed of large waveforms
           * @property {number} pixelRatio=window.devicePixelRatio The pixel ratio used to
           * calculate display
           * @property {PluginDefinition[]} plugins=[] An array of plugin definitions to
           * register during instantiation, they will be directly initialised unless they
           * are added with the `deferInit` property set to true.
           * @property {string} progressColor='#555' The fill color of the part of the
           * waveform behind the cursor. When `progressColor` and `waveColor` are the same
           * the progress wave is not rendered at all.
           * @property {boolean} removeMediaElementOnDestroy=true Set to false to keep the
           * media element in the DOM when the player is destroyed. This is useful when
           * reusing an existing media element via the `loadMediaElement` method.
           * @property {Object} renderer=MultiCanvas Can be used to inject a custom
           * renderer.
           * @property {boolean|number} responsive=false If set to `true` resize the
           * waveform, when the window is resized. This is debounced with a `100ms`
           * timeout by default. If this parameter is a number it represents that timeout.
           * @property {boolean} rtl=false If set to `true`, renders waveform from
           * right-to-left.
           * @property {boolean} scrollParent=false Whether to scroll the container with a
           * lengthy waveform. Otherwise the waveform is shrunk to the container width
           * (see fillParent).
           * @property {number} skipLength=2 Number of seconds to skip with the
           * skipForward() and skipBackward() methods.
           * @property {boolean} splitChannels=false Render with separate waveforms for
           * the channels of the audio
           * @property {SplitChannelOptions} splitChannelsOptions={} Options for splitChannel rendering
           * @property {boolean} vertical=false Render the waveform vertically instead of horizontally.
           * @property {string} waveColor='#999' The fill color of the waveform after the
           * cursor.
           * @property {object} xhr={} XHR options. For example:
           * `let xhr = {
           *     cache: 'default',
           *     mode: 'cors',
           *     method: 'GET',
           *     credentials: 'same-origin',
           *     redirect: 'follow',
           *     referrer: 'client',
           *     requestHeaders: [
           *         {
           *             key: 'Authorization',
           *             value: 'my-token'
           *         }
           *     ]
           * };`
           */

          /**
           * @typedef {Object} PluginDefinition
           * @desc The Object used to describe a plugin
           * @example wavesurfer.addPlugin(pluginDefinition);
           * @property {string} name The name of the plugin, the plugin instance will be
           * added as a property to the wavesurfer instance under this name
           * @property {?Object} staticProps The properties that should be added to the
           * wavesurfer instance as static properties
           * @property {?boolean} deferInit Don't initialise plugin
           * automatically
           * @property {Object} params={} The plugin parameters, they are the first parameter
           * passed to the plugin class constructor function
           * @property {PluginClass} instance The plugin instance factory, is called with
           * the dependency specified in extends. Returns the plugin class.
           */

          /**
           * @typedef {Object} SplitChannelOptions
           * @desc parameters applied when splitChannels option is true
           * @property {boolean} overlay=false determines whether channels are rendered on top of each other or on separate tracks
           * @property {object} channelColors={} object describing color for each channel. Example:
           * {
           *     0: {
           *         progressColor: 'green',
           *         waveColor: 'pink'
           *     },
           *     1: {
           *         progressColor: 'orange',
           *         waveColor: 'purple'
           *     }
           * }
           * @property {number[]} filterChannels=[] indexes of channels to be hidden from rendering
           * @property {boolean} relativeNormalization=false determines whether
           * normalization is done per channel or maintains proportionality between
           * channels. Only applied when normalize and splitChannels are both true.
           * @since 4.3.0
           */

          /**
           * @interface PluginClass
           *
           * @desc This is the interface which is implemented by all plugin classes. Note
           * that this only turns into an observer after being passed through
           * `wavesurfer.addPlugin`.
           *
           * @extends {Observer}
           */
          var PluginClass = /*#__PURE__*/function () {
            /**
             * Construct the plugin
             *
             * @param {Object} params={} The plugin params (specific to the plugin)
             * @param {Object} ws The wavesurfer instance
             */
            function PluginClass(params, ws) {
              _classCallCheck(this, PluginClass);
            }
            /**
             * Initialise the plugin
             *
             * Start doing something. This is called by
             * `wavesurfer.initPlugin(pluginName)`
             */

            _createClass(PluginClass, [{
              key: "create",
              value:
              /**
               * Plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * It returns a `PluginDefinition` object representing the plugin.
               *
               * @param {Object} params={} The plugin params (specific to the plugin)
               */
              function create(params) {}
            }, {
              key: "init",
              value: function init() {}
              /**
               * Destroy the plugin instance
               *
               * Stop doing something. This is called by
               * `wavesurfer.destroyPlugin(pluginName)`
               */

            }, {
              key: "destroy",
              value: function destroy() {}
            }]);

            return PluginClass;
          }();
          /**
           * WaveSurfer core library class
           *
           * @extends {Observer}
           * @example
           * const params = {
           *   container: '#waveform',
           *   waveColor: 'violet',
           *   progressColor: 'purple'
           * };
           *
           * // initialise like this
           * const wavesurfer = WaveSurfer.create(params);
           *
           * // or like this ...
           * const wavesurfer = new WaveSurfer(params);
           * wavesurfer.init();
           *
           * // load audio file
           * wavesurfer.load('example/media/demo.wav');
           */

          var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
            _inherits(WaveSurfer, _util$Observer);

            var _super = _createSuper(WaveSurfer);

            /**
             * Initialise wavesurfer instance
             *
             * @param {WavesurferParams} params Instantiation options for wavesurfer
             * @example
             * const wavesurfer = new WaveSurfer(params);
             * @returns {this} Wavesurfer instance
             */
            function WaveSurfer(params) {
              var _this;

              _classCallCheck(this, WaveSurfer);

              _this = _super.call(this);
              /**
               * Extract relevant parameters (or defaults)
               * @private
               */

              _this.defaultParams = {
                audioContext: null,
                audioScriptProcessor: null,
                audioRate: 1,
                autoCenter: true,
                autoCenterRate: 5,
                autoCenterImmediately: false,
                backend: 'WebAudio',
                backgroundColor: null,
                barHeight: 1,
                barRadius: 0,
                barGap: null,
                barMinHeight: null,
                container: null,
                cursorColor: '#333',
                cursorWidth: 1,
                dragSelection: true,
                drawingContextAttributes: {
                  // Boolean that hints the user agent to reduce the latency
                  // by desynchronizing the canvas paint cycle from the event
                  // loop
                  desynchronized: false
                },
                duration: null,
                fillParent: true,
                forceDecode: false,
                height: 128,
                hideScrollbar: false,
                interact: true,
                loopSelection: true,
                maxCanvasWidth: 4000,
                mediaContainer: null,
                mediaControls: false,
                mediaType: 'audio',
                minPxPerSec: 20,
                normalize: false,
                partialRender: false,
                pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
                plugins: [],
                progressColor: '#555',
                removeMediaElementOnDestroy: true,
                renderer: _drawer.default,
                responsive: false,
                rtl: false,
                scrollParent: false,
                skipLength: 2,
                splitChannels: false,
                splitChannelsOptions: {
                  overlay: false,
                  channelColors: {},
                  filterChannels: [],
                  relativeNormalization: false
                },
                vertical: false,
                waveColor: '#999',
                xhr: {}
              };
              _this.backends = {
                MediaElement: _mediaelement.default,
                WebAudio: _webaudio.default,
                MediaElementWebAudio: _mediaelementWebaudio.default
              };
              _this.util = util;
              _this.params = _extends({}, _this.defaultParams, params);
              _this.params.splitChannelsOptions = _extends({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
              /** @private */

              _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;

              if (!_this.container) {
                throw new Error('Container element not found');
              }

              if (_this.params.mediaContainer == null) {
                /** @private */
                _this.mediaContainer = _this.container;
              } else if (typeof _this.params.mediaContainer == 'string') {
                /** @private */
                _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
              } else {
                /** @private */
                _this.mediaContainer = _this.params.mediaContainer;
              }

              if (!_this.mediaContainer) {
                throw new Error('Media Container element not found');
              }

              if (_this.params.maxCanvasWidth <= 1) {
                throw new Error('maxCanvasWidth must be greater than 1');
              } else if (_this.params.maxCanvasWidth % 2 == 1) {
                throw new Error('maxCanvasWidth must be an even number');
              }

              if (_this.params.rtl === true) {
                if (_this.params.vertical === true) {
                  util.style(_this.container, {
                    transform: 'rotateX(180deg)'
                  });
                } else {
                  util.style(_this.container, {
                    transform: 'rotateY(180deg)'
                  });
                }
              }

              if (_this.params.backgroundColor) {
                _this.setBackgroundColor(_this.params.backgroundColor);
              }
              /**
               * @private Used to save the current volume when muting so we can
               * restore once unmuted
               * @type {number}
               */

              _this.savedVolume = 0;
              /**
               * @private The current muted state
               * @type {boolean}
               */

              _this.isMuted = false;
              /**
               * @private Will hold a list of event descriptors that need to be
               * canceled on subsequent loads of audio
               * @type {Object[]}
               */

              _this.tmpEvents = [];
              /**
               * @private Holds any running audio downloads
               * @type {Observer}
               */

              _this.currentRequest = null;
              /** @private */

              _this.arraybuffer = null;
              /** @private */

              _this.drawer = null;
              /** @private */

              _this.backend = null;
              /** @private */

              _this.peakCache = null; // cache constructor objects

              if (typeof _this.params.renderer !== 'function') {
                throw new Error('Renderer parameter is invalid');
              }
              /**
               * @private The uninitialised Drawer class
               */

              _this.Drawer = _this.params.renderer;
              /**
               * @private The uninitialised Backend class
               */
              // Back compat

              if (_this.params.backend == 'AudioElement') {
                _this.params.backend = 'MediaElement';
              }

              if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
                _this.params.backend = 'MediaElement';
              }

              _this.Backend = _this.backends[_this.params.backend];
              /**
               * @private map of plugin names that are currently initialised
               */

              _this.initialisedPluginList = {};
              /** @private */

              _this.isDestroyed = false;
              /**
               * Get the current ready status.
               *
               * @example const isReady = wavesurfer.isReady;
               * @return {boolean}
               */

              _this.isReady = false; // responsive debounced event listener. If this.params.responsive is not
              // set, this is never called. Use 100ms or this.params.responsive as
              // timeout for the debounce function.

              var prevWidth = 0;
              _this._onResize = util.debounce(function () {
                if (prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
                  prevWidth = _this.drawer.wrapper.clientWidth;

                  _this.drawer.fireEvent('redraw');
                }
              }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
              return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
            }
            /**
             * Initialise the wave
             *
             * @example
             * var wavesurfer = new WaveSurfer(params);
             * wavesurfer.init();
             * @return {this} The wavesurfer instance
             */

            _createClass(WaveSurfer, [{
              key: "init",
              value: function init() {
                this.registerPlugins(this.params.plugins);
                this.createDrawer();
                this.createBackend();
                this.createPeakCache();
                return this;
              }
              /**
               * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
               * this function is called in the init function of wavesurfer
               *
               * @param {PluginDefinition[]} plugins An array of plugin definitions
               * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "registerPlugins",
              value: function registerPlugins(plugins) {
                var _this2 = this;

                // first instantiate all the plugins
                plugins.forEach(function (plugin) {
                  return _this2.addPlugin(plugin);
                }); // now run the init functions

                plugins.forEach(function (plugin) {
                  // call init function of the plugin if deferInit is falsey
                  // in that case you would manually use initPlugins()
                  if (!plugin.deferInit) {
                    _this2.initPlugin(plugin.name);
                  }
                });
                this.fireEvent('plugins-registered', plugins);
                return this;
              }
              /**
               * Get a map of plugin names that are currently initialised
               *
               * @example wavesurfer.getPlugins();
               * @return {Object} Object with plugin names
               */

            }, {
              key: "getActivePlugins",
              value: function getActivePlugins() {
                return this.initialisedPluginList;
              }
              /**
               * Add a plugin object to wavesurfer
               *
               * @param {PluginDefinition} plugin A plugin definition
               * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
               * @example wavesurfer.addPlugin(WaveSurfer.minimap());
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "addPlugin",
              value: function addPlugin(plugin) {
                var _this3 = this;

                if (!plugin.name) {
                  throw new Error('Plugin does not have a name!');
                }

                if (!plugin.instance) {
                  throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
                } // staticProps properties are applied to wavesurfer instance


                if (plugin.staticProps) {
                  Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
                    /**
                     * Properties defined in a plugin definition's `staticProps` property are added as
                     * staticProps properties of the WaveSurfer instance
                     */
                    _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
                  });
                }

                var Instance = plugin.instance; // turn the plugin instance into an observer

                var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
                observerPrototypeKeys.forEach(function (key) {
                  Instance.prototype[key] = util.Observer.prototype[key];
                });
                /**
                 * Instantiated plugin classes are added as a property of the wavesurfer
                 * instance
                 * @type {Object}
                 */

                this[plugin.name] = new Instance(plugin.params || {}, this);
                this.fireEvent('plugin-added', plugin.name);
                return this;
              }
              /**
               * Initialise a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-initialised
               * @example wavesurfer.initPlugin('minimap');
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "initPlugin",
              value: function initPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet!"));
                }

                if (this.initialisedPluginList[name]) {
                  // destroy any already initialised plugins
                  this.destroyPlugin(name);
                }

                this[name].init();
                this.initialisedPluginList[name] = true;
                this.fireEvent('plugin-initialised', name);
                return this;
              }
              /**
               * Destroy a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-destroyed
               * @example wavesurfer.destroyPlugin('minimap');
               * @returns {this} The wavesurfer instance
               */

            }, {
              key: "destroyPlugin",
              value: function destroyPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
                }

                if (!this.initialisedPluginList[name]) {
                  throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
                }

                if (typeof this[name].destroy !== 'function') {
                  throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
                }

                this[name].destroy();
                delete this.initialisedPluginList[name];
                this.fireEvent('plugin-destroyed', name);
                return this;
              }
              /**
               * Destroy all initialised plugins. Convenience function to use when
               * wavesurfer is removed
               *
               * @private
               */

            }, {
              key: "destroyAllPlugins",
              value: function destroyAllPlugins() {
                var _this4 = this;

                Object.keys(this.initialisedPluginList).forEach(function (name) {
                  return _this4.destroyPlugin(name);
                });
              }
              /**
               * Create the drawer and draw the waveform
               *
               * @private
               * @emits WaveSurfer#drawer-created
               */

            }, {
              key: "createDrawer",
              value: function createDrawer() {
                var _this5 = this;

                this.drawer = new this.Drawer(this.container, this.params);
                this.drawer.init();
                this.fireEvent('drawer-created', this.drawer);

                if (this.params.responsive !== false) {
                  window.addEventListener('resize', this._onResize, true);
                  window.addEventListener('orientationchange', this._onResize, true);
                }

                this.drawer.on('redraw', function () {
                  _this5.drawBuffer();

                  _this5.drawer.progress(_this5.backend.getPlayedPercents());
                }); // Click-to-seek

                this.drawer.on('click', function (e, progress) {
                  setTimeout(function () {
                    return _this5.seekTo(progress);
                  }, 0);
                }); // Relay the scroll event from the drawer

                this.drawer.on('scroll', function (e) {
                  if (_this5.params.partialRender) {
                    _this5.drawBuffer();
                  }

                  _this5.fireEvent('scroll', e);
                });
              }
              /**
               * Create the backend
               *
               * @private
               * @emits WaveSurfer#backend-created
               */

            }, {
              key: "createBackend",
              value: function createBackend() {
                var _this6 = this;

                if (this.backend) {
                  this.backend.destroy();
                }

                this.backend = new this.Backend(this.params);
                this.backend.init();
                this.fireEvent('backend-created', this.backend);
                this.backend.on('finish', function () {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('finish');
                });
                this.backend.on('play', function () {
                  return _this6.fireEvent('play');
                });
                this.backend.on('pause', function () {
                  return _this6.fireEvent('pause');
                });
                this.backend.on('audioprocess', function (time) {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('audioprocess', time);
                }); // only needed for MediaElement and MediaElementWebAudio backend

                if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
                  this.backend.on('seek', function () {
                    _this6.drawer.progress(_this6.backend.getPlayedPercents());
                  });
                  this.backend.on('volume', function () {
                    var newVolume = _this6.getVolume();

                    _this6.fireEvent('volume', newVolume);

                    if (_this6.backend.isMuted !== _this6.isMuted) {
                      _this6.isMuted = _this6.backend.isMuted;

                      _this6.fireEvent('mute', _this6.isMuted);
                    }
                  });
                }
              }
              /**
               * Create the peak cache
               *
               * @private
               */

            }, {
              key: "createPeakCache",
              value: function createPeakCache() {
                if (this.params.partialRender) {
                  this.peakCache = new _peakcache.default();
                }
              }
              /**
               * Get the duration of the audio clip
               *
               * @example const duration = wavesurfer.getDuration();
               * @return {number} Duration in seconds
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                return this.backend.getDuration();
              }
              /**
               * Get the current playback position
               *
               * @example const currentTime = wavesurfer.getCurrentTime();
               * @return {number} Playback position in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.backend.getCurrentTime();
              }
              /**
               * Set the current play time in seconds.
               *
               * @param {number} seconds A positive number in seconds. E.g. 10 means 10
               * seconds, 60 means 1 minute
               */

            }, {
              key: "setCurrentTime",
              value: function setCurrentTime(seconds) {
                if (seconds >= this.getDuration()) {
                  this.seekTo(1);
                } else {
                  this.seekTo(seconds / this.getDuration());
                }
              }
              /**
               * Starts playback from the current position. Optional start and end
               * measured in seconds can be used to set the range of audio to play.
               *
               * @param {?number} start Position to start at
               * @param {?number} end Position to end at
               * @emits WaveSurfer#interaction
               * @return {Promise} Result of the backend play method
               * @example
               * // play from second 1 to 5
               * wavesurfer.play(1, 5);
               */

            }, {
              key: "play",
              value: function play(start, end) {
                var _this7 = this;

                this.fireEvent('interaction', function () {
                  return _this7.play(start, end);
                });
                return this.backend.play(start, end);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} position Position (in seconds) to stop at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(position) {
                this.backend.setPlayEnd(position);
              }
              /**
               * Stops and pauses playback
               *
               * @example wavesurfer.pause();
               * @return {Promise} Result of the backend pause method
               */

            }, {
              key: "pause",
              value: function pause() {
                if (!this.backend.isPaused()) {
                  return this.backend.pause();
                }
              }
              /**
               * Toggle playback
               *
               * @example wavesurfer.playPause();
               * @return {Promise} Result of the backend play or pause method
               */

            }, {
              key: "playPause",
              value: function playPause() {
                return this.backend.isPaused() ? this.play() : this.pause();
              }
              /**
               * Get the current playback state
               *
               * @example const isPlaying = wavesurfer.isPlaying();
               * @return {boolean} False if paused, true if playing
               */

            }, {
              key: "isPlaying",
              value: function isPlaying() {
                return !this.backend.isPaused();
              }
              /**
               * Skip backward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipBackward();
               */

            }, {
              key: "skipBackward",
              value: function skipBackward(seconds) {
                this.skip(-seconds || -this.params.skipLength);
              }
              /**
               * Skip forward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipForward();
               */

            }, {
              key: "skipForward",
              value: function skipForward(seconds) {
                this.skip(seconds || this.params.skipLength);
              }
              /**
               * Skip a number of seconds from the current position (use a negative value
               * to go backwards).
               *
               * @param {number} offset Amount to skip back or forwards
               * @example
               * // go back 2 seconds
               * wavesurfer.skip(-2);
               */

            }, {
              key: "skip",
              value: function skip(offset) {
                var duration = this.getDuration() || 1;
                var position = this.getCurrentTime() || 0;
                position = Math.max(0, Math.min(duration, position + (offset || 0)));
                this.seekAndCenter(position / duration);
              }
              /**
               * Seeks to a position and centers the view
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @example
               * // seek and go to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekAndCenter",
              value: function seekAndCenter(progress) {
                this.seekTo(progress);
                this.drawer.recenter(progress);
              }
              /**
               * Seeks to a position
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @emits WaveSurfer#interaction
               * @emits WaveSurfer#seek
               * @example
               * // seek to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekTo",
              value: function seekTo(progress) {
                var _this8 = this;

                // return an error if progress is not a number between 0 and 1
                if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
                  throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
                }

                this.fireEvent('interaction', function () {
                  return _this8.seekTo(progress);
                });
                var isWebAudioBackend = this.params.backend === 'WebAudio';
                var paused = this.backend.isPaused();

                if (isWebAudioBackend && !paused) {
                  this.backend.pause();
                } // avoid small scrolls while paused seeking


                var oldScrollParent = this.params.scrollParent;
                this.params.scrollParent = false;
                this.backend.seekTo(progress * this.getDuration());
                this.drawer.progress(progress);

                if (isWebAudioBackend && !paused) {
                  this.backend.play();
                }

                this.params.scrollParent = oldScrollParent;
                this.fireEvent('seek', progress);
              }
              /**
               * Stops and goes to the beginning.
               *
               * @example wavesurfer.stop();
               */

            }, {
              key: "stop",
              value: function stop() {
                this.pause();
                this.seekTo(0);
                this.drawer.progress(0);
              }
              /**
               * Sets the ID of the audio device to use for output and returns a Promise.
               *
               * @param {string} deviceId String value representing underlying output
               * device
               * @returns {Promise} `Promise` that resolves to `undefined` when there are
               * no errors detected.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                return this.backend.setSinkId(deviceId);
              }
              /**
               * Set the playback volume.
               *
               * @param {number} newVolume A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               * @emits WaveSurfer#volume
               */

            }, {
              key: "setVolume",
              value: function setVolume(newVolume) {
                this.backend.setVolume(newVolume);
                this.fireEvent('volume', newVolume);
              }
              /**
               * Get the playback volume.
               *
               * @return {number} A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.backend.getVolume();
              }
              /**
               * Set the playback rate.
               *
               * @param {number} rate A positive number. E.g. 0.5 means half the normal
               * speed, 2 means double speed and so on.
               * @example wavesurfer.setPlaybackRate(2);
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(rate) {
                this.backend.setPlaybackRate(rate);
              }
              /**
               * Get the playback rate.
               *
               * @return {number} The current playback rate.
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.backend.getPlaybackRate();
              }
              /**
               * Toggle the volume on and off. If not currently muted it will save the
               * current volume value and turn the volume off. If currently muted then it
               * will restore the volume to the saved value, and then rest the saved
               * value.
               *
               * @example wavesurfer.toggleMute();
               */

            }, {
              key: "toggleMute",
              value: function toggleMute() {
                this.setMute(!this.isMuted);
              }
              /**
               * Enable or disable muted audio
               *
               * @param {boolean} mute Specify `true` to mute audio.
               * @emits WaveSurfer#volume
               * @emits WaveSurfer#mute
               * @example
               * // unmute
               * wavesurfer.setMute(false);
               * console.log(wavesurfer.getMute()) // logs false
               */

            }, {
              key: "setMute",
              value: function setMute(mute) {
                // ignore all muting requests if the audio is already in that state
                if (mute === this.isMuted) {
                  this.fireEvent('mute', this.isMuted);
                  return;
                }

                if (this.backend.setMute) {
                  // Backends such as the MediaElement backend have their own handling
                  // of mute, let them handle it.
                  this.backend.setMute(mute);
                  this.isMuted = mute;
                } else {
                  if (mute) {
                    // If currently not muted then save current volume,
                    // turn off the volume and update the mute properties
                    this.savedVolume = this.backend.getVolume();
                    this.backend.setVolume(0);
                    this.isMuted = true;
                    this.fireEvent('volume', 0);
                  } else {
                    // If currently muted then restore to the saved volume
                    // and update the mute properties
                    this.backend.setVolume(this.savedVolume);
                    this.isMuted = false;
                    this.fireEvent('volume', this.savedVolume);
                  }
                }

                this.fireEvent('mute', this.isMuted);
              }
              /**
               * Get the current mute status.
               *
               * @example const isMuted = wavesurfer.getMute();
               * @return {boolean} Current mute status
               */

            }, {
              key: "getMute",
              value: function getMute() {
                return this.isMuted;
              }
              /**
               * Get the list of current set filters as an array.
               *
               * Filters must be set with setFilters method first
               *
               * @return {array} List of enabled filters
               */

            }, {
              key: "getFilters",
              value: function getFilters() {
                return this.backend.filters || [];
              }
              /**
               * Toggles `scrollParent` and redraws
               *
               * @example wavesurfer.toggleScroll();
               */

            }, {
              key: "toggleScroll",
              value: function toggleScroll() {
                this.params.scrollParent = !this.params.scrollParent;
                this.drawBuffer();
              }
              /**
               * Toggle mouse interaction
               *
               * @example wavesurfer.toggleInteraction();
               */

            }, {
              key: "toggleInteraction",
              value: function toggleInteraction() {
                this.params.interact = !this.params.interact;
              }
              /**
               * Get the fill color of the waveform after the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getWaveColor",
              value: function getWaveColor() {
                return this.params.waveColor;
              }
              /**
               * Set the fill color of the waveform after the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setWaveColor('#ddd');
               */

            }, {
              key: "setWaveColor",
              value: function setWaveColor(color) {
                this.params.waveColor = color;
                this.drawBuffer();
              }
              /**
               * Get the fill color of the waveform behind the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getProgressColor",
              value: function getProgressColor() {
                return this.params.progressColor;
              }
              /**
               * Set the fill color of the waveform behind the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setProgressColor('#400');
               */

            }, {
              key: "setProgressColor",
              value: function setProgressColor(color) {
                this.params.progressColor = color;
                this.drawBuffer();
              }
              /**
               * Get the background color of the waveform container.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getBackgroundColor",
              value: function getBackgroundColor() {
                return this.params.backgroundColor;
              }
              /**
               * Set the background color of the waveform container.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setBackgroundColor('#FF00FF');
               */

            }, {
              key: "setBackgroundColor",
              value: function setBackgroundColor(color) {
                this.params.backgroundColor = color;
                util.style(this.container, {
                  background: this.params.backgroundColor
                });
              }
              /**
               * Get the fill color of the cursor indicating the playhead
               * position.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getCursorColor",
              value: function getCursorColor() {
                return this.params.cursorColor;
              }
              /**
               * Set the fill color of the cursor indicating the playhead
               * position.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setCursorColor('#222');
               */

            }, {
              key: "setCursorColor",
              value: function setCursorColor(color) {
                this.params.cursorColor = color;
                this.drawer.updateCursor();
              }
              /**
               * Get the height of the waveform.
               *
               * @return {number} Height measured in pixels.
               */

            }, {
              key: "getHeight",
              value: function getHeight() {
                return this.params.height;
              }
              /**
               * Set the height of the waveform.
               *
               * @param {number} height Height measured in pixels.
               * @example wavesurfer.setHeight(200);
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                this.params.height = height;
                this.drawer.setHeight(height * this.params.pixelRatio);
                this.drawBuffer();
              }
              /**
               * Hide channels from being drawn on the waveform if splitting channels.
               *
               * For example, if we want to draw only the peaks for the right stereo channel:
               *
               * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
               * wavesurfer.load('stereo_audio.mp3');
               *
               * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
               *
               * @param {array} channelIndices Channels to be filtered out from drawing.
               * @version 4.0.0
               */

            }, {
              key: "setFilteredChannels",
              value: function setFilteredChannels(channelIndices) {
                this.params.splitChannelsOptions.filterChannels = channelIndices;
                this.drawBuffer();
              }
              /**
               * Get the correct peaks for current wave view-port and render wave
               *
               * @private
               * @emits WaveSurfer#redraw
               */

            }, {
              key: "drawBuffer",
              value: function drawBuffer() {
                var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
                var parentWidth = this.drawer.getWidth();
                var width = nominalWidth; // always start at 0 after zooming for scrolling : issue redraw left part

                var start = 0;
                var end = Math.max(start + parentWidth, width); // Fill container

                if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
                  width = parentWidth;
                  start = 0;
                  end = width;
                }

                var peaks;

                if (this.params.partialRender) {
                  var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
                  var i;

                  for (i = 0; i < newRanges.length; i++) {
                    peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
                    this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
                  }
                } else {
                  peaks = this.backend.getPeaks(width, start, end);
                  this.drawer.drawPeaks(peaks, width, start, end);
                }

                this.fireEvent('redraw', peaks, width);
              }
              /**
               * Horizontally zooms the waveform in and out. It also changes the parameter
               * `minPxPerSec` and enables the `scrollParent` option. Calling the function
               * with a falsey parameter will reset the zoom state.
               *
               * @param {?number} pxPerSec Number of horizontal pixels per second of
               * audio, if none is set the waveform returns to unzoomed state
               * @emits WaveSurfer#zoom
               * @example wavesurfer.zoom(20);
               */

            }, {
              key: "zoom",
              value: function zoom(pxPerSec) {
                if (!pxPerSec) {
                  this.params.minPxPerSec = this.defaultParams.minPxPerSec;
                  this.params.scrollParent = false;
                } else {
                  this.params.minPxPerSec = pxPerSec;
                  this.params.scrollParent = true;
                }

                this.drawBuffer();
                this.drawer.progress(this.backend.getPlayedPercents());
                this.drawer.recenter(this.getCurrentTime() / this.getDuration());
                this.fireEvent('zoom', pxPerSec);
              }
              /**
               * Decode buffer and load
               *
               * @private
               * @param {ArrayBuffer} arraybuffer Buffer to process
               */

            }, {
              key: "loadArrayBuffer",
              value: function loadArrayBuffer(arraybuffer) {
                var _this9 = this;

                this.decodeArrayBuffer(arraybuffer, function (data) {
                  if (!_this9.isDestroyed) {
                    _this9.loadDecodedBuffer(data);
                  }
                });
              }
              /**
               * Directly load an externally decoded AudioBuffer
               *
               * @private
               * @param {AudioBuffer} buffer Buffer to process
               * @emits WaveSurfer#ready
               */

            }, {
              key: "loadDecodedBuffer",
              value: function loadDecodedBuffer(buffer) {
                this.backend.load(buffer);
                this.drawBuffer();
                this.isReady = true;
                this.fireEvent('ready');
              }
              /**
               * Loads audio data from a Blob or File object
               *
               * @param {Blob|File} blob Audio data
               * @example
               */

            }, {
              key: "loadBlob",
              value: function loadBlob(blob) {
                var _this10 = this;

                // Create file reader
                var reader = new FileReader();
                reader.addEventListener('progress', function (e) {
                  return _this10.onProgress(e);
                });
                reader.addEventListener('load', function (e) {
                  return _this10.loadArrayBuffer(e.target.result);
                });
                reader.addEventListener('error', function () {
                  return _this10.fireEvent('error', 'Error reading file');
                });
                reader.readAsArrayBuffer(blob);
                this.empty();
              }
              /**
               * Loads audio and re-renders the waveform.
               *
               * @param {string|HTMLMediaElement} url The url of the audio file or the
               * audio element with the audio
               * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
               * the audio to render the waveform if this is specified
               * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
               * `'none'|'metadata'|'auto'` Preload attribute for the media element
               * @param {?number} duration The duration of the audio. This is used to
               * render the peaks data in the correct size for the audio duration (as
               * befits the current `minPxPerSec` and zoom value) without having to decode
               * the audio.
               * @returns {void}
               * @throws Will throw an error if the `url` argument is empty.
               * @example
               * // uses fetch or media element to load file (depending on backend)
               * wavesurfer.load('http://example.com/demo.wav');
               *
               * // setting preload attribute with media element backend and supplying
               * // peaks
               * wavesurfer.load(
               *   'http://example.com/demo.wav',
               *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
               *   true
               * );
               */

            }, {
              key: "load",
              value: function load(url, peaks, preload, duration) {
                if (!url) {
                  throw new Error('url parameter cannot be empty');
                }

                this.empty();

                if (preload) {
                  // check whether the preload attribute will be usable and if not log
                  // a warning listing the reasons why not and nullify the variable
                  var preloadIgnoreReasons = {
                    "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
                    'Peaks are not provided': !peaks,
                    "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
                    'Url is not of type string': typeof url !== 'string'
                  };
                  var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
                    return preloadIgnoreReasons[reason];
                  });

                  if (activeReasons.length) {
                    // eslint-disable-next-line no-console
                    console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- ')); // stop invalid values from being used

                    preload = null;
                  }
                } // loadBuffer(url, peaks, duration) requires that url is a string
                // but users can pass in a HTMLMediaElement to WaveSurfer


                if (this.params.backend === 'WebAudio' && url instanceof HTMLMediaElement) {
                  url = url.src;
                }

                switch (this.params.backend) {
                  case 'WebAudio':
                    return this.loadBuffer(url, peaks, duration);

                  case 'MediaElement':
                  case 'MediaElementWebAudio':
                    return this.loadMediaElement(url, peaks, preload, duration);
                }
              }
              /**
               * Loads audio using Web Audio buffer backend.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string} url URL of audio file
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Optional duration of audio file
               * @returns {void}
               */

            }, {
              key: "loadBuffer",
              value: function loadBuffer(url, peaks, duration) {
                var _this11 = this;

                var load = function load(action) {
                  if (action) {
                    _this11.tmpEvents.push(_this11.once('ready', action));
                  }

                  return _this11.getArrayBuffer(url, function (data) {
                    return _this11.loadArrayBuffer(data);
                  });
                };

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                  this.tmpEvents.push(this.once('interaction', load));
                } else {
                  return load();
                }
              }
              /**
               * Either create a media element, or load an existing media element.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
               * existing HTML5 Audio/Video Element
               * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
               * dependency
               * @param {?boolean} preload Set to true if the preload attribute of the
               * audio element should be enabled
               * @param {?number} duration Optional duration of audio file
               */

            }, {
              key: "loadMediaElement",
              value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
                var _this12 = this;

                var url = urlOrElt;

                if (typeof urlOrElt === 'string') {
                  this.backend.load(url, this.mediaContainer, peaks, preload);
                } else {
                  var elt = urlOrElt;
                  this.backend.loadElt(elt, peaks); // If peaks are not provided,
                  // url = element.src so we can get peaks with web audio

                  url = elt.src;
                }

                this.tmpEvents.push(this.backend.once('canplay', function () {
                  // ignore when backend was already destroyed
                  if (!_this12.backend.destroyed) {
                    _this12.drawBuffer();

                    _this12.isReady = true;

                    _this12.fireEvent('ready');
                  }
                }), this.backend.once('error', function (err) {
                  return _this12.fireEvent('error', err);
                })); // If peaks are provided, render them and fire the `waveform-ready` event.

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                } // If no pre-decoded peaks are provided, or are provided with
                // forceDecode flag, attempt to download the audio file and decode it
                // with Web Audio.


                if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
                  this.getArrayBuffer(url, function (arraybuffer) {
                    _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
                      _this12.backend.buffer = buffer;

                      _this12.backend.setPeaks(null);

                      _this12.drawBuffer();

                      _this12.fireEvent('waveform-ready');
                    });
                  });
                }
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {Object} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback) {
                var _this13 = this;

                this.arraybuffer = arraybuffer;
                this.backend.decodeArrayBuffer(arraybuffer, function (data) {
                  // Only use the decoded data if we haven't been destroyed or
                  // another decode started in the meantime
                  if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
                    callback(data);
                    _this13.arraybuffer = null;
                  }
                }, function () {
                  return _this13.fireEvent('error', 'Error decoding audiobuffer');
                });
              }
              /**
               * Load an array buffer using fetch and pass the result to a callback
               *
               * @param {string} url The URL of the file object
               * @param {function} callback The function to call on complete
               * @returns {util.fetchFile} fetch call
               * @private
               */

            }, {
              key: "getArrayBuffer",
              value: function getArrayBuffer(url, callback) {
                var _this14 = this;

                var options = _extends({
                  url: url,
                  responseType: 'arraybuffer'
                }, this.params.xhr);
                var request = util.fetchFile(options);
                this.currentRequest = request;
                this.tmpEvents.push(request.on('progress', function (e) {
                  _this14.onProgress(e);
                }), request.on('success', function (data) {
                  callback(data);
                  _this14.currentRequest = null;
                }), request.on('error', function (e) {
                  _this14.fireEvent('error', e);

                  _this14.currentRequest = null;
                }));
                return request;
              }
              /**
               * Called while the audio file is loading
               *
               * @private
               * @param {Event} e Progress event
               * @emits WaveSurfer#loading
               */

            }, {
              key: "onProgress",
              value: function onProgress(e) {
                var percentComplete;

                if (e.lengthComputable) {
                  percentComplete = e.loaded / e.total;
                } else {
                  // Approximate progress with an asymptotic
                  // function, and assume downloads in the 1-3 MB range.
                  percentComplete = e.loaded / (e.loaded + 1000000);
                }

                this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
              }
              /**
               * Exports PCM data into a JSON array and optionally opens in a new window
               * as valid JSON Blob instance.
               *
               * @param {number} length=1024 The scale in which to export the peaks
               * @param {number} accuracy=10000
               * @param {?boolean} noWindow Set to true to disable opening a new
               * window with the JSON
               * @param {number} start Start index
               * @param {number} end End index
               * @return {Promise} Promise that resolves with array of peaks
               */

            }, {
              key: "exportPCM",
              value: function exportPCM(length, accuracy, noWindow, start, end) {
                length = length || 1024;
                start = start || 0;
                accuracy = accuracy || 10000;
                noWindow = noWindow || false;
                var peaks = this.backend.getPeaks(length, start, end);
                var arr = [].map.call(peaks, function (val) {
                  return Math.round(val * accuracy) / accuracy;
                });
                return new Promise(function (resolve, reject) {
                  if (!noWindow) {
                    var blobJSON = new Blob([JSON.stringify(arr)], {
                      type: 'application/json;charset=utf-8'
                    });
                    var objURL = URL.createObjectURL(blobJSON);
                    window.open(objURL);
                    URL.revokeObjectURL(objURL);
                  }

                  resolve(arr);
                });
              }
              /**
               * Save waveform image as data URI.
               *
               * The default format is `'image/png'`. Other supported types are
               * `'image/jpeg'` and `'image/webp'`.
               *
               * @param {string} format='image/png' A string indicating the image format.
               * The default format type is `'image/png'`.
               * @param {number} quality=1 A number between 0 and 1 indicating the image
               * quality to use for image formats that use lossy compression such as
               * `'image/jpeg'`` and `'image/webp'`.
               * @param {string} type Image data type to return. Either 'dataURL' (default)
               * or 'blob'.
               * @return {string|string[]|Promise} When using `'dataURL'` type this returns
               * a single data URL or an array of data URLs, one for each canvas. When using
               * `'blob'` type this returns a `Promise` resolving with an array of `Blob`
               * instances, one for each canvas.
               */

            }, {
              key: "exportImage",
              value: function exportImage(format, quality, type) {
                if (!format) {
                  format = 'image/png';
                }

                if (!quality) {
                  quality = 1;
                }

                if (!type) {
                  type = 'dataURL';
                }

                return this.drawer.getImage(format, quality, type);
              }
              /**
               * Cancel any fetch request currently in progress
               */

            }, {
              key: "cancelAjax",
              value: function cancelAjax() {
                if (this.currentRequest && this.currentRequest.controller) {
                  // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
                  // See: Wavesurfer issue #2042
                  // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
                  if (this.currentRequest._reader) {
                    // Ignoring exceptions thrown by call to cancel()
                    this.currentRequest._reader.cancel().catch(function (err) {});
                  }

                  this.currentRequest.controller.abort();
                  this.currentRequest = null;
                }
              }
              /**
               * @private
               */

            }, {
              key: "clearTmpEvents",
              value: function clearTmpEvents() {
                this.tmpEvents.forEach(function (e) {
                  return e.un();
                });
              }
              /**
               * Display empty waveform.
               */

            }, {
              key: "empty",
              value: function empty() {
                if (!this.backend.isPaused()) {
                  this.stop();
                  this.backend.disconnectSource();
                }

                this.isReady = false;
                this.cancelAjax();
                this.clearTmpEvents(); // empty drawer

                this.drawer.progress(0);
                this.drawer.setWidth(0);
                this.drawer.drawPeaks({
                  length: this.drawer.getWidth()
                }, 0);
              }
              /**
               * Remove events, elements and disconnect WebAudio nodes.
               *
               * @emits WaveSurfer#destroy
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.destroyAllPlugins();
                this.fireEvent('destroy');
                this.cancelAjax();
                this.clearTmpEvents();
                this.unAll();

                if (this.params.responsive !== false) {
                  window.removeEventListener('resize', this._onResize, true);
                  window.removeEventListener('orientationchange', this._onResize, true);
                }

                if (this.backend) {
                  this.backend.destroy(); // clears memory usage

                  this.backend = null;
                }

                if (this.drawer) {
                  this.drawer.destroy();
                }

                this.isDestroyed = true;
                this.isReady = false;
                this.arraybuffer = null;
              }
            }], [{
              key: "create",
              value:
              /** @private */

              /** @private */

              /**
               * Instantiate this class, call its `init` function and returns it
               *
               * @param {WavesurferParams} params The wavesurfer parameters
               * @return {Object} WaveSurfer instance
               * @example const wavesurfer = WaveSurfer.create(params);
               */
              function create(params) {
                var wavesurfer = new WaveSurfer(params);
                return wavesurfer.init();
              }
              /**
               * The library version number is available as a static property of the
               * WaveSurfer class
               *
               * @type {String}
               * @example
               * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
               */

            }]);

            return WaveSurfer;
          }(util.Observer);

          exports.default = WaveSurfer;
          WaveSurfer.VERSION = "5.1.0";
          WaveSurfer.util = util;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/webaudio.js":
        /*!*************************!*\
          !*** ./src/webaudio.js ***!
          \*************************/
        /***/function srcWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          // using constants to prevent someone writing the string wrong
          var PLAYING = 'playing';
          var PAUSED = 'paused';
          var FINISHED = 'finished';
          /**
           * WebAudio backend
           *
           * @extends {Observer}
           */

          var WebAudio = /*#__PURE__*/function (_util$Observer) {
            _inherits(WebAudio, _util$Observer);

            var _super = _createSuper(WebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function WebAudio(params) {
              var _this$stateBehaviors, _this$states;

              var _this;

              _classCallCheck(this, WebAudio);

              _this = _super.call(this);
              /** @private */

              _this.audioContext = null;
              _this.offlineAudioContext = null;
              _this.stateBehaviors = (_this$stateBehaviors = {}, _defineProperty(_this$stateBehaviors, PLAYING, {
                init: function init() {
                  this.addOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition + this.getPlayedTime();
                }
              }), _defineProperty(_this$stateBehaviors, PAUSED, {
                init: function init() {
                  this.removeOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition;
                }
              }), _defineProperty(_this$stateBehaviors, FINISHED, {
                init: function init() {
                  this.removeOnAudioProcess();
                  this.fireEvent('finish');
                },
                getPlayedPercents: function getPlayedPercents() {
                  return 1;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.getDuration();
                }
              }), _this$stateBehaviors);
              _this.params = params;
              /** ac: Audio Context instance */

              _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
              /**@private */

              _this.lastPlay = _this.ac.currentTime;
              /** @private */

              _this.startPosition = 0;
              /** @private */

              _this.scheduledPause = null;
              /** @private */

              _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.filters = [];
              /** gainNode: allows to control audio volume */

              _this.gainNode = null;
              /** @private */

              _this.mergedPeaks = null;
              /** @private */

              _this.offlineAc = null;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** analyser: provides audio analysis information */

              _this.analyser = null;
              /** scriptNode: allows processing audio */

              _this.scriptNode = null;
              /** @private */

              _this.source = null;
              /** @private */

              _this.splitPeaks = [];
              /** @private */

              _this.state = null;
              /** @private */

              _this.explicitDuration = params.duration;
              /**
               * Boolean indicating if the backend was destroyed.
               */

              _this.destroyed = false;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(WebAudio, [{
              key: "supportsWebAudio",
              value:
              /** scriptBufferSize: size of the processing buffer */

              /** audioContext: allows to process audio with WebAudio API */

              /** @private */

              /** @private */

              /**
               * Does the browser support this backend
               *
               * @return {boolean} Whether or not this browser supports this backend
               */
              function supportsWebAudio() {
                return !!(window.AudioContext || window.webkitAudioContext);
              }
              /**
               * Get the audio context used by this backend or create one
               *
               * @return {AudioContext} Existing audio context, or creates a new one
               */

            }, {
              key: "getAudioContext",
              value: function getAudioContext() {
                if (!window.WaveSurferAudioContext) {
                  window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                return window.WaveSurferAudioContext;
              }
              /**
               * Get the offline audio context used by this backend or create one
               *
               * @param {number} sampleRate The sample rate to use
               * @return {OfflineAudioContext} Existing offline audio context, or creates
               * a new one
               */

            }, {
              key: "getOfflineAudioContext",
              value: function getOfflineAudioContext(sampleRate) {
                if (!window.WaveSurferOfflineAudioContext) {
                  window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
                }

                return window.WaveSurferOfflineAudioContext;
              }
            }, {
              key: "init",
              value: function init() {
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
                this.setState(PAUSED);
                this.setPlaybackRate(this.params.audioRate);
                this.setLength(0);
              }
              /** @private */

            }, {
              key: "disconnectFilters",
              value: function disconnectFilters() {
                if (this.filters) {
                  this.filters.forEach(function (filter) {
                    filter && filter.disconnect();
                  });
                  this.filters = null; // Reconnect direct path

                  this.analyser.connect(this.gainNode);
                }
              }
              /**
               * @private
               *
               * @param {string} state The new state
               */

            }, {
              key: "setState",
              value: function setState(state) {
                if (this.state !== this.states[state]) {
                  this.state = this.states[state];
                  this.state.init.call(this);
                }
              }
              /**
               * Unpacked `setFilters()`
               *
               * @param {...AudioNode} filters One or more filters to set
               */

            }, {
              key: "setFilter",
              value: function setFilter() {
                for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
                  filters[_key] = arguments[_key];
                }

                this.setFilters(filters);
              }
              /**
               * Insert custom Web Audio nodes into the graph
               *
               * @param {AudioNode[]} filters Packed filters array
               * @example
               * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
               * wavesurfer.backend.setFilter(lowpass);
               */

            }, {
              key: "setFilters",
              value: function setFilters(filters) {
                // Remove existing filters
                this.disconnectFilters(); // Insert filters if filter array not empty

                if (filters && filters.length) {
                  this.filters = filters; // Disconnect direct path before inserting filters

                  this.analyser.disconnect(); // Connect each filter in turn

                  filters.reduce(function (prev, curr) {
                    prev.connect(curr);
                    return curr;
                  }, this.analyser).connect(this.gainNode);
                }
              }
              /** Create ScriptProcessorNode to process audio */

            }, {
              key: "createScriptNode",
              value: function createScriptNode() {
                if (this.params.audioScriptProcessor) {
                  this.scriptNode = this.params.audioScriptProcessor;
                } else {
                  if (this.ac.createScriptProcessor) {
                    this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
                  } else {
                    this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
                  }
                }

                this.scriptNode.connect(this.ac.destination);
              }
              /** @private */

            }, {
              key: "addOnAudioProcess",
              value: function addOnAudioProcess() {
                var _this2 = this;

                this.scriptNode.onaudioprocess = function () {
                  var time = _this2.getCurrentTime();

                  if (time >= _this2.getDuration()) {
                    _this2.setState(FINISHED);

                    _this2.fireEvent('pause');
                  } else if (time >= _this2.scheduledPause) {
                    _this2.pause();
                  } else if (_this2.state === _this2.states[PLAYING]) {
                    _this2.fireEvent('audioprocess', time);
                  }
                };
              }
              /** @private */

            }, {
              key: "removeOnAudioProcess",
              value: function removeOnAudioProcess() {
                this.scriptNode.onaudioprocess = null;
              }
              /** Create analyser node to perform audio analysis */

            }, {
              key: "createAnalyserNode",
              value: function createAnalyserNode() {
                this.analyser = this.ac.createAnalyser();
                this.analyser.connect(this.gainNode);
              }
              /**
               * Create the gain node needed to control the playback volume.
               *
               */

            }, {
              key: "createVolumeNode",
              value: function createVolumeNode() {
                // Create gain node using the AudioContext
                if (this.ac.createGain) {
                  this.gainNode = this.ac.createGain();
                } else {
                  this.gainNode = this.ac.createGainNode();
                } // Add the gain node to the graph


                this.gainNode.connect(this.ac.destination);
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  /**
                   * The webaudio API doesn't currently support setting the device
                   * output. Here we create an HTMLAudioElement, connect the
                   * webaudio stream to that element and setSinkId there.
                   */
                  var audio = new window.Audio();

                  if (!audio.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  audio.autoplay = true;
                  var dest = this.ac.createMediaStreamDestination();
                  this.gainNode.disconnect();
                  this.gainNode.connect(dest);
                  audio.srcObject = dest.stream;
                  return audio.setSinkId(deviceId);
                } else {
                  return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
                }
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.gainNode.gain.value;
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {ArrayBuffer} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete.
               * @param {function} errback The function to call on error.
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback, errback) {
                if (!this.offlineAc) {
                  this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
                }

                if ('webkitAudioContext' in window) {
                  // Safari: no support for Promise-based decodeAudioData enabled
                  // Enable it in Safari using the Experimental Features > Modern WebAudio API option
                  this.offlineAc.decodeAudioData(arraybuffer, function (data) {
                    return callback(data);
                  }, errback);
                } else {
                  this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
                    return callback(data);
                  }).catch(function (err) {
                    return errback(err);
                  });
                }
              }
              /**
               * Set pre-decoded peaks
               *
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Explicit duration
               */

            }, {
              key: "setPeaks",
              value: function setPeaks(peaks, duration) {
                if (duration != null) {
                  this.explicitDuration = duration;
                }

                this.peaks = peaks;
              }
              /**
               * Set the rendered length (different from the length of the audio)
               *
               * @param {number} length The rendered length
               */

            }, {
              key: "setLength",
              value: function setLength(length) {
                // No resize, we can preserve the cached peaks.
                if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
                  return;
                }

                this.splitPeaks = [];
                this.mergedPeaks = []; // Set the last element of the sparse array so the peak arrays are
                // appropriately sized for other calculations.

                var channels = this.buffer ? this.buffer.numberOfChannels : 1;
                var c;

                for (c = 0; c < channels; c++) {
                  this.splitPeaks[c] = [];
                  this.splitPeaks[c][2 * (length - 1)] = 0;
                  this.splitPeaks[c][2 * (length - 1) + 1] = 0;
                }

                this.mergedPeaks[2 * (length - 1)] = 0;
                this.mergedPeaks[2 * (length - 1) + 1] = 0;
              }
              /**
               * Compute the max and min value of the waveform when broken into <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
               * peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.peaks) {
                  return this.peaks;
                }

                if (!this.buffer) {
                  return [];
                }

                first = first || 0;
                last = last || length - 1;
                this.setLength(length);

                if (!this.buffer) {
                  return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
                }
                /**
                 * The following snippet fixes a buffering data issue on the Safari
                 * browser which returned undefined It creates the missing buffer based
                 * on 1 channel, 4096 samples and the sampleRate from the current
                 * webaudio context 4096 samples seemed to be the best fit for rendering
                 * will review this code once a stable version of Safari TP is out
                 */

                if (!this.buffer.length) {
                  var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
                  this.buffer = newBuffer.buffer;
                }

                var sampleSize = this.buffer.length / length;
                var sampleStep = ~~(sampleSize / 10) || 1;
                var channels = this.buffer.numberOfChannels;
                var c;

                for (c = 0; c < channels; c++) {
                  var peaks = this.splitPeaks[c];
                  var chan = this.buffer.getChannelData(c);
                  var i = void 0;

                  for (i = first; i <= last; i++) {
                    var start = ~~(i * sampleSize);
                    var end = ~~(start + sampleSize);
                    /**
                     * Initialize the max and min to the first sample of this
                     * subrange, so that even if the samples are entirely
                     * on one side of zero, we still return the true max and
                     * min values in the subrange.
                     */

                    var min = chan[start];
                    var max = min;
                    var j = void 0;

                    for (j = start; j < end; j += sampleStep) {
                      var value = chan[j];

                      if (value > max) {
                        max = value;
                      }

                      if (value < min) {
                        min = value;
                      }
                    }

                    peaks[2 * i] = max;
                    peaks[2 * i + 1] = min;

                    if (c == 0 || max > this.mergedPeaks[2 * i]) {
                      this.mergedPeaks[2 * i] = max;
                    }

                    if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
                      this.mergedPeaks[2 * i + 1] = min;
                    }
                  }
                }

                return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.state.getPlayedPercents.call(this);
              }
              /** @private */

            }, {
              key: "disconnectSource",
              value: function disconnectSource() {
                if (this.source) {
                  this.source.disconnect();
                }
              }
              /**
               * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
               */

            }, {
              key: "destroyWebAudio",
              value: function destroyWebAudio() {
                this.disconnectFilters();
                this.disconnectSource();
                this.gainNode.disconnect();
                this.scriptNode.disconnect();
                this.analyser.disconnect(); // close the audioContext if closeAudioContext option is set to true

                if (this.params.closeAudioContext) {
                  // check if browser supports AudioContext.close()
                  if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
                    this.ac.close();
                  } // clear the reference to the audiocontext


                  this.ac = null; // clear the actual audiocontext, either passed as param or the
                  // global singleton

                  if (!this.params.audioContext) {
                    window.WaveSurferAudioContext = null;
                  } else {
                    this.params.audioContext = null;
                  } // clear the offlineAudioContext


                  window.WaveSurferOfflineAudioContext = null;
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (!this.isPaused()) {
                  this.pause();
                }

                this.unAll();
                this.buffer = null;
                this.destroyed = true;
                this.destroyWebAudio();
              }
              /**
               * Loaded a decoded audio buffer
               *
               * @param {Object} buffer Decoded audio buffer to load
               */

            }, {
              key: "load",
              value: function load(buffer) {
                this.startPosition = 0;
                this.lastPlay = this.ac.currentTime;
                this.buffer = buffer;
                this.createSource();
              }
              /** @private */

            }, {
              key: "createSource",
              value: function createSource() {
                this.disconnectSource();
                this.source = this.ac.createBufferSource(); // adjust for old browsers

                this.source.start = this.source.start || this.source.noteGrainOn;
                this.source.stop = this.source.stop || this.source.noteOff;
                this.setPlaybackRate(this.playbackRate);
                this.source.buffer = this.buffer;
                this.source.connect(this.analyser);
              }
              /**
               * @private
               *
               * some browsers require an explicit call to #resume before they will play back audio
               */

            }, {
              key: "resumeAudioContext",
              value: function resumeAudioContext() {
                if (this.ac.state == 'suspended') {
                  this.ac.resume && this.ac.resume();
                }
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Whether or not this backend is currently paused
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return this.state !== this.states[PLAYING];
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration of loaded buffer
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                if (!this.buffer) {
                  return 0;
                }

                return this.buffer.duration;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               * @param {number} end Position to end at in seconds
               * @return {{start: number, end: number}} Object containing start and end
               * positions
               */

            }, {
              key: "seekTo",
              value: function seekTo(start, end) {
                if (!this.buffer) {
                  return;
                }

                this.scheduledPause = null;

                if (start == null) {
                  start = this.getCurrentTime();

                  if (start >= this.getDuration()) {
                    start = 0;
                  }
                }

                if (end == null) {
                  end = this.getDuration();
                }

                this.startPosition = start;
                this.lastPlay = this.ac.currentTime;

                if (this.state === this.states[FINISHED]) {
                  this.setState(PAUSED);
                }

                return {
                  start: start,
                  end: end
                };
              }
              /**
               * Get the playback position in seconds
               *
               * @return {number} The playback position in seconds
               */

            }, {
              key: "getPlayedTime",
              value: function getPlayedTime() {
                return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop relative to the beginning of a clip.
               */

            }, {
              key: "play",
              value: function play(start, end) {
                if (!this.buffer) {
                  return;
                } // need to re-create source on each playback


                this.createSource();
                var adjustedTime = this.seekTo(start, end);
                start = adjustedTime.start;
                end = adjustedTime.end;
                this.scheduledPause = end;
                this.source.start(0, start);
                this.resumeAudioContext();
                this.setState(PLAYING);
                this.fireEvent('play');
              }
              /**
               * Pauses the loaded audio.
               */

            }, {
              key: "pause",
              value: function pause() {
                this.scheduledPause = null;
                this.startPosition += this.getPlayedTime();
                this.source && this.source.stop(0);
                this.setState(PAUSED);
                this.fireEvent('pause');
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} The current time in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.state.getCurrentTime.call(this);
              }
              /**
               * Returns the current playback rate. (0=no playback, 1=normal playback)
               *
               * @return {number} The current playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value The playback rate to use
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} end Position to end at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                this.scheduledPause = end;
              }
            }]);

            return WebAudio;
          }(util.Observer);

          exports.default = WebAudio;
          WebAudio.scriptBufferSize = 256;
          module.exports = exports.default;

          /***/
        },

        /***/"./node_modules/debounce/index.js":
        /*!****************************************!*\
          !*** ./node_modules/debounce/index.js ***!
          \****************************************/
        /***/function node_modulesDebounceIndexJs(module) {

          /**
           * Returns a function, that, as long as it continues to be invoked, will not
           * be triggered. The function will be called after it stops being called for
           * N milliseconds. If `immediate` is passed, trigger the function on the
           * leading edge, instead of the trailing. The function also has a property 'clear' 
           * that is a function which will clear the timer to prevent previously scheduled executions. 
           *
           * @source underscore.js
           * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
           * @param {Function} function to wrap
           * @param {Number} timeout in ms (`100`)
           * @param {Boolean} whether to execute at the beginning (`false`)
           * @api public
           */
          function debounce(func, wait, immediate) {
            var timeout, args, context, timestamp, result;
            if (null == wait) wait = 100;

            function later() {
              var last = Date.now() - timestamp;

              if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
              } else {
                timeout = null;
                if (!immediate) {
                  result = func.apply(context, args);
                  context = args = null;
                }
              }
            };

            var debounced = function debounced() {
              context = this;
              args = arguments;
              timestamp = Date.now();
              var callNow = immediate && !timeout;
              if (!timeout) timeout = setTimeout(later, wait);
              if (callNow) {
                result = func.apply(context, args);
                context = args = null;
              }

              return result;
            };

            debounced.clear = function () {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
            };

            debounced.flush = function () {
              if (timeout) {
                result = func.apply(context, args);
                context = args = null;

                clearTimeout(timeout);
                timeout = null;
              }
            };

            return debounced;
          };

          // Adds compatibility for ES modules
          debounce.debounce = debounce;

          module.exports = debounce;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/wavesurfer.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js cursor plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["cursor"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/cursor/index.js":
        /*!************************************!*\
          !*** ./src/plugin/cursor/index.js ***!
          \************************************/
        /***/function srcPluginCursorIndexJs(module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} CursorPluginParams
           * @property {?boolean} deferInit Set to true to stop auto init in `addPlugin()`
           * @property {boolean} hideOnBlur=true Hide the cursor when the mouse leaves the
           * waveform
           * @property {string} width='1px' The width of the cursor
           * @property {string} color='black' The color of the cursor
           * @property {string} opacity='0.25' The opacity of the cursor
           * @property {string} style='solid' The border style of the cursor
           * @property {number} zIndex=3 The z-index of the cursor element
           * @property {object} customStyle An object with custom styles which are applied
           * to the cursor element
           * @property {boolean} showTime=false Show the time on the cursor.
           * @property {object} customShowTimeStyle An object with custom styles which are
           * applied to the cursor time element.
           * @property {string} followCursorY=false Use `true` to make the time on
           * the cursor follow the x and the y-position of the mouse. Use `false` to make the
           * it only follow the x-position of the mouse.
           * @property {function} formatTimeCallback Formats the timestamp on the cursor.
           */

          /**
           * Displays a thin line at the position of the cursor on the waveform.
           *
           * @implements {PluginClass}
           * @extends {Observer}
           * @example
           * // es6
           * import CursorPlugin from 'wavesurfer.cursor.js';
           *
           * // commonjs
           * var CursorPlugin = require('wavesurfer.cursor.js');
           *
           * // if you are using <script> tags
           * var CursorPlugin = window.WaveSurfer.cursor;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     CursorPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var CursorPlugin = /*#__PURE__*/function () {
            /**
             * Construct the plugin class. You probably want to use `CursorPlugin.create`
             * instead.
             *
             * @param {CursorPluginParams} params Plugin parameters
             * @param {object} ws Wavesurfer instance
             */
            function CursorPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, CursorPlugin);

              this.defaultParams = {
                hideOnBlur: true,
                width: '1px',
                color: 'black',
                opacity: '0.25',
                style: 'solid',
                zIndex: 4,
                customStyle: {},
                customShowTimeStyle: {},
                showTime: false,
                followCursorY: false,
                formatTimeCallback: null
              };

              this._onMousemove = function (e) {
                var bbox = _this.wavesurfer.container.getBoundingClientRect();

                var y = 0;
                var x = e.clientX - bbox.left;

                var flip = bbox.right < e.clientX + _this.outerWidth(_this.displayTime);

                if (_this.params.showTime && _this.params.followCursorY) {
                  // follow y-position of the mouse
                  y = e.clientY - (bbox.top + bbox.height / 2);
                }

                _this.updateCursorPosition(x, y, flip);
              };

              this._onMouseenter = function () {
                return _this.showCursor();
              };

              this._onMouseleave = function () {
                return _this.hideCursor();
              };

              this.wavesurfer = ws;
              this.style = ws.util.style;
              /**
               * The cursor HTML element
               *
               * @type {?HTMLElement}
               */

              this.cursor = null;
              /**
               * displays the time next to the cursor
               *
               * @type {?HTMLElement}
               */

              this.showTime = null;
              /**
               * The html container that will display the time
               *
               * @type {?HTMLElement}
               */

              this.displayTime = null;
              this.params = _extends({}, this.defaultParams, params);
            }
            /**
             * Initialise the plugin (used by the Plugin API)
             */

            _createClass(CursorPlugin, [{
              key: "init",
              value: function init() {
                this.wrapper = this.wavesurfer.container;
                this.cursor = this.wrapper.appendChild(this.style(document.createElement('cursor'), _extends({
                  position: 'absolute',
                  zIndex: this.params.zIndex,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  width: '0',
                  display: 'flex',
                  borderRightStyle: this.params.style,
                  borderRightWidth: this.params.width,
                  borderRightColor: this.params.color,
                  opacity: this.params.opacity,
                  pointerEvents: 'none'
                }, this.params.customStyle)));

                if (this.params.showTime) {
                  this.showTime = this.wrapper.appendChild(this.style(document.createElement('showTitle'), _extends({
                    position: 'absolute',
                    zIndex: this.params.zIndex,
                    left: 0,
                    top: 0,
                    bottom: 0,
                    width: 'auto',
                    display: 'flex',
                    opacity: this.params.opacity,
                    pointerEvents: 'none',
                    height: '100%'
                  }, this.params.customStyle)));
                  this.displayTime = this.showTime.appendChild(this.style(document.createElement('div'), _extends({
                    display: 'inline',
                    pointerEvents: 'none',
                    margin: 'auto',
                    visibility: 'hidden' // initial value will be hidden just for measuring purpose

                  }, this.params.customShowTimeStyle))); // initial value to measure display width

                  this.displayTime.innerHTML = this.formatTime(0);
                }

                this.wrapper.addEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  // ensure elements are hidden initially
                  this.hideCursor();
                  this.wrapper.addEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.addEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Destroy the plugin (used by the Plugin API)
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (this.params.showTime) {
                  this.cursor.parentNode.removeChild(this.showTime);
                }

                this.cursor.parentNode.removeChild(this.cursor);
                this.wrapper.removeEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  this.wrapper.removeEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.removeEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Update the cursor position
               *
               * @param {number} xpos The x offset of the cursor in pixels
               * @param {number} ypos The y offset of the cursor in pixels
               * @param {boolean} flip Flag to flip duration text from right to left
               */

            }, {
              key: "updateCursorPosition",
              value: function updateCursorPosition(xpos, ypos) {
                var flip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                this.style(this.cursor, {
                  left: "".concat(xpos, "px")
                });

                if (this.params.showTime) {
                  var duration = this.wavesurfer.getDuration();
                  var elementWidth = this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
                  var scrollWidth = this.wavesurfer.drawer.getScrollX();
                  var scrollTime = duration / this.wavesurfer.drawer.width * scrollWidth;
                  var timeValue = Math.max(0, xpos / elementWidth * duration) + scrollTime;
                  var formatValue = this.formatTime(timeValue);

                  if (flip) {
                    var textOffset = this.outerWidth(this.displayTime);
                    xpos -= textOffset;
                  }

                  this.style(this.showTime, {
                    left: "".concat(xpos, "px"),
                    top: "".concat(ypos, "px")
                  });
                  this.style(this.displayTime, {
                    visibility: 'visible'
                  });
                  this.displayTime.innerHTML = "".concat(formatValue);
                }
              }
              /**
               * Show the cursor
               */

            }, {
              key: "showCursor",
              value: function showCursor() {
                this.style(this.cursor, {
                  display: 'flex'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'flex'
                  });
                }
              }
              /**
               * Hide the cursor
               */

            }, {
              key: "hideCursor",
              value: function hideCursor() {
                this.style(this.cursor, {
                  display: 'none'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'none'
                  });
                }
              }
              /**
               * Format the timestamp for `cursorTime`.
               *
               * @param {number} cursorTime Time in seconds
               * @returns {string} Formatted timestamp
               */

            }, {
              key: "formatTime",
              value: function formatTime(cursorTime) {
                cursorTime = isNaN(cursorTime) ? 0 : cursorTime;

                if (this.params.formatTimeCallback) {
                  return this.params.formatTimeCallback(cursorTime);
                }

                return [cursorTime].map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2), // seconds
                  ('000' + Math.floor(time % 1 * 1000)).slice(-3) // milliseconds
                  ].join(':');
                });
              }
              /**
               * Get outer width of given element.
               *
               * @param {DOM} element DOM Element
               * @returns {number} outer width
               */

            }, {
              key: "outerWidth",
              value: function outerWidth(element) {
                if (!element) {
                  return 0;
                }

                var width = element.offsetWidth;
                var style = getComputedStyle(element);
                width += parseInt(style.marginLeft + style.marginRight);
                return width;
              }
            }], [{
              key: "create",
              value:
              /**
               * Cursor plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param  {CursorPluginParams} params parameters use to initialise the
               * plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'cursor',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {},
                  instance: CursorPlugin
                };
              }
              /**
               * @type {CursorPluginParams}
               */

            }]);

            return CursorPlugin;
          }();

          exports.default = CursorPlugin;
          module.exports = exports.default;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/cursor/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.cursor.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js regions plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["regions"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/regions/index.js":
        /*!*************************************!*\
          !*** ./src/plugin/regions/index.js ***!
          \*************************************/
        /***/function srcPluginRegionsIndexJs(module, exports, __webpack_require__) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _region = __webpack_require__( /*! ./region.js */"./src/plugin/regions/region.js");

          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {
                symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              }keys.push.apply(keys, symbols);
            }return keys;
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Regions are visual overlays on waveform that can be used to play and loop
           * portions of audio. Regions can be dragged and resized.
           *
           * Visual customization is possible via CSS (using the selectors
           * `.wavesurfer-region` and `.wavesurfer-handle`).
           *
           * @implements {PluginClass}
           * @extends {Observer}
           *
           * @example
           * // es6
           * import RegionsPlugin from 'wavesurfer.regions.js';
           *
           * // commonjs
           * var RegionsPlugin = require('wavesurfer.regions.js');
           *
           * // if you are using <script> tags
           * var RegionsPlugin = window.WaveSurfer.regions;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     RegionsPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var RegionsPlugin = /*#__PURE__*/function () {
            function RegionsPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, RegionsPlugin);

              this.params = params;
              this.wavesurfer = ws;
              this.util = _objectSpread(_objectSpread({}, ws.util), {}, {
                getRegionSnapToGridValue: function getRegionSnapToGridValue(value) {
                  return _this.getRegionSnapToGridValue(value, params);
                }
              });
              this.maxRegions = params.maxRegions;
              this.regionsMinLength = params.regionsMinLength || null; // turn the plugin instance into an observer

              var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
              observerPrototypeKeys.forEach(function (key) {
                _region.Region.prototype[key] = _this.util.Observer.prototype[key];
              });
              this.wavesurfer.Region = _region.Region; // By default, scroll the container if the user drags a region
              // within 5% of its edge

              var scrollWidthProportion = 0.05;

              this._onBackendCreated = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.orientation = _this.wavesurfer.drawer.orientation;

                if (_this.params.regions) {
                  _this.params.regions.forEach(function (region) {
                    region.edgeScrollWidth = _this.params.edgeScrollWidth || _this.wrapper.clientWidth * scrollWidthProportion;

                    _this.add(region);
                  });
                }
              }; // Id-based hash of regions


              this.list = {};

              this._onReady = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.vertical = _this.wavesurfer.drawer.params.vertical;

                if (_this.params.dragSelection) {
                  _this.enableDragSelection(_this.params);
                }

                Object.keys(_this.list).forEach(function (id) {
                  _this.list[id].updateRender();
                });
              };
            }

            _createClass(RegionsPlugin, [{
              key: "init",
              value: function init() {
                // Check if ws is ready
                if (this.wavesurfer.isReady) {
                  this._onBackendCreated();

                  this._onReady();
                } else {
                  this.wavesurfer.once('ready', this._onReady);
                  this.wavesurfer.once('backend-created', this._onBackendCreated);
                }
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.wavesurfer.un('ready', this._onReady);
                this.wavesurfer.un('backend-created', this._onBackendCreated);
                this.disableDragSelection();
                this.clear();
              }
              /**
               * check to see if adding a new region would exceed maxRegions
               * @return {boolean} whether we should proceed and create a region
               * @private
               */

            }, {
              key: "wouldExceedMaxRegions",
              value: function wouldExceedMaxRegions() {
                return this.maxRegions && Object.keys(this.list).length >= this.maxRegions;
              }
              /**
               * Add a region
               *
               * @param {object} params Region parameters
               * @return {Region} The created region
               */

            }, {
              key: "add",
              value: function add(params) {
                var _this2 = this;

                if (this.wouldExceedMaxRegions()) {
                  return null;
                }

                if (!params.minLength && this.regionsMinLength) {
                  params = _objectSpread(_objectSpread({}, params), {}, {
                    minLength: this.regionsMinLength
                  });
                }

                var region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);
                this.list[region.id] = region;
                region.on('remove', function () {
                  delete _this2.list[region.id];
                });
                return region;
              }
              /**
               * Remove all regions
               */

            }, {
              key: "clear",
              value: function clear() {
                var _this3 = this;

                Object.keys(this.list).forEach(function (id) {
                  _this3.list[id].remove();
                });
              }
            }, {
              key: "enableDragSelection",
              value: function enableDragSelection(params) {
                var _this4 = this;

                this.disableDragSelection();
                var slop = params.slop || 2;
                var container = this.wavesurfer.drawer.container;
                var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
                var scrollSpeed = params.scrollSpeed || 1;
                var scrollThreshold = params.scrollThreshold || 10;
                var drag;
                var duration = this.wavesurfer.getDuration();
                var maxScroll;
                var start;
                var region;
                var touchId;
                var pxMove = 0;
                var scrollDirection;
                var wrapperRect; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(e) {
                  if (!region || !scrollDirection) {
                    return;
                  } // Update scroll position


                  var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                  _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range

                  var end = _this4.wavesurfer.drawer.handleEvent(e);

                  region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                  }); // Check that there is more to scroll and repeat

                  if (scrollLeft < maxScroll && scrollLeft > 0) {
                    window.requestAnimationFrame(function () {
                      edgeScroll(e);
                    });
                  }
                };

                var eventDown = function eventDown(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  duration = _this4.wavesurfer.getDuration();
                  touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  drag = true;
                  start = _this4.wavesurfer.drawer.handleEvent(e, true);
                  region = null;
                  scrollDirection = null;
                };

                this.wrapper.addEventListener('mousedown', eventDown);
                this.wrapper.addEventListener('touchstart', eventDown);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchstart', eventDown);

                  _this4.wrapper.removeEventListener('mousedown', eventDown);
                });

                var eventUp = function eventUp(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  drag = false;
                  pxMove = 0;
                  scrollDirection = null;

                  if (region) {
                    _this4.util.preventClick();

                    region.fireEvent('update-end', e);

                    _this4.wavesurfer.fireEvent('region-update-end', region, e);
                  }

                  region = null;
                };

                this.wrapper.addEventListener('mouseleave', eventUp);
                this.wrapper.addEventListener('mouseup', eventUp);
                this.wrapper.addEventListener('touchend', eventUp);
                document.body.addEventListener('mouseup', eventUp);
                document.body.addEventListener('touchend', eventUp);
                this.on('disable-drag-selection', function () {
                  document.body.removeEventListener('mouseup', eventUp);
                  document.body.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('mouseup', eventUp);

                  _this4.wrapper.removeEventListener('mouseleave', eventUp);
                });

                var eventMove = function eventMove(event) {
                  if (!drag) {
                    return;
                  }

                  if (++pxMove <= slop) {
                    return;
                  }

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  } // auto-create a region during mouse drag, unless region-count would exceed "maxRegions"


                  if (!region) {
                    region = _this4.add(params || {});

                    if (!region) {
                      return;
                    }
                  }

                  var end = _this4.wavesurfer.drawer.handleEvent(event);

                  var startUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(start * duration);

                  var endUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(end * duration);

                  region.update({
                    start: Math.min(endUpdate, startUpdate),
                    end: Math.max(endUpdate, startUpdate)
                  });

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical); // If scrolling is enabled


                  if (scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Check threshold based on mouse
                    var x = orientedEvent.clientX - wrapperRect.left;

                    if (x <= scrollThreshold) {
                      scrollDirection = -1;
                    } else if (x >= wrapperRect.right - scrollThreshold) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    scrollDirection && edgeScroll(event);
                  }
                };

                this.wrapper.addEventListener('mousemove', eventMove);
                this.wrapper.addEventListener('touchmove', eventMove);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchmove', eventMove);

                  _this4.wrapper.removeEventListener('mousemove', eventMove);
                });
                this.wavesurfer.on('region-created', function (region) {
                  if (_this4.regionsMinLength) {
                    region.minLength = _this4.regionsMinLength;
                  }
                });
              }
            }, {
              key: "disableDragSelection",
              value: function disableDragSelection() {
                this.fireEvent('disable-drag-selection');
              }
              /**
               * Get current region
               *
               * The smallest region that contains the current time. If several such
               * regions exist, take the first. Return `null` if none exist.
               *
               * @returns {Region} The current region
               */

            }, {
              key: "getCurrentRegion",
              value: function getCurrentRegion() {
                var _this5 = this;

                var time = this.wavesurfer.getCurrentTime();
                var min = null;
                Object.keys(this.list).forEach(function (id) {
                  var cur = _this5.list[id];

                  if (cur.start <= time && cur.end >= time) {
                    if (!min || cur.end - cur.start < min.end - min.start) {
                      min = cur;
                    }
                  }
                });
                return min;
              }
              /**
               * Match the value to the grid, if required
               *
               * If the regions plugin params have a snapToGridInterval set, return the
               * value matching the nearest grid interval. If no snapToGridInterval is set,
               * the passed value will be returned without modification.
               *
               * @param {number} value the value to snap to the grid, if needed
               * @param {Object} params the regions plugin params
               * @returns {number} value
               */

            }, {
              key: "getRegionSnapToGridValue",
              value: function getRegionSnapToGridValue(value, params) {
                if (params.snapToGridInterval) {
                  // the regions should snap to a grid
                  var offset = params.snapToGridOffset || 0;
                  return Math.round((value - offset) / params.snapToGridInterval) * params.snapToGridInterval + offset;
                } // no snap-to-grid


                return value;
              }
            }], [{
              key: "create",
              value:
              /**
               * Regions plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param {RegionsPluginParams} params parameters use to initialise the plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'regions',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {
                    addRegion: function addRegion(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      return this.regions.add(options);
                    },
                    clearRegions: function clearRegions() {
                      this.regions && this.regions.clear();
                    },
                    enableDragSelection: function enableDragSelection(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      this.regions.enableDragSelection(options);
                    },
                    disableDragSelection: function disableDragSelection() {
                      this.regions.disableDragSelection();
                    }
                  },
                  instance: RegionsPlugin
                };
              }
            }]);

            return RegionsPlugin;
          }();

          exports.default = RegionsPlugin;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/plugin/regions/region.js":
        /*!**************************************!*\
          !*** ./src/plugin/regions/region.js ***!
          \**************************************/
        /***/function srcPluginRegionsRegionJs(__unused_webpack_module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Region = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           *  @since 4.0.0
           *
           * (Single) Region plugin class
           *
           * Must be turned into an observer before instantiating. This is done in
           * `RegionsPlugin` (main plugin class).
           *
           * @extends {Observer}
           */
          var Region = /*#__PURE__*/function () {
            function Region(params, regionsUtils, ws) {
              var _params$showTooltip,
                  _this = this;

              _classCallCheck(this, Region);

              this.wavesurfer = ws;
              this.wrapper = ws.drawer.wrapper;
              this.util = ws.util;
              this.style = this.util.style;
              this.regionsUtil = regionsUtils;
              this.vertical = ws.drawer.params.vertical;
              this.id = params.id == null ? ws.util.getId() : params.id;
              this.start = Number(params.start) || 0;
              this.end = params.end == null ? // small marker-like region
              this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
              this.resize = params.resize === undefined ? true : Boolean(params.resize);
              this.drag = params.drag === undefined ? true : Boolean(params.drag); // reflect resize and drag state of region for region-updated listener

              this.isResizing = false;
              this.isDragging = false;
              this.loop = Boolean(params.loop);
              this.color = params.color || 'rgba(0, 0, 0, 0.1)'; // The left and right handleStyle properties can be set to 'none' for
              // no styling or can be assigned an object containing CSS properties.

              this.handleStyle = params.handleStyle || {
                left: {},
                right: {}
              };
              this.handleLeftEl = null;
              this.handleRightEl = null;
              this.data = params.data || {};
              this.attributes = params.attributes || {};
              this.showTooltip = (_params$showTooltip = params.showTooltip) !== null && _params$showTooltip !== void 0 ? _params$showTooltip : true;
              this.maxLength = params.maxLength; // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided

              this.minLength = params.minLength;

              this._onRedraw = function () {
                return _this.updateRender();
              };

              this.scroll = params.scroll !== false && ws.params.scrollParent;
              this.scrollSpeed = params.scrollSpeed || 1;
              this.scrollThreshold = params.scrollThreshold || 10; // Determines whether the context menu is prevented from being opened.

              this.preventContextMenu = params.preventContextMenu === undefined ? false : Boolean(params.preventContextMenu); // select channel ID to set region

              var channelIdx = params.channelIdx == null ? -1 : parseInt(params.channelIdx);
              this.regionHeight = '100%';
              this.marginTop = '0px';

              if (channelIdx !== -1) {
                var channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : -1;

                if (channelCount >= 0 && channelIdx < channelCount) {
                  this.regionHeight = Math.floor(1 / channelCount * 100) + '%';
                  this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';
                }
              }

              this.formatTimeCallback = params.formatTimeCallback;
              this.edgeScrollWidth = params.edgeScrollWidth;
              this.bindInOut();
              this.render();
              this.wavesurfer.on('zoom', this._onRedraw);
              this.wavesurfer.on('redraw', this._onRedraw);
              this.wavesurfer.fireEvent('region-created', this);
            }
            /* Update region params. */

            _createClass(Region, [{
              key: "update",
              value: function update(params) {
                if (params.start != null) {
                  this.start = Number(params.start);
                }

                if (params.end != null) {
                  this.end = Number(params.end);
                }

                if (params.loop != null) {
                  this.loop = Boolean(params.loop);
                }

                if (params.color != null) {
                  this.color = params.color;
                }

                if (params.handleStyle != null) {
                  this.handleStyle = params.handleStyle;
                }

                if (params.data != null) {
                  this.data = params.data;
                }

                if (params.resize != null) {
                  this.resize = Boolean(params.resize);
                  this.updateHandlesResize(this.resize);
                }

                if (params.drag != null) {
                  this.drag = Boolean(params.drag);
                }

                if (params.maxLength != null) {
                  this.maxLength = Number(params.maxLength);
                }

                if (params.minLength != null) {
                  this.minLength = Number(params.minLength);
                }

                if (params.attributes != null) {
                  this.attributes = params.attributes;
                }

                this.updateRender();
                this.fireEvent('update');
                this.wavesurfer.fireEvent('region-updated', this);
              }
              /* Remove a single region. */

            }, {
              key: "remove",
              value: function remove() {
                if (this.element) {
                  this.wrapper.removeChild(this.element.domElement);
                  this.element = null;
                  this.fireEvent('remove');
                  this.wavesurfer.un('zoom', this._onRedraw);
                  this.wavesurfer.un('redraw', this._onRedraw);
                  this.wavesurfer.fireEvent('region-removed', this);
                }
              }
              /**
               * Play the audio region.
               * @param {number} start Optional offset to start playing at
               */

            }, {
              key: "play",
              value: function play(start) {
                var s = start || this.start;
                this.wavesurfer.play(s, this.end);
                this.fireEvent('play');
                this.wavesurfer.fireEvent('region-play', this);
              }
              /**
               * Play the audio region in a loop.
               * @param {number} start Optional offset to start playing at
               * */

            }, {
              key: "playLoop",
              value: function playLoop(start) {
                this.loop = true;
                this.play(start);
              }
              /**
               * Set looping on/off.
               * @param {boolean} loop True if should play in loop
               */

            }, {
              key: "setLoop",
              value: function setLoop(loop) {
                this.loop = loop;
              }
              /* Render a region as a DOM element. */

            }, {
              key: "render",
              value: function render() {
                this.element = this.util.withOrientation(this.wrapper.appendChild(document.createElement('region')), this.vertical);
                this.element.className = 'wavesurfer-region';

                if (this.showTooltip) {
                  this.element.title = this.formatTime(this.start, this.end);
                }

                this.element.setAttribute('data-id', this.id);

                for (var attrname in this.attributes) {
                  this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                }

                this.style(this.element, {
                  position: 'absolute',
                  zIndex: 2,
                  height: this.regionHeight,
                  top: this.marginTop
                });
                /* Resize handles */

                if (this.resize) {
                  this.handleLeftEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleRightEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';
                  this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end'; // Default CSS properties for both handles.

                  var css = {
                    cursor: this.vertical ? 'row-resize' : 'col-resize',
                    position: 'absolute',
                    top: '0px',
                    width: '2px',
                    height: '100%',
                    backgroundColor: 'rgba(0, 0, 0, 1)'
                  }; // Merge CSS properties per handle.

                  var handleLeftCss = this.handleStyle.left !== 'none' ? _extends({
                    left: '0px'
                  }, css, this.handleStyle.left) : null;
                  var handleRightCss = this.handleStyle.right !== 'none' ? _extends({
                    right: '0px'
                  }, css, this.handleStyle.right) : null;

                  if (handleLeftCss) {
                    this.style(this.handleLeftEl, handleLeftCss);
                  }

                  if (handleRightCss) {
                    this.style(this.handleRightEl, handleRightCss);
                  }
                }

                this.updateRender();
                this.bindEvents();
              }
            }, {
              key: "formatTime",
              value: function formatTime(start, end) {
                if (this.formatTimeCallback) {
                  return this.formatTimeCallback(start, end);
                }

                return (start == end ? [start] : [start, end]).map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2) // seconds
                  ].join(':');
                }).join('-');
              }
            }, {
              key: "getWidth",
              value: function getWidth() {
                return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
              }
              /* Update element's position, width, color. */

            }, {
              key: "updateRender",
              value: function updateRender() {
                // duration varies during loading process, so don't overwrite important data
                var dur = this.wavesurfer.getDuration();
                var width = this.getWidth();
                var startLimited = this.start;
                var endLimited = this.end;

                if (startLimited < 0) {
                  startLimited = 0;
                  endLimited = endLimited - startLimited;
                }

                if (endLimited > dur) {
                  endLimited = dur;
                  startLimited = dur - (endLimited - startLimited);
                }

                if (this.minLength != null) {
                  endLimited = Math.max(startLimited + this.minLength, endLimited);
                }

                if (this.maxLength != null) {
                  endLimited = Math.min(startLimited + this.maxLength, endLimited);
                }

                if (this.element != null) {
                  // Calculate the left and width values of the region such that
                  // no gaps appear between regions.
                  var left = Math.round(startLimited / dur * width);
                  var regionWidth = Math.round(endLimited / dur * width) - left;
                  this.style(this.element, {
                    left: left + 'px',
                    width: regionWidth + 'px',
                    backgroundColor: this.color,
                    cursor: this.drag ? 'move' : 'default'
                  });

                  for (var attrname in this.attributes) {
                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                  }

                  if (this.showTooltip) {
                    this.element.title = this.formatTime(this.start, this.end);
                  }
                }
              }
              /* Bind audio events. */

            }, {
              key: "bindInOut",
              value: function bindInOut() {
                var _this2 = this;

                this.firedIn = false;
                this.firedOut = false;

                var onProcess = function onProcess(time) {
                  var start = Math.round(_this2.start * 10) / 10;
                  var end = Math.round(_this2.end * 10) / 10;
                  time = Math.round(time * 10) / 10;

                  if (!_this2.firedOut && _this2.firedIn && (start > time || end <= time)) {
                    _this2.firedOut = true;
                    _this2.firedIn = false;

                    _this2.fireEvent('out');

                    _this2.wavesurfer.fireEvent('region-out', _this2);
                  }

                  if (!_this2.firedIn && start <= time && end > time) {
                    _this2.firedIn = true;
                    _this2.firedOut = false;

                    _this2.fireEvent('in');

                    _this2.wavesurfer.fireEvent('region-in', _this2);
                  }
                };

                this.wavesurfer.backend.on('audioprocess', onProcess);
                this.on('remove', function () {
                  _this2.wavesurfer.backend.un('audioprocess', onProcess);
                });
                /* Loop playback. */

                this.on('out', function () {
                  if (_this2.loop) {
                    var realTime = _this2.wavesurfer.getCurrentTime();

                    if (realTime >= _this2.start && realTime <= _this2.end) {
                      _this2.wavesurfer.play(_this2.start);
                    }
                  }
                });
              }
              /* Bind DOM events. */

            }, {
              key: "bindEvents",
              value: function bindEvents() {
                var _this3 = this;

                var preventContextMenu = this.preventContextMenu;
                this.element.addEventListener('mouseenter', function (e) {
                  _this3.fireEvent('mouseenter', e);

                  _this3.wavesurfer.fireEvent('region-mouseenter', _this3, e);
                });
                this.element.addEventListener('mouseleave', function (e) {
                  _this3.fireEvent('mouseleave', e);

                  _this3.wavesurfer.fireEvent('region-mouseleave', _this3, e);
                });
                this.element.addEventListener('click', function (e) {
                  e.preventDefault();

                  _this3.fireEvent('click', e);

                  _this3.wavesurfer.fireEvent('region-click', _this3, e);
                });
                this.element.addEventListener('dblclick', function (e) {
                  e.stopPropagation();
                  e.preventDefault();

                  _this3.fireEvent('dblclick', e);

                  _this3.wavesurfer.fireEvent('region-dblclick', _this3, e);
                });
                this.element.addEventListener('contextmenu', function (e) {
                  if (preventContextMenu) {
                    e.preventDefault();
                  }

                  _this3.fireEvent('contextmenu', e);

                  _this3.wavesurfer.fireEvent('region-contextmenu', _this3, e);
                });
                /* Drag or resize on mousemove. */

                if (this.drag || this.resize) {
                  this.bindDragEvents();
                }
              }
            }, {
              key: "bindDragEvents",
              value: function bindDragEvents() {
                var _this4 = this;

                var container = this.wavesurfer.drawer.container;
                var scrollSpeed = this.scrollSpeed;
                var scrollThreshold = this.scrollThreshold;
                var startTime;
                var touchId;
                var drag;
                var maxScroll;
                var resize;
                var updated = false;
                var scrollDirection;
                var wrapperRect;
                var regionLeftHalfTime;
                var regionRightHalfTime; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(event) {
                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  var duration = _this4.wavesurfer.getDuration();

                  if (!scrollDirection || !drag && !resize) {
                    return;
                  }

                  var x = orientedEvent.clientX;
                  var distanceBetweenCursorAndWrapperEdge = 0;
                  var regionHalfTimeWidth = 0;
                  var adjustment = 0; // Get the currently selected time according to the mouse position

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // Considering the point of contact with the region while edgescrolling
                    if (scrollDirection === -1) {
                      regionHalfTimeWidth = regionLeftHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;
                    } else {
                      regionHalfTimeWidth = regionRightHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;
                    }
                  } else {
                    // Considering minLength while edgescroll
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  } // Don't edgescroll if region has reached min or max limit


                  var wrapperScrollLeft = _this4.wrapper.scrollLeft;

                  if (scrollDirection === -1) {
                    if (Math.round(wrapperScrollLeft) === 0) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {
                      return;
                    }
                  } else {
                    if (Math.round(wrapperScrollLeft) === maxScroll) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {
                      return;
                    }
                  } // Update scroll position


                  var scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;

                  if (scrollDirection === -1) {
                    var calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedLeft;
                  } else {
                    var calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedRight;
                  }

                  var delta = time - startTime;
                  startTime = time; // Continue dragging or resizing

                  drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize); // Repeat

                  window.requestAnimationFrame(function () {
                    edgeScroll(event);
                  });
                };

                var onDown = function onDown(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  touchId = event.targetTouches ? event.targetTouches[0].identifier : null; // stop the event propagation, if this region is resizable or draggable
                  // and the event is therefore handled here.

                  if (_this4.drag || _this4.resize) {
                    event.stopPropagation();
                  } // Store the selected startTime we begun dragging or resizing


                  startTime = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event, true) * duration); // Store the selected point of contact when we begin dragging

                  regionLeftHalfTime = startTime - _this4.start;
                  regionRightHalfTime = _this4.end - startTime; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  _this4.isResizing = false;
                  _this4.isDragging = false;

                  if (event.target.tagName.toLowerCase() === 'handle') {
                    _this4.isResizing = true;
                    resize = event.target.classList.contains('wavesurfer-handle-start') ? 'start' : 'end';
                  } else {
                    _this4.isDragging = true;
                    drag = true;
                    resize = false;
                  }
                };

                var onUp = function onUp(event) {
                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (drag || resize) {
                    _this4.isDragging = false;
                    _this4.isResizing = false;
                    drag = false;
                    scrollDirection = null;
                    resize = false;
                  }

                  if (updated) {
                    updated = false;

                    _this4.util.preventClick();

                    _this4.fireEvent('update-end', event);

                    _this4.wavesurfer.fireEvent('region-update-end', _this4, event);
                  }
                };

                var onMove = function onMove(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  }

                  if (!drag && !resize) {
                    return;
                  }

                  var oldTime = startTime;

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // To maintain relative cursor start point while dragging
                    var maxEnd = _this4.wavesurfer.getDuration();

                    if (time > maxEnd - regionRightHalfTime) {
                      time = maxEnd - regionRightHalfTime;
                    }

                    if (time - regionLeftHalfTime < 0) {
                      time = regionLeftHalfTime;
                    }
                  }

                  if (resize) {
                    // To maintain relative cursor start point while resizing
                    // we have to handle for minLength
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  }

                  var delta = time - startTime;
                  startTime = time; // Drag

                  if (_this4.drag && drag) {
                    updated = updated || !!delta;

                    _this4.onDrag(delta);
                  } // Resize


                  if (_this4.resize && resize) {
                    updated = updated || !!delta;

                    _this4.onResize(delta, resize);
                  }

                  if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Triggering edgescroll from within edgeScrollWidth
                    var x = orientedEvent.clientX; // Check direction

                    if (x < wrapperRect.left + _this4.edgeScrollWidth) {
                      scrollDirection = -1;
                    } else if (x > wrapperRect.right - _this4.edgeScrollWidth) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    if (scrollDirection) {
                      edgeScroll(event);
                    }
                  }
                };

                this.element.addEventListener('mousedown', onDown);
                this.element.addEventListener('touchstart', onDown);
                document.body.addEventListener('mousemove', onMove);
                document.body.addEventListener('touchmove', onMove, {
                  passive: false
                });
                document.addEventListener('mouseup', onUp);
                document.body.addEventListener('touchend', onUp);
                this.on('remove', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                  document.body.removeEventListener('mousemove', onMove);
                  document.body.removeEventListener('touchmove', onMove);
                });
                this.wavesurfer.on('destroy', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                });
              }
            }, {
              key: "onDrag",
              value: function onDrag(delta) {
                var maxEnd = this.wavesurfer.getDuration();

                if (this.end + delta > maxEnd) {
                  delta = maxEnd - this.end;
                }

                if (this.start + delta < 0) {
                  delta = this.start * -1;
                }

                this.update({
                  start: this.start + delta,
                  end: this.end + delta
                });
              }
              /**
               * @example
               * onResize(-5, 'start') // Moves the start point 5 seconds back
               * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward
               *
               * @param {number} delta How much to add or subtract, given in seconds
               * @param {string} direction 'start 'or 'end'
               */

            }, {
              key: "onResize",
              value: function onResize(delta, direction) {
                var duration = this.wavesurfer.getDuration();

                if (direction === 'start') {
                  // Check if changing the start by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta > 0 && this.end - (this.start + delta) < this.minLength) {
                    delta = this.end - this.minLength - this.start;
                  }

                  if (delta < 0 && this.start + delta < 0) {
                    delta = this.start * -1;
                  }

                  this.update({
                    start: Math.min(this.start + delta, this.end),
                    end: Math.max(this.start + delta, this.end)
                  });
                } else {
                  // Check if changing the end by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta < 0 && this.end + delta - this.start < this.minLength) {
                    delta = this.start + this.minLength - this.end;
                  }

                  if (delta > 0 && this.end + delta > duration) {
                    delta = duration - this.end;
                  }

                  this.update({
                    start: Math.min(this.end + delta, this.start),
                    end: Math.max(this.end + delta, this.start)
                  });
                }
              }
            }, {
              key: "updateHandlesResize",
              value: function updateHandlesResize(resize) {
                var cursorStyle;

                if (resize) {
                  cursorStyle = this.vertical ? 'row-resize' : 'col-resize';
                } else {
                  cursorStyle = 'auto';
                }

                this.handleLeftEl && this.style(this.handleLeftEl, {
                  cursor: cursorStyle
                });
                this.handleRightEl && this.style(this.handleRightEl, {
                  cursor: cursorStyle
                });
              }
            }]);

            return Region;
          }();

          exports.Region = Region;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/regions/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.regions.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMjM1ZDRjMjE0ZmNjNWQ2OTBkOWUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0LmpzIiwid2VicGFjazovLy8uL3N0eWxlcy93YXZlZm9ybS5jc3M/M2MzZCIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL1dhdmVmb3JtSW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaDVwLXBhcmVudC9zcmMvcGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oNXAtcGFyZW50L3NyYy9jaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJsIiwiaSIsIkg1UCIsIkg1UEVkaXRvciIsIndpZGdldHMiLCJ3YXZlZm9ybUluaXQiLCJXYXZlZm9ybUluaXQiLCJwYXJlbnQiLCJmaWVsZCIsInBhcmFtcyIsInNldFZhbHVlIiwiaWQiLCJjckF1ZGlvSW5kZXgiLCJjb250YWluZXIiLCJhdWRpb1BhcmFtcyIsInN0YXJ0VGltZSIsInN0YXJ0RHVyYXRpb24iLCJ1bmRlZmluZWQiLCJlbmRUaW1lIiwiZW5kRHVyYXRpb24iLCJhdWRpb0R1cmF0aW9uIiwicHJvdG90eXBlIiwiY3JlYXRlIiwiUGFyZW50IiwiY29uc3RydWN0b3IiLCJwYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlIiwiaW5pdCIsInNlbGYiLCJsZW5ndGgiLCJ3YXZlc3VyZmVyIiwiV2F2ZVN1cmZlciIsIndhdmVDb2xvciIsInByb2dyZXNzQ29sb3IiLCJmaWxsUGFyZW50IiwicmVzcG9uc2l2ZSIsImJhckhlaWdodCIsInBsdWdpbnMiLCJSZWdpb25zUGx1Z2luIiwicmVnaW9uc01pbkxlbmd0aCIsIm1heFJlZ2lvbnMiLCJyZWdpb25zIiwic3RhcnQiLCJlbmQiLCJsb29wIiwiY29sb3IiLCJkcmFnU2VsZWN0aW9uIiwic2xvcCIsImNzcyIsInJlZ2lvbiIsInJlbmRlcmFibGVDb21tb25GaWVsZHMiLCJmaWVsZHMiLCJzdWJDb250ZW50SWQiLCJwYXRoIiwiZmlsZXMiLCJmaWxlIiwiZ2V0UGF0aCIsIiQiLCJkb25lIiwic2V0VGltZW91dCIsImxvYWQiLCJmYWlsIiwiY29udGVudElkIiwib24iLCJ2YWx1ZXMiLCJsaXN0Iiwid2lkdGgiLCJjcCIsImdldER1cmF0aW9uIiwid2F2ZWZvcm0iLCJ3YXZlZm9ybVBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJzdGFydER1cmF0aW9uRmllbGQiLCJxdWVyeVNlbGVjdG9yIiwiZW5kRHVyYXRpb25GaWVsZCIsInN0YXJ0RHVyYXRpb25GaWVsZElucHV0IiwiZW5kRHVyYXRpb25GaWVsZElucHV0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdGFydER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyIiwidGFyZ2V0IiwidmFsdWUiLCJlbmREdXJhdGlvblZhbHVlQ2hhbmdlSGFuZGxlciIsIndhdmVmb3JtRWxlbWVudHMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJwcmV2aW91c1dhdmVmb3JtQ29udGVudCIsInByZXZpb3VzRW5kRHVyYXRpb25GaWVsZCIsInByZXZpb3VzRW5kRHVyYXRpb25JbnB1dCIsInBhcnNlRmxvYXQiLCJmaWxlc0ZpZWxkIiwiZmlsZXNMaXN0RWxlbWVudCIsIm9ic2VydmVyQ29uZmlnIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnNMaXN0IiwiJHN0YXJ0aW5wdXQiLCJmaW5kIiwiJGVuZGlucHV0IiwidmFsIiwiZmluZEZpZWxkIiwidXBkYXRlIiwib2JzZXJ2ZSIsImV2ZW50IiwidG9GaXhlZCIsInJlZ2lvbklkIiwiJHBsYXlSZWdpb25CdXR0b24iLCJhcHBlbmQiLCJwbGF5IiwiaXNOYU4iLCJpbnB1dFN0YXJ0VGltZSIsImlucHV0RW5kVGltZSIsImFwcGVuZFRvIiwiJHdyYXBwZXIiLCJucyIsImdldE5leHRGaWVsZElkIiwiaHRtbCIsImNyZWF0ZUZpZWxkTWFya3VwIiwiJGl0ZW0iLCJzZXRJZCIsIndvcmRUZXh0IiwidGV4dCIsInNsaWRlcyIsInNsaWRlSW5kZXgiLCJjdXJySW5kZXgiLCJwYXJhbVRleHQiLCJjaGVja0JveEVsZW1lbnRGb3JXb3JkIiwiZ2V0U2VudGVuY2UiLCJjb25zb2xlIiwibG9nIiwiaXNBbHJlYWR5VXNlZCIsImNoZWNrSWZXb3JkSXNVc2VkSW5PdGhlcldhdmVmb3JtIiwiaXMiLCJpbnB1dCIsImdldEVsZW1lbnRCeUlkIiwiY2hlY2tlZCIsImF0dHIiLCIkd29yZCIsInRyaW0iLCJyZXBsYWNlIiwidG9TdHJpbmciLCJwdXNoIiwic3BsaXQiLCJ0ZW1wV29yZFRleHQiLCJmaWx0ZXIiLCJvYmoiLCJpbnB1dElkIiwic2xpZGVDaGVja2JveEluZm8iLCJ3b3JkSW5kZXgiLCJwYXJzZUludCIsImluZGV4IiwibmFtZSIsInZhbGlkYXRlIiwicHJldkRhdGEiLCJzZW50ZW5jZVdvcmRzIiwic3BsaXR0ZWRQcmV2RGF0YSIsImFscmVhZHlGb3VuZFNwbGl0dGVkUHJldkRhdGFXb3JkIiwiZWxlbWVudHMiLCJhY3Rpb24iLCJsaWJyYXJ5IiwiY2hlY2tCb3hXb3JkIiwiaW5uZXJUZXh0IiwiaiIsImRlZiIsImluZGV4T2YiLCJyZW1vdmUiLCJDaGlsZCIsInJlcXVpcmUiLCJFdmVudERpc3BhdGNoZXIiLCJwYXJhbWV0ZXJzIiwiY2FsbCIsInVwZGF0ZUluZGV4ZXMiLCJmcm9tIiwiYWRkQ2hpbGQiLCJjaGlsZFBhcmFtZXRlcnMiLCJpbnN0YW5jZSIsInNwbGljZSIsInJlbW92ZUNoaWxkIiwibW92ZUNoaWxkIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsImNoaWxkIiwialF1ZXJ5IiwiSm91YmVsVUkiLCJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJkZWZhdWx0IiwiX3N0eWxlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9nZXRJZCIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJDYW52YXNFbnRyeSIsIndhdmUiLCJ3YXZlQ3R4IiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0N0eCIsInRvTG93ZXJDYXNlIiwiY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMiLCJpbml0V2F2ZSIsImVsZW1lbnQiLCJnZXRDb250ZXh0IiwiaW5pdFByb2dyZXNzIiwidXBkYXRlRGltZW5zaW9ucyIsImVsZW1lbnRXaWR0aCIsInRvdGFsV2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRMZWZ0IiwiZWxlbWVudFNpemUiLCJoYXNQcm9ncmVzc0NhbnZhcyIsImNsZWFyV2F2ZSIsImNsZWFyUmVjdCIsImNhbnZhcyIsInNldEZpbGxTdHlsZXMiLCJmaWxsU3R5bGUiLCJhcHBseUNhbnZhc1RyYW5zZm9ybXMiLCJ2ZXJ0aWNhbCIsInNldFRyYW5zZm9ybSIsImZpbGxSZWN0cyIsIngiLCJ5IiwicmFkaXVzIiwiZmlsbFJlY3RUb0NvbnRleHQiLCJjdHgiLCJkcmF3Um91bmRlZFJlY3QiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInF1YWRyYXRpY0N1cnZlVG8iLCJjbG9zZVBhdGgiLCJmaWxsIiwiZHJhd0xpbmVzIiwicGVha3MiLCJhYnNtYXgiLCJoYWxmSCIsIm9mZnNldFkiLCJkcmF3TGluZVRvQ29udGV4dCIsImZpcnN0IiwiTWF0aCIsInJvdW5kIiwibGFzdCIsImNhbnZhc1N0YXJ0IiwiY2FudmFzRW5kIiwic2NhbGUiLCJoYWxmT2Zmc2V0IiwiYWJzbWF4SGFsZiIsInBlYWsiLCJoIiwiaGFsZlBpeGVsIiwiZGVzdHJveSIsImdldEltYWdlIiwiZm9ybWF0IiwicXVhbGl0eSIsInR5cGUiLCJfdGhpcyIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9CbG9iIiwidG9EYXRhVVJMIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidXRpbCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwiY2FjaGUiLCJoYXMiLCJuZXdPYmoiLCJoYXNQcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImRlc2MiLCJzZXQiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJnZXRQcm90b3R5cGVPZiIsIkRyYXdlciIsIl91dGlsJE9ic2VydmVyIiwiX3N1cGVyIiwid2l0aE9yaWVudGF0aW9uIiwicGl4ZWxSYXRpbyIsImxhc3RQb3MiLCJ3cmFwcGVyIiwic3R5bGUiLCJlbCIsInN0eWxlcyIsImNyZWF0ZVdyYXBwZXIiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5IiwicG9zaXRpb24iLCJ1c2VyU2VsZWN0Iiwid2Via2l0VXNlclNlbGVjdCIsInNjcm9sbFBhcmVudCIsIm92ZXJmbG93WCIsImhpZGVTY3JvbGxiYXIiLCJvdmVyZmxvd1kiLCJzZXR1cFdyYXBwZXJFdmVudHMiLCJoYW5kbGVFdmVudCIsIm5vUHJldmVudCIsInByZXZlbnREZWZhdWx0IiwiY2xpZW50WCIsInRhcmdldFRvdWNoZXMiLCJiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwibm9taW5hbFdpZHRoIiwicGFyZW50V2lkdGgiLCJnZXRXaWR0aCIsInByb2dyZXNzUGl4ZWxzIiwiZ2V0UHJvZ3Jlc3NQaXhlbHMiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJjbGFtcCIsIndyYXBwZXJCYm94IiwicnRsIiwicmlnaHQiLCJsZWZ0IiwiX3RoaXMyIiwib3JpZW50ZWRFdmVudCIsInNjcm9sbGJhckhlaWdodCIsIm9mZnNldEhlaWdodCIsImNsaWVudEhlaWdodCIsImNsaWVudFkiLCJib3R0b20iLCJpbnRlcmFjdCIsImZpcmVFdmVudCIsImRyYXdQZWFrcyIsInNldFdpZHRoIiwiYmFyV2lkdGgiLCJkcmF3QmFycyIsImRyYXdXYXZlIiwicmVzZXRTY3JvbGwiLCJyZWNlbnRlciIsInBlcmNlbnQiLCJyZWNlbnRlck9uUG9zaXRpb24iLCJpbW1lZGlhdGUiLCJoYWxmIiwiY2xpZW50V2lkdGgiLCJtYXhTY3JvbGwiLCJvZmZzZXQiLCJyYXRlIiwiYXV0b0NlbnRlclJhdGUiLCJtYXgiLCJtaW4iLCJnZXRTY3JvbGxYIiwibmV3V2lkdGgiLCJ1cGRhdGVTaXplIiwic2V0SGVpZ2h0IiwiX3Byb2dyZXNzIiwibWluUHhEZWx0YSIsInBvcyIsImF1dG9DZW50ZXIiLCJuZXdQb3MiLCJhdXRvQ2VudGVySW1tZWRpYXRlbHkiLCJ1cGRhdGVQcm9ncmVzcyIsInVuQWxsIiwicGFyZW50Tm9kZSIsImRvbUVsZW1lbnQiLCJ1cGRhdGVDdXJzb3IiLCJjaGFubmVsSW5kZXgiLCJPYnNlcnZlciIsIl9kcmF3ZXIiLCJfZHJhd2VyMiIsIk11bHRpQ2FudmFzIiwiX0RyYXdlciIsIm1heENhbnZhc1dpZHRoIiwibWF4Q2FudmFzRWxlbWVudFdpZHRoIiwiY2FudmFzZXMiLCJwcm9ncmVzc1dhdmUiLCJFbnRyeUNsYXNzIiwiZHJhd2luZ0NvbnRleHRBdHRyaWJ1dGVzIiwib3ZlcmxhcCIsImNlaWwiLCJiYXJSYWRpdXMiLCJjcmVhdGVFbGVtZW50cyIsInpJbmRleCIsInRvcCIsIm92ZXJmbG93IiwiYm94U2l6aW5nIiwiYm9yZGVyUmlnaHRTdHlsZSIsInBvaW50ZXJFdmVudHMiLCJhZGRDYW52YXMiLCJib3JkZXJSaWdodFdpZHRoIiwiY3Vyc29yV2lkdGgiLCJib3JkZXJSaWdodENvbG9yIiwiY3Vyc29yQ29sb3IiLCJyZXF1aXJlZENhbnZhc2VzIiwicmVtb3ZlQ2FudmFzIiwiY2FudmFzV2lkdGgiLCJsYXN0Q2FudmFzIiwiZm9yRWFjaCIsImVudHJ5IiwibGVmdE9mZnNldCIsImxhc3RFbnRyeSIsInBvcCIsIl90aGlzMyIsImZyYW1lIiwiX3RoaXM0IiwicHJlcGFyZURyYXciLCJfcmVmIiwiaGFzTWluVmFscyIsImNoIiwicGVha0luZGV4U2NhbGUiLCJiYXIiLCJnYXAiLCJiYXJHYXAiLCJzdGVwIiwiZmxvb3IiLCJiYXJNaW5IZWlnaHQiLCJfdGhpczUiLCJfcmVmMiIsInJlZmxlY3RlZFBlYWtzIiwibGVuIiwiZHJhd0xpbmUiLCJfdGhpczYiLCJfcmVmMyIsInNwbGl0Q2hhbm5lbHNPcHRpb25zIiwiY2hhbm5lbENvbG9ycyIsInN0YXJ0Q2FudmFzIiwiZW5kQ2FudmFzIiwiaW50ZXJzZWN0aW9uIiwieDEiLCJ5MSIsIngyIiwieTIiLCJfcmVmNCIsImhpZGVDaGFubmVsIiwic3BsaXRDaGFubmVscyIsImZpbHRlckNoYW5uZWxzIiwiaW5jbHVkZXMiLCJmbiIsImRyYXdJbmRleCIsIm5vcm1hbGl6ZWRNYXgiLCJfdGhpczciLCJBcnJheSIsImNoYW5uZWxzIiwiZmlsdGVyZWRDaGFubmVscyIsImMiLCJvdmVybGF5Iiwib3ZlcmFsbEFic01heCIsInJlbGF0aXZlTm9ybWFsaXphdGlvbiIsIm1hcCIsImNoYW5uZWxQZWFrcyIsImFic01heCIsIm5vcm1hbGl6ZSIsInNvbWUiLCJhbGwiLCJpbWFnZXMiLCJfbWVkaWFlbGVtZW50IiwiX2dldCIsInByb3BlcnR5IiwicmVjZWl2ZXIiLCJiYXNlIiwiX3N1cGVyUHJvcEJhc2UiLCJvYmplY3QiLCJNZWRpYUVsZW1lbnRXZWJBdWRpbyIsIl9NZWRpYUVsZW1lbnQiLCJzb3VyY2VNZWRpYUVsZW1lbnQiLCJzZXRQbGF5YmFja1JhdGUiLCJhdWRpb1JhdGUiLCJjcmVhdGVUaW1lciIsImNyZWF0ZVZvbHVtZU5vZGUiLCJjcmVhdGVTY3JpcHROb2RlIiwiY3JlYXRlQW5hbHlzZXJOb2RlIiwiX2xvYWQiLCJtZWRpYSIsInByZWxvYWQiLCJjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UiLCJtZWRpYUVsZW1lbnQiLCJhYyIsImNvbm5lY3QiLCJhbmFseXNlciIsInJlc3VtZUF1ZGlvQ29udGV4dCIsImRlc3Ryb3lXZWJBdWRpbyIsIl93ZWJhdWRpbyIsIk1lZGlhRWxlbWVudCIsIl9XZWJBdWRpbyIsImN1cnJlbnRUaW1lIiwiZHVyYXRpb24iLCJwYXVzZWQiLCJwbGF5YmFja1JhdGUiLCJwYXVzZSIsInZvbHVtZSIsIm1lZGlhVHlwZSIsImVsZW1lbnRQb3NpdGlvbiIsImlzTXV0ZWQiLCJidWZmZXIiLCJvblBsYXlFbmQiLCJtZWRpYUxpc3RlbmVycyIsIl9zZXR1cE1lZGlhTGlzdGVuZXJzIiwiZXJyb3IiLCJjYW5wbGF5IiwiZW5kZWQiLCJzZWVrZWQiLCJ2b2x1bWVjaGFuZ2UiLCJtdXRlZCIsImtleXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25BdWRpb1Byb2Nlc3MiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwidXJsIiwiY29udHJvbHMiLCJtZWRpYUNvbnRyb2xzIiwiYXV0b3BsYXkiLCJzcmMiLCJwcmV2TWVkaWEiLCJsb2FkRWx0IiwiZWx0IiwiSFRNTE1lZGlhRWxlbWVudCIsIkVycm9yIiwic2V0Vm9sdW1lIiwiZXhwbGljaXREdXJhdGlvbiIsIkluZmluaXR5Iiwic2Vla2FibGUiLCJnZXRQbGF5ZWRQZXJjZW50cyIsImdldFBsYXliYWNrUmF0ZSIsInNlZWtUbyIsImNsZWFyUGxheUVuZCIsInByb21pc2UiLCJzZXRQbGF5RW5kIiwiX29uUGxheUVuZCIsInRpbWUiLCJ1biIsImdldFBlYWtzIiwic2V0U2lua0lkIiwiZGV2aWNlSWQiLCJyZWplY3QiLCJnZXRWb2x1bWUiLCJzZXRNdXRlIiwiZGVzdHJveWVkIiwicmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95IiwiUGVha0NhY2hlIiwiY2xlYXJQZWFrQ2FjaGUiLCJwZWFrQ2FjaGVSYW5nZXMiLCJwZWFrQ2FjaGVMZW5ndGgiLCJhZGRSYW5nZVRvUGVha0NhY2hlIiwidW5jYWNoZWRSYW5nZXMiLCJpdGVtIiwiYXJyIiwiY29uY2F0Iiwic29ydCIsImEiLCJiIiwidW5jYWNoZWRSYW5nZVBhaXJzIiwiZ2V0Q2FjaGVSYW5nZXMiLCJwZWFrQ2FjaGVSYW5nZVBhaXJzIiwiX21heCIsIl9taW4iLCJmZXRjaEZpbGUiLCJfb2JzZXJ2ZXIiLCJQcm9ncmVzc0hhbmRsZXIiLCJjb250ZW50TGVuZ3RoIiwicmVzcG9uc2UiLCJfcmVhZGVyIiwiYm9keSIsImdldFJlYWRlciIsInRvdGFsIiwibG9hZGVkIiwiY29udHJvbGxlciIsInJlYWQiLCJ0aGVuIiwib25Qcm9ncmVzcyIsImxlbmd0aENvbXB1dGFibGUiLCJjbG9zZSIsImJ5dGVMZW5ndGgiLCJlbnF1ZXVlIiwiY2F0Y2giLCJvcHRpb25zIiwiZmV0Y2hIZWFkZXJzIiwiSGVhZGVycyIsImZldGNoUmVxdWVzdCIsIlJlcXVlc3QiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXF1ZXN0SGVhZGVycyIsImhlYWRlciIsInJlc3BvbnNlVHlwZSIsImZldGNoT3B0aW9ucyIsIm1ldGhvZCIsImhlYWRlcnMiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsInJlZmVycmVyIiwic2lnbmFsIiwiZmV0Y2giLCJwcm9ncmVzc0F2YWlsYWJsZSIsIlJlc3BvbnNlIiwiUmVhZGFibGVTdHJlYW0iLCJlcnJNc2ciLCJvayIsImFycmF5QnVmZmVyIiwianNvbiIsImJsb2IiLCJzdGF0dXMiLCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZnVuYyIsIl9sZW4iLCJhcmdzIiwiX2tleSIsImdldElkIiwicHJlZml4IiwicmFuZG9tIiwic3Vic3RyaW5nIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfYWJzTWF4IiwiX2ZyYW1lIiwiX2RlYm91bmNlIiwiX3ByZXZlbnRDbGljayIsIl9mZXRjaCIsIl9jbGFtcCIsIl9vcmllbnRhdGlvbiIsImxhcmdlc3QiLCJzbWFsbGVzdCIsIk51bWJlciIsIl9kaXNhYmxlZEV2ZW50RW1pc3Npb25zIiwiaGFuZGxlcnMiLCJjYWxsYmFjayIsIm9uY2UiLCJoYW5kbGVyIiwic2V0RGlzYWJsZWRFdmVudEVtaXNzaW9ucyIsImV2ZW50TmFtZXMiLCJfaXNEaXNhYmxlZEV2ZW50RW1pc3Npb24iLCJfbGVuMiIsIl9rZXkyIiwidmVydGljYWxQcm9wTWFwIiwib2Zmc2V0VG9wIiwib2Zmc2V0V2lkdGgiLCJtYXBQcm9wIiwicHJvcCIsImlzUHJveHkiLCJiaW5kIiwicHJldmVudENsaWNrIiwicHJldmVudENsaWNrSGFuZGxlciIsInN0b3BQcm9wYWdhdGlvbiIsIl9kZWZhdWx0Iiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3BlYWtjYWNoZSIsIl9tZWRpYWVsZW1lbnRXZWJhdWRpbyIsIlBsdWdpbkNsYXNzIiwid3MiLCJkZWZhdWx0UGFyYW1zIiwiYXVkaW9Db250ZXh0IiwiYXVkaW9TY3JpcHRQcm9jZXNzb3IiLCJiYWNrZW5kIiwiYmFja2dyb3VuZENvbG9yIiwiZGVzeW5jaHJvbml6ZWQiLCJmb3JjZURlY29kZSIsImxvb3BTZWxlY3Rpb24iLCJtZWRpYUNvbnRhaW5lciIsIm1pblB4UGVyU2VjIiwicGFydGlhbFJlbmRlciIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJyZW5kZXJlciIsInNraXBMZW5ndGgiLCJ4aHIiLCJiYWNrZW5kcyIsIldlYkF1ZGlvIiwidHJhbnNmb3JtIiwic2V0QmFja2dyb3VuZENvbG9yIiwic2F2ZWRWb2x1bWUiLCJ0bXBFdmVudHMiLCJjdXJyZW50UmVxdWVzdCIsImFycmF5YnVmZmVyIiwiZHJhd2VyIiwicGVha0NhY2hlIiwic3VwcG9ydHNXZWJBdWRpbyIsIkJhY2tlbmQiLCJpbml0aWFsaXNlZFBsdWdpbkxpc3QiLCJpc0Rlc3Ryb3llZCIsImlzUmVhZHkiLCJwcmV2V2lkdGgiLCJfb25SZXNpemUiLCJkZWJvdW5jZSIsInJlZ2lzdGVyUGx1Z2lucyIsImNyZWF0ZURyYXdlciIsImNyZWF0ZUJhY2tlbmQiLCJjcmVhdGVQZWFrQ2FjaGUiLCJwbHVnaW4iLCJhZGRQbHVnaW4iLCJkZWZlckluaXQiLCJpbml0UGx1Z2luIiwiZ2V0QWN0aXZlUGx1Z2lucyIsInBsdWdpblN0YXRpY1Byb3AiLCJJbnN0YW5jZSIsIm9ic2VydmVyUHJvdG90eXBlS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJkZXN0cm95UGx1Z2luIiwiZGVzdHJveUFsbFBsdWdpbnMiLCJkcmF3QnVmZmVyIiwibmV3Vm9sdW1lIiwic2V0Q3VycmVudFRpbWUiLCJzZWNvbmRzIiwicGxheVBhdXNlIiwiaXNQbGF5aW5nIiwic2tpcEJhY2t3YXJkIiwic2tpcCIsInNraXBGb3J3YXJkIiwic2Vla0FuZENlbnRlciIsIl90aGlzOCIsImlzRmluaXRlIiwiaXNXZWJBdWRpb0JhY2tlbmQiLCJvbGRTY3JvbGxQYXJlbnQiLCJzdG9wIiwidG9nZ2xlTXV0ZSIsIm11dGUiLCJnZXRNdXRlIiwiZ2V0RmlsdGVycyIsImZpbHRlcnMiLCJ0b2dnbGVTY3JvbGwiLCJ0b2dnbGVJbnRlcmFjdGlvbiIsImdldFdhdmVDb2xvciIsInNldFdhdmVDb2xvciIsImdldFByb2dyZXNzQ29sb3IiLCJzZXRQcm9ncmVzc0NvbG9yIiwiZ2V0QmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZCIsImdldEN1cnNvckNvbG9yIiwic2V0Q3Vyc29yQ29sb3IiLCJnZXRIZWlnaHQiLCJzZXRGaWx0ZXJlZENoYW5uZWxzIiwiY2hhbm5lbEluZGljZXMiLCJuZXdSYW5nZXMiLCJ6b29tIiwicHhQZXJTZWMiLCJsb2FkQXJyYXlCdWZmZXIiLCJfdGhpczkiLCJkZWNvZGVBcnJheUJ1ZmZlciIsImRhdGEiLCJsb2FkRGVjb2RlZEJ1ZmZlciIsImxvYWRCbG9iIiwiX3RoaXMxMCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImVtcHR5IiwicHJlbG9hZElnbm9yZVJlYXNvbnMiLCJhY3RpdmVSZWFzb25zIiwicmVhc29uIiwid2FybiIsImpvaW4iLCJsb2FkQnVmZmVyIiwibG9hZE1lZGlhRWxlbWVudCIsIl90aGlzMTEiLCJnZXRBcnJheUJ1ZmZlciIsInNldFBlYWtzIiwidXJsT3JFbHQiLCJfdGhpczEyIiwiZXJyIiwiX3RoaXMxMyIsIl90aGlzMTQiLCJyZXF1ZXN0IiwicGVyY2VudENvbXBsZXRlIiwiZXhwb3J0UENNIiwiYWNjdXJhY3kiLCJub1dpbmRvdyIsImJsb2JKU09OIiwiQmxvYiIsIkpTT04iLCJzdHJpbmdpZnkiLCJvYmpVUkwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJvcGVuIiwicmV2b2tlT2JqZWN0VVJMIiwiZXhwb3J0SW1hZ2UiLCJjYW5jZWxBamF4IiwiY2FuY2VsIiwiYWJvcnQiLCJjbGVhclRtcEV2ZW50cyIsImRpc2Nvbm5lY3RTb3VyY2UiLCJWRVJTSU9OIiwiX2RlZmluZVByb3BlcnR5IiwiUExBWUlORyIsIlBBVVNFRCIsIkZJTklTSEVEIiwiX3RoaXMkc3RhdGVCZWhhdmlvcnMiLCJfdGhpcyRzdGF0ZXMiLCJvZmZsaW5lQXVkaW9Db250ZXh0Iiwic3RhdGVCZWhhdmlvcnMiLCJhZGRPbkF1ZGlvUHJvY2VzcyIsInN0YXJ0UG9zaXRpb24iLCJnZXRQbGF5ZWRUaW1lIiwicmVtb3ZlT25BdWRpb1Byb2Nlc3MiLCJnZXRBdWRpb0NvbnRleHQiLCJsYXN0UGxheSIsInNjaGVkdWxlZFBhdXNlIiwic3RhdGVzIiwiZ2Fpbk5vZGUiLCJtZXJnZWRQZWFrcyIsIm9mZmxpbmVBYyIsInNjcmlwdE5vZGUiLCJzb3VyY2UiLCJzcGxpdFBlYWtzIiwic3RhdGUiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJXYXZlU3VyZmVyQXVkaW9Db250ZXh0IiwiZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCIsInNhbXBsZVJhdGUiLCJXYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dCIsIk9mZmxpbmVBdWRpb0NvbnRleHQiLCJ3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0Iiwic2V0U3RhdGUiLCJzZXRMZW5ndGgiLCJkaXNjb25uZWN0RmlsdGVycyIsImRpc2Nvbm5lY3QiLCJzZXRGaWx0ZXIiLCJzZXRGaWx0ZXJzIiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJzY3JpcHRCdWZmZXJTaXplIiwiY3JlYXRlSmF2YVNjcmlwdE5vZGUiLCJkZXN0aW5hdGlvbiIsIm9uYXVkaW9wcm9jZXNzIiwiY3JlYXRlQW5hbHlzZXIiLCJjcmVhdGVHYWluIiwiY3JlYXRlR2Fpbk5vZGUiLCJhdWRpbyIsIkF1ZGlvIiwiZGVzdCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJzcmNPYmplY3QiLCJzdHJlYW0iLCJnYWluIiwic2V0VmFsdWVBdFRpbWUiLCJlcnJiYWNrIiwiZGVjb2RlQXVkaW9EYXRhIiwibnVtYmVyT2ZDaGFubmVscyIsIm5ld0J1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsInNhbXBsZVNpemUiLCJzYW1wbGVTdGVwIiwiY2hhbiIsImdldENoYW5uZWxEYXRhIiwiY2xvc2VBdWRpb0NvbnRleHQiLCJjcmVhdGVTb3VyY2UiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJub3RlR3JhaW5PbiIsIm5vdGVPZmYiLCJyZXN1bWUiLCJhZGp1c3RlZFRpbWUiLCJ3YWl0IiwidGltZW91dCIsImNvbnRleHQiLCJ0aW1lc3RhbXAiLCJsYXRlciIsIkRhdGUiLCJub3ciLCJkZWJvdW5jZWQiLCJjYWxsTm93IiwiY2xlYXIiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIkN1cnNvclBsdWdpbiIsImhpZGVPbkJsdXIiLCJvcGFjaXR5IiwiY3VzdG9tU3R5bGUiLCJjdXN0b21TaG93VGltZVN0eWxlIiwic2hvd1RpbWUiLCJmb2xsb3dDdXJzb3JZIiwiZm9ybWF0VGltZUNhbGxiYWNrIiwiX29uTW91c2Vtb3ZlIiwiZmxpcCIsIm91dGVyV2lkdGgiLCJkaXNwbGF5VGltZSIsInVwZGF0ZUN1cnNvclBvc2l0aW9uIiwiX29uTW91c2VlbnRlciIsInNob3dDdXJzb3IiLCJfb25Nb3VzZWxlYXZlIiwiaGlkZUN1cnNvciIsImN1cnNvciIsIm1hcmdpbiIsInZpc2liaWxpdHkiLCJpbm5lckhUTUwiLCJmb3JtYXRUaW1lIiwieHBvcyIsInlwb3MiLCJzY3JvbGxUaW1lIiwidGltZVZhbHVlIiwiZm9ybWF0VmFsdWUiLCJ0ZXh0T2Zmc2V0IiwiY3Vyc29yVGltZSIsInNsaWNlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIl9yZWdpb24iLCJvd25LZXlzIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltIiwiX29iamVjdFNwcmVhZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlIiwiUmVnaW9uIiwic2Nyb2xsV2lkdGhQcm9wb3J0aW9uIiwiX29uQmFja2VuZENyZWF0ZWQiLCJvcmllbnRhdGlvbiIsImVkZ2VTY3JvbGxXaWR0aCIsImFkZCIsIl9vblJlYWR5IiwiZW5hYmxlRHJhZ1NlbGVjdGlvbiIsInVwZGF0ZVJlbmRlciIsImRpc2FibGVEcmFnU2VsZWN0aW9uIiwid291bGRFeGNlZWRNYXhSZWdpb25zIiwibWluTGVuZ3RoIiwic2Nyb2xsIiwic2Nyb2xsU3BlZWQiLCJzY3JvbGxUaHJlc2hvbGQiLCJkcmFnIiwidG91Y2hJZCIsInB4TW92ZSIsInNjcm9sbERpcmVjdGlvbiIsIndyYXBwZXJSZWN0IiwiZWRnZVNjcm9sbCIsImV2ZW50RG93biIsInRvdWNoZXMiLCJpZGVudGlmaWVyIiwiZXZlbnRVcCIsImV2ZW50TW92ZSIsInN0YXJ0VXBkYXRlIiwiZW5kVXBkYXRlIiwiZ2V0Q3VycmVudFJlZ2lvbiIsImN1ciIsInNuYXBUb0dyaWRJbnRlcnZhbCIsInNuYXBUb0dyaWRPZmZzZXQiLCJhZGRSZWdpb24iLCJjbGVhclJlZ2lvbnMiLCJyZWdpb25zVXRpbHMiLCJfcGFyYW1zJHNob3dUb29sdGlwIiwicmVnaW9uc1V0aWwiLCJyZXNpemUiLCJpc1Jlc2l6aW5nIiwiaXNEcmFnZ2luZyIsImhhbmRsZVN0eWxlIiwiaGFuZGxlTGVmdEVsIiwiaGFuZGxlUmlnaHRFbCIsInNob3dUb29sdGlwIiwibWF4TGVuZ3RoIiwiX29uUmVkcmF3IiwicHJldmVudENvbnRleHRNZW51IiwiY2hhbm5lbElkeCIsInJlZ2lvbkhlaWdodCIsIm1hcmdpblRvcCIsImNoYW5uZWxDb3VudCIsImJpbmRJbk91dCIsInJlbmRlciIsInVwZGF0ZUhhbmRsZXNSZXNpemUiLCJzIiwicGxheUxvb3AiLCJzZXRMb29wIiwiY2xhc3NOYW1lIiwidGl0bGUiLCJzZXRBdHRyaWJ1dGUiLCJhdHRybmFtZSIsImhhbmRsZUxlZnRDc3MiLCJoYW5kbGVSaWdodENzcyIsImJpbmRFdmVudHMiLCJkdXIiLCJzdGFydExpbWl0ZWQiLCJlbmRMaW1pdGVkIiwicmVnaW9uV2lkdGgiLCJmaXJlZEluIiwiZmlyZWRPdXQiLCJvblByb2Nlc3MiLCJyZWFsVGltZSIsImJpbmREcmFnRXZlbnRzIiwidXBkYXRlZCIsInJlZ2lvbkxlZnRIYWxmVGltZSIsInJlZ2lvblJpZ2h0SGFsZlRpbWUiLCJkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSIsInJlZ2lvbkhhbGZUaW1lV2lkdGgiLCJhZGp1c3RtZW50Iiwid3JhcHBlclNjcm9sbExlZnQiLCJjYWxjdWxhdGVkTGVmdCIsImNhbGN1bGF0ZWRSaWdodCIsImRlbHRhIiwib25EcmFnIiwib25SZXNpemUiLCJvbkRvd24iLCJ0YWdOYW1lIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJvblVwIiwib25Nb3ZlIiwib2xkVGltZSIsIm1heEVuZCIsInBhc3NpdmUiLCJkaXJlY3Rpb24iLCJjdXJz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LCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAyMzVkNGMyMTRmY2M1ZDY5MGQ5ZSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJpbXBvcnQgJy4vc3R5bGVzL3dhdmVmb3JtLmNzcydcclxuaW1wb3J0IFdhdmVmb3JtSW5pdCBmcm9tIFwiLi9zY3JpcHRzL1dhdmVmb3JtSW5pdFwiO1xyXG5cclxuLy8gTG9hZCBsaWJyYXJ5XHJcbkg1UCA9IEg1UCB8fCB7fTtcclxuSDVQRWRpdG9yLndpZGdldHMud2F2ZWZvcm1Jbml0ID0gSDVQRWRpdG9yLldhdmVmb3JtSW5pdCA9IFdhdmVmb3JtSW5pdDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZGlzdC5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMvd2F2ZWZvcm0uY3NzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQYXJlbnQgZnJvbSAnaDVwLXBhcmVudCc7XHJcbmltcG9ydCB7XHJcbiAgalF1ZXJ5IGFzICRcclxufSBmcm9tICcuLi9nbG9iYWxzJztcclxuaW1wb3J0IFdhdmVTdXJmZXIgZnJvbSAnd2F2ZXN1cmZlci5qcyc7XHJcbmltcG9ydCBDdXJzb3JQbHVnaW4gZnJvbSBcIndhdmVzdXJmZXIuanMvZGlzdC9wbHVnaW4vd2F2ZXN1cmZlci5jdXJzb3IuanNcIjtcclxuaW1wb3J0IFJlZ2lvbnNQbHVnaW4gZnJvbSBcIndhdmVzdXJmZXIuanMvZGlzdC9wbHVnaW4vd2F2ZXN1cmZlci5yZWdpb25zLmpzXCI7XHJcblxyXG5sZXQgV2F2ZWZvcm1Jbml0ID0gZnVuY3Rpb24gKHBhcmVudCwgZmllbGQsIHBhcmFtcywgc2V0VmFsdWUpIHtcclxuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgdGhpcy5zZXRWYWx1ZSA9IHNldFZhbHVlO1xyXG5cclxuICB0aGlzLmlkID0gbnVsbDtcclxuICB0aGlzLmNyQXVkaW9JbmRleCA9IDA7XHJcbiAgdGhpcy5jb250YWluZXIgPSBudWxsO1xyXG4gIHRoaXMuYXVkaW9QYXJhbXMgPSB0aGlzLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmFtcy5wYXJhbXM7XHJcbiAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLnBhcmVudC5wYXJhbXMuc3RhcnREdXJhdGlvbiAhPSB1bmRlZmluZWQgPyB0aGlzLnBhcmVudC5wYXJhbXMuc3RhcnREdXJhdGlvbiA6IDA7XHJcbiAgdGhpcy5lbmRUaW1lID0gdGhpcy5wYXJlbnQucGFyYW1zLmVuZER1cmF0aW9uICE9IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50LnBhcmFtcy5lbmREdXJhdGlvbiA6IDAuMjtcclxuICB0aGlzLmF1ZGlvRHVyYXRpb247XHJcbn1cclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2F2ZWZvcm1Jbml0O1xyXG5cclxuV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2UgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIHRoZSB3YXZlZm9ybSBlZGl0b3IuXHJcbiAqIEBwYXJhbSB7Kn0gJHdyYXBwZXIgXHJcbiAqL1xyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIGlmICghc2VsZi5jb250YWluZXIgfHwgKHNlbGYuY29udGFpbmVyICYmIHNlbGYuY29udGFpbmVyLmxlbmd0aCA9PSAwKSkgcmV0dXJuO1xyXG4gIHZhciB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xyXG4gICAgY29udGFpbmVyOiBzZWxmLmNvbnRhaW5lclswXSxcclxuICAgIHdhdmVDb2xvcjogJ2dyZWVuJyxcclxuICAgIHByb2dyZXNzQ29sb3I6ICdncmV5JyxcclxuICAgIGZpbGxQYXJlbnQ6IHRydWUsXHJcbiAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgYmFySGVpZ2h0OiA4LFxyXG4gICAgcGx1Z2luczogW1xyXG4gICAgICBSZWdpb25zUGx1Z2luLmNyZWF0ZSh7XHJcbiAgICAgICAgcmVnaW9uc01pbkxlbmd0aDogMC4xLFxyXG4gICAgICAgIG1heFJlZ2lvbnM6IDEsXHJcbiAgICAgICAgcmVnaW9uczogW3tcclxuICAgICAgICAgIHN0YXJ0OiBzZWxmLnN0YXJ0VGltZSxcclxuICAgICAgICAgIGVuZDogc2VsZi5lbmRUaW1lLFxyXG4gICAgICAgICAgbG9vcDogZmFsc2UsXHJcbiAgICAgICAgICBjb2xvcjogJ3JnYmEoMjUwLCAyMDMsIDExMCwgMC41KSdcclxuICAgICAgICB9XSxcclxuICAgICAgICBkcmFnU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICBzbG9wOiA1XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgXVxyXG4gIH0pO1xyXG5cclxuICAkKCcud2F2ZXN1cmZlci1oYW5kbGUnKS5jc3MoXCJ3aWR0aFwiLCBcIjRweFwiKTtcclxuICAkKCcud2F2ZXN1cmZlci1oYW5kbGUnKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzcwNzA3MFwiKTtcclxuXHJcbiAgdGhpcy5yZWdpb24gPSB1bmRlZmluZWQ7XHJcblxyXG4gIHNlbGYuY3JBdWRpb0luZGV4ID0gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzLmxlbmd0aDtcclxuICAvLyBsZXQgcGF0aCA9IEg1UEVkaXRvci5yZW5kZXJhYmxlQ29tbW9uRmllbGRzW1wiSDVQLkNSQXVkaW8gMS40XCJdLmZpZWxkc1tzZWxmLmNyQXVkaW9JbmRleC0gMV0ucGFyYW1zLmZpbGVzID8gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzW3NlbGYuY3JBdWRpb0luZGV4IC0gMV0ucGFyYW1zLmZpbGVzWzBdLnBhdGggOiB1bmRlZmluZWQ7XHJcbiAgbGV0IGlkID0gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzWzBdLnBhcmVudC5wYXJhbXMuc3ViQ29udGVudElkO1xyXG4gIGxldCBwYXRoID0gc2VsZi5hdWRpb1BhcmFtcy5maWxlcyA/IHNlbGYuYXVkaW9QYXJhbXMuZmlsZXNbMF0ucGF0aCA6IHVuZGVmaW5lZDtcclxuICAvLyBsZXQgaWQgPSAgc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJhbXMuc3ViQ29udGVudElkO1xyXG4gIGlmIChwYXRoICE9IHVuZGVmaW5lZCAmJiBpZCAhPSB1bmRlZmluZWQpIHtcclxuICAgIGxldCBmaWxlID0gSDVQLmdldFBhdGgocGF0aCwgaWQpO1xyXG4gICAgJC5nZXQoZmlsZSkuZG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdhdmVzdXJmZXIubG9hZChmaWxlKTtcclxuICAgICAgfSwgMTAwMClcclxuICAgIH0pLmZhaWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICBsZXQgaWQgPSBINVBFZGl0b3IuY29udGVudElkO1xyXG4gICAgICBsZXQgZmlsZSA9IEg1UC5nZXRQYXRoKHBhdGgsIGlkKTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2F2ZXN1cmZlci5sb2FkKGZpbGUpO1xyXG4gICAgICB9LCAxMDAwKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG5cclxuICB3YXZlc3VyZmVyLm9uKCdyZWFkeScsICgpID0+IHtcclxuICAgIHRoaXMucmVnaW9uID0gT2JqZWN0LnZhbHVlcyh3YXZlc3VyZmVyLnJlZ2lvbnMubGlzdClbMF07XHJcbiAgICBsZXQgd2lkdGggPSBzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC53aWR0aCArIChzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC53aWR0aCAqIDAuMjUpO1xyXG4gICAgc2VsZi5hdWRpb0R1cmF0aW9uID0gd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xyXG4gICAgLy8gd2F2ZXN1cmZlci5wYXJhbXMubWluUHhQZXJTZWMgPSB3aWR0aCAvIHdhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcclxuICAgIC8vIHdhdmVzdXJmZXIuZHJhd0J1ZmZlcigpO1xyXG5cclxuICAgIC8vIGxldCByZWdpb25JZCA9IHNlbGYuaWQgKyBcInBsYXlSZWdpb25cIlxyXG4gICAgLy8gbGV0ICRwbGF5UmVnaW9uQnV0dG9uID0gJzxidXR0b24gaWQgPSAnKyByZWdpb25JZCArJyBjbGFzcyA9IFwicGxheVJlZ2lvblwiPlBsYXk8L2J1dHRvbj4nXHJcbiAgICAvLyAkKCcjJyArIHNlbGYuaWQpLmZpbmQoJy53YXZlc3VyZmVyLXJlZ2lvbicpLmFwcGVuZCgkcGxheVJlZ2lvbkJ1dHRvbilcclxuICAgIC8vICQoJyMnICsgcmVnaW9uSWQpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAvLyAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgIC8vICAgaWYgKHJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgIC8vICAgICByZWdpb24ucGxheSgpXHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH0pXHJcbiAgfSk7XHJcblxyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgaWYgKHNlbGYuY29udGFpbmVyWzBdKSB7XHJcbiAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gc3RhcnQgYW5kIGVuZCBkdXJhdGlvbiBmb3IgdGhpcyB3YXZlc3VyZmVyIGluc3RhbmNlXHJcbiAgICAgIGxldCB3YXZlZm9ybSA9IHNlbGYuY29udGFpbmVyWzBdO1xyXG4gICAgICBsZXQgd2F2ZWZvcm1QYXJlbnQgPSB3YXZlZm9ybS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gICAgICBsZXQgc3RhcnREdXJhdGlvbkZpZWxkID0gd2F2ZWZvcm1QYXJlbnQucXVlcnlTZWxlY3RvcignLmZpZWxkLW5hbWUtc3RhcnREdXJhdGlvbicpO1xyXG4gICAgICBsZXQgZW5kRHVyYXRpb25GaWVsZCA9IHdhdmVmb3JtUGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1uYW1lLWVuZER1cmF0aW9uJyk7XHJcblxyXG4gICAgICBpZiAoc3RhcnREdXJhdGlvbkZpZWxkICYmIGVuZER1cmF0aW9uRmllbGQpIHtcclxuICAgICAgICBsZXQgc3RhcnREdXJhdGlvbkZpZWxkSW5wdXQgPSBzdGFydER1cmF0aW9uRmllbGQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICAgICAgICBsZXQgZW5kRHVyYXRpb25GaWVsZElucHV0ID0gZW5kRHVyYXRpb25GaWVsZC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBmb2N1c291dCBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgIHN0YXJ0RHVyYXRpb25GaWVsZElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5zdGFydER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyKGUudGFyZ2V0LnZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgICAgZW5kRHVyYXRpb25GaWVsZElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5lbmREdXJhdGlvblZhbHVlQ2hhbmdlSGFuZGxlcihlLnRhcmdldC52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB2YWx1ZXMgb2Ygc3RhcnQgZHVyYXRpb24gYW5kIGVuZCBkdXJhdGlvbiBiYXNlZCBvbiBwcmV2aW91c1xyXG4gICAgICAgIC8vIHdhdmVmb3JtIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgIGxldCB3YXZlZm9ybUVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndhdmVmb3JtXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F2ZWZvcm1FbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHdhdmVmb3JtRWxlbWVudHNbaV0uaWQgPT09IHNlbGYuY29udGFpbmVyWzBdLmlkICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1dhdmVmb3JtQ29udGVudCA9IHdhdmVmb3JtRWxlbWVudHNbaSAtIDFdLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IHByZXZpb3VzRW5kRHVyYXRpb25GaWVsZCA9IHByZXZpb3VzV2F2ZWZvcm1Db250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1uYW1lLWVuZER1cmF0aW9uJyk7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0VuZER1cmF0aW9uRmllbGQpIHtcclxuICAgICAgICAgICAgICBsZXQgcHJldmlvdXNFbmREdXJhdGlvbklucHV0ID0gcHJldmlvdXNFbmREdXJhdGlvbkZpZWxkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcblxyXG4gICAgICAgICAgICAgIHN0YXJ0RHVyYXRpb25GaWVsZElucHV0LnZhbHVlID0gcGFyc2VGbG9hdChwcmV2aW91c0VuZER1cmF0aW9uSW5wdXQudmFsdWUpICsgMC4wMDE7XHJcbiAgICAgICAgICAgICAgZW5kRHVyYXRpb25GaWVsZElucHV0LnZhbHVlID0gcGFyc2VGbG9hdChwcmV2aW91c0VuZER1cmF0aW9uSW5wdXQudmFsdWUpICsgMC4wMDEgKyAwLjE7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgdGhpcy5zdGFydER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyKHN0YXJ0RHVyYXRpb25GaWVsZElucHV0LnZhbHVlKTtcclxuICAgICAgICAgICAgICB0aGlzLmVuZER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyKGVuZER1cmF0aW9uRmllbGRJbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBhdWRpbyBsb2FkZXIgb2JzZXJ2ZXIgb24gdGhpcyB3YXZlc3VyZmVyIGluc3RhbmNlXHJcbiAgICAgIGxldCBmaWxlc0ZpZWxkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZpZWxkLW5hbWUtZmlsZXNcIilbMF07XHJcbiAgICAgIGlmIChmaWxlc0ZpZWxkKSB7XHJcbiAgICAgICAgbGV0IGZpbGVzTGlzdEVsZW1lbnQgPSBmaWxlc0ZpZWxkLnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyQ29uZmlnID0geyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zTGlzdCwgb2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgIGxldCBpZCA9IEg1UEVkaXRvci5yZW5kZXJhYmxlQ29tbW9uRmllbGRzW1wiSDVQLkNSQXVkaW8gMS40XCJdLmZpZWxkc1tzZWxmLmNyQXVkaW9JbmRleCAtIDFdLnBhcmVudC5wYXJhbXMuc3ViQ29udGVudElkO1xyXG4gICAgICAgICAgbGV0IHBhdGggPSBzZWxmLmF1ZGlvUGFyYW1zLmZpbGVzID8gc2VsZi5hdWRpb1BhcmFtcy5maWxlc1swXS5wYXRoIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgaWYgKHBhdGggIT0gdW5kZWZpbmVkICYmIGlkICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXQgZmlsZSA9IEg1UC5nZXRQYXRoKHBhdGgsIGlkKTtcclxuICAgICAgICAgICAgJC5nZXQoZmlsZSkuZG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXZlc3VyZmVyLmxvYWQoZmlsZSk7XHJcbiAgICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGxldCBpZCA9IEg1UEVkaXRvci5jb250ZW50SWQ7XHJcbiAgICAgICAgICAgICAgbGV0IGZpbGUgPSBINVAuZ2V0UGF0aChwYXRoLCBpZCk7XHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXZlc3VyZmVyLmxvYWQoZmlsZSk7XHJcbiAgICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5yZWdpb24gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCAkc3RhcnRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtc3RhcnREdXJhdGlvbicpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgIGxldCAkZW5kaW5wdXQgPSAkKCcjJyArIHRoaXMuaWQpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5maWVsZC1uYW1lLWVuZER1cmF0aW9uJykuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgJHN0YXJ0aW5wdXQudmFsKDApO1xyXG4gICAgICAgICAgICAkZW5kaW5wdXQudmFsKDAuMik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5maW5kRmllbGQoXCJzdGFydER1cmF0aW9uXCIsIHRoaXMucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyAwKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcImVuZER1cmF0aW9uXCIsIHRoaXMucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyAwLjIpO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICAgIGVuZDogMC4yXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uLnVwZGF0ZShwYXJhbXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGZpbGVzTGlzdEVsZW1lbnQsIG9ic2VydmVyQ29uZmlnKTtcclxuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCAyMDAwKTtcclxuXHJcbiAgd2F2ZXN1cmZlci5vbigncmVnaW9uLXVwZGF0ZWQnLCAoZXZlbnQpID0+IHtcclxuICAgIHRoaXMuc3RhcnQgPSBldmVudC5zdGFydDtcclxuICAgIHRoaXMuZW5kID0gZXZlbnQuZW5kO1xyXG4gICAgdGhpcy4kc3RhcnRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtc3RhcnREdXJhdGlvbicpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLiRlbmRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKS5maW5kKCdpbnB1dCcpO1xyXG4gICAgdGhpcy4kc3RhcnRpbnB1dC52YWwodGhpcy5zdGFydC50b0ZpeGVkKDQpKTtcclxuICAgIHRoaXMuJGVuZGlucHV0LnZhbCh0aGlzLmVuZC50b0ZpeGVkKDQpKTtcclxuICAgIHRoaXMuc2V0VmFsdWUodGhpcy5maW5kRmllbGQoXCJzdGFydER1cmF0aW9uXCIsIHRoaXMucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyB0aGlzLnN0YXJ0LnRvRml4ZWQoNCkpO1xyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcImVuZER1cmF0aW9uXCIsIHRoaXMucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyB0aGlzLmVuZC50b0ZpeGVkKDQpKTtcclxuICB9KTtcclxuXHJcbiAgaWYgKHRoaXMuaWQgIT0gbnVsbCkge1xyXG4gICAgbGV0IHJlZ2lvbklkID0gdGhpcy5pZCArIFwicGxheVJlZ2lvblwiO1xyXG4gICAgbGV0ICRwbGF5UmVnaW9uQnV0dG9uID0gJCgnPGJ1dHRvbiBpZCA9ICcgKyByZWdpb25JZCArICcgY2xhc3MgPSBcInBsYXlSZWdpb25cIj5QbGF5PC9idXR0b24+Jyk7XHJcbiAgICAkKHNlbGYuY29udGFpbmVyKS5wYXJlbnQoJ2RpdicpLmFwcGVuZCgkcGxheVJlZ2lvbkJ1dHRvbik7XHJcbiAgICAkKCRwbGF5UmVnaW9uQnV0dG9uKS5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLnJlZ2lvbi5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLnN0YXJ0RHVyYXRpb25WYWx1ZUNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gIGlmICh0aGlzLnJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgIGlmIChwYXJzZUZsb2F0KHZhbHVlKSA+IHRoaXMuYXVkaW9EdXJhdGlvbikge1xyXG4gICAgICAgIHZhbHVlID0gMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBpbnB1dFN0YXJ0VGltZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICBsZXQgaW5wdXRFbmRUaW1lID0gdGhpcy5yZWdpb24uZW5kIDw9IHBhcnNlRmxvYXQodmFsdWUpID8gcGFyc2VGbG9hdCh2YWx1ZSkgKyAwLjIgOiB0aGlzLnJlZ2lvbi5lbmQ7XHJcbiAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgc3RhcnQ6IGlucHV0U3RhcnRUaW1lLnRvRml4ZWQoNCksXHJcbiAgICAgICAgZW5kOiBpbnB1dEVuZFRpbWUudG9GaXhlZCg0KVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnJlZ2lvbi51cGRhdGUocGFyYW1zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQodGhpcykucGFyZW50KCkuZmluZCgnLmg1cC1lcnJvcnMnKS5hcHBlbmQoXCI8cD5UaGUgZW50ZXJlZCB2YWx1ZSBtdXN0IGJlIE51bWJlciBub3QgYWxwaGFiZXQ8L3A+XCIpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLmVuZER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICBpZiAodGhpcy5yZWdpb24gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICBpZiAocGFyc2VGbG9hdCh2YWx1ZSkgPiB0aGlzLmF1ZGlvRHVyYXRpb24pIHtcclxuICAgICAgICB2YWx1ZSA9IHNlbGYuYXVkaW9EdXJhdGlvbiAtIDAuMDU7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGlucHV0U3RhcnRUaW1lID0gcGFyc2VGbG9hdCh2YWx1ZSkgPD0gdGhpcy5yZWdpb24uc3RhcnQgPyAwIDogdGhpcy5yZWdpb24uc3RhcnQ7XHJcbiAgICAgIGxldCBpbnB1dEVuZFRpbWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICBzdGFydDogaW5wdXRTdGFydFRpbWUudG9GaXhlZCg0KSxcclxuICAgICAgICBlbmQ6IGlucHV0RW5kVGltZS50b0ZpeGVkKDQpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucmVnaW9uLnVwZGF0ZShwYXJhbXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJCh0aGlzKS5wYXJlbnQoKS5maW5kKCcuaDVwLWVycm9ycycpLmFwcGVuZChcIjxwPlRoZSBlbnRlcmVkIHZhbHVlIG11c3QgYmUgTnVtYmVyIG5vdCBhbHBoYWJldDwvcD5cIilcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBcHBlbmQgdGhlIGZpZWxkIHRvIHRoZSB3cmFwcGVyLlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSB7SDVQLmpRdWVyeX0gJHdyYXBwZXJcclxuICovXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbiAoJHdyYXBwZXIpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgY29uc3QgaWQgPSBucy5nZXROZXh0RmllbGRJZCh0aGlzLmZpZWxkKTtcclxuICB2YXIgaHRtbCA9IEg1UEVkaXRvci5jcmVhdGVGaWVsZE1hcmt1cCh0aGlzLmZpZWxkLCAnPGRpdiBjbGFzcz1cIndhdmVmb3JtXCIgaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCJoNXAtY29sb3ItcGlja2VyXCI+JywgaWQpO1xyXG4gIHNlbGYuJGl0ZW0gPSBINVBFZGl0b3IuJChodG1sKTtcclxuICB0aGlzLnNldElkKGlkKTtcclxuICBsZXQgd29yZFRleHQgPSAodGhpcy5wYXJlbnQucGFyYW1zLnRleHQgIT0gdW5kZWZpbmVkKSA/IHRoaXMucGFyZW50LnBhcmFtcy50ZXh0IDogJydcclxuICAkd3JhcHBlci5hcHBlbmQoJzxoMSBjbGFzcz1cInRlc3RcIj5TZWxlY3Qgd29yZChzKTwvaDE+JylcclxuICAvLyAkd3JhcHBlci5hcHBlbmQoJzxsYWJlbCBjbGFzcz1cImg1cGVkaXRvci1sYWJlbFwiPjxpbnB1dCBpZD1cImZpZWxkLXdvcmRzLTEyNVwiIHR5cGU9XCJjaGVja2JveFwiPldpbGwgRG8gQW5pbWF0aW9uPC9sYWJlbD4nKVxyXG4gIC8vbGV0IGNoZWNrQm94RWxlbWVudEZvcldvcmQ9JHdyYXBwZXIuYXBwZW5kKHRoaXMuZ2V0U2VudGVuY2Uoc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQuY3Auc2xpZGVzLHNlbGYucGFyZW50LnBhcmVudC5wYXJlbnQucGFyZW50LmNwLmN1cnJlbnRTbGlkZUluZGV4KSlcclxuICBsZXQgc2xpZGVzID0gc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQuY3Auc2xpZGVzO1xyXG4gIGxldCBzbGlkZUluZGV4ID0gdGhpcy5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJhbXMucGFyYW1zLmN1cnJJbmRleDtcclxuICBsZXQgcGFyYW1UZXh0ID0gdGhpcy5wYXJlbnQucGFyYW1zLnRleHQ7XHJcbiAgbGV0IGNoZWNrQm94RWxlbWVudEZvcldvcmQgPSAkd3JhcHBlci5hcHBlbmQodGhpcy5nZXRTZW50ZW5jZShzbGlkZXMsIHNsaWRlSW5kZXgsIHBhcmFtVGV4dCkpO1xyXG4gIHNlbGYuJGl0ZW0uYXBwZW5kVG8oJHdyYXBwZXIpO1xyXG4gIHNlbGYuY29udGFpbmVyID0gc2VsZi4kaXRlbS5maW5kKCcjJyArIHRoaXMuaWQpO1xyXG4gIGNvbnNvbGUubG9nKGNoZWNrQm94RWxlbWVudEZvcldvcmQpO1xyXG4gICQoY2hlY2tCb3hFbGVtZW50Rm9yV29yZCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0KTtcclxuICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC5pZCk7XHJcbiAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQudmFsdWUpO1xyXG4gICAgbGV0IGlzQWxyZWFkeVVzZWQgPSBzZWxmLmNoZWNrSWZXb3JkSXNVc2VkSW5PdGhlcldhdmVmb3JtKHNsaWRlSW5kZXgsIGV2ZW50LnRhcmdldC5pZCk7XHJcbiAgICBpZiAoJCgnIycgKyBldmVudC50YXJnZXQuaWQpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgIGlmIChpc0FscmVhZHlVc2VkKSB7XHJcbiAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZXZlbnQudGFyZ2V0LmlkKS5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3b3JkVGV4dCA9IHdvcmRUZXh0ICsgJyAnICsgZXZlbnQudGFyZ2V0LnZhbHVlICsgJyAnO1xyXG4gICAgICAgICQoJyMnICsgZXZlbnQudGFyZ2V0LmlkKS5hdHRyKCdjaGVja2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy4kd29yZCA9ICQoJyMnICsgaWQpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5maWVsZC1uYW1lLXRleHQnKS5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgIHRoaXMuJHdvcmQudmFsKCh3b3JkVGV4dC50cmltKCkpLnJlcGxhY2UoLyAgKy9nLCAnICcpKTtcclxuICAgICAgICAkKHRoaXMuJHdvcmQpLmF0dHIoJ2NoZWNrZWQnLCB0cnVlKTtcclxuICAgICAgICBzZWxmLnNldFZhbHVlKHNlbGYuZmluZEZpZWxkKFwidGV4dFwiLCBzZWxmLnBhcmVudC5maWVsZC5maWVsZHMpLCBcIlwiICsgd29yZFRleHQucmVwbGFjZSgvICArL2csICcgJykpO1xyXG4gICAgICAgIFdhdmVmb3JtSW5pdC5wYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlW3NsaWRlSW5kZXgudG9TdHJpbmcoKV0ucHVzaCh7J2luZGV4JzogZXZlbnQudGFyZ2V0LmlkLnNwbGl0KCdfJylbMV0sICdpZCc6IGV2ZW50LnRhcmdldC5pZH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkKCcjJyArIGV2ZW50LnRhcmdldC5pZCkuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgbGV0IHRlbXBXb3JkVGV4dCA9IHdvcmRUZXh0LnJlcGxhY2UoZXZlbnQudGFyZ2V0LnZhbHVlLCAnJyk7XHJcbiAgICAgIHdvcmRUZXh0ID0gdGVtcFdvcmRUZXh0O1xyXG4gICAgICB0aGlzLiR3b3JkID0gJCgnIycgKyBpZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtdGV4dCcpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICAgIHNlbGYuc2V0VmFsdWUoc2VsZi5maW5kRmllbGQoXCJ0ZXh0XCIsIHNlbGYucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyB3b3JkVGV4dC5yZXBsYWNlKC8gICsvZywgJyAnKSk7XHJcbiAgICAgICQodGhpcy4kd29yZCkuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgdGhpcy4kd29yZC52YWwoKHdvcmRUZXh0LnRyaW0oKSkucmVwbGFjZSgvICArL2csICcgJykpO1xyXG4gICAgICBXYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZVtzbGlkZUluZGV4LnRvU3RyaW5nKCldID0gV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2Vbc2xpZGVJbmRleC50b1N0cmluZygpXS5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2JqLmlkID09PSBldmVudC50YXJnZXQuaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2UpO1xyXG4gIH0pXHJcbiAgc2VsZi5zZXRWYWx1ZShzZWxmLmZpbmRGaWVsZChcInRleHRcIiwgc2VsZi5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMucGFyZW50LnBhcmFtcy50ZXh0KTtcclxuICBzZWxmLmluaXQoKTtcclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuY2hlY2tJZldvcmRJc1VzZWRJbk90aGVyV2F2ZWZvcm0gPSBmdW5jdGlvbiAoc2xpZGVJbmRleCwgaW5wdXRJZCkge1xyXG4gIGxldCBzbGlkZUNoZWNrYm94SW5mbyA9IFdhdmVmb3JtSW5pdC5wYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlW3NsaWRlSW5kZXgudG9TdHJpbmcoKV07XHJcbiAgbGV0IHdvcmRJbmRleCA9IHBhcnNlSW50KGlucHV0SWQuc3BsaXQoJ18nKVsxXSk7XHJcbiAgaWYgKHNsaWRlQ2hlY2tib3hJbmZvICE9PSBudWxsICYmIHNsaWRlQ2hlY2tib3hJbmZvICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVDaGVja2JveEluZm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHBhcnNlSW50KHNsaWRlQ2hlY2tib3hJbmZvW2ldLmluZGV4KSA9PT0gd29yZEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2Vbc2xpZGVJbmRleC50b1N0cmluZygpXSA9IFtdO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZmluZEZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIGZpZWxkcykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoZmllbGRzW2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIGZpZWxkc1tpXTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgdGhpcy5pZCA9IGlkO1xyXG59XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLmZpbmRGaWVsZCA9IGZ1bmN0aW9uIChuYW1lLCBmaWVsZHMpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGZpZWxkc1tpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgIHJldHVybiBmaWVsZHNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyB0aGlzLmhpZGUoKTtcclxuICAvLyByZXR1cm4gKHRoaXMucGFyYW1zICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJhbXMubGVuZ3RoICE9PSAwKTtcclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZ2V0U2VudGVuY2UgPSBmdW5jdGlvbiAoc2xpZGVzLCBzbGlkZUluZGV4LCBwcmV2RGF0YSkge1xyXG4gIHZhciBzZW50ZW5jZVdvcmRzID0gW107XHJcbiAgdmFyIHNwbGl0dGVkUHJldkRhdGEgPSAocHJldkRhdGEgIT0gdW5kZWZpbmVkKSA/IHByZXZEYXRhLnNwbGl0KCcgJykgOiBbXTtcclxuICBsZXQgYWxyZWFkeUZvdW5kU3BsaXR0ZWRQcmV2RGF0YVdvcmQgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNbc2xpZGVJbmRleF0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChzbGlkZXNbc2xpZGVJbmRleF0uZWxlbWVudHNbaV0uYWN0aW9uLmxpYnJhcnkuc3BsaXQoJyAnKVswXSA9PSBcIkg1UC5DUkFkdmFuY2VkVGV4dFwiKSB7XHJcbiAgICAgIHZhciBjaGVja0JveFdvcmQgPSAnJztcclxuICAgICAgc2VudGVuY2VXb3JkcyA9ICQoc2xpZGVzW3NsaWRlSW5kZXhdLmVsZW1lbnRzW2ldLmFjdGlvbi5wYXJhbXMudGV4dClbMF0uaW5uZXJUZXh0LnNwbGl0KCcgJyk7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VudGVuY2VXb3Jkcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBkZWYgPSAoc3BsaXR0ZWRQcmV2RGF0YS5pbmRleE9mKHNlbnRlbmNlV29yZHNbal0pICE9PSAtMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHNlbnRlbmNlV29yZHNbal0ucmVwbGFjZSgvICArL2csICcgJykgIT0gJycpIHtcclxuICAgICAgICAgIGlmIChkZWYgJiYgIWFscmVhZHlGb3VuZFNwbGl0dGVkUHJldkRhdGFXb3JkICYmICF0aGlzLmNoZWNrSWZXb3JkSXNVc2VkSW5PdGhlcldhdmVmb3JtKHNsaWRlSW5kZXgsIHRoaXMuaWQgKyBqKSkge1xyXG4gICAgICAgICAgICBjaGVja0JveFdvcmQgPSBjaGVja0JveFdvcmQgKyAnPGxhYmVsIGNsYXNzPVwiaDVwZWRpdG9yLWxhYmVsIGlkID0nICsgdGhpcy5pZCArIGogKyAnXCI+PGlucHV0IGlkPScgKyB0aGlzLmlkICsgXCJfXCIgKyBqICsgJyB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIicgKyBzZW50ZW5jZVdvcmRzW2pdICsgJ1wiY2hlY2tlZD4nICsgc2VudGVuY2VXb3Jkc1tqXSArICc8L2xhYmVsPic7XHJcbiAgICAgICAgICAgIGFscmVhZHlGb3VuZFNwbGl0dGVkUHJldkRhdGFXb3JkID0gdHJ1ZTtcclxuICAgICAgICAgICAgV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2Vbc2xpZGVJbmRleC50b1N0cmluZygpXS5wdXNoKHtcImluZGV4XCI6IGosIFwiaWRcIjogdGhpcy5pZCArIGp9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoZWNrQm94V29yZCA9IGNoZWNrQm94V29yZCArICc8bGFiZWwgY2xhc3M9XCJoNXBlZGl0b3ItbGFiZWwgaWQgPScgKyB0aGlzLmlkICsgaiArICdcIj48aW5wdXQgaWQ9JyArIHRoaXMuaWQgKyBcIl9cIiArIGogKyAnIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiJyArIHNlbnRlbmNlV29yZHNbal0gKyAnXCI+JyArIHNlbnRlbmNlV29yZHNbal0gKyAnPC9sYWJlbD4nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBjb25zb2xlLmxvZyhXYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZSk7XHJcbiAgcmV0dXJuIGNoZWNrQm94V29yZDtcclxufVxyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBXYXZlZm9ybUluaXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9XYXZlZm9ybUluaXQuanMiLCJjb25zdCBDaGlsZCA9IHJlcXVpcmUoJy4vY2hpbGQuanMnKTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyID0gSDVQLkV2ZW50RGlzcGF0Y2hlcjtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIFBhcmVudChjb25zdHJ1Y3RvciwgcGFyYW1ldGVycykge1xyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RGlzcGF0Y2hlci5jYWxsKHNlbGYpO1xyXG5cclxuICBzZWxmLmNoaWxkcmVuID0gW107XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgaW5kZXhlcyBvZiB0aGUgY2hpbGRyZW4uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tIFdoZXJlIHRvIHN0YXJ0XHJcbiAgICovXHJcbiAgdmFyIHVwZGF0ZUluZGV4ZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xyXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBzZWxmLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHNlbGYuY2hpbGRyZW5baV0uaW5kZXggPSBpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmUgYSBuZXcgY2hpbGQgdG8gdGhpcyBwYXJlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGNoaWxkUGFyYW1ldGVycyBMYXVuY2ggcGFyYW1ldGVyc1xyXG4gICAqL1xyXG4gIHNlbGYuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRQYXJhbWV0ZXJzLCBpbmRleCkge1xyXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaW5kZXggPSBzZWxmLmNoaWxkcmVuLmxlbmd0aFxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIG5ldyBjaGlsZCB3aXRoIHRoZSBjdXJyZW50IGluc3RhbmNlIGFzIGl0cyBwYXJlbnRcclxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENoaWxkKGluZGV4LCBzZWxmKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IHNlbGYuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgIC8vIEFkZGVkIGF0IHRoZSBlbmRcclxuICAgICAgc2VsZi5jaGlsZHJlbi5wdXNoKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBJbnNlcnRlZCBhdCBhIHNwZWNpZmljIGxvY2F0aW9uXHJcbiAgICAgIHNlbGYuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBpbnN0YW5jZSk7XHJcbiAgICAgIHVwZGF0ZUluZGV4ZXMoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJ1biBvcmlnaW5hbCBjb25zdHJ1Y3RvclxyXG4gICAgY29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgY2hpbGRQYXJhbWV0ZXJzKTtcclxuXHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZhIGEgbmV3IGNoaWxkIGZyb20gaXRzIHBhcmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIHNlbGYucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgIC8vIFJlbW92ZSBmcm9tIGFycmF5XHJcbiAgICBzZWxmLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGludGVybmFsIGluZGV4ZXNcclxuICAgIHVwZGF0ZUluZGV4ZXMoaW5kZXgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIGNoaWxkIGludG8gYSBuZXcgcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRJbmRleFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleFxyXG4gICAqL1xyXG4gIHNlbGYubW92ZUNoaWxkID0gZnVuY3Rpb24gKG9sZEluZGV4LCBuZXdJbmRleCkge1xyXG4gICAgY29uc3QgY2hpbGQgPSBzZWxmLmNoaWxkcmVuLnNwbGljZShvbGRJbmRleCwgMSlbMF07XHJcbiAgICBzZWxmLmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgY2hpbGQpO1xyXG5cclxuICAgIHVwZGF0ZUluZGV4ZXMobmV3SW5kZXggPCBvbGRJbmRleCA/IG5ld0luZGV4IDogb2xkSW5kZXgpO1xyXG4gIH07XHJcblxyXG4gIGlmIChwYXJhbWV0ZXJzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2VsZi5hZGRDaGlsZChwYXJhbWV0ZXJzW2ldKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblBhcmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUpO1xyXG5QYXJlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyZW50O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJlbnQ7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oNXAtcGFyZW50L3NyYy9wYXJlbnQuanMiLCIvKipcclxuICogQGNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiBDaGlsZChpbmRleCwgcGFyZW50KSB7XHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHNlbGYuaW5kZXggPSBpbmRleDtcclxuICBzZWxmLnBhcmVudCA9IHBhcmVudDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaGlsZDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL2NoaWxkLmpzIiwiZXhwb3J0IGNvbnN0IGpRdWVyeSA9IEg1UC5qUXVlcnk7XHJcbmV4cG9ydCBjb25zdCBFdmVudERpc3BhdGNoZXIgPSBINVAuRXZlbnREaXNwYXRjaGVyO1xyXG5leHBvcnQgY29uc3QgSm91YmVsVUkgPSBINVAuSm91YmVsVUk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2dsb2JhbHMuanMiLCIvKiFcbiAqIHdhdmVzdXJmZXIuanMgNS4xLjAgKDIwMjEtMDYtMjApXG4gKiBodHRwczovL3dhdmVzdXJmZXItanMub3JnXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJXYXZlU3VyZmVyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIldhdmVTdXJmZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiV2F2ZVN1cmZlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL2RyYXdlci5jYW52YXNlbnRyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZHJhd2VyLmNhbnZhc2VudHJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9zdHlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL3N0eWxlICovIFwiLi9zcmMvdXRpbC9zdHlsZS5qc1wiKSk7XG5cbnZhciBfZ2V0SWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9nZXQtaWQgKi8gXCIuL3NyYy91dGlsL2dldC1pZC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBUaGUgYENhbnZhc0VudHJ5YCBjbGFzcyByZXByZXNlbnRzIGFuIGVsZW1lbnQgY29uc2lzdGluZyBvZiBhIHdhdmUgYGNhbnZhc2BcbiAqIGFuZCBhbiAob3B0aW9uYWwpIHByb2dyZXNzIHdhdmUgYGNhbnZhc2AuXG4gKlxuICogVGhlIGBNdWx0aUNhbnZhc2AgcmVuZGVyZXIgdXNlcyBvbmUgb3IgbW9yZSBgQ2FudmFzRW50cnlgIGluc3RhbmNlcyB0b1xuICogcmVuZGVyIGEgd2F2ZWZvcm0sIGRlcGVuZGluZyBvbiB0aGUgem9vbSBsZXZlbC5cbiAqL1xudmFyIENhbnZhc0VudHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FudmFzRW50cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc0VudHJ5KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3YXZlIG5vZGVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLndhdmUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSB3YXZlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cblxuICAgIHRoaXMud2F2ZUN0eCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIChvcHRpb25hbCkgcHJvZ3Jlc3Mgd2F2ZSBub2RlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG5cbiAgICB0aGlzLnByb2dyZXNzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgKG9wdGlvbmFsKSBwcm9ncmVzcyB3YXZlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cblxuICAgIHRoaXMucHJvZ3Jlc3NDdHggPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIHRoZSBhcmVhIHRoZSBjYW52YXMgc2hvdWxkIHJlbmRlciwgYmV0d2VlbiAwIGFuZCAxXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgLyoqXG4gICAgICogRW5kIG9mIHRoZSBhcmVhIHRoZSBjYW52YXMgc2hvdWxkIHJlbmRlciwgYmV0d2VlbiAwIGFuZCAxXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5lbmQgPSAxO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgdGhpcy5pZCA9ICgwLCBfZ2V0SWQuZGVmYXVsdCkodHlwZW9mIHRoaXMuY29uc3RydWN0b3IubmFtZSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKSArICdfJyA6ICdjYW52YXNlbnRyeV8nKTtcbiAgICAvKipcbiAgICAgKiBDYW52YXMgMmQgY29udGV4dCBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgdGhpcy5jYW52YXNDb250ZXh0QXR0cmlidXRlcyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgd2F2ZSBjYW52YXMgZWxlbWVudCBhbmQgY3JlYXRlIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBlbGVtZW50IFRoZSB3YXZlIGBjYW52YXNgIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc0VudHJ5LCBbe1xuICAgIGtleTogXCJpbml0V2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0V2F2ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLndhdmUgPSBlbGVtZW50O1xuICAgICAgdGhpcy53YXZlQ3R4ID0gdGhpcy53YXZlLmdldENvbnRleHQoJzJkJywgdGhpcy5jYW52YXNDb250ZXh0QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBwcm9ncmVzcyB3YXZlIGNhbnZhcyBlbGVtZW50IGFuZCBjcmVhdGUgdGhlIDJEIHJlbmRlcmluZ1xuICAgICAqIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnQgVGhlIHByb2dyZXNzIHdhdmUgYGNhbnZhc2AgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgdGhpcy5wcm9ncmVzcyA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLnByb2dyZXNzQ3R4ID0gdGhpcy5wcm9ncmVzcy5nZXRDb250ZXh0KCcyZCcsIHRoaXMuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGRpbWVuc2lvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtZW50V2lkdGggV2lkdGggb2YgdGhlIGVudHJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsV2lkdGggVG90YWwgd2lkdGggb2YgdGhlIG11bHRpIGNhbnZhcyByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgbmV3IHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaW1lbnNpb25zKGVsZW1lbnRXaWR0aCwgdG90YWxXaWR0aCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgLy8gd2hlcmUgdGhlIGNhbnZhcyBzdGFydHMgYW5kIGVuZHMgaW4gdGhlIHdhdmVmb3JtLCByZXByZXNlbnRlZCBhcyBhXG4gICAgICAvLyBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMVxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMud2F2ZS5vZmZzZXRMZWZ0IC8gdG90YWxXaWR0aCB8fCAwO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgZWxlbWVudFdpZHRoIC8gdG90YWxXaWR0aDsgLy8gc2V0IHdhdmUgY2FudmFzIGRpbWVuc2lvbnNcblxuICAgICAgdGhpcy53YXZlLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLndhdmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIGVsZW1lbnRTaXplID0ge1xuICAgICAgICB3aWR0aDogZWxlbWVudFdpZHRoICsgJ3B4J1xuICAgICAgfTtcbiAgICAgICgwLCBfc3R5bGUuZGVmYXVsdCkodGhpcy53YXZlLCBlbGVtZW50U2l6ZSk7XG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIC8vIHNldCBwcm9ncmVzcyBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLnByb2dyZXNzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAoMCwgX3N0eWxlLmRlZmF1bHQpKHRoaXMucHJvZ3Jlc3MsIGVsZW1lbnRTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHdhdmUgYW5kIHByb2dyZXNzIHJlbmRlcmluZyBjb250ZXh0c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyV2F2ZSgpIHtcbiAgICAgIC8vIHdhdmVcbiAgICAgIHRoaXMud2F2ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53YXZlQ3R4LmNhbnZhcy53aWR0aCwgdGhpcy53YXZlQ3R4LmNhbnZhcy5oZWlnaHQpOyAvLyBwcm9ncmVzc1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICB0aGlzLnByb2dyZXNzQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnByb2dyZXNzQ3R4LmNhbnZhcy53aWR0aCwgdGhpcy5wcm9ncmVzc0N0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxsIHN0eWxlcyBmb3Igd2F2ZSBhbmQgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YXZlQ29sb3IgRmlsbCBjb2xvciBmb3IgdGhlIHdhdmUgY2FudmFzXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBwcm9ncmVzc0NvbG9yIEZpbGwgY29sb3IgZm9yIHRoZSBwcm9ncmVzcyBjYW52YXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbGxTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsbFN0eWxlcyh3YXZlQ29sb3IsIHByb2dyZXNzQ29sb3IpIHtcbiAgICAgIHRoaXMud2F2ZUN0eC5maWxsU3R5bGUgPSB3YXZlQ29sb3I7XG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDdHguZmlsbFN0eWxlID0gcHJvZ3Jlc3NDb2xvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYW52YXMgdHJhbnNmb3JtcyBmb3Igd2F2ZSBhbmQgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmVydGljYWwgV2hldGhlciB0byByZW5kZXIgdmVydGljYWxseVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlDYW52YXNUcmFuc2Zvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Q2FudmFzVHJhbnNmb3Jtcyh2ZXJ0aWNhbCkge1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIC8vIFJlZmxlY3QgdGhlIHdhdmVmb3JtIGFjcm9zcyB0aGUgbGluZSB5ID0gLXhcbiAgICAgICAgdGhpcy53YXZlQ3R4LnNldFRyYW5zZm9ybSgwLCAxLCAxLCAwLCAwLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDdHguc2V0VHJhbnNmb3JtKDAsIDEsIDEsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSByZWN0YW5nbGUgZm9yIHdhdmUgYW5kIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbGxSZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICB0aGlzLmZpbGxSZWN0VG9Db250ZXh0KHRoaXMud2F2ZUN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgdGhpcy5maWxsUmVjdFRvQ29udGV4dCh0aGlzLnByb2dyZXNzQ3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBhY3R1YWwgcmVjdGFuZ2xlIG9uIGEgYGNhbnZhc2AgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY29udGV4dCBvZiB0YXJnZXQgY2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaWxsUmVjdFRvQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdFRvQ29udGV4dChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFkaXVzKSB7XG4gICAgICAgIHRoaXMuZHJhd1JvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJvdW5kZWQgcmVjdGFuZ2xlIG9uIENhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDYW52YXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFgtcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFktcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQGV4YW1wbGUgZHJhd1JvdW5kZWRSZWN0KGN0eCwgNTAsIDUwLCA1LCAxMCwgMylcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdSb3VuZGVkUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Um91bmRlZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgIGlmIChoZWlnaHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBwZWFrcyBhcmUgZmxvYXQgdmFsdWVzIGZyb20gLTEgdG8gMS4gVXNlIGFic29sdXRlIGhlaWdodCB2YWx1ZXMgaW5cbiAgICAgIC8vIG9yZGVyIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgcm91bmRlZCByZWN0YW5nbGUgY29vcmRpbmF0ZXNcblxuXG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICBoZWlnaHQgKj0gLTE7XG4gICAgICAgIHkgLT0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBhY3R1YWwgd2F2ZSBhbmQgcHJvZ3Jlc3MgbGluZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBlYWtzIEFycmF5IHdpdGggcGVha3MgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhYnNtYXggTWF4aW11bSBwZWFrIHZhbHVlIChhYnNvbHV0ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFsZkggSGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIE9mZnNldCB0byB0aGUgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZXMocGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHRoaXMuZHJhd0xpbmVUb0NvbnRleHQodGhpcy53YXZlQ3R4LCBwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuZHJhd0xpbmVUb0NvbnRleHQodGhpcy5wcm9ncmVzc0N0eCwgcGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGFjdHVhbCB3YXZlZm9ybSBsaW5lIG9uIGEgYGNhbnZhc2AgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY29udGV4dCBvZiB0YXJnZXQgY2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGVha3MgQXJyYXkgd2l0aCBwZWFrcyBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFic21heCBNYXhpbXVtIHBlYWsgdmFsdWUgKGFic29sdXRlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYWxmSCBIYWxmIHRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgT2Zmc2V0IHRvIHRoZSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xpbmVUb0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmVUb0NvbnRleHQoY3R4LCBwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gcGVha3MubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBmaXJzdCA9IE1hdGgucm91bmQobGVuZ3RoICogdGhpcy5zdGFydCk7IC8vIHVzZSBvbmUgbW9yZSBwZWFrIHZhbHVlIHRvIG1ha2Ugc3VyZSB3ZSBqb2luIHBlYWtzIGF0IGVuZHMgLS0gdW5sZXNzLFxuICAgICAgLy8gb2YgY291cnNlLCB0aGlzIGlzIHRoZSBsYXN0IGNhbnZhc1xuXG4gICAgICB2YXIgbGFzdCA9IE1hdGgucm91bmQobGVuZ3RoICogdGhpcy5lbmQpICsgMTtcbiAgICAgIHZhciBjYW52YXNTdGFydCA9IGZpcnN0O1xuICAgICAgdmFyIGNhbnZhc0VuZCA9IGxhc3Q7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLndhdmUud2lkdGggLyAoY2FudmFzRW5kIC0gY2FudmFzU3RhcnQgLSAxKTsgLy8gb3B0aW1pemF0aW9uXG5cbiAgICAgIHZhciBoYWxmT2Zmc2V0ID0gaGFsZkggKyBvZmZzZXRZO1xuICAgICAgdmFyIGFic21heEhhbGYgPSBhYnNtYXggLyBoYWxmSDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oKGNhbnZhc1N0YXJ0IC0gZmlyc3QpICogc2NhbGUsIGhhbGZPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbygoY2FudmFzU3RhcnQgLSBmaXJzdCkgKiBzY2FsZSwgaGFsZk9mZnNldCAtIE1hdGgucm91bmQoKHBlYWtzWzIgKiBjYW52YXNTdGFydF0gfHwgMCkgLyBhYnNtYXhIYWxmKSk7XG4gICAgICB2YXIgaSwgcGVhaywgaDtcblxuICAgICAgZm9yIChpID0gY2FudmFzU3RhcnQ7IGkgPCBjYW52YXNFbmQ7IGkrKykge1xuICAgICAgICBwZWFrID0gcGVha3NbMiAqIGldIHx8IDA7XG4gICAgICAgIGggPSBNYXRoLnJvdW5kKHBlYWsgLyBhYnNtYXhIYWxmKTtcbiAgICAgICAgY3R4LmxpbmVUbygoaSAtIGZpcnN0KSAqIHNjYWxlICsgdGhpcy5oYWxmUGl4ZWwsIGhhbGZPZmZzZXQgLSBoKTtcbiAgICAgIH0gLy8gZHJhdyB0aGUgYm90dG9tIGVkZ2UgZ29pbmcgYmFja3dhcmRzLCB0byBtYWtlIGEgc2luZ2xlXG4gICAgICAvLyBjbG9zZWQgaHVsbCB0byBmaWxsXG5cblxuICAgICAgdmFyIGogPSBjYW52YXNFbmQgLSAxO1xuXG4gICAgICBmb3IgKGo7IGogPj0gY2FudmFzU3RhcnQ7IGotLSkge1xuICAgICAgICBwZWFrID0gcGVha3NbMiAqIGogKyAxXSB8fCAwO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChwZWFrIC8gYWJzbWF4SGFsZik7XG4gICAgICAgIGN0eC5saW5lVG8oKGogLSBmaXJzdCkgKiBzY2FsZSArIHRoaXMuaGFsZlBpeGVsLCBoYWxmT2Zmc2V0IC0gaCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lVG8oKGNhbnZhc1N0YXJ0IC0gZmlyc3QpICogc2NhbGUsIGhhbGZPZmZzZXQgLSBNYXRoLnJvdW5kKChwZWFrc1syICogY2FudmFzU3RhcnQgKyAxXSB8fCAwKSAvIGFic21heEhhbGYpKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgZW50cnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMud2F2ZUN0eCA9IG51bGw7XG4gICAgICB0aGlzLndhdmUgPSBudWxsO1xuICAgICAgdGhpcy5wcm9ncmVzc0N0eCA9IG51bGw7XG4gICAgICB0aGlzLnByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGltYWdlIGRhdGEgb2YgdGhlIHdhdmUgYGNhbnZhc2AgZWxlbWVudFxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBhIGB0eXBlYCBvZiBgJ2Jsb2InYCwgdGhpcyB3aWxsIHJldHVybiBhIGBQcm9taXNlYCB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhIGBCbG9iYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQ9J2ltYWdlL3BuZycgQW4gb3B0aW9uYWwgdmFsdWUgb2YgYSBmb3JtYXQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eT0wLjkyIEFuIG9wdGlvbmFsIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZT0nZGF0YVVSTCcgRWl0aGVyICdkYXRhVVJMJyBvciAnYmxvYicuXG4gICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2V9IFdoZW4gdXNpbmcgdGhlIGRlZmF1bHQgYCdkYXRhVVJMJ2AgYHR5cGVgIHRoaXNcbiAgICAgKiByZXR1cm5zIGEgZGF0YSBVUkwuIFdoZW4gdXNpbmcgdGhlIGAnYmxvYidgIGB0eXBlYCB0aGlzIHJldHVybnMgYVxuICAgICAqIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggYSBgQmxvYmAgaW5zdGFuY2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgX3RoaXMud2F2ZS50b0Jsb2IocmVzb2x2ZSwgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkYXRhVVJMJykge1xuICAgICAgICByZXR1cm4gdGhpcy53YXZlLnRvRGF0YVVSTChmb3JtYXQsIHF1YWxpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXNFbnRyeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzRW50cnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZHJhd2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kcmF3ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgcmVuZGVyZXJzXG4gKlxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICovXG52YXIgRHJhd2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfdXRpbCRPYnNlcnZlcikge1xuICBfaW5oZXJpdHMoRHJhd2VyLCBfdXRpbCRPYnNlcnZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEcmF3ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBub2RlIG9mIHRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFRoZSB3YXZlc3VyZmVyIGluaXRpYWxpc2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIERyYXdlcihjb250YWluZXIsIHBhcmFtcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5jb250YWluZXIgPSB1dGlsLndpdGhPcmllbnRhdGlvbihjb250YWluZXIsIHBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1dhdmVzdXJmZXJQYXJhbXN9XG4gICAgICovXG5cbiAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSByZW5kZXJlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCAqIF90aGlzLnBhcmFtcy5waXhlbFJhdGlvO1xuICAgIF90aGlzLmxhc3RQb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBgPHdhdmU+YCBlbGVtZW50IHdoaWNoIGlzIGFkZGVkIHRvIHRoZSBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG5cbiAgICBfdGhpcy53cmFwcGVyID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIG9mIGB1dGlsLnN0eWxlYFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0aGF0IHRoZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgVGhlIG1hcCBvZiBwcm9wTmFtZTogYXR0cmlidXRlLCBib3RoIGFyZSB1c2VkIGFzLWlzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEcmF3ZXIsIFt7XG4gICAga2V5OiBcInN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0eWxlKGVsLCBzdHlsZXMpIHtcbiAgICAgIHJldHVybiB1dGlsLnN0eWxlKGVsLCBzdHlsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHdyYXBwZXIgYDx3YXZlPmAgZWxlbWVudCwgc3R5bGUgaXQgYW5kIHNldCB1cCB0aGUgZXZlbnRzIGZvclxuICAgICAqIGludGVyYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVXcmFwcGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoKSB7XG4gICAgICB0aGlzLndyYXBwZXIgPSB1dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd3YXZlJykpLCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMud3JhcHBlciwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICB3ZWJraXRVc2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIGhlaWdodDogdGhpcy5wYXJhbXMuaGVpZ2h0ICsgJ3B4J1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5maWxsUGFyZW50IHx8IHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCkge1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMud3JhcHBlciwge1xuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgb3ZlcmZsb3dYOiB0aGlzLnBhcmFtcy5oaWRlU2Nyb2xsYmFyID8gJ2hpZGRlbicgOiAnYXV0bycsXG4gICAgICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXR1cFdyYXBwZXJFdmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNsaWNrIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIENsaWNrIGV2ZW50XG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gbm9QcmV2ZW50IFNldCB0byB0cnVlIHRvIG5vdCBjYWxsIGBlLnByZXZlbnREZWZhdWx0KClgXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBQbGF5YmFjayBwb3NpdGlvbiBmcm9tIDAgdG8gMVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXZlbnQoZSwgbm9QcmV2ZW50KSB7XG4gICAgICAhbm9QcmV2ZW50ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBjbGllbnRYID0gdXRpbC53aXRoT3JpZW50YXRpb24oZS50YXJnZXRUb3VjaGVzID8gZS50YXJnZXRUb3VjaGVzWzBdIDogZSwgdGhpcy5wYXJhbXMudmVydGljYWwpLmNsaWVudFg7XG4gICAgICB2YXIgYmJveCA9IHRoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBub21pbmFsV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgdmFyIHByb2dyZXNzUGl4ZWxzID0gdGhpcy5nZXRQcm9ncmVzc1BpeGVscyhiYm94LCBjbGllbnRYKTtcbiAgICAgIHZhciBwcm9ncmVzcztcblxuICAgICAgaWYgKCF0aGlzLnBhcmFtcy5maWxsUGFyZW50ICYmIG5vbWluYWxXaWR0aCA8IHBhcmVudFdpZHRoKSB7XG4gICAgICAgIHByb2dyZXNzID0gcHJvZ3Jlc3NQaXhlbHMgKiAodGhpcy5wYXJhbXMucGl4ZWxSYXRpbyAvIG5vbWluYWxXaWR0aCkgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gKHByb2dyZXNzUGl4ZWxzICsgdGhpcy53cmFwcGVyLnNjcm9sbExlZnQpIC8gdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1dGlsLmNsYW1wKHByb2dyZXNzLCAwLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvZ3Jlc3NQaXhlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NQaXhlbHMod3JhcHBlckJib3gsIGNsaWVudFgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5ydGwpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXJCYm94LnJpZ2h0IC0gY2xpZW50WDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbGllbnRYIC0gd3JhcHBlckJib3gubGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBXcmFwcGVyRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwV3JhcHBlckV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgb3JpZW50ZWRFdmVudCA9IHV0aWwud2l0aE9yaWVudGF0aW9uKGUsIF90aGlzMi5wYXJhbXMudmVydGljYWwpO1xuICAgICAgICB2YXIgc2Nyb2xsYmFySGVpZ2h0ID0gX3RoaXMyLndyYXBwZXIub2Zmc2V0SGVpZ2h0IC0gX3RoaXMyLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGlmIChzY3JvbGxiYXJIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAvLyBzY3JvbGxiYXIgaXMgdmlzaWJsZS4gIENoZWNrIGlmIGNsaWNrIHdhcyBvbiBpdFxuICAgICAgICAgIHZhciBiYm94ID0gX3RoaXMyLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAob3JpZW50ZWRFdmVudC5jbGllbnRZID49IGJib3guYm90dG9tIC0gc2Nyb2xsYmFySGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgbW91c2Vkb3duIGFzIGl0IHdhcyBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzMi5wYXJhbXMuaW50ZXJhY3QpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdjbGljaycsIGUsIF90aGlzMi5oYW5kbGVFdmVudChlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzMi5wYXJhbXMuaW50ZXJhY3QpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdkYmxjbGljaycsIGUsIF90aGlzMi5oYW5kbGVFdmVudChlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZmlyZUV2ZW50KCdzY3JvbGwnLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IHBlYWtzIG9uIHRoZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzXG4gICAgICogZm9yIHNwbGl0IGNoYW5uZWwgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgd2lkdGggb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmUgZHJhd25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQZWFrcyhwZWFrcywgbGVuZ3RoLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0V2lkdGgobGVuZ3RoKSkge1xuICAgICAgICB0aGlzLmNsZWFyV2F2ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmFtcy5iYXJXaWR0aCA/IHRoaXMuZHJhd0JhcnMocGVha3MsIDAsIHN0YXJ0LCBlbmQpIDogdGhpcy5kcmF3V2F2ZShwZWFrcywgMCwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byB0aGUgYmVnaW5uaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFNjcm9sbCgpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnNjcm9sbExlZnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlbnRlciB0aGUgdmlldy1wb3J0IGF0IGEgY2VydGFpbiBwZXJjZW50IG9mIHRoZSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnQgVmFsdWUgZnJvbSAwIHRvIDEgb24gdGhlIHdhdmVmb3JtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWNlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlbnRlcihwZXJjZW50KSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggKiBwZXJjZW50O1xuICAgICAgdGhpcy5yZWNlbnRlck9uUG9zaXRpb24ocG9zaXRpb24sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlbnRlciB0aGUgdmlldy1wb3J0IG9uIGEgcG9zaXRpb24sIGVpdGhlciBzY3JvbGwgdGhlcmUgaW1tZWRpYXRlbHkgb3JcbiAgICAgKiBpbiBzdGVwcyBvZiA1IHBpeGVsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFgtb2Zmc2V0IGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW1tZWRpYXRlIFNldCB0byB0cnVlIHRvIGltbWVkaWF0ZWx5IHNjcm9sbCBzb21ld2hlcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlY2VudGVyT25Qb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlbnRlck9uUG9zaXRpb24ocG9zaXRpb24sIGltbWVkaWF0ZSkge1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdDtcbiAgICAgIHZhciBoYWxmID0gfn4odGhpcy53cmFwcGVyLmNsaWVudFdpZHRoIC8gMik7XG4gICAgICB2YXIgbWF4U2Nyb2xsID0gdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoIC0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgdmFyIHRhcmdldCA9IHBvc2l0aW9uIC0gaGFsZjtcbiAgICAgIHZhciBvZmZzZXQgPSB0YXJnZXQgLSBzY3JvbGxMZWZ0O1xuXG4gICAgICBpZiAobWF4U2Nyb2xsID09IDApIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjb250aW51ZSBpZiBzY3JvbGxiYXIgaXMgbm90IHRoZXJlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaWYgdGhlIGN1cnNvciBpcyBjdXJyZW50bHkgdmlzaWJsZS4uLlxuXG5cbiAgICAgIGlmICghaW1tZWRpYXRlICYmIC1oYWxmIDw9IG9mZnNldCAmJiBvZmZzZXQgPCBoYWxmKSB7XG4gICAgICAgIC8vIHNldCByYXRlIGF0IHdoaWNoIHdhdmVmb3JtIGlzIGNlbnRlcmVkXG4gICAgICAgIHZhciByYXRlID0gdGhpcy5wYXJhbXMuYXV0b0NlbnRlclJhdGU7IC8vIG1ha2UgcmF0ZSBkZXBlbmQgb24gd2lkdGggb2YgdmlldyBhbmQgbGVuZ3RoIG9mIHdhdmVmb3JtXG5cbiAgICAgICAgcmF0ZSAvPSBoYWxmO1xuICAgICAgICByYXRlICo9IG1heFNjcm9sbDtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoLXJhdGUsIE1hdGgubWluKHJhdGUsIG9mZnNldCkpO1xuICAgICAgICB0YXJnZXQgPSBzY3JvbGxMZWZ0ICsgb2Zmc2V0O1xuICAgICAgfSAvLyBsaW1pdCB0YXJnZXQgdG8gdmFsaWQgcmFuZ2UgKDAgdG8gbWF4U2Nyb2xsKVxuXG5cbiAgICAgIHRhcmdldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heFNjcm9sbCwgdGFyZ2V0KSk7IC8vIG5vIHVzZSBhdHRlbXB0aW5nIHRvIHNjcm9sbCBpZiB3ZSdyZSBub3QgbW92aW5nXG5cbiAgICAgIGlmICh0YXJnZXQgIT0gc2Nyb2xsTGVmdCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCA9IHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY3JvbGxYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjcm9sbFgoKSB7XG4gICAgICB2YXIgeCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXIpIHtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBhcmFtcy5waXhlbFJhdGlvO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCAqIHBpeGVsUmF0aW8pOyAvLyBJbiBjYXNlcyBvZiBlbGFzdGljIHNjcm9sbCAoc2FmYXJpIHdpdGggbW91c2Ugd2hlZWwpIHlvdSBjYW5cbiAgICAgICAgLy8gc2Nyb2xsIGJleW9uZCB0aGUgbGltaXRzIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBmbG9vciB0aGUgc2Nyb2xsYWJsZSBleHRlbnQgdG8gbWFrZSBzdXJlIGFuIG91dFxuICAgICAgICAvLyBvZiBib3VuZHMgdmFsdWUgaXMgbm90IHJldHVybmVkXG4gICAgICAgIC8vIFRpY2tldCAjMTMxMlxuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbWF4U2Nyb2xsID0gfn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoICogcGl4ZWxSYXRpbyAtIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgeCA9IE1hdGgubWluKG1heFNjcm9sbCwgTWF0aC5tYXgoMCwgeCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGggKiB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciB3YXMgdXBkYXRlZCBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICBpZiAodGhpcy53aWR0aCA9PSB3aWR0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbGxQYXJlbnQgfHwgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gfn4odGhpcy53aWR0aCAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pICsgJ3B4JztcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIsIHtcbiAgICAgICAgICB3aWR0aDogbmV3V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciB3YXMgdXBkYXRlZCBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICBpZiAoaGVpZ2h0ID09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMud3JhcHBlciwge1xuICAgICAgICBoZWlnaHQ6IH5+KHRoaXMuaGVpZ2h0IC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSB3YXZlc3VyZmVyIHdoZW4gcHJvZ3Jlc3Mgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvZ3Jlc3MgRnJvbSAwIHRvIDFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgICAgdmFyIG1pblB4RGVsdGEgPSAxIC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICAgIHZhciBwb3MgPSBNYXRoLnJvdW5kKF9wcm9ncmVzcyAqIHRoaXMud2lkdGgpICogbWluUHhEZWx0YTtcblxuICAgICAgaWYgKHBvcyA8IHRoaXMubGFzdFBvcyB8fCBwb3MgLSB0aGlzLmxhc3RQb3MgPj0gbWluUHhEZWx0YSkge1xuICAgICAgICB0aGlzLmxhc3RQb3MgPSBwb3M7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCAmJiB0aGlzLnBhcmFtcy5hdXRvQ2VudGVyKSB7XG4gICAgICAgICAgdmFyIG5ld1BvcyA9IH5+KHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAqIF9wcm9ncmVzcyk7XG4gICAgICAgICAgdGhpcy5yZWNlbnRlck9uUG9zaXRpb24obmV3UG9zLCB0aGlzLnBhcmFtcy5hdXRvQ2VudGVySW1tZWRpYXRlbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhwb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHdhdmVzdXJmZXIgaXMgZGVzdHJveWVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVuQWxsKCk7XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlci5wYXJlbnROb2RlID09IHRoaXMuY29udGFpbmVyLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIuZG9tRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndyYXBwZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZW5kZXJlci1zcGVjaWZpYyBtZXRob2RzICovXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgY3Vyc29yIHJlbGF0ZWQgcGFyYW1zIGhhdmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcigpIHt9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciBjaGFuZ2VzIHNvIHRoZSByZW5kZXJlciBjYW4gYWRqdXN0XG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHt9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHdhdmVmb3JtIHdpdGggYmFyc1xuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXMgZm9yIHNwbGl0IGNoYW5uZWxcbiAgICAgKiByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLiBOb3JtYWxseVxuICAgICAqIHNob3VsZCBiZSAwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCYXJzKHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQpIHt9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5cyBmb3Igc3BsaXQgY2hhbm5lbFxuICAgICAqIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuIE5vcm1hbGx5XG4gICAgICogc2hvdWxkIGJlIDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1dhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1dhdmUocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCkge31cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyV2F2ZSgpIHt9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBuZXcgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBYLU9mZnNldCBvZiBwcm9ncmVzcyBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKHBvc2l0aW9uKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIERyYXdlcjtcbn0odXRpbC5PYnNlcnZlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERyYXdlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kcmF3ZXIubXVsdGljYW52YXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RyYXdlci5tdWx0aWNhbnZhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9kcmF3ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHJhd2VyICovIFwiLi9zcmMvZHJhd2VyLmpzXCIpKTtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCIpKTtcblxudmFyIF9kcmF3ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RyYXdlci5jYW52YXNlbnRyeSAqLyBcIi4vc3JjL2RyYXdlci5jYW52YXNlbnRyeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIE11bHRpQ2FudmFzIHJlbmRlcmVyIGZvciB3YXZlc3VyZmVyLiBJcyBjdXJyZW50bHkgdGhlIGRlZmF1bHQgYW5kIHNvbGVcbiAqIGJ1aWx0aW4gcmVuZGVyZXIuXG4gKlxuICogQSBgTXVsdGlDYW52YXNgIGNvbnNpc3RzIG9mIG9uZSBvciBtb3JlIGBDYW52YXNFbnRyeWAgaW5zdGFuY2VzLCBkZXBlbmRpbmdcbiAqIG9uIHRoZSB6b29tIGxldmVsLlxuICovXG52YXIgTXVsdGlDYW52YXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EcmF3ZXIpIHtcbiAgX2luaGVyaXRzKE11bHRpQ2FudmFzLCBfRHJhd2VyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE11bHRpQ2FudmFzKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBjb250YWluZXIgbm9kZSBvZiB0aGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBUaGUgd2F2ZXN1cmZlciBpbml0aWFsaXNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBNdWx0aUNhbnZhcyhjb250YWluZXIsIHBhcmFtcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aUNhbnZhcyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lciwgcGFyYW1zKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMubWF4Q2FudmFzV2lkdGggPSBwYXJhbXMubWF4Q2FudmFzV2lkdGg7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aCA9IE1hdGgucm91bmQocGFyYW1zLm1heENhbnZhc1dpZHRoIC8gcGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9ncmVzcyB3YXZlIGlzIHJlbmRlcmVkLiBJZiB0aGUgYHdhdmVDb2xvcmBcbiAgICAgKiBhbmQgYHByb2dyZXNzQ29sb3JgIGFyZSB0aGUgc2FtZSBjb2xvciBpdCBpcyBub3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIF90aGlzLmhhc1Byb2dyZXNzQ2FudmFzID0gcGFyYW1zLndhdmVDb2xvciAhPSBwYXJhbXMucHJvZ3Jlc3NDb2xvcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMuaGFsZlBpeGVsID0gMC41IC8gcGFyYW1zLnBpeGVsUmF0aW87XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBgQ2FudmFzRW50cnlgIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cblxuICAgIF90aGlzLmNhbnZhc2VzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuXG4gICAgX3RoaXMucHJvZ3Jlc3NXYXZlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBDbGFzcyB1c2VkIHRvIGdlbmVyYXRlIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG5cbiAgICBfdGhpcy5FbnRyeUNsYXNzID0gX2RyYXdlcjIuZGVmYXVsdDtcbiAgICAvKipcbiAgICAgKiBDYW52YXMgMmQgY29udGV4dCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cblxuICAgIF90aGlzLmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzID0gcGFyYW1zLmRyYXdpbmdDb250ZXh0QXR0cmlidXRlcztcbiAgICAvKipcbiAgICAgKiBPdmVybGFwIGFkZGVkIGJldHdlZW4gZW50cmllcyB0byBwcmV2ZW50IHZlcnRpY2FsIHdoaXRlIHN0cmlwZXNcbiAgICAgKiBiZXR3ZWVuIGBjYW52YXNgIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLm92ZXJsYXAgPSAyICogTWF0aC5jZWlsKHBhcmFtcy5waXhlbFJhdGlvIC8gMik7XG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgd2F2ZSBiYXJzLiBNYWtlcyBiYXJzIHJvdW5kZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5iYXJSYWRpdXMgPSBwYXJhbXMuYmFyUmFkaXVzIHx8IDA7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byByZW5kZXIgdGhlIHdhdmVmb3JtIHZlcnRpY2FsbHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBfdGhpcy52ZXJ0aWNhbCA9IHBhcmFtcy52ZXJ0aWNhbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRyYXdlclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNdWx0aUNhbnZhcywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5jcmVhdGVXcmFwcGVyKCk7XG4gICAgICB0aGlzLmNyZWF0ZUVsZW1lbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgY2FudmFzIGVsZW1lbnRzIGFuZCBzdHlsZSB0aGVtXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdGhpcy5wcm9ncmVzc1dhdmUgPSB1dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnd2F2ZScpKSwgdGhpcy5wYXJhbXMudmVydGljYWwpO1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiAzLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB3aWR0aDogJzAnLFxuICAgICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBib3JkZXJSaWdodFN0eWxlOiAnc29saWQnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRDYW52YXMoKTtcbiAgICAgIHRoaXMudXBkYXRlQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjdXJzb3Igc3R5bGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDdXJzb3IoKSB7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLCB7XG4gICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRoaXMucGFyYW1zLmN1cnNvcldpZHRoICsgJ3B4JyxcbiAgICAgICAgYm9yZGVyUmlnaHRDb2xvcjogdGhpcy5wYXJhbXMuY3Vyc29yQ29sb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdG8gdGhlIHVwZGF0ZWQgc2l6ZSBieSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2FudmFzZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdG90YWxXaWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgdmFyIHJlcXVpcmVkQ2FudmFzZXMgPSBNYXRoLmNlaWwodG90YWxXaWR0aCAvICh0aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aCArIHRoaXMub3ZlcmxhcCkpOyAvLyBhZGQgcmVxdWlyZWQgY2FudmFzZXNcblxuICAgICAgd2hpbGUgKHRoaXMuY2FudmFzZXMubGVuZ3RoIDwgcmVxdWlyZWRDYW52YXNlcykge1xuICAgICAgICB0aGlzLmFkZENhbnZhcygpO1xuICAgICAgfSAvLyByZW1vdmUgb2xkZXIgZXhpc3RpbmcgY2FudmFzZXMsIGlmIGFueVxuXG5cbiAgICAgIHdoaWxlICh0aGlzLmNhbnZhc2VzLmxlbmd0aCA+IHJlcXVpcmVkQ2FudmFzZXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDYW52YXMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5tYXhDYW52YXNXaWR0aCArIHRoaXMub3ZlcmxhcDtcbiAgICAgIHZhciBsYXN0Q2FudmFzID0gdGhpcy5jYW52YXNlcy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICBpZiAoaSA9PSBsYXN0Q2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzV2lkdGggPSBfdGhpczIud2lkdGggLSBfdGhpczIubWF4Q2FudmFzV2lkdGggKiBsYXN0Q2FudmFzO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLnVwZGF0ZURpbWVuc2lvbnMoZW50cnksIGNhbnZhc1dpZHRoLCBfdGhpczIuaGVpZ2h0KTtcblxuICAgICAgICBlbnRyeS5jbGVhcldhdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYW52YXMgdG8gdGhlIGNhbnZhcyBsaXN0XG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDYW52YXMoKSB7XG4gICAgICB2YXIgZW50cnkgPSBuZXcgdGhpcy5FbnRyeUNsYXNzKCk7XG4gICAgICBlbnRyeS5jYW52YXNDb250ZXh0QXR0cmlidXRlcyA9IHRoaXMuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXM7XG4gICAgICBlbnRyeS5oYXNQcm9ncmVzc0NhbnZhcyA9IHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXM7XG4gICAgICBlbnRyeS5oYWxmUGl4ZWwgPSB0aGlzLmhhbGZQaXhlbDtcbiAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gdGhpcy5tYXhDYW52YXNFbGVtZW50V2lkdGggKiB0aGlzLmNhbnZhc2VzLmxlbmd0aDsgLy8gd2F2ZVxuXG4gICAgICB2YXIgd2F2ZSA9IHV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSksIHRoaXMucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgIHRoaXMuc3R5bGUod2F2ZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiAyLFxuICAgICAgICBsZWZ0OiBsZWZ0T2Zmc2V0ICsgJ3B4JyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgZW50cnkuaW5pdFdhdmUod2F2ZSk7IC8vIHByb2dyZXNzXG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMucHJvZ3Jlc3NXYXZlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSwgdGhpcy5wYXJhbXMudmVydGljYWwpO1xuICAgICAgICB0aGlzLnN0eWxlKHByb2dyZXNzLCB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgbGVmdDogbGVmdE9mZnNldCArICdweCcsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICB9KTtcbiAgICAgICAgZW50cnkuaW5pdFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXNlcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wIHNpbmdsZSBjYW52YXMgZnJvbSB0aGUgbGlzdFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2FudmFzKCkge1xuICAgICAgdmFyIGxhc3RFbnRyeSA9IHRoaXMuY2FudmFzZXNbdGhpcy5jYW52YXNlcy5sZW5ndGggLSAxXTsgLy8gd2F2ZVxuXG4gICAgICBsYXN0RW50cnkud2F2ZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGxhc3RFbnRyeS53YXZlLmRvbUVsZW1lbnQpOyAvLyBwcm9ncmVzc1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICBsYXN0RW50cnkucHJvZ3Jlc3MucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChsYXN0RW50cnkucHJvZ3Jlc3MuZG9tRWxlbWVudCk7XG4gICAgICB9IC8vIGNsZWFudXBcblxuXG4gICAgICBpZiAobGFzdEVudHJ5KSB7XG4gICAgICAgIGxhc3RFbnRyeS5kZXN0cm95KCk7XG4gICAgICAgIGxhc3RFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FudmFzZXMucG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGltZW5zaW9ucyBvZiBhIGNhbnZhcyBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VudHJ5fSBlbnRyeSBUYXJnZXQgZW50cnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aCBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9ucyhlbnRyeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IE1hdGgucm91bmQod2lkdGggLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoIC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7IC8vIHVwZGF0ZSBjYW52YXMgZGltZW5zaW9uc1xuXG4gICAgICBlbnRyeS51cGRhdGVEaW1lbnNpb25zKGVsZW1lbnRXaWR0aCwgdG90YWxXaWR0aCwgd2lkdGgsIGhlaWdodCk7IC8vIHN0eWxlIGVsZW1lbnRcblxuICAgICAgdGhpcy5zdHlsZSh0aGlzLnByb2dyZXNzV2F2ZSwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHdob2xlIG11bHRpLWNhbnZhc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyV2F2ZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB1dGlsLmZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5LmNsZWFyV2F2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSB3YXZlZm9ybSB3aXRoIGJhcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzXG4gICAgICogZm9yIHNwbGl0IGNoYW5uZWwgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC4gTm9ybWFsbHlcbiAgICAgKiBzaG91bGQgYmUgMC4gTXVzdCBiZSBhbiBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFycyhwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZURyYXcocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGFic21heCA9IF9yZWYuYWJzbWF4LFxuICAgICAgICAgICAgaGFzTWluVmFscyA9IF9yZWYuaGFzTWluVmFscyxcbiAgICAgICAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0WSA9IF9yZWYub2Zmc2V0WSxcbiAgICAgICAgICAgIGhhbGZIID0gX3JlZi5oYWxmSCxcbiAgICAgICAgICAgIHBlYWtzID0gX3JlZi5wZWFrcyxcbiAgICAgICAgICAgIGNoID0gX3JlZi5jaGFubmVsSW5kZXg7XG5cbiAgICAgICAgLy8gaWYgZHJhd0JhcnMgd2FzIGNhbGxlZCB3aXRoaW4gd3MuZW1wdHkgd2UgZG9uJ3QgcGFzcyBhIHN0YXJ0IGFuZFxuICAgICAgICAvLyBkb24ndCB3YW50IGFueXRoaW5nIHRvIGhhcHBlblxuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTa2lwIGV2ZXJ5IG90aGVyIHZhbHVlIGlmIHRoZXJlIGFyZSBuZWdhdGl2ZXMuXG5cblxuICAgICAgICB2YXIgcGVha0luZGV4U2NhbGUgPSBoYXNNaW5WYWxzID8gMiA6IDE7XG4gICAgICAgIHZhciBsZW5ndGggPSBwZWFrcy5sZW5ndGggLyBwZWFrSW5kZXhTY2FsZTtcbiAgICAgICAgdmFyIGJhciA9IF90aGlzNC5wYXJhbXMuYmFyV2lkdGggKiBfdGhpczQucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgICAgIHZhciBnYXAgPSBfdGhpczQucGFyYW1zLmJhckdhcCA9PT0gbnVsbCA/IE1hdGgubWF4KF90aGlzNC5wYXJhbXMucGl4ZWxSYXRpbywgfn4oYmFyIC8gMikpIDogTWF0aC5tYXgoX3RoaXM0LnBhcmFtcy5waXhlbFJhdGlvLCBfdGhpczQucGFyYW1zLmJhckdhcCAqIF90aGlzNC5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBzdGVwID0gYmFyICsgZ2FwO1xuICAgICAgICB2YXIgc2NhbGUgPSBsZW5ndGggLyBfdGhpczQud2lkdGg7XG4gICAgICAgIHZhciBmaXJzdCA9IHN0YXJ0O1xuICAgICAgICB2YXIgbGFzdCA9IGVuZDtcbiAgICAgICAgdmFyIGkgPSBmaXJzdDtcblxuICAgICAgICBmb3IgKGk7IGkgPCBsYXN0OyBpICs9IHN0ZXApIHtcbiAgICAgICAgICB2YXIgcGVhayA9IHBlYWtzW01hdGguZmxvb3IoaSAqIHNjYWxlICogcGVha0luZGV4U2NhbGUpXSB8fCAwO1xuICAgICAgICAgIHZhciBoID0gTWF0aC5yb3VuZChwZWFrIC8gYWJzbWF4ICogaGFsZkgpO1xuICAgICAgICAgIC8qIGluIGNhc2Ugb2Ygc2lsZW5jZXMsIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhhdCB3ZVxuICAgICAgICAgICAqIGFsd2F5cyBkcmF3ICpzb21ldGhpbmcqIChub3JtYWxseSBhIDFweCBoaWdoIGJhcikgKi9cblxuICAgICAgICAgIGlmIChoID09IDAgJiYgX3RoaXM0LnBhcmFtcy5iYXJNaW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGggPSBfdGhpczQucGFyYW1zLmJhck1pbkhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczQuZmlsbFJlY3QoaSArIF90aGlzNC5oYWxmUGl4ZWwsIGhhbGZIIC0gaCArIG9mZnNldFksIGJhciArIF90aGlzNC5oYWxmUGl4ZWwsIGggKiAyLCBfdGhpczQuYmFyUmFkaXVzLCBjaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzXG4gICAgICogZm9yIHNwbGl0IGNoYW5uZWwgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC4gTm9ybWFsbHlcbiAgICAgKiBzaG91bGQgYmUgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZCAoSWYgdGhpcyBpc24ndCBzZXQgb25seSBhIGZsYXQgbGluZSBpcyByZW5kZXJlZClcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3V2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3V2F2ZShwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZURyYXcocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBhYnNtYXggPSBfcmVmMi5hYnNtYXgsXG4gICAgICAgICAgICBoYXNNaW5WYWxzID0gX3JlZjIuaGFzTWluVmFscyxcbiAgICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldFkgPSBfcmVmMi5vZmZzZXRZLFxuICAgICAgICAgICAgaGFsZkggPSBfcmVmMi5oYWxmSCxcbiAgICAgICAgICAgIHBlYWtzID0gX3JlZjIucGVha3MsXG4gICAgICAgICAgICBjaGFubmVsSW5kZXggPSBfcmVmMi5jaGFubmVsSW5kZXg7XG5cbiAgICAgICAgaWYgKCFoYXNNaW5WYWxzKSB7XG4gICAgICAgICAgdmFyIHJlZmxlY3RlZFBlYWtzID0gW107XG4gICAgICAgICAgdmFyIGxlbiA9IHBlYWtzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVmbGVjdGVkUGVha3NbMiAqIGldID0gcGVha3NbaV07XG4gICAgICAgICAgICByZWZsZWN0ZWRQZWFrc1syICogaSArIDFdID0gLXBlYWtzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlYWtzID0gcmVmbGVjdGVkUGVha3M7XG4gICAgICAgIH0gLy8gaWYgZHJhd1dhdmUgd2FzIGNhbGxlZCB3aXRoaW4gd3MuZW1wdHkgd2UgZG9uJ3QgcGFzcyBhIHN0YXJ0IGFuZFxuICAgICAgICAvLyBlbmQgYW5kIHNpbXBseSB3YW50IGEgZmxhdCBsaW5lXG5cblxuICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzNS5kcmF3TGluZShwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCwgY2hhbm5lbEluZGV4KTtcbiAgICAgICAgfSAvLyBhbHdheXMgZHJhdyBhIG1lZGlhbiBsaW5lXG5cblxuICAgICAgICBfdGhpczUuZmlsbFJlY3QoMCwgaGFsZkggKyBvZmZzZXRZIC0gX3RoaXM1LmhhbGZQaXhlbCwgX3RoaXM1LndpZHRoLCBfdGhpczUuaGFsZlBpeGVsLCBfdGhpczUuYmFyUmFkaXVzLCBjaGFubmVsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIGNhbnZhcyBlbnRyaWVzIHRvIHJlbmRlciB0aGVpciBwb3J0aW9uIG9mIHRoZSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGVha3MgUGVha3MgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhYnNtYXggTWF4aW11bSBwZWFrIHZhbHVlIChhYnNvbHV0ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFsZkggSGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIE9mZnNldCB0byB0aGUgdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge2NoYW5uZWxJbmRleH0gY2hhbm5lbEluZGV4IFRoZSBjaGFubmVsIGluZGV4IG9mIHRoZSBsaW5lIGRyYXduXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZShwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCwgY2hhbm5lbEluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYzID0gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMuY2hhbm5lbENvbG9yc1tjaGFubmVsSW5kZXhdIHx8IHt9LFxuICAgICAgICAgIHdhdmVDb2xvciA9IF9yZWYzLndhdmVDb2xvcixcbiAgICAgICAgICBwcm9ncmVzc0NvbG9yID0gX3JlZjMucHJvZ3Jlc3NDb2xvcjtcblxuICAgICAgdGhpcy5jYW52YXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICBfdGhpczYuc2V0RmlsbFN0eWxlcyhlbnRyeSwgd2F2ZUNvbG9yLCBwcm9ncmVzc0NvbG9yKTtcblxuICAgICAgICBfdGhpczYuYXBwbHlDYW52YXNUcmFuc2Zvcm1zKGVudHJ5LCBfdGhpczYucGFyYW1zLnZlcnRpY2FsKTtcblxuICAgICAgICBlbnRyeS5kcmF3TGluZXMocGVha3MsIGFic21heCwgaGFsZkgsIG9mZnNldFksIHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSByZWN0YW5nbGUgb24gdGhlIG11bHRpLWNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWC1wb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS1wb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7Y2hhbm5lbEluZGV4fSBjaGFubmVsSW5kZXggVGhlIGNoYW5uZWwgaW5kZXggb2YgdGhlIGJhciBkcmF3blxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbFJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBjaGFubmVsSW5kZXgpIHtcbiAgICAgIHZhciBzdGFydENhbnZhcyA9IE1hdGguZmxvb3IoeCAvIHRoaXMubWF4Q2FudmFzV2lkdGgpO1xuICAgICAgdmFyIGVuZENhbnZhcyA9IE1hdGgubWluKE1hdGguY2VpbCgoeCArIHdpZHRoKSAvIHRoaXMubWF4Q2FudmFzV2lkdGgpICsgMSwgdGhpcy5jYW52YXNlcy5sZW5ndGgpO1xuICAgICAgdmFyIGkgPSBzdGFydENhbnZhcztcblxuICAgICAgZm9yIChpOyBpIDwgZW5kQ2FudmFzOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5jYW52YXNlc1tpXTtcbiAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSBpICogdGhpcy5tYXhDYW52YXNXaWR0aDtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHtcbiAgICAgICAgICB4MTogTWF0aC5tYXgoeCwgaSAqIHRoaXMubWF4Q2FudmFzV2lkdGgpLFxuICAgICAgICAgIHkxOiB5LFxuICAgICAgICAgIHgyOiBNYXRoLm1pbih4ICsgd2lkdGgsIGkgKiB0aGlzLm1heENhbnZhc1dpZHRoICsgZW50cnkud2F2ZS53aWR0aCksXG4gICAgICAgICAgeTI6IHkgKyBoZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLngxIDwgaW50ZXJzZWN0aW9uLngyKSB7XG4gICAgICAgICAgdmFyIF9yZWY0ID0gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMuY2hhbm5lbENvbG9yc1tjaGFubmVsSW5kZXhdIHx8IHt9LFxuICAgICAgICAgICAgICB3YXZlQ29sb3IgPSBfcmVmNC53YXZlQ29sb3IsXG4gICAgICAgICAgICAgIHByb2dyZXNzQ29sb3IgPSBfcmVmNC5wcm9ncmVzc0NvbG9yO1xuXG4gICAgICAgICAgdGhpcy5zZXRGaWxsU3R5bGVzKGVudHJ5LCB3YXZlQ29sb3IsIHByb2dyZXNzQ29sb3IpO1xuICAgICAgICAgIHRoaXMuYXBwbHlDYW52YXNUcmFuc2Zvcm1zKGVudHJ5LCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICAgICAgZW50cnkuZmlsbFJlY3RzKGludGVyc2VjdGlvbi54MSAtIGxlZnRPZmZzZXQsIGludGVyc2VjdGlvbi55MSwgaW50ZXJzZWN0aW9uLngyIC0gaW50ZXJzZWN0aW9uLngxLCBpbnRlcnNlY3Rpb24ueTIgLSBpbnRlcnNlY3Rpb24ueTEsIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRvIGhpZGUgdGhlIGNoYW5uZWwgZnJvbSBiZWluZyBkcmF3biBiYXNlZCBvbiBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zIHtib29sfSBUcnVlIHRvIGhpZGUgdGhlIGNoYW5uZWwsIGZhbHNlIHRvIGRyYXcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoaWRlQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQ2hhbm5lbChjaGFubmVsSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzICYmIHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLmZpbHRlckNoYW5uZWxzLmluY2x1ZGVzKGNoYW5uZWxJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHByZXBhcmF0aW9uIHRhc2tzIGFuZCBjYWxjdWxhdGlvbnMgd2hpY2ggYXJlIHNoYXJlZCBieSBgZHJhd0JhcnNgXG4gICAgICogYW5kIGBkcmF3V2F2ZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzIGZvclxuICAgICAqIHNwbGl0IGNoYW5uZWwgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC4gTm9ybWFsbHlcbiAgICAgKiBzaG91bGQgYmUgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZC4gSWYgdGhpcyBpc24ndCBzZXQgb25seSBhIGZsYXQgbGluZSBpcyByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHRvIGNhbGwsIGUuZy4gYGRyYXdXYXZlYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkcmF3SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwgYWZ0ZXIgZmlsdGVyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gbm9ybWFsaXplZE1heCBNYXhpbXVtIG1vZHVsYXRpb24gdmFsdWUgYWNyb3NzIGNoYW5uZWxzIGZvciB1c2Ugd2l0aCByZWxhdGl2ZU5vcm1hbGl6YXRpb24uIElnbm9yZWQgd2hlbiB1bmRlZmluZWRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVEcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVEcmF3KHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQsIGZuLCBkcmF3SW5kZXgsIG5vcm1hbGl6ZWRNYXgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdXRpbC5mcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNwbGl0IGNoYW5uZWxzIGFuZCBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgY2hhbm5lbEluZGV4IHNldFxuICAgICAgICBpZiAocGVha3NbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHZhciBjaGFubmVscyA9IHBlYWtzO1xuXG4gICAgICAgICAgaWYgKF90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVscykge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkQ2hhbm5lbHMgPSBjaGFubmVscy5maWx0ZXIoZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFfdGhpczcuaGlkZUNoYW5uZWwoaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgX3RoaXM3LnNldEhlaWdodChNYXRoLm1heChmaWx0ZXJlZENoYW5uZWxzLmxlbmd0aCwgMSkgKiBfdGhpczcucGFyYW1zLmhlaWdodCAqIF90aGlzNy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdmVyYWxsQWJzTWF4O1xuXG4gICAgICAgICAgICBpZiAoX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucyAmJiBfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLnJlbGF0aXZlTm9ybWFsaXphdGlvbikge1xuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgbWF4aW11bSBwZWFrIGFjcm9zcyBjaGFubmVscyB0byB1c2UgZm9yIG5vcm1hbGl6YXRpb25cbiAgICAgICAgICAgICAgb3ZlcmFsbEFic01heCA9IHV0aWwubWF4KGNoYW5uZWxzLm1hcChmdW5jdGlvbiAoY2hhbm5lbFBlYWtzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuYWJzTWF4KGNoYW5uZWxQZWFrcyk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWxQZWFrcywgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM3LnByZXBhcmVEcmF3KGNoYW5uZWxQZWFrcywgaSwgc3RhcnQsIGVuZCwgZm4sIGZpbHRlcmVkQ2hhbm5lbHMuaW5kZXhPZihjaGFubmVsUGVha3MpLCBvdmVyYWxsQWJzTWF4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlYWtzID0gY2hhbm5lbHNbMF07XG4gICAgICAgIH0gLy8gUmV0dXJuIGFuZCBkbyBub3QgZHJhdyBjaGFubmVsIHBlYWtzIGlmIGhpZGRlbi5cblxuXG4gICAgICAgIGlmIChfdGhpczcuaGlkZUNoYW5uZWwoY2hhbm5lbEluZGV4KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBjYWxjdWxhdGUgbWF4aW11bSBtb2R1bGF0aW9uIHZhbHVlLCBlaXRoZXIgZnJvbSB0aGUgYmFySGVpZ2h0XG4gICAgICAgIC8vIHBhcmFtZXRlciBvciBpZiBub3JtYWxpemU9dHJ1ZSBmcm9tIHRoZSBsYXJnZXN0IHZhbHVlIGluIHRoZSBwZWFrXG4gICAgICAgIC8vIHNldFxuXG5cbiAgICAgICAgdmFyIGFic21heCA9IDEgLyBfdGhpczcucGFyYW1zLmJhckhlaWdodDtcblxuICAgICAgICBpZiAoX3RoaXM3LnBhcmFtcy5ub3JtYWxpemUpIHtcbiAgICAgICAgICBhYnNtYXggPSBub3JtYWxpemVkTWF4ID09PSB1bmRlZmluZWQgPyB1dGlsLmFic01heChwZWFrcykgOiBub3JtYWxpemVkTWF4O1xuICAgICAgICB9IC8vIEJhciB3YXZlIGRyYXdzIHRoZSBib3R0b20gb25seSBhcyBhIHJlZmxlY3Rpb24gb2YgdGhlIHRvcCxcbiAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCBuZWdhdGl2ZSB2YWx1ZXNcblxuXG4gICAgICAgIHZhciBoYXNNaW5WYWxzID0gW10uc29tZS5jYWxsKHBlYWtzLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbCA8IDA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXM3LnBhcmFtcy5oZWlnaHQgKiBfdGhpczcucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBvZmZzZXRZID0gaGVpZ2h0ICogZHJhd0luZGV4IHx8IDA7IC8vIE92ZXJyaWRlIG9mZnNldFkgaWYgb3ZlcmxheSBpcyB0cnVlXG5cbiAgICAgICAgaWYgKF90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMgJiYgX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgb2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm4oe1xuICAgICAgICAgIGFic21heDogYWJzbWF4LFxuICAgICAgICAgIGhhc01pblZhbHM6IGhhc01pblZhbHMsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgICAgICBoYWxmSDogaGFsZkgsXG4gICAgICAgICAgcGVha3M6IHBlYWtzLFxuICAgICAgICAgIGNoYW5uZWxJbmRleDogY2hhbm5lbEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxsIHN0eWxlcyBmb3IgYSBjZXJ0YWluIGVudHJ5ICh3YXZlIGFuZCBwcm9ncmVzcylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRW50cnl9IGVudHJ5IFRhcmdldCBlbnRyeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YXZlQ29sb3IgV2F2ZSBjb2xvciB0byBkcmF3IHRoaXMgZW50cnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3Jlc3NDb2xvciBQcm9ncmVzcyBjb2xvciB0byBkcmF3IHRoaXMgZW50cnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbGxTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsbFN0eWxlcyhlbnRyeSkge1xuICAgICAgdmFyIHdhdmVDb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5wYXJhbXMud2F2ZUNvbG9yO1xuICAgICAgdmFyIHByb2dyZXNzQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMucGFyYW1zLnByb2dyZXNzQ29sb3I7XG4gICAgICBlbnRyeS5zZXRGaWxsU3R5bGVzKHdhdmVDb2xvciwgcHJvZ3Jlc3NDb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FudmFzIHRyYW5zZm9ybXMgZm9yIGEgY2VydGFpbiBlbnRyeSAod2F2ZSBhbmQgcHJvZ3Jlc3MpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VudHJ5fSBlbnRyeSBUYXJnZXQgZW50cnlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcnRpY2FsIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSB3YXZlZm9ybSB2ZXJ0aWNhbGx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUNhbnZhc1RyYW5zZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlDYW52YXNUcmFuc2Zvcm1zKGVudHJ5KSB7XG4gICAgICB2YXIgdmVydGljYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgZW50cnkuYXBwbHlDYW52YXNUcmFuc2Zvcm1zKHZlcnRpY2FsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGltYWdlIGRhdGEgb2YgdGhlIG11bHRpLWNhbnZhc1xuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBhIGB0eXBlYCBvZiBgJ2Jsb2InYCwgdGhpcyB3aWxsIHJldHVybiBhIGBQcm9taXNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQ9J2ltYWdlL3BuZycgQW4gb3B0aW9uYWwgdmFsdWUgb2YgYSBmb3JtYXQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eT0wLjkyIEFuIG9wdGlvbmFsIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZT0nZGF0YVVSTCcgRWl0aGVyICdkYXRhVVJMJyBvciAnYmxvYicuXG4gICAgICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfFByb21pc2V9IFdoZW4gdXNpbmcgdGhlIGRlZmF1bHQgYCdkYXRhVVJMJ2BcbiAgICAgKiBgdHlwZWAgdGhpcyByZXR1cm5zIGEgc2luZ2xlIGRhdGEgVVJMIG9yIGFuIGFycmF5IG9mIGRhdGEgVVJMcyxcbiAgICAgKiBvbmUgZm9yIGVhY2ggY2FudmFzLiBXaGVuIHVzaW5nIHRoZSBgJ2Jsb2InYCBgdHlwZWAgdGhpcyByZXR1cm5zIGFcbiAgICAgKiBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGBCbG9iYCBpbnN0YW5jZXMsIG9uZSBmb3IgZWFjaFxuICAgICAqIGNhbnZhcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5jYW52YXNlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5LmdldEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RhdGFVUkwnKSB7XG4gICAgICAgIHZhciBpbWFnZXMgPSB0aGlzLmNhbnZhc2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cnkuZ2V0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbWFnZXMubGVuZ3RoID4gMSA/IGltYWdlcyA6IGltYWdlc1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBuZXcgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBYLW9mZnNldCBvZiBwcm9ncmVzcyBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLCB7XG4gICAgICAgIHdpZHRoOiBwb3NpdGlvbiArICdweCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNdWx0aUNhbnZhcztcbn0oX2RyYXdlci5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlDYW52YXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWVkaWFlbGVtZW50LXdlYmF1ZGlvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9tZWRpYWVsZW1lbnQtd2ViYXVkaW8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfbWVkaWFlbGVtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lZGlhZWxlbWVudCAqLyBcIi4vc3JjL21lZGlhZWxlbWVudC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBNZWRpYUVsZW1lbnRXZWJBdWRpbyBiYWNrZW5kOiBsb2FkIGF1ZGlvIHZpYSBhbiBIVE1MNSBhdWRpbyB0YWcsIGJ1dCBwbGF5YmFjayB3aXRoIHRoZSBXZWJBdWRpbyBBUEkuXG4gKiBUaGUgYWR2YW50YWdlIGhlcmUgaXMgdGhhdCB0aGUgaHRtbDUgPGF1ZGlvPiB0YWcgY2FuIHBlcmZvcm0gcmFuZ2UgcmVxdWVzdHMgb24gdGhlIHNlcnZlciBhbmQgbm90XG4gKiBidWZmZXIgdGhlIGVudGlyZSBmaWxlIGluIG9uZSByZXF1ZXN0LCBhbmQgeW91IHN0aWxsIGdldCB0aGUgZmlsdGVyaW5nIGFuZCBzY3JpcHRpbmcgZnVuY3Rpb25hbGl0eVxuICogb2YgdGhlIHdlYmF1ZGlvIEFQSS5cbiAqIE5vdGUgdGhhdCBpbiBvcmRlciB0byB1c2UgcmFuZ2UgcmVxdWVzdHMgYW5kIHByZXZlbnQgYnVmZmVyaW5nLCB5b3UgbXVzdCBwcm92aWRlIHBlYWsgZGF0YS5cbiAqXG4gKiBAc2luY2UgMy4yLjBcbiAqL1xudmFyIE1lZGlhRWxlbWVudFdlYkF1ZGlvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWVkaWFFbGVtZW50KSB7XG4gIF9pbmhlcml0cyhNZWRpYUVsZW1lbnRXZWJBdWRpbywgX01lZGlhRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNZWRpYUVsZW1lbnRXZWJBdWRpbyk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgYmFja2VuZFxuICAgKlxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBXYXZlc3VyZmVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIE1lZGlhRWxlbWVudFdlYkF1ZGlvKHBhcmFtcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUVsZW1lbnRXZWJBdWRpbyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zb3VyY2VNZWRpYUVsZW1lbnQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgYmFja2VuZCwgY2FsbGVkIGluIGB3YXZlc3VyZmVyLmNyZWF0ZUJhY2tlbmQoKWBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWVkaWFFbGVtZW50V2ViQXVkaW8sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGFyYW1zLmF1ZGlvUmF0ZSk7XG4gICAgICB0aGlzLmNyZWF0ZVRpbWVyKCk7XG4gICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlU2NyaXB0Tm9kZSgpO1xuICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgY2FsbGVkIGJ5IGJvdGggYGxvYWRgIChmcm9tIHVybClcbiAgICAgKiBhbmQgYGxvYWRFbHRgIChleGlzdGluZyBtZWRpYSBlbGVtZW50KSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYSBIVE1MNSBBdWRpbyBvciBWaWRlbyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBBcnJheSBvZiBwZWFrIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZCBIVE1MIDUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWQobWVkaWEsIHBlYWtzLCBwcmVsb2FkKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZWRpYUVsZW1lbnRXZWJBdWRpby5wcm90b3R5cGUpLCBcIl9sb2FkXCIsIHRoaXMpLmNhbGwodGhpcywgbWVkaWEsIHBlYWtzLCBwcmVsb2FkKTtcblxuICAgICAgdGhpcy5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTWVkaWFFbGVtZW50U291cmNlIG5vZGVcbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50IEhUTUw1IEF1ZGlvIHRvIGxvYWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZU1lZGlhRWxlbWVudCA9IHRoaXMuYWMuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKG1lZGlhRWxlbWVudCk7XG4gICAgICB0aGlzLnNvdXJjZU1lZGlhRWxlbWVudC5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5yZXN1bWVBdWRpb0NvbnRleHQoKTtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZWRpYUVsZW1lbnRXZWJBdWRpby5wcm90b3R5cGUpLCBcInBsYXlcIiwgdGhpcykuY2FsbCh0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB3YXZlc3VyZmVyIGlzIGRlc3Ryb3llZFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZWRpYUVsZW1lbnRXZWJBdWRpby5wcm90b3R5cGUpLCBcImRlc3Ryb3lcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5kZXN0cm95V2ViQXVkaW8oKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVkaWFFbGVtZW50V2ViQXVkaW87XG59KF9tZWRpYWVsZW1lbnQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1lZGlhRWxlbWVudFdlYkF1ZGlvO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21lZGlhZWxlbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWVkaWFlbGVtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3dlYmF1ZGlvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYmF1ZGlvICovIFwiLi9zcmMvd2ViYXVkaW8uanNcIikpO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBNZWRpYUVsZW1lbnQgYmFja2VuZFxuICovXG52YXIgTWVkaWFFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2ViQXVkaW8pIHtcbiAgX2luaGVyaXRzKE1lZGlhRWxlbWVudCwgX1dlYkF1ZGlvKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE1lZGlhRWxlbWVudCk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgYmFja2VuZFxuICAgKlxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBXYXZlc3VyZmVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIE1lZGlhRWxlbWVudChwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAvKipcbiAgICAgKiBJbml0aWFsbHkgYSBkdW1teSBtZWRpYSBlbGVtZW50IHRvIGNhdGNoIGVycm9ycy4gT25jZSBgX2xvYWRgIGlzXG4gICAgICogY2FsbGVkLCB0aGlzIHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgX3RoaXMubWVkaWEgPSB7XG4gICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgcGF1c2VkOiB0cnVlLFxuICAgICAgcGxheWJhY2tSYXRlOiAxLFxuICAgICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHt9LFxuICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge30sXG4gICAgICB2b2x1bWU6IDBcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMubWVkaWFUeXBlID0gcGFyYW1zLm1lZGlhVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuZWxlbWVudFBvc2l0aW9uID0gcGFyYW1zLmVsZW1lbnRQb3NpdGlvbjtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBlYWtzID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy52b2x1bWUgPSAxO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLm9uUGxheUVuZCA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5tZWRpYUxpc3RlbmVycyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgYmFja2VuZCwgY2FsbGVkIGluIGB3YXZlc3VyZmVyLmNyZWF0ZUJhY2tlbmQoKWBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWVkaWFFbGVtZW50LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBhcmFtcy5hdWRpb1JhdGUpO1xuICAgICAgdGhpcy5jcmVhdGVUaW1lcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIG1lZGlhIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBNZWRpYUxpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBNZWRpYUxpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdlcnJvcicsICdFcnJvciBsb2FkaW5nIG1lZGlhIGVsZW1lbnQnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMuY2FucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnY2FucGxheScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5lbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnZmluaXNoJyk7XG4gICAgICB9OyAvLyBsaXN0ZW4gdG8gYW5kIHJlbGF5IHBsYXksIHBhdXNlIGFuZCBzZWVrZWQgZXZlbnRzIHRvIGVuYWJsZVxuICAgICAgLy8gcGxheWJhY2sgY29udHJvbCBmcm9tIHRoZSBleHRlcm5hbCBtZWRpYSBlbGVtZW50XG5cblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdwbGF5Jyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdwYXVzZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5zZWVrZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnc2VlaycpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy52b2x1bWVjaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLmlzTXV0ZWQgPSBfdGhpczIubWVkaWEubXV0ZWQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5pc011dGVkKSB7XG4gICAgICAgICAgX3RoaXMyLnZvbHVtZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLnZvbHVtZSA9IF90aGlzMi5tZWRpYS52b2x1bWU7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCd2b2x1bWUnKTtcbiAgICAgIH07IC8vIHJlc2V0IGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubWVkaWFMaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIF90aGlzMi5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKGlkLCBfdGhpczIubWVkaWFMaXN0ZW5lcnNbaWRdKTtcblxuICAgICAgICBfdGhpczIubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihpZCwgX3RoaXMyLm1lZGlhTGlzdGVuZXJzW2lkXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGltZXIgdG8gcHJvdmlkZSBhIG1vcmUgcHJlY2lzZSBgYXVkaW9wcm9jZXNzYCBldmVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRpbWVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvbkF1ZGlvUHJvY2VzcyA9IGZ1bmN0aW9uIG9uQXVkaW9Qcm9jZXNzKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdhdWRpb3Byb2Nlc3MnLCBfdGhpczMuZ2V0Q3VycmVudFRpbWUoKSk7IC8vIENhbGwgYWdhaW4gaW4gdGhlIG5leHQgZnJhbWVcblxuXG4gICAgICAgIHV0aWwuZnJhbWUob25BdWRpb1Byb2Nlc3MpKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCdwbGF5Jywgb25BdWRpb1Byb2Nlc3MpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9uZSBtb3JlIHRpbWUgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHN0dWNrIGluXG4gICAgICAvLyBjYXNlIG9mIGxvd2VyIGZyYW1lcmF0ZXNcblxuICAgICAgdGhpcy5vbigncGF1c2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ2F1ZGlvcHJvY2VzcycsIF90aGlzMy5nZXRDdXJyZW50VGltZSgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbWVkaWEgZWxlbWVudCB3aXRoIHVybCBhcyBpdHMgc291cmNlLFxuICAgICAqIGFuZCBhcHBlbmQgdG8gY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFBhdGggdG8gbWVkaWEgZmlsZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBIVE1MIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIEFycmF5IG9mIHBlYWsgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVsb2FkIEhUTUwgNSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYHVybGAgYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgbWVkaWFcbiAgICAgKiBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgY29udGFpbmVyLCBwZWFrcywgcHJlbG9hZCkge1xuICAgICAgdmFyIG1lZGlhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1lZGlhVHlwZSk7XG4gICAgICBtZWRpYS5jb250cm9scyA9IHRoaXMucGFyYW1zLm1lZGlhQ29udHJvbHM7XG4gICAgICBtZWRpYS5hdXRvcGxheSA9IHRoaXMucGFyYW1zLmF1dG9wbGF5IHx8IGZhbHNlO1xuICAgICAgbWVkaWEucHJlbG9hZCA9IHByZWxvYWQgPT0gbnVsbCA/ICdhdXRvJyA6IHByZWxvYWQ7XG4gICAgICBtZWRpYS5zcmMgPSB1cmw7XG4gICAgICBtZWRpYS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHZhciBwcmV2TWVkaWEgPSBjb250YWluZXIucXVlcnlTZWxlY3Rvcih0aGlzLm1lZGlhVHlwZSk7XG5cbiAgICAgIGlmIChwcmV2TWVkaWEpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHByZXZNZWRpYSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtZWRpYSk7XG5cbiAgICAgIHRoaXMuX2xvYWQobWVkaWEsIHBlYWtzLCBwcmVsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBleGlzdGluZyBtZWRpYSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBlbHQgSFRNTDUgQXVkaW8gb3IgVmlkZW8gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQXJyYXkgb2YgcGVhayBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkRWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRFbHQoZWx0LCBwZWFrcykge1xuICAgICAgZWx0LmNvbnRyb2xzID0gdGhpcy5wYXJhbXMubWVkaWFDb250cm9scztcbiAgICAgIGVsdC5hdXRvcGxheSA9IHRoaXMucGFyYW1zLmF1dG9wbGF5IHx8IGZhbHNlO1xuXG4gICAgICB0aGlzLl9sb2FkKGVsdCwgcGVha3MsIGVsdC5wcmVsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCBieSBib3RoIGBsb2FkYCAoZnJvbSB1cmwpXG4gICAgICogYW5kIGBsb2FkRWx0YCAoZXhpc3RpbmcgbWVkaWEgZWxlbWVudCkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWEgSFRNTDUgQXVkaW8gb3IgVmlkZW8gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQXJyYXkgb2YgcGVhayBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWxvYWQgSFRNTCA1IHByZWxvYWQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBgbWVkaWFgIGFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIG1lZGlhXG4gICAgICogZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWQobWVkaWEsIHBlYWtzLCBwcmVsb2FkKSB7XG4gICAgICAvLyB2ZXJpZnkgbWVkaWEgZWxlbWVudCBpcyB2YWxpZFxuICAgICAgaWYgKCEobWVkaWEgaW5zdGFuY2VvZiBIVE1MTWVkaWFFbGVtZW50KSB8fCB0eXBlb2YgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYSBwYXJhbWV0ZXIgaXMgbm90IGEgdmFsaWQgbWVkaWEgZWxlbWVudCcpO1xuICAgICAgfSAvLyBsb2FkIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5IG9uIGlPUywgb3RoZXJ3aXNlIHBlYWtzIHdvbid0IGRyYXdcbiAgICAgIC8vIHVudGlsIGEgdXNlciBpbnRlcmFjdGlvbiB0cmlnZ2VycyBsb2FkIC0tPiAncmVhZHknIGV2ZW50XG4gICAgICAvL1xuICAgICAgLy8gbm90ZSB0aGF0IHdlIGF2b2lkIGNhbGxpbmcgbWVkaWEubG9hZCBoZXJlIHdoZW4gZ2l2ZW4gcGVha3MgYW5kIHByZWxvYWQgPT0gJ25vbmUnXG4gICAgICAvLyBhcyB0aGlzIGFsbW9zdCBhbHdheXMgdHJpZ2dlcnMgc29tZSBicm93c2VyIGZldGNoIG9mIHRoZSBtZWRpYS5cblxuXG4gICAgICBpZiAodHlwZW9mIG1lZGlhLmxvYWQgPT0gJ2Z1bmN0aW9uJyAmJiAhKHBlYWtzICYmIHByZWxvYWQgPT0gJ25vbmUnKSkge1xuICAgICAgICAvLyBSZXNldHMgdGhlIG1lZGlhIGVsZW1lbnQgYW5kIHJlc3RhcnRzIHRoZSBtZWRpYSByZXNvdXJjZS4gQW55XG4gICAgICAgIC8vIHBlbmRpbmcgZXZlbnRzIGFyZSBkaXNjYXJkZWQuIEhvdyBtdWNoIG1lZGlhIGRhdGEgaXMgZmV0Y2hlZCBpc1xuICAgICAgICAvLyBzdGlsbCBhZmZlY3RlZCBieSB0aGUgcHJlbG9hZCBhdHRyaWJ1dGUuXG4gICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuXG4gICAgICB0aGlzLl9zZXR1cE1lZGlhTGlzdGVuZXJzKCk7XG5cbiAgICAgIHRoaXMucGVha3MgPSBwZWFrcztcbiAgICAgIHRoaXMub25QbGF5RW5kID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG1lZGlhLm11dGVkO1xuICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wbGF5YmFja1JhdGUpO1xuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy52b2x1bWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLmlzUGxheWluZygpYCBhbmQgYHdhdmVzdXJmZXIucGxheVBhdXNlKClgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBNZWRpYSBwYXVzZWQgb3Igbm90XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1BhdXNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5tZWRpYSB8fCB0aGlzLm1lZGlhLnBhdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpYFxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBEdXJhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5leHBsaWNpdER1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9ICh0aGlzLmJ1ZmZlciB8fCB0aGlzLm1lZGlhKS5kdXJhdGlvbjtcblxuICAgICAgaWYgKGR1cmF0aW9uID49IEluZmluaXR5KSB7XG4gICAgICAgIC8vIHN0cmVhbWluZyBhdWRpb1xuICAgICAgICBkdXJhdGlvbiA9IHRoaXMubWVkaWEuc2Vla2FibGUuZW5kKDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzIHJlbGF0aXZlIHRvIHRoZSBhdWRpby1jbGlwJ3NcbiAgICAgKiBkdXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQ3VycmVudCB0aW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9zaXRpb24gZnJvbSAwIHRvIDFcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQ3VycmVudCBwb3NpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWVkUGVyY2VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWVkUGVyY2VudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VGltZSgpIC8gdGhpcy5nZXREdXJhdGlvbigpIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXVkaW8gc291cmNlIHBsYXliYWNrIHJhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBsYXliYWNrIHJhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5YmFja1JhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbGF5YmFja1JhdGUgfHwgdGhpcy5tZWRpYS5wbGF5YmFja1JhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXVkaW8gc291cmNlIHBsYXliYWNrIHJhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgUGxheWJhY2sgcmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXliYWNrUmF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZSB8fCAxO1xuICAgICAgdGhpcy5tZWRpYS5wbGF5YmFja1JhdGUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5zZWVrVG8oKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBQb3NpdGlvbiB0byBzdGFydCBhdCBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWVrVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla1RvKHN0YXJ0KSB7XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYXJQbGF5RW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBsb2FkZWQgYXVkaW8gcmVnaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldCBpbiBzZWNvbmRzLCByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nXG4gICAgICogb2YgYSBjbGlwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgV2hlbiB0byBzdG9wLCByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgY2xpcC5cbiAgICAgKiBAZW1pdHMgTWVkaWFFbGVtZW50I3BsYXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXN1bHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShzdGFydCwgZW5kKSB7XG4gICAgICB0aGlzLnNlZWtUbyhzdGFydCk7XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMubWVkaWEucGxheSgpO1xuICAgICAgZW5kICYmIHRoaXMuc2V0UGxheUVuZChlbmQpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgbG9hZGVkIGF1ZGlvLlxuICAgICAqXG4gICAgICogQGVtaXRzIE1lZGlhRWxlbWVudCNwYXVzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc3VsdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMubWVkaWEucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhclBsYXlFbmQoKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBsYXkgZW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFdoZXJlIHRvIGVuZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5RW5kKGVuZCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2xlYXJQbGF5RW5kKCk7XG5cbiAgICAgIHRoaXMuX29uUGxheUVuZCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lID49IGVuZCkge1xuICAgICAgICAgIF90aGlzNC5wYXVzZSgpO1xuXG4gICAgICAgICAgX3RoaXM0LnNlZWtUbyhlbmQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCdhdWRpb3Byb2Nlc3MnLCB0aGlzLl9vblBsYXlFbmQpO1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyUGxheUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclBsYXlFbmQoKSB7XG4gICAgICBpZiAodGhpcy5fb25QbGF5RW5kKSB7XG4gICAgICAgIHRoaXMudW4oJ2F1ZGlvcHJvY2VzcycsIHRoaXMuX29uUGxheUVuZCk7XG4gICAgICAgIHRoaXMuX29uUGxheUVuZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG1heCBhbmQgbWluIHZhbHVlIG9mIHRoZSB3YXZlZm9ybSB3aGVuIGJyb2tlbiBpbnRvXG4gICAgICogPGxlbmd0aD4gc3VicmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBIb3cgbWFueSBzdWJyYW5nZXMgdG8gYnJlYWsgdGhlIHdhdmVmb3JtIGludG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0IEZpcnN0IHNhbXBsZSBpbiB0aGUgcmVxdWlyZWQgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3QgTGFzdCBzYW1wbGUgaW4gdGhlIHJlcXVpcmVkIHJhbmdlLlxuICAgICAqIEByZXR1cm4ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IEFycmF5IG9mIDIqPGxlbmd0aD4gcGVha3Mgb3IgYXJyYXkgb2ZcbiAgICAgKiBhcnJheXMgb2YgcGVha3MgY29uc2lzdGluZyBvZiAobWF4LCBtaW4pIHZhbHVlcyBmb3IgZWFjaCBzdWJyYW5nZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlYWtzKGxlbmd0aCwgZmlyc3QsIGxhc3QpIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWVkaWFFbGVtZW50LnByb3RvdHlwZSksIFwiZ2V0UGVha3NcIiwgdGhpcykuY2FsbCh0aGlzLCBsZW5ndGgsIGZpcnN0LCBsYXN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGVha3MgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2luayBpZCBmb3IgdGhlIG1lZGlhIHBsYXllclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIFN0cmluZyB2YWx1ZSByZXByZXNlbnRpbmcgYXVkaW8gZGV2aWNlIGlkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlXG4gICAgICogYXJlIG5vIGVycm9ycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNpbmtJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICBpZiAoIXRoaXMubWVkaWEuc2V0U2lua0lkKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignc2V0U2lua0lkIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBkZXZpY2VJZDogJyArIGRldmljZUlkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB2b2x1bWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgQSBmbG9hdGluZyBwb2ludCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vm9sdW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMudm9sdW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF1ZGlvIHZvbHVtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZvbHVtZSh2YWx1ZSkge1xuICAgICAgdGhpcy52b2x1bWUgPSB2YWx1ZTsgLy8gbm8gbmVlZCB0byBjaGFuZ2Ugd2hlbiBpdCdzIGFscmVhZHkgYXQgdGhhdCB2b2x1bWVcblxuICAgICAgaWYgKHRoaXMubWVkaWEudm9sdW1lICE9PSB0aGlzLnZvbHVtZSkge1xuICAgICAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHRoaXMudm9sdW1lO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBtdXRlZCBhdWRpb1xuICAgICAqXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdXRlZCBTcGVjaWZ5IGB0cnVlYCB0byBtdXRlIGF1ZGlvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TXV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNdXRlKG11dGVkKSB7XG4gICAgICAvLyBUaGlzIGNhdXNlcyBhIHZvbHVtZSBjaGFuZ2UgdG8gYmUgZW1pdHRlZCB0b28gdGhyb3VnaCB0aGVcbiAgICAgIC8vIHZvbHVtZWNoYW5nZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHRoaXMuaXNNdXRlZCA9IHRoaXMubWVkaWEubXV0ZWQgPSBtdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB3YXZlc3VyZmVyIGlzIGRlc3Ryb3llZFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy51bkFsbCgpO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlOyAvLyBjbGVhbnVwIG1lZGlhIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm1lZGlhTGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoX3RoaXM1Lm1lZGlhKSB7XG4gICAgICAgICAgX3RoaXM1Lm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoaWQsIF90aGlzNS5tZWRpYUxpc3RlbmVyc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveSAmJiB0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLm1lZGlhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tZWRpYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZWRpYUVsZW1lbnQ7XG59KF93ZWJhdWRpby5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWVkaWFFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BlYWtjYWNoZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGVha2NhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIENhY2hlcyB0aGUgZGVjb2RlZCBwZWFrcyBkYXRhIHRvIGltcHJvdmUgcmVuZGVyaW5nIHNwZWVkIGZvciBsYXJnZSBhdWRpb1xuICpcbiAqIElzIHVzZWQgaWYgdGhlIG9wdGlvbiBwYXJhbWV0ZXIgYHBhcnRpYWxSZW5kZXJgIGlzIHNldCB0byBgdHJ1ZWBcbiAqL1xudmFyIFBlYWtDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBjYWNoZVxuICAgKi9cbiAgZnVuY3Rpb24gUGVha0NhY2hlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZWFrQ2FjaGUpO1xuXG4gICAgdGhpcy5jbGVhclBlYWtDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBFbXB0eSB0aGUgY2FjaGVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUGVha0NhY2hlLCBbe1xuICAgIGtleTogXCJjbGVhclBlYWtDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclBlYWtDYWNoZSgpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmxhdCBhcnJheSB3aXRoIGVudHJpZXMgdGhhdCBhcmUgYWx3YXlzIGluIHBhaXJzIHRvIG1hcmsgdGhlXG4gICAgICAgKiBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIHN1YnJhbmdlLiAgVGhpcyBpcyBhIGNvbnZlbmllbmNlIHNvIHdlIGNhblxuICAgICAgICogaXRlcmF0ZSBvdmVyIHRoZSBwYWlycyBmb3IgZWFzeSBzZXQgZGlmZmVyZW5jZSBvcGVyYXRpb25zLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdGhpcy5wZWFrQ2FjaGVSYW5nZXMgPSBbXTtcbiAgICAgIC8qKlxuICAgICAgICogTGVuZ3RoIG9mIHRoZSBlbnRpcmUgY2FjaGFibGUgcmVnaW9uLCB1c2VkIGZvciByZXNldHRpbmcgdGhlIGNhY2hlXG4gICAgICAgKiB3aGVuIHRoaXMgY2hhbmdlcyAoem9vbSBldmVudHMsIGZvciBpbnN0YW5jZSkuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIHRoaXMucGVha0NhY2hlTGVuZ3RoID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJhbmdlIG9mIHBlYWtzIHRvIHRoZSBjYWNoZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeCBvZmZzZXQgb2YgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHggb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIHJhbmdlXG4gICAgICogQHJldHVybiB7TnVtYmVyLjxBcnJheVtdPn0gQXJyYXkgd2l0aCBhcnJheXMgb2YgbnVtYmVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmFuZ2VUb1BlYWtDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSYW5nZVRvUGVha0NhY2hlKGxlbmd0aCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKGxlbmd0aCAhPSB0aGlzLnBlYWtDYWNoZUxlbmd0aCkge1xuICAgICAgICB0aGlzLmNsZWFyUGVha0NhY2hlKCk7XG4gICAgICAgIHRoaXMucGVha0NhY2hlTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgfSAvLyBSZXR1cm4gcmFuZ2VzIHRoYXQgd2VyZW4ndCBpbiB0aGUgY2FjaGUgYmVmb3JlIHRoZSBjYWxsLlxuXG5cbiAgICAgIHZhciB1bmNhY2hlZFJhbmdlcyA9IFtdO1xuICAgICAgdmFyIGkgPSAwOyAvLyBTa2lwIHJhbmdlcyBiZWZvcmUgdGhlIGN1cnJlbnQgc3RhcnQuXG5cbiAgICAgIHdoaWxlIChpIDwgdGhpcy5wZWFrQ2FjaGVSYW5nZXMubGVuZ3RoICYmIHRoaXMucGVha0NhY2hlUmFuZ2VzW2ldIDwgc3RhcnQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfSAvLyBJZiB8aXwgaXMgZXZlbiwgfHN0YXJ0fCBmYWxscyBhZnRlciBhbiBleGlzdGluZyByYW5nZS4gIE90aGVyd2lzZSxcbiAgICAgIC8vIHxzdGFydHwgZmFsbHMgYmV0d2VlbiBhbiBleGlzdGluZyByYW5nZSwgYW5kIHRoZSB1bmNhY2hlZCByZWdpb25cbiAgICAgIC8vIHN0YXJ0cyB3aGVuIHdlIGVuY291bnRlciB0aGUgbmV4dCBub2RlIGluIHxwZWFrQ2FjaGVSYW5nZXN8IG9yXG4gICAgICAvLyB8ZW5kfCwgd2hpY2hldmVyIGNvbWVzIGZpcnN0LlxuXG5cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIHVuY2FjaGVkUmFuZ2VzLnB1c2goc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSA8IHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSA8PSBlbmQpIHtcbiAgICAgICAgdW5jYWNoZWRSYW5nZXMucHVzaCh0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSk7XG4gICAgICAgIGkrKztcbiAgICAgIH0gLy8gSWYgfGl8IGlzIGV2ZW4sIHxlbmR8IGlzIGFmdGVyIGFsbCBleGlzdGluZyByYW5nZXMuXG5cblxuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgdW5jYWNoZWRSYW5nZXMucHVzaChlbmQpO1xuICAgICAgfSAvLyBGaWx0ZXIgb3V0IHRoZSAwLWxlbmd0aCByYW5nZXMuXG5cblxuICAgICAgdW5jYWNoZWRSYW5nZXMgPSB1bmNhY2hlZFJhbmdlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIHBvcywgYXJyKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgKyAxXTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zIC0gMV0gJiYgaXRlbSAhPSBhcnJbcG9zICsgMV07XG4gICAgICB9KTsgLy8gTWVyZ2UgdGhlIHR3byByYW5nZXMgdG9nZXRoZXIsIHVuY2FjaGVkUmFuZ2VzIHdpbGwgZWl0aGVyIGNvbnRhaW5cbiAgICAgIC8vIHdob2xseSBuZXcgcG9pbnRzLCBvciBkdXBsaWNhdGVzIG9mIHBvaW50cyBpbiBwZWFrQ2FjaGVSYW5nZXMuICBJZlxuICAgICAgLy8gZHVwbGljYXRlcyBhcmUgZGV0ZWN0ZWQsIHJlbW92ZSBib3RoIGFuZCBleHRlbmQgdGhlIHJhbmdlLlxuXG4gICAgICB0aGlzLnBlYWtDYWNoZVJhbmdlcyA9IHRoaXMucGVha0NhY2hlUmFuZ2VzLmNvbmNhdCh1bmNhY2hlZFJhbmdlcyk7XG4gICAgICB0aGlzLnBlYWtDYWNoZVJhbmdlcyA9IHRoaXMucGVha0NhY2hlUmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBwb3MsIGFycikge1xuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zICsgMV07XG4gICAgICAgIH0gZWxzZSBpZiAocG9zID09IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyAtIDFdICYmIGl0ZW0gIT0gYXJyW3BvcyArIDFdO1xuICAgICAgfSk7IC8vIFB1c2ggdGhlIHVuY2FjaGVkIHJhbmdlcyBpbnRvIGFuIGFycmF5IG9mIGFycmF5cyBmb3IgZWFzZSBvZlxuICAgICAgLy8gaXRlcmF0aW9uIGluIHRoZSBmdW5jdGlvbnMgdGhhdCBjYWxsIHRoaXMuXG5cbiAgICAgIHZhciB1bmNhY2hlZFJhbmdlUGFpcnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHVuY2FjaGVkUmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHVuY2FjaGVkUmFuZ2VQYWlycy5wdXNoKFt1bmNhY2hlZFJhbmdlc1tpXSwgdW5jYWNoZWRSYW5nZXNbaSArIDFdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmNhY2hlZFJhbmdlUGFpcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0ZXN0aW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXIuPEFycmF5W10+fSBBcnJheSB3aXRoIGFycmF5cyBvZiBudW1iZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZVJhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZVJhbmdlcygpIHtcbiAgICAgIHZhciBwZWFrQ2FjaGVSYW5nZVBhaXJzID0gW107XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGVha0NhY2hlUmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBlYWtDYWNoZVJhbmdlUGFpcnMucHVzaChbdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV0sIHRoaXMucGVha0NhY2hlUmFuZ2VzW2kgKyAxXV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVha0NhY2hlUmFuZ2VQYWlycztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGVha0NhY2hlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQZWFrQ2FjaGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9hYnNNYXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9hYnNNYXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhYnNNYXg7XG5cbnZhciBfbWF4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21heCAqLyBcIi4vc3JjL3V0aWwvbWF4LmpzXCIpKTtcblxudmFyIF9taW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWluICovIFwiLi9zcmMvdXRpbC9taW4uanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogR2V0IHRoZSBsYXJnZXN0IGFic29sdXRlIHZhbHVlIGluIGFuIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtBcnJheX0gdmFsdWVzIEFycmF5IG9mIG51bWJlcnNcclxuICogQHJldHVybnMge051bWJlcn0gTGFyZ2VzdCBudW1iZXIgZm91bmRcclxuICogQGV4YW1wbGUgY29uc29sZS5sb2cobWF4KFstMywgMiwgMV0pLCBtYXgoWy0zLCAyLCA0XSkpOyAvLyBsb2dzIDMgNFxyXG4gKiBAc2luY2UgNC4zLjBcclxuICovXG5mdW5jdGlvbiBhYnNNYXgodmFsdWVzKSB7XG4gIHZhciBtYXggPSAoMCwgX21heC5kZWZhdWx0KSh2YWx1ZXMpO1xuICB2YXIgbWluID0gKDAsIF9taW4uZGVmYXVsdCkodmFsdWVzKTtcbiAgcmV0dXJuIC1taW4gPiBtYXggPyAtbWluIDogbWF4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9jbGFtcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvY2xhbXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsYW1wO1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBUaGUgbnVtYmVyIHRvIGJlIGxpbWl0ZWQgdG8gYSByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGxpbWl0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgbGltaXQgcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXhdXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsKSwgbWF4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvZmV0Y2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2ZldGNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaEZpbGU7XG5cbnZhciBfb2JzZXJ2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JzZXJ2ZXIgKi8gXCIuL3NyYy91dGlsL29ic2VydmVyLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgUHJvZ3Jlc3NIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIFByb2dyZXNzSGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09ic2VydmVyfSBpbnN0YW5jZSBUaGUgYGZldGNoRmlsZWAgb2JzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb250ZW50TGVuZ3RoIENvbnRlbnQgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSBSZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9ncmVzc0hhbmRsZXIoaW5zdGFuY2UsIGNvbnRlbnRMZW5ndGgsIHJlc3BvbnNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyZXNzSGFuZGxlcik7XG5cbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgdGhpcy5pbnN0YW5jZS5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB0aGlzLnRvdGFsID0gcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApO1xuICAgIHRoaXMubG9hZGVkID0gMDtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgb25jZSwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGBSZWFkYWJsZVN0cmVhbWBgXG4gICAqIGlzIGNvbnN0cnVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgQ29udHJvbGxlciBpbnN0YW5jZVxuICAgKiAgICAgdXNlZCB0byBjb250cm9sIHRoZSBzdHJlYW0uXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFByb2dyZXNzSGFuZGxlciwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJlYWQgPSBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAvLyBpbnN0YW5jZS5fcmVhZGVyLnJlYWQoKSByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gICAgICAgIC8vIHdoZW4gYSB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZFxuICAgICAgICBfdGhpcy5pbnN0YW5jZS5fcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBfcmVmLmRvbmUsXG4gICAgICAgICAgICAgIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICAgICAgICAgIC8vIHJlc3VsdCBvYmplY3RzIGNvbnRhaW4gdHdvIHByb3BlcnRpZXM6XG4gICAgICAgICAgLy8gZG9uZSAgLSB0cnVlIGlmIHRoZSBzdHJlYW0gaGFzIGFscmVhZHkgZ2l2ZW4geW91IGFsbCBpdHMgZGF0YS5cbiAgICAgICAgICAvLyB2YWx1ZSAtIHNvbWUgZGF0YS4gQWx3YXlzIHVuZGVmaW5lZCB3aGVuIGRvbmUgaXMgdHJ1ZS5cbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIG9uUHJvZ3Jlc3MgY2FsbGVkIHdoZW4gY29udGVudC1sZW5ndGg9MFxuICAgICAgICAgICAgaWYgKF90aGlzLnRvdGFsID09PSAwKSB7XG4gICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLm9uUHJvZ3Jlc3MuY2FsbChfdGhpcy5pbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgIGxvYWRlZDogX3RoaXMubG9hZGVkLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBfdGhpcy50b3RhbCxcbiAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG5cblxuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmxvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgICAgX3RoaXMuaW5zdGFuY2Uub25Qcm9ncmVzcy5jYWxsKF90aGlzLmluc3RhbmNlLCB7XG4gICAgICAgICAgICBsb2FkZWQ6IF90aGlzLmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBfdGhpcy50b3RhbCxcbiAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6ICEoX3RoaXMudG90YWwgPT09IDApXG4gICAgICAgICAgfSk7IC8vIGVucXVldWUgdGhlIG5leHQgZGF0YSBjaHVuayBpbnRvIG91ciB0YXJnZXQgc3RyZWFtXG5cblxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgcmVhZCgpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZWFkKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFByb2dyZXNzSGFuZGxlcjtcbn0oKTtcbi8qKlxuICogTG9hZCBhIGZpbGUgdXNpbmcgYGZldGNoYC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBSZXF1ZXN0IG9wdGlvbnMgdG8gdXNlLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEByZXR1cm5zIHtPYnNlcnZlcn0gT2JzZXJ2ZXIgaW5zdGFuY2VcbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZhdWx0IG9wdGlvbnNcbiAqIGxldCBvcHRpb25zID0ge1xuICogICAgIHVybDogdW5kZWZpbmVkLFxuICogICAgIG1ldGhvZDogJ0dFVCcsXG4gKiAgICAgbW9kZTogJ2NvcnMnLFxuICogICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICogICAgIGNhY2hlOiAnZGVmYXVsdCcsXG4gKiAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gKiAgICAgcmVxdWVzdEhlYWRlcnM6IFtdLFxuICogICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAqICAgICByZWZlcnJlcjogJ2NsaWVudCdcbiAqIH07XG4gKlxuICogLy8gb3ZlcnJpZGUgc29tZSBvcHRpb25zXG4gKiBvcHRpb25zLnVybCA9ICcuLi9tZWRpYS9kZW1vLndhdic7XG5cbiAqIC8vIGF2YWlsYWJsZSB0eXBlczogJ2FycmF5YnVmZmVyJywgJ2Jsb2InLCAnanNvbicgb3IgJ3RleHQnXG4gKiBvcHRpb25zLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gKlxuICogLy8gbWFrZSBmZXRjaCBjYWxsXG4gKiBsZXQgcmVxdWVzdCA9IHV0aWwuZmV0Y2hGaWxlKG9wdGlvbnMpO1xuICpcbiAqIC8vIGxpc3RlbiBmb3IgZXZlbnRzXG4gKiByZXF1ZXN0Lm9uKCdwcm9ncmVzcycsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdwcm9ncmVzcycsIGUpO1xuICogfSk7XG4gKlxuICogcmVxdWVzdC5vbignc3VjY2VzcycsIGRhdGEgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdzdWNjZXNzIScsIGRhdGEpO1xuICogfSk7XG4gKlxuICogcmVxdWVzdC5vbignZXJyb3InLCBlID0+IHtcbiAqICAgICBjb25zb2xlLndhcm4oJ2ZldGNoRmlsZSBlcnJvcjogJywgZSk7XG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIGZldGNoRmlsZShvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2ggb3B0aW9ucyBtaXNzaW5nJyk7XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaCB1cmwgbWlzc2luZycpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IF9vYnNlcnZlci5kZWZhdWx0KCk7XG4gIHZhciBmZXRjaEhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICB2YXIgZmV0Y2hSZXF1ZXN0ID0gbmV3IFJlcXVlc3Qob3B0aW9ucy51cmwpOyAvLyBhZGQgYWJpbGl0eSB0byBhYm9ydFxuXG4gIGluc3RhbmNlLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7IC8vIGNoZWNrIGlmIGhlYWRlcnMgaGF2ZSB0byBiZSBhZGRlZFxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVxdWVzdEhlYWRlcnMpIHtcbiAgICAvLyBhZGQgY3VzdG9tIHJlcXVlc3QgaGVhZGVyc1xuICAgIG9wdGlvbnMucmVxdWVzdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICBmZXRjaEhlYWRlcnMuYXBwZW5kKGhlYWRlci5rZXksIGhlYWRlci52YWx1ZSk7XG4gICAgfSk7XG4gIH0gLy8gcGFyc2UgZmV0Y2ggb3B0aW9uc1xuXG5cbiAgdmFyIHJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlIHx8ICdqc29uJztcbiAgdmFyIGZldGNoT3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgIGhlYWRlcnM6IGZldGNoSGVhZGVycyxcbiAgICBtb2RlOiBvcHRpb25zLm1vZGUgfHwgJ2NvcnMnLFxuICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgY2FjaGU6IG9wdGlvbnMuY2FjaGUgfHwgJ2RlZmF1bHQnLFxuICAgIHJlZGlyZWN0OiBvcHRpb25zLnJlZGlyZWN0IHx8ICdmb2xsb3cnLFxuICAgIHJlZmVycmVyOiBvcHRpb25zLnJlZmVycmVyIHx8ICdjbGllbnQnLFxuICAgIHNpZ25hbDogaW5zdGFuY2UuY29udHJvbGxlci5zaWduYWxcbiAgfTtcbiAgZmV0Y2goZmV0Y2hSZXF1ZXN0LCBmZXRjaE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgLy8gc3RvcmUgcmVzcG9uc2UgcmVmZXJlbmNlXG4gICAgaW5zdGFuY2UucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB2YXIgcHJvZ3Jlc3NBdmFpbGFibGUgPSB0cnVlO1xuXG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAvLyBSZWFkYWJsZVN0cmVhbSBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcbiAgICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW1cbiAgICAgIHByb2dyZXNzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgfSAvLyBTZXJ2ZXIgbXVzdCBzZW5kIENPUlMgaGVhZGVyIFwiQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnM6IGNvbnRlbnQtbGVuZ3RoXCJcblxuXG4gICAgdmFyIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcblxuICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAvLyBDb250ZW50LUxlbmd0aCBzZXJ2ZXIgcmVzcG9uc2UgaGVhZGVyIG1pc3NpbmcuXG4gICAgICAvLyBEb24ndCBldmFsdWF0ZSBkb3dubG9hZCBwcm9ncmVzcyBpZiB3ZSBjYW4ndCBjb21wYXJlIGFnYWluc3QgYSB0b3RhbCBzaXplXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9DT1JTI0FjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzXG4gICAgICBwcm9ncmVzc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHJvZ3Jlc3NBdmFpbGFibGUpIHtcbiAgICAgIC8vIG5vdCBhYmxlIHRvIGNoZWNrIGRvd25sb2FkIHByb2dyZXNzIHNvIHNraXAgaXRcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IC8vIGZpcmUgcHJvZ3Jlc3MgZXZlbnQgd2hlbiBkdXJpbmcgbG9hZFxuXG5cbiAgICBpbnN0YW5jZS5vblByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGluc3RhbmNlLmZpcmVFdmVudCgncHJvZ3Jlc3MnLCBlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShuZXcgUmVhZGFibGVTdHJlYW0obmV3IFByb2dyZXNzSGFuZGxlcihpbnN0YW5jZSwgY29udGVudExlbmd0aCwgcmVzcG9uc2UpKSwgZmV0Y2hPcHRpb25zKTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICB2YXIgZXJyTXNnO1xuXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuXG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBlcnJNc2cgPSAnVW5rbm93biByZXNwb25zZVR5cGU6ICcgKyByZXNwb25zZVR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgIGVyck1zZyA9ICdIVFRQIGVycm9yIHN0YXR1czogJyArIHJlc3BvbnNlLnN0YXR1cztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpbnN0YW5jZS5maXJlRXZlbnQoJ3N1Y2Nlc3MnLCByZXNwb25zZSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGluc3RhbmNlLmZpcmVFdmVudCgnZXJyb3InLCBlcnJvcik7XG4gIH0pOyAvLyByZXR1cm4gdGhlIGZldGNoIHJlcXVlc3RcblxuICBpbnN0YW5jZS5mZXRjaFJlcXVlc3QgPSBmZXRjaFJlcXVlc3Q7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvZnJhbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2ZyYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmcmFtZTtcblxudmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVxdWVzdC1hbmltYXRpb24tZnJhbWUgKi8gXCIuL3NyYy91dGlsL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIGN5Y2xlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICpcbiAqIEByZXR1cm4ge2Z1bmN9IFRoZSBmdW5jdGlvbiB3cmFwcGVkIHdpdGhpbiBhIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICovXG5mdW5jdGlvbiBmcmFtZShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3JlcXVlc3RBbmltYXRpb25GcmFtZS5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9nZXQtaWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9nZXQtaWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRJZDtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gcHJlZml4ZWQgSURcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFByZWZpeCB0byB1c2UuIERlZmF1bHQgaXMgYCd3YXZlc3VyZmVyXydgLlxuICogQHJldHVybnMge1N0cmluZ30gUmFuZG9tIHByZWZpeGVkIElEXG4gKiBAZXhhbXBsZVxuICogY29uc29sZS5sb2coZ2V0SWQoKSk7IC8vIGxvZ3MgJ3dhdmVzdXJmZXJfYjVwb3JzNHJ1NmcnXG4gKlxuICogbGV0IHByZWZpeCA9ICdmb28tJztcbiAqIGNvbnNvbGUubG9nKGdldElkKHByZWZpeCkpOyAvLyBsb2dzICdmb28tYjVwb3JzNHJ1NmcnXG4gKi9cbmZ1bmN0aW9uIGdldElkKHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICBwcmVmaXggPSAnd2F2ZXN1cmZlcl8nO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeCArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnN1YnN0cmluZygyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldElkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0SWQuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF4XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWF4LmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1pblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21pbi5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhYnNNYXhcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hYnNNYXguZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT2JzZXJ2ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9vYnNlcnZlci5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHlsZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N0eWxlLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RBbmltYXRpb25GcmFtZS5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcmFtZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZyYW1lLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlYm91bmNlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGVib3VuY2UuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJldmVudENsaWNrXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcHJldmVudENsaWNrLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZldGNoRmlsZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZldGNoLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsYW1wXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY2xhbXAuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2l0aE9yaWVudGF0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfb3JpZW50YXRpb24uZGVmYXVsdDtcbiAgfVxufSkpO1xuXG52YXIgX2dldElkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldC1pZCAqLyBcIi4vc3JjL3V0aWwvZ2V0LWlkLmpzXCIpKTtcblxudmFyIF9tYXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF4ICovIFwiLi9zcmMvdXRpbC9tYXguanNcIikpO1xuXG52YXIgX21pbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taW4gKi8gXCIuL3NyYy91dGlsL21pbi5qc1wiKSk7XG5cbnZhciBfYWJzTWF4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Fic01heCAqLyBcIi4vc3JjL3V0aWwvYWJzTWF4LmpzXCIpKTtcblxudmFyIF9vYnNlcnZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vYnNlcnZlciAqLyBcIi4vc3JjL3V0aWwvb2JzZXJ2ZXIuanNcIikpO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0eWxlICovIFwiLi9zcmMvdXRpbC9zdHlsZS5qc1wiKSk7XG5cbnZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lICovIFwiLi9zcmMvdXRpbC9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qc1wiKSk7XG5cbnZhciBfZnJhbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhbWUgKi8gXCIuL3NyYy91dGlsL2ZyYW1lLmpzXCIpKTtcblxudmFyIF9kZWJvdW5jZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGVib3VuY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qc1wiKSk7XG5cbnZhciBfcHJldmVudENsaWNrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ByZXZlbnQtY2xpY2sgKi8gXCIuL3NyYy91dGlsL3ByZXZlbnQtY2xpY2suanNcIikpO1xuXG52YXIgX2ZldGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZldGNoICovIFwiLi9zcmMvdXRpbC9mZXRjaC5qc1wiKSk7XG5cbnZhciBfY2xhbXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2xhbXAgKi8gXCIuL3NyYy91dGlsL2NsYW1wLmpzXCIpKTtcblxudmFyIF9vcmllbnRhdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vcmllbnRhdGlvbiAqLyBcIi4vc3JjL3V0aWwvb3JpZW50YXRpb24uanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL21heC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL21heC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1heDtcblxuLyoqXG4gKiBHZXQgdGhlIGxhcmdlc3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0gICB7QXJyYXl9IHZhbHVlcyBBcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBMYXJnZXN0IG51bWJlciBmb3VuZFxuICogQGV4YW1wbGUgY29uc29sZS5sb2cobWF4KFsxLCAyLCAzXSkpOyAvLyBsb2dzIDNcbiAqL1xuZnVuY3Rpb24gbWF4KHZhbHVlcykge1xuICB2YXIgbGFyZ2VzdCA9IC1JbmZpbml0eTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKHZhbHVlc1tpXSA+IGxhcmdlc3QpIHtcbiAgICAgIGxhcmdlc3QgPSB2YWx1ZXNbaV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxhcmdlc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL21pbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL21pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1pbjtcblxuLyoqXG4gKiBHZXQgdGhlIHNtYWxsZXN0IHZhbHVlXG4gKlxuICogQHBhcmFtICAge0FycmF5fSB2YWx1ZXMgQXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge051bWJlcn0gU21hbGxlc3QgbnVtYmVyIGZvdW5kXG4gKiBAZXhhbXBsZSBjb25zb2xlLmxvZyhtaW4oWzEsIDIsIDNdKSk7IC8vIGxvZ3MgMVxuICovXG5mdW5jdGlvbiBtaW4odmFsdWVzKSB7XG4gIHZhciBzbWFsbGVzdCA9IE51bWJlcihJbmZpbml0eSk7XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIGlmICh2YWx1ZXNbaV0gPCBzbWFsbGVzdCkge1xuICAgICAgc21hbGxlc3QgPSB2YWx1ZXNbaV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNtYWxsZXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9vYnNlcnZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvb2JzZXJ2ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpc3RlbmVyRGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHVuIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAqL1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzXG4gKi9cbnZhciBPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBPYnNlcnZlclxuICAgKi9cbiAgZnVuY3Rpb24gT2JzZXJ2ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9ic2VydmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRvZG8gSW5pdGlhbGlzZSB0aGUgaGFuZGxlcnMgaGVyZSBhbHJlYWR5IGFuZCByZW1vdmUgdGhlIGNvbmRpdGlvbmFsXG4gICAgICogYXNzaWdubWVudCBpbiBgb24oKWBcbiAgICAgKi9cbiAgICB0aGlzLl9kaXNhYmxlZEV2ZW50RW1pc3Npb25zID0gW107XG4gICAgdGhpcy5oYW5kbGVycyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGhhbmRsZXIgZnVuY3Rpb24gZm9yIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkXG4gICAqIEByZXR1cm4ge0xpc3RlbmVyRGVzY3JpcHRvcn0gVGhlIGV2ZW50IGRlc2NyaXB0b3JcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF07XG5cbiAgICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGZuKTsgLy8gUmV0dXJuIGFuIGV2ZW50IGRlc2NyaXB0b3JcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZXZlbnQsXG4gICAgICAgIGNhbGxiYWNrOiBmbixcbiAgICAgICAgdW46IGZ1bmN0aW9uIHVuKGUsIGZuKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnVuKGUsIGZuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQgdGhlIGxpc3RlbmVyIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVtb3ZlZCBsaXN0ZW5zIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuKGV2ZW50LCBmbikge1xuICAgICAgaWYgKCF0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF07XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgIGZvciAoaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbaV0gPT0gZm4pIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bkFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bkFsbCgpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBoYW5kbGVyIHRvIGFuIGV2ZW50LiBUaGUgaGFuZGxlciBpcyBleGVjdXRlZCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBUaGUgY2FsbGJhY2sgdGhhdCBpcyBvbmx5IHRvIGJlIGNhbGxlZCBvbmNlXG4gICAgICogQHJldHVybiB7TGlzdGVuZXJEZXNjcmlwdG9yfSBUaGUgZXZlbnQgZGVzY3JpcHRvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvKiAgZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG4gICAgICAgIGhhbmRsZXIuYXBwbHkoX3RoaXMyLCBhcmdzKTtcbiAgICAgICAgLyogIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnVuKGV2ZW50LCBmbik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBmaXJpbmcgYSBsaXN0IG9mIGV2ZW50cyBieSBuYW1lLiBXaGVuIHNwZWNpZmllZCwgZXZlbnQgaGFuZGxlcnMgZm9yIGFueSBldmVudCB0eXBlXG4gICAgICogcGFzc2VkIGluIGhlcmUgd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnROYW1lcyBhbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkaXNhYmxlIGVtaXNzaW9ucyBmb3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRpc2FibGUgc2VlayBhbmQgaW50ZXJhY3Rpb24gZXZlbnRzXG4gICAgICogd2F2ZXN1cmZlci5zZXREaXNhYmxlZEV2ZW50RW1pc3Npb25zKFsnc2VlaycsICdpbnRlcmFjdGlvbiddKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERpc2FibGVkRXZlbnRFbWlzc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWRFdmVudEVtaXNzaW9ucyhldmVudE5hbWVzKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZEV2ZW50RW1pc3Npb25zID0gZXZlbnROYW1lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogcGx1Z2lucyBib3Jyb3cgcGFydCBvZiB0aGlzIGNsYXNzIHdpdGhvdXQgY2FsbGluZyB0aGUgY29uc3RydWN0b3IsXG4gICAgICogc28gd2UgaGF2ZSB0byBiZSBjYXJlZnVsIGFib3V0IF9kaXNhYmxlZEV2ZW50RW1pc3Npb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNEaXNhYmxlZEV2ZW50RW1pc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRGlzYWJsZWRFdmVudEVtaXNzaW9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWRFdmVudEVtaXNzaW9ucyAmJiB0aGlzLl9kaXNhYmxlZEV2ZW50RW1pc3Npb25zLmluY2x1ZGVzKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgZmlyZSBhbiBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0byBmaXJlIG1hbnVhbGx5XG4gICAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRvIGNhbGwgdGhlIGxpc3RlbmVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVFdmVudChldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhhbmRsZXJzIHx8IHRoaXMuX2lzRGlzYWJsZWRFdmVudEVtaXNzaW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgZm4uYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gT2JzZXJ2ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9vcmllbnRhdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvb3JpZW50YXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhPcmllbnRhdGlvbjtcbnZhciB2ZXJ0aWNhbFByb3BNYXAgPSB7XG4gIHdpZHRoOiAnaGVpZ2h0JyxcbiAgaGVpZ2h0OiAnd2lkdGgnLFxuICBvdmVyZmxvd1g6ICdvdmVyZmxvd1knLFxuICBvdmVyZmxvd1k6ICdvdmVyZmxvd1gnLFxuICBjbGllbnRXaWR0aDogJ2NsaWVudEhlaWdodCcsXG4gIGNsaWVudEhlaWdodDogJ2NsaWVudFdpZHRoJyxcbiAgY2xpZW50WDogJ2NsaWVudFknLFxuICBjbGllbnRZOiAnY2xpZW50WCcsXG4gIHNjcm9sbFdpZHRoOiAnc2Nyb2xsSGVpZ2h0JyxcbiAgc2Nyb2xsTGVmdDogJ3Njcm9sbFRvcCcsXG4gIG9mZnNldExlZnQ6ICdvZmZzZXRUb3AnLFxuICBvZmZzZXRUb3A6ICdvZmZzZXRMZWZ0JyxcbiAgb2Zmc2V0SGVpZ2h0OiAnb2Zmc2V0V2lkdGgnLFxuICBvZmZzZXRXaWR0aDogJ29mZnNldEhlaWdodCcsXG4gIGxlZnQ6ICd0b3AnLFxuICByaWdodDogJ2JvdHRvbScsXG4gIHRvcDogJ2xlZnQnLFxuICBib3R0b206ICdyaWdodCcsXG4gIGJvcmRlclJpZ2h0U3R5bGU6ICdib3JkZXJCb3R0b21TdHlsZScsXG4gIGJvcmRlclJpZ2h0V2lkdGg6ICdib3JkZXJCb3R0b21XaWR0aCcsXG4gIGJvcmRlclJpZ2h0Q29sb3I6ICdib3JkZXJCb3R0b21Db2xvcidcbn07XG4vKipcbiAqIENvbnZlcnQgYSBob3Jpem9udGFsbHktb3JpZW50ZWQgcHJvcGVydHkgbmFtZSB0byBhIHZlcnRpY2FsIG9uZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBBIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7Ym9vbH0gdmVydGljYWwgV2hldGhlciB0aGUgZWxlbWVudCBpcyBvcmllbnRlZCB2ZXJ0aWNhbGx5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwcm9wLCBjb252ZXJ0ZWQgYXBwcm9wcmlhdGVseVxuICovXG5cbmZ1bmN0aW9uIG1hcFByb3AocHJvcCwgdmVydGljYWwpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2ZXJ0aWNhbFByb3BNYXAsIHByb3ApKSB7XG4gICAgcmV0dXJuIHZlcnRpY2FsID8gdmVydGljYWxQcm9wTWFwW3Byb3BdIDogcHJvcDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufVxuXG52YXIgaXNQcm94eSA9IFN5bWJvbChcImlzUHJveHlcIik7XG4vKipcbiAqIFJldHVybnMgYW4gYXBwcm9wcmlhdGVseSBvcmllbnRlZCBvYmplY3QgYmFzZWQgb24gdmVydGljYWwuXG4gKiBJZiB2ZXJ0aWNhbCBpcyB0cnVlLCBhdHRyaWJ1dGUgZ2V0dGluZyBhbmQgc2V0dGluZyB3aWxsIGJlIG1hcHBlZCB0aHJvdWdoXG4gKiB2ZXJ0aWNhbFByb3BNYXAsIHNvIHRoYXQgZS5nLiBnZXR0aW5nIHRoZSBvYmplY3QncyAud2lkdGggd2lsbCBnaXZlIGl0c1xuICogLmhlaWdodCBpbnN0ZWFkLlxuICogQ2VydGFpbiBtZXRob2RzIG9mIGFuIG9yaWVudGVkIG9iamVjdCB3aWxsIHJldHVybiBvcmllbnRlZCBvYmplY3RzIGFzIHdlbGwuXG4gKiBPcmllbnRlZCBvYmplY3RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZSBET00gZGlyZWN0bHkgc2luY2UgdGhleSBhcmUgUHJveHkgb2JqZWN0c1xuICogYW5kIHRodXMgZmFpbCB0eXBlY2hlY2tzLiBVc2UgZG9tRWxlbWVudCB0byBnZXQgdGhlIGFjdHVhbCBlbGVtZW50IGZvciB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0byBiZSB3cmFwcGVkIGFuZCBvcmllbnRlZFxuICogQHBhcmFtIHtib29sfSB2ZXJ0aWNhbCBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIG9yaWVudGVkIHZlcnRpY2FsbHlcbiAqIEByZXR1cm5zIHtQcm94eX0gQW4gb3JpZW50ZWQgb2JqZWN0IHdpdGggYXR0ciB0cmFuc2xhdGlvbiB2aWEgdmVydGljYWxBdHRyTWFwXG4gKiBAc2luY2UgNS4wLjBcbiAqL1xuXG5mdW5jdGlvbiB3aXRoT3JpZW50YXRpb24odGFyZ2V0LCB2ZXJ0aWNhbCkge1xuICBpZiAodGFyZ2V0W2lzUHJveHldKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQob2JqLCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAocHJvcCA9PT0gaXNQcm94eSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdkb21FbGVtZW50Jykge1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIHJldHVybiB3aXRoT3JpZW50YXRpb24ob2JqLnN0eWxlLCB2ZXJ0aWNhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aE9yaWVudGF0aW9uKG9iai5jYW52YXMsIHZlcnRpY2FsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0Jykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aE9yaWVudGF0aW9uKG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYXBwbHkob2JqLCBhcmd1bWVudHMpLCB2ZXJ0aWNhbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnZ2V0Q29udGV4dCcpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhPcmllbnRhdGlvbihvYmouZ2V0Q29udGV4dC5hcHBseShvYmosIGFyZ3VtZW50cyksIHZlcnRpY2FsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialttYXBQcm9wKHByb3AsIHZlcnRpY2FsKV07XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUuYmluZChvYmopIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIG9ialttYXBQcm9wKHByb3AsIHZlcnRpY2FsKV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvcHJldmVudC1jbGljay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9wcmV2ZW50LWNsaWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHByZXZlbnRDbGljaztcblxuLyoqXG4gKiBTdG9wcyBwcm9wYWdhdGlvbiBvZiBjbGljayBldmVudCBhbmQgcmVtb3ZlcyBldmVudCBsaXN0ZW5lclxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGNsaWNrIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRDbGlja0hhbmRsZXIoZXZlbnQpIHtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2ZW50Q2xpY2tIYW5kbGVyLCB0cnVlKTtcbn1cbi8qKlxuICogU3RhcnRzIGxpc3RlbmluZyBmb3IgY2xpY2sgZXZlbnQgYW5kIHByZXZlbnQgcHJvcGFnYXRpb25cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFZhbHVlc1xuICovXG5cblxuZnVuY3Rpb24gcHJldmVudENsaWNrKHZhbHVlcykge1xuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcHJldmVudENsaWNrSGFuZGxlciwgdHJ1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGZ1bmN0aW9uIGZvciB0aGUgYnJvd3Nlciwgb3IgYSBzaGltIHdpdGhcbiAqIGBzZXRUaW1lb3V0YCBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IGZvdW5kXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259IEF2YWlsYWJsZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBmdW5jdGlvbiBmb3IgdGhlIGJyb3dzZXJcbiAqL1xudmFyIF9kZWZhdWx0ID0gKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG59KS5iaW5kKHdpbmRvdyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvc3R5bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3N0eWxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzdHlsZTtcblxuLyoqXG4gKiBBcHBseSBhIG1hcCBvZiBzdHlsZXMgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRoYXQgdGhlIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgVGhlIG1hcCBvZiBwcm9wTmFtZTogYXR0cmlidXRlLCBib3RoIGFyZSB1c2VkIGFzLWlzXG4gKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IGVsXG4gKi9cbmZ1bmN0aW9uIHN0eWxlKGVsLCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKGVsLnN0eWxlW3Byb3BdICE9PSBzdHlsZXNbcHJvcF0pIHtcbiAgICAgIGVsLnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3dhdmVzdXJmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy93YXZlc3VyZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCIpKTtcblxudmFyIF9kcmF3ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHJhd2VyLm11bHRpY2FudmFzICovIFwiLi9zcmMvZHJhd2VyLm11bHRpY2FudmFzLmpzXCIpKTtcblxudmFyIF93ZWJhdWRpbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93ZWJhdWRpbyAqLyBcIi4vc3JjL3dlYmF1ZGlvLmpzXCIpKTtcblxudmFyIF9tZWRpYWVsZW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVkaWFlbGVtZW50ICovIFwiLi9zcmMvbWVkaWFlbGVtZW50LmpzXCIpKTtcblxudmFyIF9wZWFrY2FjaGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGVha2NhY2hlICovIFwiLi9zcmMvcGVha2NhY2hlLmpzXCIpKTtcblxudmFyIF9tZWRpYWVsZW1lbnRXZWJhdWRpbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZWRpYWVsZW1lbnQtd2ViYXVkaW8gKi8gXCIuL3NyYy9tZWRpYWVsZW1lbnQtd2ViYXVkaW8uanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLypcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciBhIEJTRC0zLUNsYXVzZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZXh0ZXJuYWwge0hUTUxFbGVtZW50fSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQgKi9cblxuLyoqIEBleHRlcm5hbCB7T2ZmbGluZUF1ZGlvQ29udGV4dH0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL09mZmxpbmVBdWRpb0NvbnRleHQgKi9cblxuLyoqIEBleHRlcm5hbCB7RmlsZX0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUgKi9cblxuLyoqIEBleHRlcm5hbCB7QmxvYn0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IgKi9cblxuLyoqIEBleHRlcm5hbCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICovXG5cbi8qKiBAZXh0ZXJuYWwge01lZGlhU3RyZWFtQ29uc3RyYWludHN9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVN0cmVhbUNvbnN0cmFpbnRzICovXG5cbi8qKiBAZXh0ZXJuYWwge0F1ZGlvTm9kZX0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdhdmVzdXJmZXJQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7QXVkaW9Db250ZXh0fSBhdWRpb0NvbnRleHQ9bnVsbCBVc2UgeW91ciBvd24gcHJldmlvdXNseVxuICogaW5pdGlhbGl6ZWQgQXVkaW9Db250ZXh0IG9yIGxlYXZlIGJsYW5rLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF1ZGlvUmF0ZT0xIFNwZWVkIGF0IHdoaWNoIHRvIHBsYXkgYXVkaW8uIExvd2VyIG51bWJlciBpc1xuICogc2xvd2VyLlxuICogQHByb3BlcnR5IHtTY3JpcHRQcm9jZXNzb3JOb2RlfSBhdWRpb1NjcmlwdFByb2Nlc3Nvcj1udWxsIFVzZSB5b3VyIG93biBwcmV2aW91c2x5XG4gKiBpbml0aWFsaXplZCBTY3JpcHRQcm9jZXNzb3JOb2RlIG9yIGxlYXZlIGJsYW5rLlxuICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvQ2VudGVyPXRydWUgSWYgYSBzY3JvbGxiYXIgaXMgcHJlc2VudCwgY2VudGVyIHRoZVxuICogd2F2ZWZvcm0gb24gY3VycmVudCBwcm9ncmVzc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGF1dG9DZW50ZXJSYXRlPTUgSWYgYXV0b0NlbnRlciBpcyBhY3RpdmUsIHJhdGUgYXQgd2hpY2ggdGhlXG4gKiB3YXZlZm9ybSBpcyBjZW50ZXJlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvQ2VudGVySW1tZWRpYXRlbHk9ZmFsc2UgSWYgYXV0b0NlbnRlciBpcyBhY3RpdmUsIGltbWVkaWF0ZWx5XG4gKiBjZW50ZXIgd2F2ZWZvcm0gb24gY3VycmVudCBwcm9ncmVzc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tlbmQ9J1dlYkF1ZGlvJyBgJ1dlYkF1ZGlvJ3wnTWVkaWFFbGVtZW50J3wnTWVkaWFFbGVtZW50V2ViQXVkaW8nYCBJbiBtb3N0IGNhc2VzXG4gKiB5b3UgZG9uJ3QgaGF2ZSB0byBzZXQgdGhpcyBtYW51YWxseS4gTWVkaWFFbGVtZW50IGlzIGEgZmFsbGJhY2sgZm9yIHVuc3VwcG9ydGVkIGJyb3dzZXJzLlxuICogTWVkaWFFbGVtZW50V2ViQXVkaW8gYWxsb3dzIHRvIHVzZSBXZWJBdWRpbyBBUEkgYWxzbyB3aXRoIGJpZyBhdWRpbyBmaWxlcywgbG9hZGluZyBhdWRpbyBsaWtlIHdpdGhcbiAqIE1lZGlhRWxlbWVudCBiYWNrZW5kIChIVE1MNSBhdWRpbyB0YWcpLiBZb3UgaGF2ZSB0byB1c2UgdGhlIHNhbWUgbWV0aG9kcyBvZiBNZWRpYUVsZW1lbnQgYmFja2VuZCBmb3IgbG9hZGluZyBhbmRcbiAqIHBsYXliYWNrLCBnaXZpbmcgYWxzbyBwZWFrcywgc28gdGhlIGF1ZGlvIGRhdGEgYXJlIG5vdCBkZWNvZGVkLiBJbiB0aGlzIHdheSB5b3UgY2FuIHVzZSBXZWJBdWRpbyBmZWF0dXJlcywgbGlrZSBmaWx0ZXJzLFxuICogYWxzbyB3aXRoIGF1ZGlvIHdpdGggYmlnIGR1cmF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqIGAgd2F2ZXN1cmZlci5sb2FkKHVybCB8IEhUTUxNZWRpYUVsZW1lbnQsIHBlYWtzLCBwcmVsb2FkLCBkdXJhdGlvbik7XG4gKiAgIHdhdmVzdXJmZXIucGxheSgpO1xuICogICB3YXZlc3VyZmVyLnNldEZpbHRlcihjdXN0b21GaWx0ZXIpO1xuICogYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvcj1udWxsIENoYW5nZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZVxuICogd2F2ZWZvcm0gY29udGFpbmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJhckhlaWdodD0xIFRoZSBoZWlnaHQgb2YgdGhlIHdhdmUgYmFycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYXJSYWRpdXM9MCBUaGUgcmFkaXVzIG9mIHRoZSB3YXZlIGJhcnMuIE1ha2VzIGJhcnMgcm91bmRlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJhckdhcD1udWxsIFRoZSBvcHRpb25hbCBzcGFjaW5nIGJldHdlZW4gYmFycyBvZiB0aGUgd2F2ZSxcbiAqIGlmIG5vdCBwcm92aWRlZCB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gbGVnYWN5IGZvcm1hdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYXJXaWR0aD1udWxsIERyYXcgdGhlIHdhdmVmb3JtIHVzaW5nIGJhcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmFyTWluSGVpZ2h0PW51bGwgSWYgc3BlY2lmaWVkLCBkcmF3IGF0IGxlYXN0IGEgYmFyIG9mIHRoaXMgaGVpZ2h0LFxuICogZWxpbWluYXRpbmcgd2F2ZWZvcm0gZ2Fwc1xuICogQHByb3BlcnR5IHtib29sZWFufSBjbG9zZUF1ZGlvQ29udGV4dD1mYWxzZSBDbG9zZSBhbmQgbnVsbGlmeSBhbGwgYXVkaW9cbiAqIGNvbnRleHRzIHdoZW4gdGhlIGRlc3Ryb3kgbWV0aG9kIGlzIGNhbGxlZC5cbiAqIEBwcm9wZXJ0eSB7IXN0cmluZ3xIVE1MRWxlbWVudH0gY29udGFpbmVyIENTUyBzZWxlY3RvciBvciBIVE1MIGVsZW1lbnQgd2hlcmVcbiAqIHRoZSB3YXZlZm9ybSBzaG91bGQgYmUgZHJhd24uIFRoaXMgaXMgdGhlIG9ubHkgcmVxdWlyZWQgcGFyYW1ldGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGN1cnNvckNvbG9yPScjMzMzJyBUaGUgZmlsbCBjb2xvciBvZiB0aGUgY3Vyc29yIGluZGljYXRpbmdcbiAqIHRoZSBwbGF5aGVhZCBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJzb3JXaWR0aD0xIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkcmF3aW5nQ29udGV4dEF0dHJpYnV0ZXM9e2Rlc3luY2hyb25pemVkOiBmYWxzZX0gRHJhd2luZyBjb250ZXh0XG4gKiBhdHRyaWJ1dGVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uPW51bGwgT3B0aW9uYWwgYXVkaW8gbGVuZ3RoIHNvIHByZS1yZW5kZXJlZCBwZWFrc1xuICogY2FuIGJlIGRpc3BsYXkgaW1tZWRpYXRlbHkgZm9yIGV4YW1wbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZpbGxQYXJlbnQ9dHJ1ZSBXaGV0aGVyIHRvIGZpbGwgdGhlIGVudGlyZSBjb250YWluZXIgb3JcbiAqIGRyYXcgb25seSBhY2NvcmRpbmcgdG8gYG1pblB4UGVyU2VjYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZm9yY2VEZWNvZGU9ZmFsc2UgRm9yY2UgZGVjb2Rpbmcgb2YgYXVkaW8gdXNpbmcgd2ViIGF1ZGlvXG4gKiB3aGVuIHpvb21pbmcgdG8gZ2V0IGEgbW9yZSBkZXRhaWxlZCB3YXZlZm9ybS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQ9MTI4IFRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtLiBNZWFzdXJlZCBpblxuICogcGl4ZWxzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBoaWRlU2Nyb2xsYmFyPWZhbHNlIFdoZXRoZXIgdG8gaGlkZSB0aGUgaG9yaXpvbnRhbFxuICogc2Nyb2xsYmFyIHdoZW4gb25lIHdvdWxkIG5vcm1hbGx5IGJlIHNob3duLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbnRlcmFjdD10cnVlIFdoZXRoZXIgdGhlIG1vdXNlIGludGVyYWN0aW9uIHdpbGwgYmVcbiAqIGVuYWJsZWQgYXQgaW5pdGlhbGl6YXRpb24uIFlvdSBjYW4gc3dpdGNoIHRoaXMgcGFyYW1ldGVyIGF0IGFueSB0aW1lIGxhdGVyXG4gKiBvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9vcFNlbGVjdGlvbj10cnVlIChVc2Ugd2l0aCByZWdpb25zIHBsdWdpbikgRW5hYmxlXG4gKiBsb29waW5nIG9mIHNlbGVjdGVkIHJlZ2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhDYW52YXNXaWR0aD00MDAwIE1heGltdW0gd2lkdGggb2YgYSBzaW5nbGUgY2FudmFzIGluXG4gKiBwaXhlbHMsIGV4Y2x1ZGluZyBhIHNtYWxsIG92ZXJsYXAgKDIgKiBgcGl4ZWxSYXRpb2AsIHJvdW5kZWQgdXAgdG8gdGhlIG5leHRcbiAqIGV2ZW4gaW50ZWdlcikuIElmIHRoZSB3YXZlZm9ybSBpcyBsb25nZXIgdGhhbiB0aGlzIHZhbHVlLCBhZGRpdGlvbmFsIGNhbnZhc2VzXG4gKiB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSB3YXZlZm9ybSwgd2hpY2ggaXMgdXNlZnVsIGZvciB2ZXJ5IGxhcmdlIHdhdmVmb3Jtc1xuICogdGhhdCBtYXkgYmUgdG9vIHdpZGUgZm9yIGJyb3dzZXJzIHRvIGRyYXcgb24gYSBzaW5nbGUgY2FudmFzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBtZWRpYUNvbnRyb2xzPWZhbHNlIChVc2Ugd2l0aCBiYWNrZW5kIGBNZWRpYUVsZW1lbnRgIG9yIGBNZWRpYUVsZW1lbnRXZWJBdWRpb2ApXG4gKiB0aGlzIGVuYWJsZXMgdGhlIG5hdGl2ZSBjb250cm9scyBmb3IgdGhlIG1lZGlhIGVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZWRpYVR5cGU9J2F1ZGlvJyAoVXNlIHdpdGggYmFja2VuZCBgTWVkaWFFbGVtZW50YCBvciBgTWVkaWFFbGVtZW50V2ViQXVkaW9gKVxuICogYCdhdWRpbyd8J3ZpZGVvJ2AgKCd2aWRlbycgb25seSBmb3IgYE1lZGlhRWxlbWVudGApXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluUHhQZXJTZWM9MjAgTWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIHBlciBzZWNvbmQgb2ZcbiAqIGF1ZGlvLlxuICogQHByb3BlcnR5IHtib29sZWFufSBub3JtYWxpemU9ZmFsc2UgSWYgdHJ1ZSwgbm9ybWFsaXplIGJ5IHRoZSBtYXhpbXVtIHBlYWtcbiAqIGluc3RlYWQgb2YgMS4wLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXJ0aWFsUmVuZGVyPWZhbHNlIFVzZSB0aGUgUGVha0NhY2hlIHRvIGltcHJvdmVcbiAqIHJlbmRlcmluZyBzcGVlZCBvZiBsYXJnZSB3YXZlZm9ybXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvPXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpbyB1c2VkIHRvXG4gKiBjYWxjdWxhdGUgZGlzcGxheVxuICogQHByb3BlcnR5IHtQbHVnaW5EZWZpbml0aW9uW119IHBsdWdpbnM9W10gQW4gYXJyYXkgb2YgcGx1Z2luIGRlZmluaXRpb25zIHRvXG4gKiByZWdpc3RlciBkdXJpbmcgaW5zdGFudGlhdGlvbiwgdGhleSB3aWxsIGJlIGRpcmVjdGx5IGluaXRpYWxpc2VkIHVubGVzcyB0aGV5XG4gKiBhcmUgYWRkZWQgd2l0aCB0aGUgYGRlZmVySW5pdGAgcHJvcGVydHkgc2V0IHRvIHRydWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvZ3Jlc3NDb2xvcj0nIzU1NScgVGhlIGZpbGwgY29sb3Igb2YgdGhlIHBhcnQgb2YgdGhlXG4gKiB3YXZlZm9ybSBiZWhpbmQgdGhlIGN1cnNvci4gV2hlbiBgcHJvZ3Jlc3NDb2xvcmAgYW5kIGB3YXZlQ29sb3JgIGFyZSB0aGUgc2FtZVxuICogdGhlIHByb2dyZXNzIHdhdmUgaXMgbm90IHJlbmRlcmVkIGF0IGFsbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95PXRydWUgU2V0IHRvIGZhbHNlIHRvIGtlZXAgdGhlXG4gKiBtZWRpYSBlbGVtZW50IGluIHRoZSBET00gd2hlbiB0aGUgcGxheWVyIGlzIGRlc3Ryb3llZC4gVGhpcyBpcyB1c2VmdWwgd2hlblxuICogcmV1c2luZyBhbiBleGlzdGluZyBtZWRpYSBlbGVtZW50IHZpYSB0aGUgYGxvYWRNZWRpYUVsZW1lbnRgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByZW5kZXJlcj1NdWx0aUNhbnZhcyBDYW4gYmUgdXNlZCB0byBpbmplY3QgYSBjdXN0b21cbiAqIHJlbmRlcmVyLlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gcmVzcG9uc2l2ZT1mYWxzZSBJZiBzZXQgdG8gYHRydWVgIHJlc2l6ZSB0aGVcbiAqIHdhdmVmb3JtLCB3aGVuIHRoZSB3aW5kb3cgaXMgcmVzaXplZC4gVGhpcyBpcyBkZWJvdW5jZWQgd2l0aCBhIGAxMDBtc2BcbiAqIHRpbWVvdXQgYnkgZGVmYXVsdC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgYSBudW1iZXIgaXQgcmVwcmVzZW50cyB0aGF0IHRpbWVvdXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJ0bD1mYWxzZSBJZiBzZXQgdG8gYHRydWVgLCByZW5kZXJzIHdhdmVmb3JtIGZyb21cbiAqIHJpZ2h0LXRvLWxlZnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNjcm9sbFBhcmVudD1mYWxzZSBXaGV0aGVyIHRvIHNjcm9sbCB0aGUgY29udGFpbmVyIHdpdGggYVxuICogbGVuZ3RoeSB3YXZlZm9ybS4gT3RoZXJ3aXNlIHRoZSB3YXZlZm9ybSBpcyBzaHJ1bmsgdG8gdGhlIGNvbnRhaW5lciB3aWR0aFxuICogKHNlZSBmaWxsUGFyZW50KS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lwTGVuZ3RoPTIgTnVtYmVyIG9mIHNlY29uZHMgdG8gc2tpcCB3aXRoIHRoZVxuICogc2tpcEZvcndhcmQoKSBhbmQgc2tpcEJhY2t3YXJkKCkgbWV0aG9kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3BsaXRDaGFubmVscz1mYWxzZSBSZW5kZXIgd2l0aCBzZXBhcmF0ZSB3YXZlZm9ybXMgZm9yXG4gKiB0aGUgY2hhbm5lbHMgb2YgdGhlIGF1ZGlvXG4gKiBAcHJvcGVydHkge1NwbGl0Q2hhbm5lbE9wdGlvbnN9IHNwbGl0Q2hhbm5lbHNPcHRpb25zPXt9IE9wdGlvbnMgZm9yIHNwbGl0Q2hhbm5lbCByZW5kZXJpbmdcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmVydGljYWw9ZmFsc2UgUmVuZGVyIHRoZSB3YXZlZm9ybSB2ZXJ0aWNhbGx5IGluc3RlYWQgb2YgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHdhdmVDb2xvcj0nIzk5OScgVGhlIGZpbGwgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGFmdGVyIHRoZVxuICogY3Vyc29yLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHhocj17fSBYSFIgb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiBgbGV0IHhociA9IHtcbiAqICAgICBjYWNoZTogJ2RlZmF1bHQnLFxuICogICAgIG1vZGU6ICdjb3JzJyxcbiAqICAgICBtZXRob2Q6ICdHRVQnLFxuICogICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICogICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAqICAgICByZWZlcnJlcjogJ2NsaWVudCcsXG4gKiAgICAgcmVxdWVzdEhlYWRlcnM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgICAga2V5OiAnQXV0aG9yaXphdGlvbicsXG4gKiAgICAgICAgICAgICB2YWx1ZTogJ215LXRva2VuJ1xuICogICAgICAgICB9XG4gKiAgICAgXVxuICogfTtgXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQbHVnaW5EZWZpbml0aW9uXG4gKiBAZGVzYyBUaGUgT2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBwbHVnaW5cbiAqIEBleGFtcGxlIHdhdmVzdXJmZXIuYWRkUGx1Z2luKHBsdWdpbkRlZmluaXRpb24pO1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiwgdGhlIHBsdWdpbiBpbnN0YW5jZSB3aWxsIGJlXG4gKiBhZGRlZCBhcyBhIHByb3BlcnR5IHRvIHRoZSB3YXZlc3VyZmVyIGluc3RhbmNlIHVuZGVyIHRoaXMgbmFtZVxuICogQHByb3BlcnR5IHs/T2JqZWN0fSBzdGF0aWNQcm9wcyBUaGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGVcbiAqIHdhdmVzdXJmZXIgaW5zdGFuY2UgYXMgc3RhdGljIHByb3BlcnRpZXNcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRlZmVySW5pdCBEb24ndCBpbml0aWFsaXNlIHBsdWdpblxuICogYXV0b21hdGljYWxseVxuICogQHByb3BlcnR5IHtPYmplY3R9IHBhcmFtcz17fSBUaGUgcGx1Z2luIHBhcmFtZXRlcnMsIHRoZXkgYXJlIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAqIHBhc3NlZCB0byB0aGUgcGx1Z2luIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge1BsdWdpbkNsYXNzfSBpbnN0YW5jZSBUaGUgcGx1Z2luIGluc3RhbmNlIGZhY3RvcnksIGlzIGNhbGxlZCB3aXRoXG4gKiB0aGUgZGVwZW5kZW5jeSBzcGVjaWZpZWQgaW4gZXh0ZW5kcy4gUmV0dXJucyB0aGUgcGx1Z2luIGNsYXNzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3BsaXRDaGFubmVsT3B0aW9uc1xuICogQGRlc2MgcGFyYW1ldGVycyBhcHBsaWVkIHdoZW4gc3BsaXRDaGFubmVscyBvcHRpb24gaXMgdHJ1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvdmVybGF5PWZhbHNlIGRldGVybWluZXMgd2hldGhlciBjaGFubmVscyBhcmUgcmVuZGVyZWQgb24gdG9wIG9mIGVhY2ggb3RoZXIgb3Igb24gc2VwYXJhdGUgdHJhY2tzXG4gKiBAcHJvcGVydHkge29iamVjdH0gY2hhbm5lbENvbG9ycz17fSBvYmplY3QgZGVzY3JpYmluZyBjb2xvciBmb3IgZWFjaCBjaGFubmVsLiBFeGFtcGxlOlxuICoge1xuICogICAgIDA6IHtcbiAqICAgICAgICAgcHJvZ3Jlc3NDb2xvcjogJ2dyZWVuJyxcbiAqICAgICAgICAgd2F2ZUNvbG9yOiAncGluaydcbiAqICAgICB9LFxuICogICAgIDE6IHtcbiAqICAgICAgICAgcHJvZ3Jlc3NDb2xvcjogJ29yYW5nZScsXG4gKiAgICAgICAgIHdhdmVDb2xvcjogJ3B1cnBsZSdcbiAqICAgICB9XG4gKiB9XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBmaWx0ZXJDaGFubmVscz1bXSBpbmRleGVzIG9mIGNoYW5uZWxzIHRvIGJlIGhpZGRlbiBmcm9tIHJlbmRlcmluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSByZWxhdGl2ZU5vcm1hbGl6YXRpb249ZmFsc2UgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gKiBub3JtYWxpemF0aW9uIGlzIGRvbmUgcGVyIGNoYW5uZWwgb3IgbWFpbnRhaW5zIHByb3BvcnRpb25hbGl0eSBiZXR3ZWVuXG4gKiBjaGFubmVscy4gT25seSBhcHBsaWVkIHdoZW4gbm9ybWFsaXplIGFuZCBzcGxpdENoYW5uZWxzIGFyZSBib3RoIHRydWUuXG4gKiBAc2luY2UgNC4zLjBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgUGx1Z2luQ2xhc3NcbiAqXG4gKiBAZGVzYyBUaGlzIGlzIHRoZSBpbnRlcmZhY2Ugd2hpY2ggaXMgaW1wbGVtZW50ZWQgYnkgYWxsIHBsdWdpbiBjbGFzc2VzLiBOb3RlXG4gKiB0aGF0IHRoaXMgb25seSB0dXJucyBpbnRvIGFuIG9ic2VydmVyIGFmdGVyIGJlaW5nIHBhc3NlZCB0aHJvdWdoXG4gKiBgd2F2ZXN1cmZlci5hZGRQbHVnaW5gLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqL1xudmFyIFBsdWdpbkNsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgcGx1Z2luXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXM9e30gVGhlIHBsdWdpbiBwYXJhbXMgKHNwZWNpZmljIHRvIHRoZSBwbHVnaW4pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3cyBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUGx1Z2luQ2xhc3MocGFyYW1zLCB3cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW5DbGFzcyk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIHBsdWdpblxuICAgKlxuICAgKiBTdGFydCBkb2luZyBzb21ldGhpbmcuIFRoaXMgaXMgY2FsbGVkIGJ5XG4gICAqIGB3YXZlc3VyZmVyLmluaXRQbHVnaW4ocGx1Z2luTmFtZSlgXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBsdWdpbkNsYXNzLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBQbHVnaW4gZGVmaW5pdGlvbiBmYWN0b3J5XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBjcmVhdGUgYSBwbHVnaW4gZGVmaW5pdGlvbiB3aGljaCBjYW4gYmVcbiAgICAgKiB1c2VkIGJ5IHdhdmVzdXJmZXIgdG8gY29ycmVjdGx5IGluc3RhbnRpYXRlIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGEgYFBsdWdpbkRlZmluaXRpb25gIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXM9e30gVGhlIHBsdWdpbiBwYXJhbXMgKHNwZWNpZmljIHRvIHRoZSBwbHVnaW4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHBhcmFtcykge31cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgICAqXG4gICAgICogU3RvcCBkb2luZyBzb21ldGhpbmcuIFRoaXMgaXMgY2FsbGVkIGJ5XG4gICAgICogYHdhdmVzdXJmZXIuZGVzdHJveVBsdWdpbihwbHVnaW5OYW1lKWBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gUGx1Z2luQ2xhc3M7XG59KCk7XG4vKipcbiAqIFdhdmVTdXJmZXIgY29yZSBsaWJyYXJ5IGNsYXNzXG4gKlxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHBhcmFtcyA9IHtcbiAqICAgY29udGFpbmVyOiAnI3dhdmVmb3JtJyxcbiAqICAgd2F2ZUNvbG9yOiAndmlvbGV0JyxcbiAqICAgcHJvZ3Jlc3NDb2xvcjogJ3B1cnBsZSdcbiAqIH07XG4gKlxuICogLy8gaW5pdGlhbGlzZSBsaWtlIHRoaXNcbiAqIGNvbnN0IHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZShwYXJhbXMpO1xuICpcbiAqIC8vIG9yIGxpa2UgdGhpcyAuLi5cbiAqIGNvbnN0IHdhdmVzdXJmZXIgPSBuZXcgV2F2ZVN1cmZlcihwYXJhbXMpO1xuICogd2F2ZXN1cmZlci5pbml0KCk7XG4gKlxuICogLy8gbG9hZCBhdWRpbyBmaWxlXG4gKiB3YXZlc3VyZmVyLmxvYWQoJ2V4YW1wbGUvbWVkaWEvZGVtby53YXYnKTtcbiAqL1xuXG5cbnZhciBXYXZlU3VyZmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfdXRpbCRPYnNlcnZlcikge1xuICBfaW5oZXJpdHMoV2F2ZVN1cmZlciwgX3V0aWwkT2JzZXJ2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV2F2ZVN1cmZlcik7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpc2Ugd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1dhdmVzdXJmZXJQYXJhbXN9IHBhcmFtcyBJbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIHdhdmVzdXJmZXJcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2F2ZXN1cmZlciA9IG5ldyBXYXZlU3VyZmVyKHBhcmFtcyk7XG4gICAqIEByZXR1cm5zIHt0aGlzfSBXYXZlc3VyZmVyIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBXYXZlU3VyZmVyKHBhcmFtcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYXZlU3VyZmVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCByZWxldmFudCBwYXJhbWV0ZXJzIChvciBkZWZhdWx0cylcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgX3RoaXMuZGVmYXVsdFBhcmFtcyA9IHtcbiAgICAgIGF1ZGlvQ29udGV4dDogbnVsbCxcbiAgICAgIGF1ZGlvU2NyaXB0UHJvY2Vzc29yOiBudWxsLFxuICAgICAgYXVkaW9SYXRlOiAxLFxuICAgICAgYXV0b0NlbnRlcjogdHJ1ZSxcbiAgICAgIGF1dG9DZW50ZXJSYXRlOiA1LFxuICAgICAgYXV0b0NlbnRlckltbWVkaWF0ZWx5OiBmYWxzZSxcbiAgICAgIGJhY2tlbmQ6ICdXZWJBdWRpbycsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gICAgICBiYXJIZWlnaHQ6IDEsXG4gICAgICBiYXJSYWRpdXM6IDAsXG4gICAgICBiYXJHYXA6IG51bGwsXG4gICAgICBiYXJNaW5IZWlnaHQ6IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBjdXJzb3JDb2xvcjogJyMzMzMnLFxuICAgICAgY3Vyc29yV2lkdGg6IDEsXG4gICAgICBkcmFnU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZHJhd2luZ0NvbnRleHRBdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIEJvb2xlYW4gdGhhdCBoaW50cyB0aGUgdXNlciBhZ2VudCB0byByZWR1Y2UgdGhlIGxhdGVuY3lcbiAgICAgICAgLy8gYnkgZGVzeW5jaHJvbml6aW5nIHRoZSBjYW52YXMgcGFpbnQgY3ljbGUgZnJvbSB0aGUgZXZlbnRcbiAgICAgICAgLy8gbG9vcFxuICAgICAgICBkZXN5bmNocm9uaXplZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAgIGZpbGxQYXJlbnQ6IHRydWUsXG4gICAgICBmb3JjZURlY29kZTogZmFsc2UsXG4gICAgICBoZWlnaHQ6IDEyOCxcbiAgICAgIGhpZGVTY3JvbGxiYXI6IGZhbHNlLFxuICAgICAgaW50ZXJhY3Q6IHRydWUsXG4gICAgICBsb29wU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgbWF4Q2FudmFzV2lkdGg6IDQwMDAsXG4gICAgICBtZWRpYUNvbnRhaW5lcjogbnVsbCxcbiAgICAgIG1lZGlhQ29udHJvbHM6IGZhbHNlLFxuICAgICAgbWVkaWFUeXBlOiAnYXVkaW8nLFxuICAgICAgbWluUHhQZXJTZWM6IDIwLFxuICAgICAgbm9ybWFsaXplOiBmYWxzZSxcbiAgICAgIHBhcnRpYWxSZW5kZXI6IGZhbHNlLFxuICAgICAgcGl4ZWxSYXRpbzogd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgc2NyZWVuLmRldmljZVhEUEkgLyBzY3JlZW4ubG9naWNhbFhEUEksXG4gICAgICBwbHVnaW5zOiBbXSxcbiAgICAgIHByb2dyZXNzQ29sb3I6ICcjNTU1JyxcbiAgICAgIHJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlbmRlcmVyOiBfZHJhd2VyLmRlZmF1bHQsXG4gICAgICByZXNwb25zaXZlOiBmYWxzZSxcbiAgICAgIHJ0bDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnQ6IGZhbHNlLFxuICAgICAgc2tpcExlbmd0aDogMixcbiAgICAgIHNwbGl0Q2hhbm5lbHM6IGZhbHNlLFxuICAgICAgc3BsaXRDaGFubmVsc09wdGlvbnM6IHtcbiAgICAgICAgb3ZlcmxheTogZmFsc2UsXG4gICAgICAgIGNoYW5uZWxDb2xvcnM6IHt9LFxuICAgICAgICBmaWx0ZXJDaGFubmVsczogW10sXG4gICAgICAgIHJlbGF0aXZlTm9ybWFsaXphdGlvbjogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgICB3YXZlQ29sb3I6ICcjOTk5JyxcbiAgICAgIHhocjoge31cbiAgICB9O1xuICAgIF90aGlzLmJhY2tlbmRzID0ge1xuICAgICAgTWVkaWFFbGVtZW50OiBfbWVkaWFlbGVtZW50LmRlZmF1bHQsXG4gICAgICBXZWJBdWRpbzogX3dlYmF1ZGlvLmRlZmF1bHQsXG4gICAgICBNZWRpYUVsZW1lbnRXZWJBdWRpbzogX21lZGlhZWxlbWVudFdlYmF1ZGlvLmRlZmF1bHRcbiAgICB9O1xuICAgIF90aGlzLnV0aWwgPSB1dGlsO1xuICAgIF90aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIF90aGlzLmRlZmF1bHRQYXJhbXMsIHBhcmFtcyk7XG4gICAgX3RoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMuZGVmYXVsdFBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucywgcGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmNvbnRhaW5lciA9ICdzdHJpbmcnID09IHR5cGVvZiBwYXJhbXMuY29udGFpbmVyID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5wYXJhbXMuY29udGFpbmVyKSA6IF90aGlzLnBhcmFtcy5jb250YWluZXI7XG5cbiAgICBpZiAoIV90aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250YWluZXIgZWxlbWVudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMucGFyYW1zLm1lZGlhQ29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX3RoaXMubWVkaWFDb250YWluZXIgPSBfdGhpcy5jb250YWluZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoaXMucGFyYW1zLm1lZGlhQ29udGFpbmVyID09ICdzdHJpbmcnKSB7XG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF90aGlzLm1lZGlhQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5wYXJhbXMubWVkaWFDb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF90aGlzLm1lZGlhQ29udGFpbmVyID0gX3RoaXMucGFyYW1zLm1lZGlhQ29udGFpbmVyO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMubWVkaWFDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVkaWEgQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLnBhcmFtcy5tYXhDYW52YXNXaWR0aCA8PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heENhbnZhc1dpZHRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICB9IGVsc2UgaWYgKF90aGlzLnBhcmFtcy5tYXhDYW52YXNXaWR0aCAlIDIgPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhDYW52YXNXaWR0aCBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLnBhcmFtcy5ydGwgPT09IHRydWUpIHtcbiAgICAgIGlmIChfdGhpcy5wYXJhbXMudmVydGljYWwgPT09IHRydWUpIHtcbiAgICAgICAgdXRpbC5zdHlsZShfdGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGVYKDE4MGRlZyknXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5zdHlsZShfdGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGVZKDE4MGRlZyknXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfdGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBfdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoX3RoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIFVzZWQgdG8gc2F2ZSB0aGUgY3VycmVudCB2b2x1bWUgd2hlbiBtdXRpbmcgc28gd2UgY2FuXG4gICAgICogcmVzdG9yZSBvbmNlIHVubXV0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG5cbiAgICBfdGhpcy5zYXZlZFZvbHVtZSA9IDA7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgVGhlIGN1cnJlbnQgbXV0ZWQgc3RhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIF90aGlzLmlzTXV0ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBXaWxsIGhvbGQgYSBsaXN0IG9mIGV2ZW50IGRlc2NyaXB0b3JzIHRoYXQgbmVlZCB0byBiZVxuICAgICAqIGNhbmNlbGVkIG9uIHN1YnNlcXVlbnQgbG9hZHMgb2YgYXVkaW9cbiAgICAgKiBAdHlwZSB7T2JqZWN0W119XG4gICAgICovXG5cbiAgICBfdGhpcy50bXBFdmVudHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBIb2xkcyBhbnkgcnVubmluZyBhdWRpbyBkb3dubG9hZHNcbiAgICAgKiBAdHlwZSB7T2JzZXJ2ZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5jdXJyZW50UmVxdWVzdCA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5hcnJheWJ1ZmZlciA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5kcmF3ZXIgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuYmFja2VuZCA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5wZWFrQ2FjaGUgPSBudWxsOyAvLyBjYWNoZSBjb25zdHJ1Y3RvciBvYmplY3RzXG5cbiAgICBpZiAodHlwZW9mIF90aGlzLnBhcmFtcy5yZW5kZXJlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlciBwYXJhbWV0ZXIgaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBUaGUgdW5pbml0aWFsaXNlZCBEcmF3ZXIgY2xhc3NcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuRHJhd2VyID0gX3RoaXMucGFyYW1zLnJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIFRoZSB1bmluaXRpYWxpc2VkIEJhY2tlbmQgY2xhc3NcbiAgICAgKi9cbiAgICAvLyBCYWNrIGNvbXBhdFxuXG4gICAgaWYgKF90aGlzLnBhcmFtcy5iYWNrZW5kID09ICdBdWRpb0VsZW1lbnQnKSB7XG4gICAgICBfdGhpcy5wYXJhbXMuYmFja2VuZCA9ICdNZWRpYUVsZW1lbnQnO1xuICAgIH1cblxuICAgIGlmICgoX3RoaXMucGFyYW1zLmJhY2tlbmQgPT0gJ1dlYkF1ZGlvJyB8fCBfdGhpcy5wYXJhbXMuYmFja2VuZCA9PT0gJ01lZGlhRWxlbWVudFdlYkF1ZGlvJykgJiYgIV93ZWJhdWRpby5kZWZhdWx0LnByb3RvdHlwZS5zdXBwb3J0c1dlYkF1ZGlvLmNhbGwobnVsbCkpIHtcbiAgICAgIF90aGlzLnBhcmFtcy5iYWNrZW5kID0gJ01lZGlhRWxlbWVudCc7XG4gICAgfVxuXG4gICAgX3RoaXMuQmFja2VuZCA9IF90aGlzLmJhY2tlbmRzW190aGlzLnBhcmFtcy5iYWNrZW5kXTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBtYXAgb2YgcGx1Z2luIG5hbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbml0aWFsaXNlZFxuICAgICAqL1xuXG4gICAgX3RoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0ID0ge307XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCByZWFkeSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBjb25zdCBpc1JlYWR5ID0gd2F2ZXN1cmZlci5pc1JlYWR5O1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBfdGhpcy5pc1JlYWR5ID0gZmFsc2U7IC8vIHJlc3BvbnNpdmUgZGVib3VuY2VkIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGlzLnBhcmFtcy5yZXNwb25zaXZlIGlzIG5vdFxuICAgIC8vIHNldCwgdGhpcyBpcyBuZXZlciBjYWxsZWQuIFVzZSAxMDBtcyBvciB0aGlzLnBhcmFtcy5yZXNwb25zaXZlIGFzXG4gICAgLy8gdGltZW91dCBmb3IgdGhlIGRlYm91bmNlIGZ1bmN0aW9uLlxuXG4gICAgdmFyIHByZXZXaWR0aCA9IDA7XG4gICAgX3RoaXMuX29uUmVzaXplID0gdXRpbC5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJldldpZHRoICE9IF90aGlzLmRyYXdlci53cmFwcGVyLmNsaWVudFdpZHRoICYmICFfdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHByZXZXaWR0aCA9IF90aGlzLmRyYXdlci53cmFwcGVyLmNsaWVudFdpZHRoO1xuXG4gICAgICAgIF90aGlzLmRyYXdlci5maXJlRXZlbnQoJ3JlZHJhdycpO1xuICAgICAgfVxuICAgIH0sIHR5cGVvZiBfdGhpcy5wYXJhbXMucmVzcG9uc2l2ZSA9PT0gJ251bWJlcicgPyBfdGhpcy5wYXJhbXMucmVzcG9uc2l2ZSA6IDEwMCk7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgdGhlIHdhdmVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHdhdmVzdXJmZXIgPSBuZXcgV2F2ZVN1cmZlcihwYXJhbXMpO1xuICAgKiB3YXZlc3VyZmVyLmluaXQoKTtcbiAgICogQHJldHVybiB7dGhpc30gVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoV2F2ZVN1cmZlciwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnModGhpcy5wYXJhbXMucGx1Z2lucyk7XG4gICAgICB0aGlzLmNyZWF0ZURyYXdlcigpO1xuICAgICAgdGhpcy5jcmVhdGVCYWNrZW5kKCk7XG4gICAgICB0aGlzLmNyZWF0ZVBlYWtDYWNoZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbmQgaW5pdGlhbGlzZSBhcnJheSBvZiBwbHVnaW5zIChpZiBgcGx1Z2luLmRlZmVySW5pdGAgaXMgZmFsc2V5KSxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiB0aGUgaW5pdCBmdW5jdGlvbiBvZiB3YXZlc3VyZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsdWdpbkRlZmluaXRpb25bXX0gcGx1Z2lucyBBbiBhcnJheSBvZiBwbHVnaW4gZGVmaW5pdGlvbnNcbiAgICAgKiBAZW1pdHMge1dhdmVTdXJmZXIjcGx1Z2lucy1yZWdpc3RlcmVkfSBDYWxsZWQgd2l0aCB0aGUgYXJyYXkgb2YgcGx1Z2luIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybiB7dGhpc30gVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyUGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbnMocGx1Z2lucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGZpcnN0IGluc3RhbnRpYXRlIGFsbCB0aGUgcGx1Z2luc1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5hZGRQbHVnaW4ocGx1Z2luKTtcbiAgICAgIH0pOyAvLyBub3cgcnVuIHRoZSBpbml0IGZ1bmN0aW9uc1xuXG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAvLyBjYWxsIGluaXQgZnVuY3Rpb24gb2YgdGhlIHBsdWdpbiBpZiBkZWZlckluaXQgaXMgZmFsc2V5XG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB5b3Ugd291bGQgbWFudWFsbHkgdXNlIGluaXRQbHVnaW5zKClcbiAgICAgICAgaWYgKCFwbHVnaW4uZGVmZXJJbml0KSB7XG4gICAgICAgICAgX3RoaXMyLmluaXRQbHVnaW4ocGx1Z2luLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbHVnaW5zLXJlZ2lzdGVyZWQnLCBwbHVnaW5zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBtYXAgb2YgcGx1Z2luIG5hbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbml0aWFsaXNlZFxuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5nZXRQbHVnaW5zKCk7XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBwbHVnaW4gbmFtZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZVBsdWdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlUGx1Z2lucygpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcGx1Z2luIG9iamVjdCB0byB3YXZlc3VyZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsdWdpbkRlZmluaXRpb259IHBsdWdpbiBBIHBsdWdpbiBkZWZpbml0aW9uXG4gICAgICogQGVtaXRzIHtXYXZlU3VyZmVyI3BsdWdpbi1hZGRlZH0gQ2FsbGVkIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0aGF0IHdhcyBhZGRlZFxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuYWRkUGx1Z2luKFdhdmVTdXJmZXIubWluaW1hcCgpKTtcbiAgICAgKiBAcmV0dXJuIHt0aGlzfSBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGx1Z2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXBsdWdpbi5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIGRvZXMgbm90IGhhdmUgYSBuYW1lIScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBsdWdpbi5pbnN0YW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5uYW1lLCBcIiBkb2VzIG5vdCBoYXZlIGFuIGluc3RhbmNlIHByb3BlcnR5IVwiKSk7XG4gICAgICB9IC8vIHN0YXRpY1Byb3BzIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gd2F2ZXN1cmZlciBpbnN0YW5jZVxuXG5cbiAgICAgIGlmIChwbHVnaW4uc3RhdGljUHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGx1Z2luLnN0YXRpY1Byb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5TdGF0aWNQcm9wKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUHJvcGVydGllcyBkZWZpbmVkIGluIGEgcGx1Z2luIGRlZmluaXRpb24ncyBgc3RhdGljUHJvcHNgIHByb3BlcnR5IGFyZSBhZGRlZCBhc1xuICAgICAgICAgICAqIHN0YXRpY1Byb3BzIHByb3BlcnRpZXMgb2YgdGhlIFdhdmVTdXJmZXIgaW5zdGFuY2VcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpczNbcGx1Z2luU3RhdGljUHJvcF0gPSBwbHVnaW4uc3RhdGljUHJvcHNbcGx1Z2luU3RhdGljUHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgSW5zdGFuY2UgPSBwbHVnaW4uaW5zdGFuY2U7IC8vIHR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZSBpbnRvIGFuIG9ic2VydmVyXG5cbiAgICAgIHZhciBvYnNlcnZlclByb3RvdHlwZUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh1dGlsLk9ic2VydmVyLnByb3RvdHlwZSk7XG4gICAgICBvYnNlcnZlclByb3RvdHlwZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIEluc3RhbmNlLnByb3RvdHlwZVtrZXldID0gdXRpbC5PYnNlcnZlci5wcm90b3R5cGVba2V5XTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBJbnN0YW50aWF0ZWQgcGx1Z2luIGNsYXNzZXMgYXJlIGFkZGVkIGFzIGEgcHJvcGVydHkgb2YgdGhlIHdhdmVzdXJmZXJcbiAgICAgICAqIGluc3RhbmNlXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG5cbiAgICAgIHRoaXNbcGx1Z2luLm5hbWVdID0gbmV3IEluc3RhbmNlKHBsdWdpbi5wYXJhbXMgfHwge30sIHRoaXMpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsdWdpbi1hZGRlZCcsIHBsdWdpbi5uYW1lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIGEgcGx1Z2luXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHBsdWdpbiBuYW1lXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjcGx1Z2luLWluaXRpYWxpc2VkXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5pbml0UGx1Z2luKCdtaW5pbWFwJyk7XG4gICAgICogQHJldHVybiB7dGhpc30gVGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRQbHVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBsdWdpbihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChuYW1lLCBcIiBoYXMgbm90IGJlZW4gYWRkZWQgeWV0IVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtuYW1lXSkge1xuICAgICAgICAvLyBkZXN0cm95IGFueSBhbHJlYWR5IGluaXRpYWxpc2VkIHBsdWdpbnNcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW25hbWVdLmluaXQoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W25hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbHVnaW4taW5pdGlhbGlzZWQnLCBuYW1lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGEgcGx1Z2luXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHBsdWdpbiBuYW1lXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjcGx1Z2luLWRlc3Ryb3llZFxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuZGVzdHJveVBsdWdpbignbWluaW1hcCcpO1xuICAgICAqIEByZXR1cm5zIHt0aGlzfSBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVBsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95UGx1Z2luKG5hbWUpIHtcbiAgICAgIGlmICghdGhpc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KG5hbWUsIFwiIGhhcyBub3QgYmVlbiBhZGRlZCB5ZXQgYW5kIGNhbm5vdCBiZSBkZXN0cm95ZWQhXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KG5hbWUsIFwiIGlzIG5vdCBhY3RpdmUgYW5kIGNhbm5vdCBiZSBkZXN0cm95ZWQhXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChuYW1lLCBcIiBkb2VzIG5vdCBoYXZlIGEgZGVzdHJveSBmdW5jdGlvbiFcIikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW25hbWVdLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdFtuYW1lXTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbHVnaW4tZGVzdHJveWVkJywgbmFtZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbGwgaW5pdGlhbGlzZWQgcGx1Z2lucy4gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gdXNlIHdoZW5cbiAgICAgKiB3YXZlc3VyZmVyIGlzIHJlbW92ZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95QWxsUGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95QWxsUGx1Z2lucygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LmRlc3Ryb3lQbHVnaW4obmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBkcmF3ZXIgYW5kIGRyYXcgdGhlIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2RyYXdlci1jcmVhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVEcmF3ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRHJhd2VyKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZHJhd2VyID0gbmV3IHRoaXMuRHJhd2VyKHRoaXMuY29udGFpbmVyLCB0aGlzLnBhcmFtcyk7XG4gICAgICB0aGlzLmRyYXdlci5pbml0KCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnZHJhd2VyLWNyZWF0ZWQnLCB0aGlzLmRyYXdlcik7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRydWUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd2VyLm9uKCdyZWRyYXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5kcmF3QnVmZmVyKCk7XG5cbiAgICAgICAgX3RoaXM1LmRyYXdlci5wcm9ncmVzcyhfdGhpczUuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKTtcbiAgICAgIH0pOyAvLyBDbGljay10by1zZWVrXG5cbiAgICAgIHRoaXMuZHJhd2VyLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlLCBwcm9ncmVzcykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNlZWtUbyhwcm9ncmVzcyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7IC8vIFJlbGF5IHRoZSBzY3JvbGwgZXZlbnQgZnJvbSB0aGUgZHJhd2VyXG5cbiAgICAgIHRoaXMuZHJhd2VyLm9uKCdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoX3RoaXM1LnBhcmFtcy5wYXJ0aWFsUmVuZGVyKSB7XG4gICAgICAgICAgX3RoaXM1LmRyYXdCdWZmZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNS5maXJlRXZlbnQoJ3Njcm9sbCcsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgYmFja2VuZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNiYWNrZW5kLWNyZWF0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUJhY2tlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQmFja2VuZCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5iYWNrZW5kKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFja2VuZCA9IG5ldyB0aGlzLkJhY2tlbmQodGhpcy5wYXJhbXMpO1xuICAgICAgdGhpcy5iYWNrZW5kLmluaXQoKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdiYWNrZW5kLWNyZWF0ZWQnLCB0aGlzLmJhY2tlbmQpO1xuICAgICAgdGhpcy5iYWNrZW5kLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi5kcmF3ZXIucHJvZ3Jlc3MoX3RoaXM2LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSk7XG5cbiAgICAgICAgX3RoaXM2LmZpcmVFdmVudCgnZmluaXNoJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYmFja2VuZC5vbigncGxheScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYWNrZW5kLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5maXJlRXZlbnQoJ3BhdXNlJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYmFja2VuZC5vbignYXVkaW9wcm9jZXNzJywgZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgX3RoaXM2LmRyYXdlci5wcm9ncmVzcyhfdGhpczYuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKTtcblxuICAgICAgICBfdGhpczYuZmlyZUV2ZW50KCdhdWRpb3Byb2Nlc3MnLCB0aW1lKTtcbiAgICAgIH0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgTWVkaWFFbGVtZW50IGFuZCBNZWRpYUVsZW1lbnRXZWJBdWRpbyBiYWNrZW5kXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5iYWNrZW5kID09PSAnTWVkaWFFbGVtZW50JyB8fCB0aGlzLnBhcmFtcy5iYWNrZW5kID09PSAnTWVkaWFFbGVtZW50V2ViQXVkaW8nKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5vbignc2VlaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYuZHJhd2VyLnByb2dyZXNzKF90aGlzNi5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYWNrZW5kLm9uKCd2b2x1bWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5ld1ZvbHVtZSA9IF90aGlzNi5nZXRWb2x1bWUoKTtcblxuICAgICAgICAgIF90aGlzNi5maXJlRXZlbnQoJ3ZvbHVtZScsIG5ld1ZvbHVtZSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXM2LmJhY2tlbmQuaXNNdXRlZCAhPT0gX3RoaXM2LmlzTXV0ZWQpIHtcbiAgICAgICAgICAgIF90aGlzNi5pc011dGVkID0gX3RoaXM2LmJhY2tlbmQuaXNNdXRlZDtcblxuICAgICAgICAgICAgX3RoaXM2LmZpcmVFdmVudCgnbXV0ZScsIF90aGlzNi5pc011dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHBlYWsgY2FjaGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQZWFrQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGVha0NhY2hlKCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLnBhcnRpYWxSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5wZWFrQ2FjaGUgPSBuZXcgX3BlYWtjYWNoZS5kZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvIGNsaXBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNvbnN0IGR1cmF0aW9uID0gd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldER1cmF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY29uc3QgY3VycmVudFRpbWUgPSB3YXZlc3VyZmVyLmdldEN1cnJlbnRUaW1lKCk7XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBQbGF5YmFjayBwb3NpdGlvbiBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0Q3VycmVudFRpbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHBsYXkgdGltZSBpbiBzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgQSBwb3NpdGl2ZSBudW1iZXIgaW4gc2Vjb25kcy4gRS5nLiAxMCBtZWFucyAxMFxuICAgICAqIHNlY29uZHMsIDYwIG1lYW5zIDEgbWludXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJyZW50VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgICBpZiAoc2Vjb25kcyA+PSB0aGlzLmdldER1cmF0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5zZWVrVG8oMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlZWtUbyhzZWNvbmRzIC8gdGhpcy5nZXREdXJhdGlvbigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBsYXliYWNrIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uIE9wdGlvbmFsIHN0YXJ0IGFuZCBlbmRcbiAgICAgKiBtZWFzdXJlZCBpbiBzZWNvbmRzIGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgcmFuZ2Ugb2YgYXVkaW8gdG8gcGxheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3RhcnQgUG9zaXRpb24gdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGVuZCBQb3NpdGlvbiB0byBlbmQgYXRcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNpbnRlcmFjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc3VsdCBvZiB0aGUgYmFja2VuZCBwbGF5IG1ldGhvZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcGxheSBmcm9tIHNlY29uZCAxIHRvIDVcbiAgICAgKiB3YXZlc3VyZmVyLnBsYXkoMSwgNSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdpbnRlcmFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5wbGF5KHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnBsYXkoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHBvaW50IGluIHNlY29uZHMgZm9yIHBsYXliYWNrIHRvIHN0b3AgYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gUG9zaXRpb24gKGluIHNlY29uZHMpIHRvIHN0b3AgYXRcbiAgICAgKiBAdmVyc2lvbiAzLjMuMFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5RW5kKHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuc2V0UGxheUVuZChwb3NpdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBwYXVzZXMgcGxheWJhY2tcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIucGF1c2UoKTtcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXN1bHQgb2YgdGhlIGJhY2tlbmQgcGF1c2UgbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIGlmICghdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgcGxheWJhY2tcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIucGxheVBhdXNlKCk7XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzdWx0IG9mIHRoZSBiYWNrZW5kIHBsYXkgb3IgcGF1c2UgbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5UGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheVBhdXNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5pc1BhdXNlZCgpID8gdGhpcy5wbGF5KCkgOiB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBwbGF5YmFjayBzdGF0ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY29uc3QgaXNQbGF5aW5nID0gd2F2ZXN1cmZlci5pc1BsYXlpbmcoKTtcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBwYXVzZWQsIHRydWUgaWYgcGxheWluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQbGF5aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICAgIHJldHVybiAhdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgYmFja3dhcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc2Vjb25kcyBBbW91bnQgdG8gc2tpcCBiYWNrLCBpZiBub3Qgc3BlY2lmaWVkIGBza2lwTGVuZ3RoYFxuICAgICAqIGlzIHVzZWRcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNraXBCYWNrd2FyZCgpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2tpcEJhY2t3YXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBCYWNrd2FyZChzZWNvbmRzKSB7XG4gICAgICB0aGlzLnNraXAoLXNlY29uZHMgfHwgLXRoaXMucGFyYW1zLnNraXBMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIGZvcndhcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gc2Vjb25kcyBBbW91bnQgdG8gc2tpcCBiYWNrLCBpZiBub3Qgc3BlY2lmaWVkIGBza2lwTGVuZ3RoYFxuICAgICAqIGlzIHVzZWRcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNraXBGb3J3YXJkKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJza2lwRm9yd2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwRm9yd2FyZChzZWNvbmRzKSB7XG4gICAgICB0aGlzLnNraXAoc2Vjb25kcyB8fCB0aGlzLnBhcmFtcy5za2lwTGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBhIG51bWJlciBvZiBzZWNvbmRzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gKHVzZSBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICogdG8gZ28gYmFja3dhcmRzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgQW1vdW50IHRvIHNraXAgYmFjayBvciBmb3J3YXJkc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ28gYmFjayAyIHNlY29uZHNcbiAgICAgKiB3YXZlc3VyZmVyLnNraXAoLTIpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2tpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwKG9mZnNldCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5nZXREdXJhdGlvbigpIHx8IDE7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldEN1cnJlbnRUaW1lKCkgfHwgMDtcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZHVyYXRpb24sIHBvc2l0aW9uICsgKG9mZnNldCB8fCAwKSkpO1xuICAgICAgdGhpcy5zZWVrQW5kQ2VudGVyKHBvc2l0aW9uIC8gZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWVrcyB0byBhIHBvc2l0aW9uIGFuZCBjZW50ZXJzIHRoZSB2aWV3XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvZ3Jlc3MgQmV0d2VlbiAwICg9YmVnaW5uaW5nKSBhbmQgMSAoPWVuZClcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHNlZWsgYW5kIGdvIHRvIHRoZSBtaWRkbGUgb2YgdGhlIGF1ZGlvXG4gICAgICogd2F2ZXN1cmZlci5zZWVrVG8oMC41KTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlZWtBbmRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla0FuZENlbnRlcihwcm9ncmVzcykge1xuICAgICAgdGhpcy5zZWVrVG8ocHJvZ3Jlc3MpO1xuICAgICAgdGhpcy5kcmF3ZXIucmVjZW50ZXIocHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWVrcyB0byBhIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvZ3Jlc3MgQmV0d2VlbiAwICg9YmVnaW5uaW5nKSBhbmQgMSAoPWVuZClcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNpbnRlcmFjdGlvblxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3NlZWtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHNlZWsgdG8gdGhlIG1pZGRsZSBvZiB0aGUgYXVkaW9cbiAgICAgKiB3YXZlc3VyZmVyLnNlZWtUbygwLjUpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Vla1RvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlZWtUbyhwcm9ncmVzcykge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIC8vIHJldHVybiBhbiBlcnJvciBpZiBwcm9ncmVzcyBpcyBub3QgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUocHJvZ3Jlc3MpIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjYWxsaW5nIHdhdmVzdXJmZXIuc2Vla1RvLCBwYXJhbWV0ZXIgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEhJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdpbnRlcmFjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5zZWVrVG8ocHJvZ3Jlc3MpO1xuICAgICAgfSk7XG4gICAgICB2YXIgaXNXZWJBdWRpb0JhY2tlbmQgPSB0aGlzLnBhcmFtcy5iYWNrZW5kID09PSAnV2ViQXVkaW8nO1xuICAgICAgdmFyIHBhdXNlZCA9IHRoaXMuYmFja2VuZC5pc1BhdXNlZCgpO1xuXG4gICAgICBpZiAoaXNXZWJBdWRpb0JhY2tlbmQgJiYgIXBhdXNlZCkge1xuICAgICAgICB0aGlzLmJhY2tlbmQucGF1c2UoKTtcbiAgICAgIH0gLy8gYXZvaWQgc21hbGwgc2Nyb2xscyB3aGlsZSBwYXVzZWQgc2Vla2luZ1xuXG5cbiAgICAgIHZhciBvbGRTY3JvbGxQYXJlbnQgPSB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYmFja2VuZC5zZWVrVG8ocHJvZ3Jlc3MgKiB0aGlzLmdldER1cmF0aW9uKCkpO1xuICAgICAgdGhpcy5kcmF3ZXIucHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoaXNXZWJBdWRpb0JhY2tlbmQgJiYgIXBhdXNlZCkge1xuICAgICAgICB0aGlzLmJhY2tlbmQucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgPSBvbGRTY3JvbGxQYXJlbnQ7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnc2VlaycsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgYW5kIGdvZXMgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc3RvcCgpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5zZWVrVG8oMCk7XG4gICAgICB0aGlzLmRyYXdlci5wcm9ncmVzcygwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSUQgb2YgdGhlIGF1ZGlvIGRldmljZSB0byB1c2UgZm9yIG91dHB1dCBhbmQgcmV0dXJucyBhIFByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSWQgU3RyaW5nIHZhbHVlIHJlcHJlc2VudGluZyB1bmRlcmx5aW5nIG91dHB1dFxuICAgICAqIGRldmljZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIGFyZVxuICAgICAqIG5vIGVycm9ycyBkZXRlY3RlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNpbmtJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwbGF5YmFjayB2b2x1bWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3Vm9sdW1lIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCAwIGJlaW5nIG5vXG4gICAgICogdm9sdW1lIGFuZCAxIGJlaW5nIGZ1bGwgdm9sdW1lLlxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3ZvbHVtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZvbHVtZShuZXdWb2x1bWUpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5zZXRWb2x1bWUobmV3Vm9sdW1lKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCd2b2x1bWUnLCBuZXdWb2x1bWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYXliYWNrIHZvbHVtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIDAgYmVpbmcgbm9cbiAgICAgKiB2b2x1bWUgYW5kIDEgYmVpbmcgZnVsbCB2b2x1bWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vm9sdW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRWb2x1bWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGUgQSBwb3NpdGl2ZSBudW1iZXIuIEUuZy4gMC41IG1lYW5zIGhhbGYgdGhlIG5vcm1hbFxuICAgICAqIHNwZWVkLCAyIG1lYW5zIGRvdWJsZSBzcGVlZCBhbmQgc28gb24uXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRQbGF5YmFja1JhdGUoMik7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5zZXRQbGF5YmFja1JhdGUocmF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGxheWJhY2sgcmF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5YmFja1JhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldFBsYXliYWNrUmF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHZvbHVtZSBvbiBhbmQgb2ZmLiBJZiBub3QgY3VycmVudGx5IG11dGVkIGl0IHdpbGwgc2F2ZSB0aGVcbiAgICAgKiBjdXJyZW50IHZvbHVtZSB2YWx1ZSBhbmQgdHVybiB0aGUgdm9sdW1lIG9mZi4gSWYgY3VycmVudGx5IG11dGVkIHRoZW4gaXRcbiAgICAgKiB3aWxsIHJlc3RvcmUgdGhlIHZvbHVtZSB0byB0aGUgc2F2ZWQgdmFsdWUsIGFuZCB0aGVuIHJlc3QgdGhlIHNhdmVkXG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnRvZ2dsZU11dGUoKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZU11dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZSgpIHtcbiAgICAgIHRoaXMuc2V0TXV0ZSghdGhpcy5pc011dGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgbXV0ZWQgYXVkaW9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZSBTcGVjaWZ5IGB0cnVlYCB0byBtdXRlIGF1ZGlvLlxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3ZvbHVtZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI211dGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHVubXV0ZVxuICAgICAqIHdhdmVzdXJmZXIuc2V0TXV0ZShmYWxzZSk7XG4gICAgICogY29uc29sZS5sb2cod2F2ZXN1cmZlci5nZXRNdXRlKCkpIC8vIGxvZ3MgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE11dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXV0ZShtdXRlKSB7XG4gICAgICAvLyBpZ25vcmUgYWxsIG11dGluZyByZXF1ZXN0cyBpZiB0aGUgYXVkaW8gaXMgYWxyZWFkeSBpbiB0aGF0IHN0YXRlXG4gICAgICBpZiAobXV0ZSA9PT0gdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdtdXRlJywgdGhpcy5pc011dGVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iYWNrZW5kLnNldE11dGUpIHtcbiAgICAgICAgLy8gQmFja2VuZHMgc3VjaCBhcyB0aGUgTWVkaWFFbGVtZW50IGJhY2tlbmQgaGF2ZSB0aGVpciBvd24gaGFuZGxpbmdcbiAgICAgICAgLy8gb2YgbXV0ZSwgbGV0IHRoZW0gaGFuZGxlIGl0LlxuICAgICAgICB0aGlzLmJhY2tlbmQuc2V0TXV0ZShtdXRlKTtcbiAgICAgICAgdGhpcy5pc011dGVkID0gbXV0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtdXRlKSB7XG4gICAgICAgICAgLy8gSWYgY3VycmVudGx5IG5vdCBtdXRlZCB0aGVuIHNhdmUgY3VycmVudCB2b2x1bWUsXG4gICAgICAgICAgLy8gdHVybiBvZmYgdGhlIHZvbHVtZSBhbmQgdXBkYXRlIHRoZSBtdXRlIHByb3BlcnRpZXNcbiAgICAgICAgICB0aGlzLnNhdmVkVm9sdW1lID0gdGhpcy5iYWNrZW5kLmdldFZvbHVtZSgpO1xuICAgICAgICAgIHRoaXMuYmFja2VuZC5zZXRWb2x1bWUoMCk7XG4gICAgICAgICAgdGhpcy5pc011dGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndm9sdW1lJywgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgY3VycmVudGx5IG11dGVkIHRoZW4gcmVzdG9yZSB0byB0aGUgc2F2ZWQgdm9sdW1lXG4gICAgICAgICAgLy8gYW5kIHVwZGF0ZSB0aGUgbXV0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdGhpcy5iYWNrZW5kLnNldFZvbHVtZSh0aGlzLnNhdmVkVm9sdW1lKTtcbiAgICAgICAgICB0aGlzLmlzTXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndm9sdW1lJywgdGhpcy5zYXZlZFZvbHVtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5maXJlRXZlbnQoJ211dGUnLCB0aGlzLmlzTXV0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbXV0ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBjb25zdCBpc011dGVkID0gd2F2ZXN1cmZlci5nZXRNdXRlKCk7XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ3VycmVudCBtdXRlIHN0YXR1c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TXV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNdXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNNdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGN1cnJlbnQgc2V0IGZpbHRlcnMgYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBGaWx0ZXJzIG11c3QgYmUgc2V0IHdpdGggc2V0RmlsdGVycyBtZXRob2QgZmlyc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBMaXN0IG9mIGVuYWJsZWQgZmlsdGVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsdGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWx0ZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5maWx0ZXJzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGBzY3JvbGxQYXJlbnRgIGFuZCByZWRyYXdzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnRvZ2dsZVNjcm9sbCgpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNjcm9sbCgpIHtcbiAgICAgIHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCA9ICF0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIG1vdXNlIGludGVyYWN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnRvZ2dsZUludGVyYWN0aW9uKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVJbnRlcmFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVJbnRlcmFjdGlvbigpIHtcbiAgICAgIHRoaXMucGFyYW1zLmludGVyYWN0ID0gIXRoaXMucGFyYW1zLmludGVyYWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGFmdGVyIHRoZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFdhdmVDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXYXZlQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMud2F2ZUNvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGFmdGVyIHRoZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0V2F2ZUNvbG9yKCcjZGRkJyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRXYXZlQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V2F2ZUNvbG9yKGNvbG9yKSB7XG4gICAgICB0aGlzLnBhcmFtcy53YXZlQ29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGJlaGluZCB0aGUgY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9ncmVzc0NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2dyZXNzQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMucHJvZ3Jlc3NDb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBiZWhpbmQgdGhlIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRQcm9ncmVzc0NvbG9yKCcjNDAwJyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9ncmVzc0NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb2dyZXNzQ29sb3IoY29sb3IpIHtcbiAgICAgIHRoaXMucGFyYW1zLnByb2dyZXNzQ29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldEJhY2tncm91bmRDb2xvcignI0ZGMDBGRicpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJhY2tncm91bmRDb2xvcihjb2xvcikge1xuICAgICAgdGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICB1dGlsLnN0eWxlKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvclxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgY3Vyc29yIGluZGljYXRpbmcgdGhlIHBsYXloZWFkXG4gICAgICogcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnNvckNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnNvckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmN1cnNvckNvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIGN1cnNvciBpbmRpY2F0aW5nIHRoZSBwbGF5aGVhZFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldEN1cnNvckNvbG9yKCcjMjIyJyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJzb3JDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJzb3JDb2xvcihjb2xvcikge1xuICAgICAgdGhpcy5wYXJhbXMuY3Vyc29yQ29sb3IgPSBjb2xvcjtcbiAgICAgIHRoaXMuZHJhd2VyLnVwZGF0ZUN1cnNvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodCBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgbWVhc3VyZWQgaW4gcGl4ZWxzLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0SGVpZ2h0KDIwMCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgdGhpcy5wYXJhbXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5kcmF3ZXIuc2V0SGVpZ2h0KGhlaWdodCAqIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgY2hhbm5lbHMgZnJvbSBiZWluZyBkcmF3biBvbiB0aGUgd2F2ZWZvcm0gaWYgc3BsaXR0aW5nIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHdlIHdhbnQgdG8gZHJhdyBvbmx5IHRoZSBwZWFrcyBmb3IgdGhlIHJpZ2h0IHN0ZXJlbyBjaGFubmVsOlxuICAgICAqXG4gICAgICogY29uc3Qgd2F2ZXN1cmZlciA9IG5ldyBXYXZlU3VyZmVyLmNyZWF0ZSh7Li4uc3BsaXRDaGFubmVsczogdHJ1ZX0pO1xuICAgICAqIHdhdmVzdXJmZXIubG9hZCgnc3RlcmVvX2F1ZGlvLm1wMycpO1xuICAgICAqXG4gICAgICogd2F2ZXN1cmZlci5zZXRGaWx0ZXJlZENoYW5uZWwoWzBdKTsgPC0tIGhpZGUgbGVmdCBjaGFubmVsIHBlYWtzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gY2hhbm5lbEluZGljZXMgQ2hhbm5lbHMgdG8gYmUgZmlsdGVyZWQgb3V0IGZyb20gZHJhd2luZy5cbiAgICAgKiBAdmVyc2lvbiA0LjAuMFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsdGVyZWRDaGFubmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWx0ZXJlZENoYW5uZWxzKGNoYW5uZWxJbmRpY2VzKSB7XG4gICAgICB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5maWx0ZXJDaGFubmVscyA9IGNoYW5uZWxJbmRpY2VzO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29ycmVjdCBwZWFrcyBmb3IgY3VycmVudCB3YXZlIHZpZXctcG9ydCBhbmQgcmVuZGVyIHdhdmVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjcmVkcmF3XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCdWZmZXIoKSB7XG4gICAgICB2YXIgbm9taW5hbFdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmdldER1cmF0aW9uKCkgKiB0aGlzLnBhcmFtcy5taW5QeFBlclNlYyAqIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5kcmF3ZXIuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciB3aWR0aCA9IG5vbWluYWxXaWR0aDsgLy8gYWx3YXlzIHN0YXJ0IGF0IDAgYWZ0ZXIgem9vbWluZyBmb3Igc2Nyb2xsaW5nIDogaXNzdWUgcmVkcmF3IGxlZnQgcGFydFxuXG4gICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0ICsgcGFyZW50V2lkdGgsIHdpZHRoKTsgLy8gRmlsbCBjb250YWluZXJcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbGxQYXJlbnQgJiYgKCF0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgfHwgbm9taW5hbFdpZHRoIDwgcGFyZW50V2lkdGgpKSB7XG4gICAgICAgIHdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwZWFrcztcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnBhcnRpYWxSZW5kZXIpIHtcbiAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMucGVha0NhY2hlLmFkZFJhbmdlVG9QZWFrQ2FjaGUod2lkdGgsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGVha3MgPSB0aGlzLmJhY2tlbmQuZ2V0UGVha3Mod2lkdGgsIG5ld1Jhbmdlc1tpXVswXSwgbmV3UmFuZ2VzW2ldWzFdKTtcbiAgICAgICAgICB0aGlzLmRyYXdlci5kcmF3UGVha3MocGVha3MsIHdpZHRoLCBuZXdSYW5nZXNbaV1bMF0sIG5ld1Jhbmdlc1tpXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlYWtzID0gdGhpcy5iYWNrZW5kLmdldFBlYWtzKHdpZHRoLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5kcmF3ZXIuZHJhd1BlYWtzKHBlYWtzLCB3aWR0aCwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdyZWRyYXcnLCBwZWFrcywgd2lkdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsbHkgem9vbXMgdGhlIHdhdmVmb3JtIGluIGFuZCBvdXQuIEl0IGFsc28gY2hhbmdlcyB0aGUgcGFyYW1ldGVyXG4gICAgICogYG1pblB4UGVyU2VjYCBhbmQgZW5hYmxlcyB0aGUgYHNjcm9sbFBhcmVudGAgb3B0aW9uLiBDYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgICAqIHdpdGggYSBmYWxzZXkgcGFyYW1ldGVyIHdpbGwgcmVzZXQgdGhlIHpvb20gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHB4UGVyU2VjIE51bWJlciBvZiBob3Jpem9udGFsIHBpeGVscyBwZXIgc2Vjb25kIG9mXG4gICAgICogYXVkaW8sIGlmIG5vbmUgaXMgc2V0IHRoZSB3YXZlZm9ybSByZXR1cm5zIHRvIHVuem9vbWVkIHN0YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjem9vbVxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuem9vbSgyMCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20ocHhQZXJTZWMpIHtcbiAgICAgIGlmICghcHhQZXJTZWMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMubWluUHhQZXJTZWMgPSB0aGlzLmRlZmF1bHRQYXJhbXMubWluUHhQZXJTZWM7XG4gICAgICAgIHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJhbXMubWluUHhQZXJTZWMgPSBweFBlclNlYztcbiAgICAgICAgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgICB0aGlzLmRyYXdlci5wcm9ncmVzcyh0aGlzLmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSk7XG4gICAgICB0aGlzLmRyYXdlci5yZWNlbnRlcih0aGlzLmdldEN1cnJlbnRUaW1lKCkgLyB0aGlzLmdldER1cmF0aW9uKCkpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3pvb20nLCBweFBlclNlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBidWZmZXIgYW5kIGxvYWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgQnVmZmVyIHRvIHByb2Nlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRBcnJheUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRlY29kZUFycmF5QnVmZmVyKGFycmF5YnVmZmVyLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIV90aGlzOS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIF90aGlzOS5sb2FkRGVjb2RlZEJ1ZmZlcihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpcmVjdGx5IGxvYWQgYW4gZXh0ZXJuYWxseSBkZWNvZGVkIEF1ZGlvQnVmZmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcHJvY2Vzc1xuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3JlYWR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkRGVjb2RlZEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkRGVjb2RlZEJ1ZmZlcihidWZmZXIpIHtcbiAgICAgIHRoaXMuYmFja2VuZC5sb2FkKGJ1ZmZlcik7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncmVhZHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYXVkaW8gZGF0YSBmcm9tIGEgQmxvYiBvciBGaWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgQXVkaW8gZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQmxvYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkQmxvYihibG9iKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIC8vIENyZWF0ZSBmaWxlIHJlYWRlclxuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5vblByb2dyZXNzKGUpO1xuICAgICAgfSk7XG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczEwLmxvYWRBcnJheUJ1ZmZlcihlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczEwLmZpcmVFdmVudCgnZXJyb3InLCAnRXJyb3IgcmVhZGluZyBmaWxlJyk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgIHRoaXMuZW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYXVkaW8gYW5kIHJlLXJlbmRlcnMgdGhlIHdhdmVmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTE1lZGlhRWxlbWVudH0gdXJsIFRoZSB1cmwgb2YgdGhlIGF1ZGlvIGZpbGUgb3IgdGhlXG4gICAgICogYXVkaW8gZWxlbWVudCB3aXRoIHRoZSBhdWRpb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgV2F2ZXN1cmZlciBkb2VzIG5vdCBoYXZlIHRvIGRlY29kZVxuICAgICAqIHRoZSBhdWRpbyB0byByZW5kZXIgdGhlIHdhdmVmb3JtIGlmIHRoaXMgaXMgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBwcmVsb2FkIChVc2Ugd2l0aCBiYWNrZW5kIGBNZWRpYUVsZW1lbnRgIGFuZCBgTWVkaWFFbGVtZW50V2ViQXVkaW9gKVxuICAgICAqIGAnbm9uZSd8J21ldGFkYXRhJ3wnYXV0bydgIFByZWxvYWQgYXR0cmlidXRlIGZvciB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpby4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogcmVuZGVyIHRoZSBwZWFrcyBkYXRhIGluIHRoZSBjb3JyZWN0IHNpemUgZm9yIHRoZSBhdWRpbyBkdXJhdGlvbiAoYXNcbiAgICAgKiBiZWZpdHMgdGhlIGN1cnJlbnQgYG1pblB4UGVyU2VjYCBhbmQgem9vbSB2YWx1ZSkgd2l0aG91dCBoYXZpbmcgdG8gZGVjb2RlXG4gICAgICogdGhlIGF1ZGlvLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYHVybGAgYXJndW1lbnQgaXMgZW1wdHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB1c2VzIGZldGNoIG9yIG1lZGlhIGVsZW1lbnQgdG8gbG9hZCBmaWxlIChkZXBlbmRpbmcgb24gYmFja2VuZClcbiAgICAgKiB3YXZlc3VyZmVyLmxvYWQoJ2h0dHA6Ly9leGFtcGxlLmNvbS9kZW1vLndhdicpO1xuICAgICAqXG4gICAgICogLy8gc2V0dGluZyBwcmVsb2FkIGF0dHJpYnV0ZSB3aXRoIG1lZGlhIGVsZW1lbnQgYmFja2VuZCBhbmQgc3VwcGx5aW5nXG4gICAgICogLy8gcGVha3NcbiAgICAgKiB3YXZlc3VyZmVyLmxvYWQoXG4gICAgICogICAnaHR0cDovL2V4YW1wbGUuY29tL2RlbW8ud2F2JyxcbiAgICAgKiAgIFswLjAyMTgsIDAuMDE4MywgMC4wMTY1LCAwLjAxOTgsIDAuMjEzNywgMC4yODg4XSxcbiAgICAgKiAgIHRydWVcbiAgICAgKiApO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgcGVha3MsIHByZWxvYWQsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VybCBwYXJhbWV0ZXIgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1wdHkoKTtcblxuICAgICAgaWYgKHByZWxvYWQpIHtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcHJlbG9hZCBhdHRyaWJ1dGUgd2lsbCBiZSB1c2FibGUgYW5kIGlmIG5vdCBsb2dcbiAgICAgICAgLy8gYSB3YXJuaW5nIGxpc3RpbmcgdGhlIHJlYXNvbnMgd2h5IG5vdCBhbmQgbnVsbGlmeSB0aGUgdmFyaWFibGVcbiAgICAgICAgdmFyIHByZWxvYWRJZ25vcmVSZWFzb25zID0ge1xuICAgICAgICAgIFwiUHJlbG9hZCBpcyBub3QgJ2F1dG8nLCAnbm9uZScgb3IgJ21ldGFkYXRhJ1wiOiBbJ2F1dG8nLCAnbWV0YWRhdGEnLCAnbm9uZSddLmluZGV4T2YocHJlbG9hZCkgPT09IC0xLFxuICAgICAgICAgICdQZWFrcyBhcmUgbm90IHByb3ZpZGVkJzogIXBlYWtzLFxuICAgICAgICAgIFwiQmFja2VuZCBpcyBub3Qgb2YgdHlwZSAnTWVkaWFFbGVtZW50JyBvciAnTWVkaWFFbGVtZW50V2ViQXVkaW8nXCI6IFsnTWVkaWFFbGVtZW50JywgJ01lZGlhRWxlbWVudFdlYkF1ZGlvJ10uaW5kZXhPZih0aGlzLnBhcmFtcy5iYWNrZW5kKSA9PT0gLTEsXG4gICAgICAgICAgJ1VybCBpcyBub3Qgb2YgdHlwZSBzdHJpbmcnOiB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYWN0aXZlUmVhc29ucyA9IE9iamVjdC5rZXlzKHByZWxvYWRJZ25vcmVSZWFzb25zKS5maWx0ZXIoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHJldHVybiBwcmVsb2FkSWdub3JlUmVhc29uc1tyZWFzb25dO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYWN0aXZlUmVhc29ucy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybignUHJlbG9hZCBwYXJhbWV0ZXIgb2Ygd2F2ZXN1cmZlci5sb2FkIHdpbGwgYmUgaWdub3JlZCBiZWNhdXNlOlxcblxcdC0gJyArIGFjdGl2ZVJlYXNvbnMuam9pbignXFxuXFx0LSAnKSk7IC8vIHN0b3AgaW52YWxpZCB2YWx1ZXMgZnJvbSBiZWluZyB1c2VkXG5cbiAgICAgICAgICBwcmVsb2FkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBsb2FkQnVmZmVyKHVybCwgcGVha3MsIGR1cmF0aW9uKSByZXF1aXJlcyB0aGF0IHVybCBpcyBhIHN0cmluZ1xuICAgICAgLy8gYnV0IHVzZXJzIGNhbiBwYXNzIGluIGEgSFRNTE1lZGlhRWxlbWVudCB0byBXYXZlU3VyZmVyXG5cblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmJhY2tlbmQgPT09ICdXZWJBdWRpbycgJiYgdXJsIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudCkge1xuICAgICAgICB1cmwgPSB1cmwuc3JjO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMucGFyYW1zLmJhY2tlbmQpIHtcbiAgICAgICAgY2FzZSAnV2ViQXVkaW8nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRCdWZmZXIodXJsLCBwZWFrcywgZHVyYXRpb24pO1xuXG4gICAgICAgIGNhc2UgJ01lZGlhRWxlbWVudCc6XG4gICAgICAgIGNhc2UgJ01lZGlhRWxlbWVudFdlYkF1ZGlvJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkTWVkaWFFbGVtZW50KHVybCwgcGVha3MsIHByZWxvYWQsIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYXVkaW8gdXNpbmcgV2ViIEF1ZGlvIGJ1ZmZlciBiYWNrZW5kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciN3YXZlZm9ybS1yZWFkeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIFBlYWtzIGRhdGFcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGR1cmF0aW9uIE9wdGlvbmFsIGR1cmF0aW9uIG9mIGF1ZGlvIGZpbGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEJ1ZmZlcih1cmwsIHBlYWtzLCBkdXJhdGlvbikge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICBfdGhpczExLnRtcEV2ZW50cy5wdXNoKF90aGlzMTEub25jZSgncmVhZHknLCBhY3Rpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpczExLmdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMS5sb2FkQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHBlYWtzKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5zZXRQZWFrcyhwZWFrcywgZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3dhdmVmb3JtLXJlYWR5Jyk7XG4gICAgICAgIHRoaXMudG1wRXZlbnRzLnB1c2godGhpcy5vbmNlKCdpbnRlcmFjdGlvbicsIGxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVpdGhlciBjcmVhdGUgYSBtZWRpYSBlbGVtZW50LCBvciBsb2FkIGFuIGV4aXN0aW5nIG1lZGlhIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3dhdmVmb3JtLXJlYWR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTE1lZGlhRWxlbWVudH0gdXJsT3JFbHQgRWl0aGVyIGEgcGF0aCB0byBhIG1lZGlhIGZpbGUsIG9yIGFuXG4gICAgICogZXhpc3RpbmcgSFRNTDUgQXVkaW8vVmlkZW8gRWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQXJyYXkgb2YgcGVha3MuIFJlcXVpcmVkIHRvIGJ5cGFzcyB3ZWIgYXVkaW9cbiAgICAgKiBkZXBlbmRlbmN5XG4gICAgICogQHBhcmFtIHs/Ym9vbGVhbn0gcHJlbG9hZCBTZXQgdG8gdHJ1ZSBpZiB0aGUgcHJlbG9hZCBhdHRyaWJ1dGUgb2YgdGhlXG4gICAgICogYXVkaW8gZWxlbWVudCBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZHVyYXRpb24gT3B0aW9uYWwgZHVyYXRpb24gb2YgYXVkaW8gZmlsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZE1lZGlhRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkTWVkaWFFbGVtZW50KHVybE9yRWx0LCBwZWFrcywgcHJlbG9hZCwgZHVyYXRpb24pIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIHVybCA9IHVybE9yRWx0O1xuXG4gICAgICBpZiAodHlwZW9mIHVybE9yRWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmJhY2tlbmQubG9hZCh1cmwsIHRoaXMubWVkaWFDb250YWluZXIsIHBlYWtzLCBwcmVsb2FkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbHQgPSB1cmxPckVsdDtcbiAgICAgICAgdGhpcy5iYWNrZW5kLmxvYWRFbHQoZWx0LCBwZWFrcyk7IC8vIElmIHBlYWtzIGFyZSBub3QgcHJvdmlkZWQsXG4gICAgICAgIC8vIHVybCA9IGVsZW1lbnQuc3JjIHNvIHdlIGNhbiBnZXQgcGVha3Mgd2l0aCB3ZWIgYXVkaW9cblxuICAgICAgICB1cmwgPSBlbHQuc3JjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRtcEV2ZW50cy5wdXNoKHRoaXMuYmFja2VuZC5vbmNlKCdjYW5wbGF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZ25vcmUgd2hlbiBiYWNrZW5kIHdhcyBhbHJlYWR5IGRlc3Ryb3llZFxuICAgICAgICBpZiAoIV90aGlzMTIuYmFja2VuZC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBfdGhpczEyLmRyYXdCdWZmZXIoKTtcblxuICAgICAgICAgIF90aGlzMTIuaXNSZWFkeSA9IHRydWU7XG5cbiAgICAgICAgICBfdGhpczEyLmZpcmVFdmVudCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgfSksIHRoaXMuYmFja2VuZC5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTIuZmlyZUV2ZW50KCdlcnJvcicsIGVycik7XG4gICAgICB9KSk7IC8vIElmIHBlYWtzIGFyZSBwcm92aWRlZCwgcmVuZGVyIHRoZW0gYW5kIGZpcmUgdGhlIGB3YXZlZm9ybS1yZWFkeWAgZXZlbnQuXG5cbiAgICAgIGlmIChwZWFrcykge1xuICAgICAgICB0aGlzLmJhY2tlbmQuc2V0UGVha3MocGVha3MsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCd3YXZlZm9ybS1yZWFkeScpO1xuICAgICAgfSAvLyBJZiBubyBwcmUtZGVjb2RlZCBwZWFrcyBhcmUgcHJvdmlkZWQsIG9yIGFyZSBwcm92aWRlZCB3aXRoXG4gICAgICAvLyBmb3JjZURlY29kZSBmbGFnLCBhdHRlbXB0IHRvIGRvd25sb2FkIHRoZSBhdWRpbyBmaWxlIGFuZCBkZWNvZGUgaXRcbiAgICAgIC8vIHdpdGggV2ViIEF1ZGlvLlxuXG5cbiAgICAgIGlmICgoIXBlYWtzIHx8IHRoaXMucGFyYW1zLmZvcmNlRGVjb2RlKSAmJiB0aGlzLmJhY2tlbmQuc3VwcG9ydHNXZWJBdWRpbygpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcbiAgICAgICAgICBfdGhpczEyLmRlY29kZUFycmF5QnVmZmVyKGFycmF5YnVmZmVyLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBfdGhpczEyLmJhY2tlbmQuYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgICAgICAgICBfdGhpczEyLmJhY2tlbmQuc2V0UGVha3MobnVsbCk7XG5cbiAgICAgICAgICAgIF90aGlzMTIuZHJhd0J1ZmZlcigpO1xuXG4gICAgICAgICAgICBfdGhpczEyLmZpcmVFdmVudCgnd2F2ZWZvcm0tcmVhZHknKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBhcnJheSBidWZmZXIgYW5kIHBhc3MgZGF0YSB0byBhIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheWJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGRlY29kZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGNvbXBsZXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVBcnJheUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgdGhpcy5hcnJheWJ1ZmZlciA9IGFycmF5YnVmZmVyO1xuICAgICAgdGhpcy5iYWNrZW5kLmRlY29kZUFycmF5QnVmZmVyKGFycmF5YnVmZmVyLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBPbmx5IHVzZSB0aGUgZGVjb2RlZCBkYXRhIGlmIHdlIGhhdmVuJ3QgYmVlbiBkZXN0cm95ZWQgb3JcbiAgICAgICAgLy8gYW5vdGhlciBkZWNvZGUgc3RhcnRlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgaWYgKCFfdGhpczEzLmlzRGVzdHJveWVkICYmIF90aGlzMTMuYXJyYXlidWZmZXIgPT0gYXJyYXlidWZmZXIpIHtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICBfdGhpczEzLmFycmF5YnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMy5maXJlRXZlbnQoJ2Vycm9yJywgJ0Vycm9yIGRlY29kaW5nIGF1ZGlvYnVmZmVyJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBhbiBhcnJheSBidWZmZXIgdXNpbmcgZmV0Y2ggYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBhIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGZpbGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gY29tcGxldGVcbiAgICAgKiBAcmV0dXJucyB7dXRpbC5mZXRjaEZpbGV9IGZldGNoIGNhbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodXJsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInXG4gICAgICB9LCB0aGlzLnBhcmFtcy54aHIpO1xuICAgICAgdmFyIHJlcXVlc3QgPSB1dGlsLmZldGNoRmlsZShvcHRpb25zKTtcbiAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgdGhpcy50bXBFdmVudHMucHVzaChyZXF1ZXN0Lm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMTQub25Qcm9ncmVzcyhlKTtcbiAgICAgIH0pLCByZXF1ZXN0Lm9uKCdzdWNjZXNzJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIF90aGlzMTQuY3VycmVudFJlcXVlc3QgPSBudWxsO1xuICAgICAgfSksIHJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMxNC5maXJlRXZlbnQoJ2Vycm9yJywgZSk7XG5cbiAgICAgICAgX3RoaXMxNC5jdXJyZW50UmVxdWVzdCA9IG51bGw7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoaWxlIHRoZSBhdWRpbyBmaWxlIGlzIGxvYWRpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBQcm9ncmVzcyBldmVudFxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2xvYWRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyhlKSB7XG4gICAgICB2YXIgcGVyY2VudENvbXBsZXRlO1xuXG4gICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgIHBlcmNlbnRDb21wbGV0ZSA9IGUubG9hZGVkIC8gZS50b3RhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFwcHJveGltYXRlIHByb2dyZXNzIHdpdGggYW4gYXN5bXB0b3RpY1xuICAgICAgICAvLyBmdW5jdGlvbiwgYW5kIGFzc3VtZSBkb3dubG9hZHMgaW4gdGhlIDEtMyBNQiByYW5nZS5cbiAgICAgICAgcGVyY2VudENvbXBsZXRlID0gZS5sb2FkZWQgLyAoZS5sb2FkZWQgKyAxMDAwMDAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maXJlRXZlbnQoJ2xvYWRpbmcnLCBNYXRoLnJvdW5kKHBlcmNlbnRDb21wbGV0ZSAqIDEwMCksIGUudGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBQQ00gZGF0YSBpbnRvIGEgSlNPTiBhcnJheSBhbmQgb3B0aW9uYWxseSBvcGVucyBpbiBhIG5ldyB3aW5kb3dcbiAgICAgKiBhcyB2YWxpZCBKU09OIEJsb2IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoPTEwMjQgVGhlIHNjYWxlIGluIHdoaWNoIHRvIGV4cG9ydCB0aGUgcGVha3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWNjdXJhY3k9MTAwMDBcbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBub1dpbmRvdyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIG9wZW5pbmcgYSBuZXdcbiAgICAgKiB3aW5kb3cgd2l0aCB0aGUgSlNPTlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIGluZGV4XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYXJyYXkgb2YgcGVha3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4cG9ydFBDTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRQQ00obGVuZ3RoLCBhY2N1cmFjeSwgbm9XaW5kb3csIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8fCAxMDI0O1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgYWNjdXJhY3kgPSBhY2N1cmFjeSB8fCAxMDAwMDtcbiAgICAgIG5vV2luZG93ID0gbm9XaW5kb3cgfHwgZmFsc2U7XG4gICAgICB2YXIgcGVha3MgPSB0aGlzLmJhY2tlbmQuZ2V0UGVha3MobGVuZ3RoLCBzdGFydCwgZW5kKTtcbiAgICAgIHZhciBhcnIgPSBbXS5tYXAuY2FsbChwZWFrcywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiBhY2N1cmFjeSkgLyBhY2N1cmFjeTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFub1dpbmRvdykge1xuICAgICAgICAgIHZhciBibG9iSlNPTiA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShhcnIpXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iSlNPTik7XG4gICAgICAgICAgd2luZG93Lm9wZW4ob2JqVVJMKTtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9ialVSTCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGFycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZSB3YXZlZm9ybSBpbWFnZSBhcyBkYXRhIFVSSS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGZvcm1hdCBpcyBgJ2ltYWdlL3BuZydgLiBPdGhlciBzdXBwb3J0ZWQgdHlwZXMgYXJlXG4gICAgICogYCdpbWFnZS9qcGVnJ2AgYW5kIGAnaW1hZ2Uvd2VicCdgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdD0naW1hZ2UvcG5nJyBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBpbWFnZSBmb3JtYXQuXG4gICAgICogVGhlIGRlZmF1bHQgZm9ybWF0IHR5cGUgaXMgYCdpbWFnZS9wbmcnYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eT0xIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpbmRpY2F0aW5nIHRoZSBpbWFnZVxuICAgICAqIHF1YWxpdHkgdG8gdXNlIGZvciBpbWFnZSBmb3JtYXRzIHRoYXQgdXNlIGxvc3N5IGNvbXByZXNzaW9uIHN1Y2ggYXNcbiAgICAgKiBgJ2ltYWdlL2pwZWcnYGAgYW5kIGAnaW1hZ2Uvd2VicCdgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEltYWdlIGRhdGEgdHlwZSB0byByZXR1cm4uIEVpdGhlciAnZGF0YVVSTCcgKGRlZmF1bHQpXG4gICAgICogb3IgJ2Jsb2InLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXXxQcm9taXNlfSBXaGVuIHVzaW5nIGAnZGF0YVVSTCdgIHR5cGUgdGhpcyByZXR1cm5zXG4gICAgICogYSBzaW5nbGUgZGF0YSBVUkwgb3IgYW4gYXJyYXkgb2YgZGF0YSBVUkxzLCBvbmUgZm9yIGVhY2ggY2FudmFzLiBXaGVuIHVzaW5nXG4gICAgICogYCdibG9iJ2AgdHlwZSB0aGlzIHJldHVybnMgYSBgUHJvbWlzZWAgcmVzb2x2aW5nIHdpdGggYW4gYXJyYXkgb2YgYEJsb2JgXG4gICAgICogaW5zdGFuY2VzLCBvbmUgZm9yIGVhY2ggY2FudmFzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKSB7XG4gICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSAnaW1hZ2UvcG5nJztcbiAgICAgIH1cblxuICAgICAgaWYgKCFxdWFsaXR5KSB7XG4gICAgICAgIHF1YWxpdHkgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdHlwZSA9ICdkYXRhVVJMJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLmdldEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbnkgZmV0Y2ggcmVxdWVzdCBjdXJyZW50bHkgaW4gcHJvZ3Jlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbEFqYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsQWpheCgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXF1ZXN0ICYmIHRoaXMuY3VycmVudFJlcXVlc3QuY29udHJvbGxlcikge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCByZXF1ZXN0IGhhcyBhIFByb2dyZXNzSGFuZGxlciwgdGhlbiBpdHMgUmVhZGFibGVTdHJlYW0gbWlnaHQgbmVlZCB0byBiZSBjYW5jZWxsZWQgdG9vXG4gICAgICAgIC8vIFNlZTogV2F2ZXN1cmZlciBpc3N1ZSAjMjA0MlxuICAgICAgICAvLyBTZWUgRmlyZWZveCBidWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE1ODM4MTVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlcXVlc3QuX3JlYWRlcikge1xuICAgICAgICAgIC8vIElnbm9yaW5nIGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGNhbGwgdG8gY2FuY2VsKClcbiAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0Ll9yZWFkZXIuY2FuY2VsKCkuY2F0Y2goZnVuY3Rpb24gKGVycikge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdC5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJUbXBFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJUbXBFdmVudHMoKSB7XG4gICAgICB0aGlzLnRtcEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnVuKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheSBlbXB0eSB3YXZlZm9ybS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5iYWNrZW5kLmRpc2Nvbm5lY3RTb3VyY2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLmNhbmNlbEFqYXgoKTtcbiAgICAgIHRoaXMuY2xlYXJUbXBFdmVudHMoKTsgLy8gZW1wdHkgZHJhd2VyXG5cbiAgICAgIHRoaXMuZHJhd2VyLnByb2dyZXNzKDApO1xuICAgICAgdGhpcy5kcmF3ZXIuc2V0V2lkdGgoMCk7XG4gICAgICB0aGlzLmRyYXdlci5kcmF3UGVha3Moe1xuICAgICAgICBsZW5ndGg6IHRoaXMuZHJhd2VyLmdldFdpZHRoKClcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnRzLCBlbGVtZW50cyBhbmQgZGlzY29ubmVjdCBXZWJBdWRpbyBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2Rlc3Ryb3lcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGVzdHJveUFsbFBsdWdpbnMoKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdkZXN0cm95Jyk7XG4gICAgICB0aGlzLmNhbmNlbEFqYXgoKTtcbiAgICAgIHRoaXMuY2xlYXJUbXBFdmVudHMoKTtcbiAgICAgIHRoaXMudW5BbGwoKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2VuZCkge1xuICAgICAgICB0aGlzLmJhY2tlbmQuZGVzdHJveSgpOyAvLyBjbGVhcnMgbWVtb3J5IHVzYWdlXG5cbiAgICAgICAgdGhpcy5iYWNrZW5kID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZHJhd2VyKSB7XG4gICAgICAgIHRoaXMuZHJhd2VyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXJyYXlidWZmZXIgPSBudWxsO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSB0aGlzIGNsYXNzLCBjYWxsIGl0cyBgaW5pdGAgZnVuY3Rpb24gYW5kIHJldHVybnMgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFRoZSB3YXZlc3VyZmVyIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFdhdmVTdXJmZXIgaW5zdGFuY2VcbiAgICAgKiBAZXhhbXBsZSBjb25zdCB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUocGFyYW1zKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgd2F2ZXN1cmZlciA9IG5ldyBXYXZlU3VyZmVyKHBhcmFtcyk7XG4gICAgICByZXR1cm4gd2F2ZXN1cmZlci5pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaWJyYXJ5IHZlcnNpb24gbnVtYmVyIGlzIGF2YWlsYWJsZSBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvZiB0aGVcbiAgICAgKiBXYXZlU3VyZmVyIGNsYXNzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc29sZS5sb2coJ1VzaW5nIHdhdmVzdXJmZXIuanMgJyArIFdhdmVTdXJmZXIuVkVSU0lPTik7XG4gICAgICovXG5cbiAgfV0pO1xuXG4gIHJldHVybiBXYXZlU3VyZmVyO1xufSh1dGlsLk9ic2VydmVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV2F2ZVN1cmZlcjtcbldhdmVTdXJmZXIuVkVSU0lPTiA9IFwiNS4xLjBcIjtcbldhdmVTdXJmZXIudXRpbCA9IHV0aWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvd2ViYXVkaW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvd2ViYXVkaW8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIHVzaW5nIGNvbnN0YW50cyB0byBwcmV2ZW50IHNvbWVvbmUgd3JpdGluZyB0aGUgc3RyaW5nIHdyb25nXG52YXIgUExBWUlORyA9ICdwbGF5aW5nJztcbnZhciBQQVVTRUQgPSAncGF1c2VkJztcbnZhciBGSU5JU0hFRCA9ICdmaW5pc2hlZCc7XG4vKipcbiAqIFdlYkF1ZGlvIGJhY2tlbmRcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cblxudmFyIFdlYkF1ZGlvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfdXRpbCRPYnNlcnZlcikge1xuICBfaW5oZXJpdHMoV2ViQXVkaW8sIF91dGlsJE9ic2VydmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFdlYkF1ZGlvKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBiYWNrZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFdhdmVzdXJmZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gV2ViQXVkaW8ocGFyYW1zKSB7XG4gICAgdmFyIF90aGlzJHN0YXRlQmVoYXZpb3JzLCBfdGhpcyRzdGF0ZXM7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViQXVkaW8pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgX3RoaXMub2ZmbGluZUF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgX3RoaXMuc3RhdGVCZWhhdmlvcnMgPSAoX3RoaXMkc3RhdGVCZWhhdmlvcnMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlQmVoYXZpb3JzLCBQTEFZSU5HLCB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB0aGlzLmFkZE9uQXVkaW9Qcm9jZXNzKCk7XG4gICAgICB9LFxuICAgICAgZ2V0UGxheWVkUGVyY2VudHM6IGZ1bmN0aW9uIGdldFBsYXllZFBlcmNlbnRzKCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmdldER1cmF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkgLyBkdXJhdGlvbiB8fCAwO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRUaW1lOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3NpdGlvbiArIHRoaXMuZ2V0UGxheWVkVGltZSgpO1xuICAgICAgfVxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVCZWhhdmlvcnMsIFBBVVNFRCwge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPbkF1ZGlvUHJvY2VzcygpO1xuICAgICAgfSxcbiAgICAgIGdldFBsYXllZFBlcmNlbnRzOiBmdW5jdGlvbiBnZXRQbGF5ZWRQZXJjZW50cygpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5nZXREdXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VGltZSgpIC8gZHVyYXRpb24gfHwgMDtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VGltZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZUJlaGF2aW9ycywgRklOSVNIRUQsIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT25BdWRpb1Byb2Nlc3MoKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ2ZpbmlzaCcpO1xuICAgICAgfSxcbiAgICAgIGdldFBsYXllZFBlcmNlbnRzOiBmdW5jdGlvbiBnZXRQbGF5ZWRQZXJjZW50cygpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LFxuICAgICAgZ2V0Q3VycmVudFRpbWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREdXJhdGlvbigpO1xuICAgICAgfVxuICAgIH0pLCBfdGhpcyRzdGF0ZUJlaGF2aW9ycyk7XG4gICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIC8qKiBhYzogQXVkaW8gQ29udGV4dCBpbnN0YW5jZSAqL1xuXG4gICAgX3RoaXMuYWMgPSBwYXJhbXMuYXVkaW9Db250ZXh0IHx8IChfdGhpcy5zdXBwb3J0c1dlYkF1ZGlvKCkgPyBfdGhpcy5nZXRBdWRpb0NvbnRleHQoKSA6IHt9KTtcbiAgICAvKipAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMubGFzdFBsYXkgPSBfdGhpcy5hYy5jdXJyZW50VGltZTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc2NoZWR1bGVkUGF1c2UgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc3RhdGVzID0gKF90aGlzJHN0YXRlcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVzLCBQTEFZSU5HLCBPYmplY3QuY3JlYXRlKF90aGlzLnN0YXRlQmVoYXZpb3JzW1BMQVlJTkddKSksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZXMsIFBBVVNFRCwgT2JqZWN0LmNyZWF0ZShfdGhpcy5zdGF0ZUJlaGF2aW9yc1tQQVVTRURdKSksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZXMsIEZJTklTSEVELCBPYmplY3QuY3JlYXRlKF90aGlzLnN0YXRlQmVoYXZpb3JzW0ZJTklTSEVEXSkpLCBfdGhpcyRzdGF0ZXMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAvKiogZ2Fpbk5vZGU6IGFsbG93cyB0byBjb250cm9sIGF1ZGlvIHZvbHVtZSAqL1xuXG4gICAgX3RoaXMuZ2Fpbk5vZGUgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMubWVyZ2VkUGVha3MgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMub2ZmbGluZUFjID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBlYWtzID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgLyoqIGFuYWx5c2VyOiBwcm92aWRlcyBhdWRpbyBhbmFseXNpcyBpbmZvcm1hdGlvbiAqL1xuXG4gICAgX3RoaXMuYW5hbHlzZXIgPSBudWxsO1xuICAgIC8qKiBzY3JpcHROb2RlOiBhbGxvd3MgcHJvY2Vzc2luZyBhdWRpbyAqL1xuXG4gICAgX3RoaXMuc2NyaXB0Tm9kZSA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc3BsaXRQZWFrcyA9IFtdO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc3RhdGUgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuZXhwbGljaXREdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbjtcbiAgICAvKipcbiAgICAgKiBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGJhY2tlbmQgd2FzIGRlc3Ryb3llZC5cbiAgICAgKi9cblxuICAgIF90aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgYmFja2VuZCwgY2FsbGVkIGluIGB3YXZlc3VyZmVyLmNyZWF0ZUJhY2tlbmQoKWBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoV2ViQXVkaW8sIFt7XG4gICAga2V5OiBcInN1cHBvcnRzV2ViQXVkaW9cIixcbiAgICB2YWx1ZTpcbiAgICAvKiogc2NyaXB0QnVmZmVyU2l6ZTogc2l6ZSBvZiB0aGUgcHJvY2Vzc2luZyBidWZmZXIgKi9cblxuICAgIC8qKiBhdWRpb0NvbnRleHQ6IGFsbG93cyB0byBwcm9jZXNzIGF1ZGlvIHdpdGggV2ViQXVkaW8gQVBJICovXG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRoaXMgYmFja2VuZFxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoaXMgYmFja2VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzV2ViQXVkaW8oKSB7XG4gICAgICByZXR1cm4gISEod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdWRpbyBjb250ZXh0IHVzZWQgYnkgdGhpcyBiYWNrZW5kIG9yIGNyZWF0ZSBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0F1ZGlvQ29udGV4dH0gRXhpc3RpbmcgYXVkaW8gY29udGV4dCwgb3IgY3JlYXRlcyBhIG5ldyBvbmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEF1ZGlvQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdWRpb0NvbnRleHQoKSB7XG4gICAgICBpZiAoIXdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZsaW5lIGF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGlzIGJhY2tlbmQgb3IgY3JlYXRlIG9uZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZVJhdGUgVGhlIHNhbXBsZSByYXRlIHRvIHVzZVxuICAgICAqIEByZXR1cm4ge09mZmxpbmVBdWRpb0NvbnRleHR9IEV4aXN0aW5nIG9mZmxpbmUgYXVkaW8gY29udGV4dCwgb3IgY3JlYXRlc1xuICAgICAqIGEgbmV3IG9uZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZsaW5lQXVkaW9Db250ZXh0KHNhbXBsZVJhdGUpIHtcbiAgICAgIGlmICghd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyAod2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQpKDEsIDIsIHNhbXBsZVJhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlU2NyaXB0Tm9kZSgpO1xuICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoUEFVU0VEKTtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGFyYW1zLmF1ZGlvUmF0ZSk7XG4gICAgICB0aGlzLnNldExlbmd0aCgwKTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0RmlsdGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0RmlsdGVycygpIHtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgIGZpbHRlciAmJiBmaWx0ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbnVsbDsgLy8gUmVjb25uZWN0IGRpcmVjdCBwYXRoXG5cbiAgICAgICAgdGhpcy5hbmFseXNlci5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIFRoZSBuZXcgc3RhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXNbc3RhdGVdKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV07XG4gICAgICAgIHRoaXMuc3RhdGUuaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnBhY2tlZCBgc2V0RmlsdGVycygpYFxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5BdWRpb05vZGV9IGZpbHRlcnMgT25lIG9yIG1vcmUgZmlsdGVycyB0byBzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWx0ZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZmlsdGVycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgZmlsdGVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRGaWx0ZXJzKGZpbHRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgY3VzdG9tIFdlYiBBdWRpbyBub2RlcyBpbnRvIHRoZSBncmFwaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdWRpb05vZGVbXX0gZmlsdGVycyBQYWNrZWQgZmlsdGVycyBhcnJheVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbG93cGFzcyA9IHdhdmVzdXJmZXIuYmFja2VuZC5hYy5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICAgKiB3YXZlc3VyZmVyLmJhY2tlbmQuc2V0RmlsdGVyKGxvd3Bhc3MpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsdGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWx0ZXJzKGZpbHRlcnMpIHtcbiAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBmaWx0ZXJzXG4gICAgICB0aGlzLmRpc2Nvbm5lY3RGaWx0ZXJzKCk7IC8vIEluc2VydCBmaWx0ZXJzIGlmIGZpbHRlciBhcnJheSBub3QgZW1wdHlcblxuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVyczsgLy8gRGlzY29ubmVjdCBkaXJlY3QgcGF0aCBiZWZvcmUgaW5zZXJ0aW5nIGZpbHRlcnNcblxuICAgICAgICB0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKTsgLy8gQ29ubmVjdCBlYWNoIGZpbHRlciBpbiB0dXJuXG5cbiAgICAgICAgZmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICBwcmV2LmNvbm5lY3QoY3Vycik7XG4gICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgIH0sIHRoaXMuYW5hbHlzZXIpLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgU2NyaXB0UHJvY2Vzc29yTm9kZSB0byBwcm9jZXNzIGF1ZGlvICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTY3JpcHROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNjcmlwdE5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMuYXVkaW9TY3JpcHRQcm9jZXNzb3IpIHtcbiAgICAgICAgdGhpcy5zY3JpcHROb2RlID0gdGhpcy5wYXJhbXMuYXVkaW9TY3JpcHRQcm9jZXNzb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hYy5jcmVhdGVTY3JpcHRQcm9jZXNzb3IpIHtcbiAgICAgICAgICB0aGlzLnNjcmlwdE5vZGUgPSB0aGlzLmFjLmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihXZWJBdWRpby5zY3JpcHRCdWZmZXJTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNjcmlwdE5vZGUgPSB0aGlzLmFjLmNyZWF0ZUphdmFTY3JpcHROb2RlKFdlYkF1ZGlvLnNjcmlwdEJ1ZmZlclNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NyaXB0Tm9kZS5jb25uZWN0KHRoaXMuYWMuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZE9uQXVkaW9Qcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9uQXVkaW9Qcm9jZXNzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBfdGhpczIuZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgICAgICBpZiAodGltZSA+PSBfdGhpczIuZ2V0RHVyYXRpb24oKSkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZShGSU5JU0hFRCk7XG5cbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdwYXVzZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPj0gX3RoaXMyLnNjaGVkdWxlZFBhdXNlKSB7XG4gICAgICAgICAgX3RoaXMyLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLnN0YXRlID09PSBfdGhpczIuc3RhdGVzW1BMQVlJTkddKSB7XG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnYXVkaW9wcm9jZXNzJywgdGltZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlT25BdWRpb1Byb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlT25BdWRpb1Byb2Nlc3MoKSB7XG4gICAgICB0aGlzLnNjcmlwdE5vZGUub25hdWRpb3Byb2Nlc3MgPSBudWxsO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGFuYWx5c2VyIG5vZGUgdG8gcGVyZm9ybSBhdWRpbyBhbmFseXNpcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQW5hbHlzZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFuYWx5c2VyTm9kZSgpIHtcbiAgICAgIHRoaXMuYW5hbHlzZXIgPSB0aGlzLmFjLmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICB0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZ2FpbiBub2RlIG5lZWRlZCB0byBjb250cm9sIHRoZSBwbGF5YmFjayB2b2x1bWUuXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVZvbHVtZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVm9sdW1lTm9kZSgpIHtcbiAgICAgIC8vIENyZWF0ZSBnYWluIG5vZGUgdXNpbmcgdGhlIEF1ZGlvQ29udGV4dFxuICAgICAgaWYgKHRoaXMuYWMuY3JlYXRlR2Fpbikge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlID0gdGhpcy5hYy5jcmVhdGVHYWluTm9kZSgpO1xuICAgICAgfSAvLyBBZGQgdGhlIGdhaW4gbm9kZSB0byB0aGUgZ3JhcGhcblxuXG4gICAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QodGhpcy5hYy5kZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2luayBpZCBmb3IgdGhlIG1lZGlhIHBsYXllclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIFN0cmluZyB2YWx1ZSByZXByZXNlbnRpbmcgYXVkaW8gZGV2aWNlIGlkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlXG4gICAgICogYXJlIG5vIGVycm9ycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNpbmtJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdlYmF1ZGlvIEFQSSBkb2Vzbid0IGN1cnJlbnRseSBzdXBwb3J0IHNldHRpbmcgdGhlIGRldmljZVxuICAgICAgICAgKiBvdXRwdXQuIEhlcmUgd2UgY3JlYXRlIGFuIEhUTUxBdWRpb0VsZW1lbnQsIGNvbm5lY3QgdGhlXG4gICAgICAgICAqIHdlYmF1ZGlvIHN0cmVhbSB0byB0aGF0IGVsZW1lbnQgYW5kIHNldFNpbmtJZCB0aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBhdWRpbyA9IG5ldyB3aW5kb3cuQXVkaW8oKTtcblxuICAgICAgICBpZiAoIWF1ZGlvLnNldFNpbmtJZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3NldFNpbmtJZCBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlcicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1ZGlvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRlc3QgPSB0aGlzLmFjLmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICAgICAgdGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChkZXN0KTtcbiAgICAgICAgYXVkaW8uc3JjT2JqZWN0ID0gZGVzdC5zdHJlYW07XG4gICAgICAgIHJldHVybiBhdWRpby5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBkZXZpY2VJZDogJyArIGRldmljZUlkKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXVkaW8gdm9sdW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQSBmbG9hdGluZyBwb2ludCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbHVlKSB7XG4gICAgICB0aGlzLmdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodmFsdWUsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdm9sdW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIEEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vm9sdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZvbHVtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdhaW5Ob2RlLmdhaW4udmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBhcnJheSBidWZmZXIgYW5kIHBhc3MgZGF0YSB0byBhIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5YnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gY29tcGxldGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlcnJvci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUFycmF5QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUFycmF5QnVmZmVyKGFycmF5YnVmZmVyLCBjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgaWYgKCF0aGlzLm9mZmxpbmVBYykge1xuICAgICAgICB0aGlzLm9mZmxpbmVBYyA9IHRoaXMuZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCh0aGlzLmFjICYmIHRoaXMuYWMuc2FtcGxlUmF0ZSA/IHRoaXMuYWMuc2FtcGxlUmF0ZSA6IDQ0MTAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCd3ZWJraXRBdWRpb0NvbnRleHQnIGluIHdpbmRvdykge1xuICAgICAgICAvLyBTYWZhcmk6IG5vIHN1cHBvcnQgZm9yIFByb21pc2UtYmFzZWQgZGVjb2RlQXVkaW9EYXRhIGVuYWJsZWRcbiAgICAgICAgLy8gRW5hYmxlIGl0IGluIFNhZmFyaSB1c2luZyB0aGUgRXhwZXJpbWVudGFsIEZlYXR1cmVzID4gTW9kZXJuIFdlYkF1ZGlvIEFQSSBvcHRpb25cbiAgICAgICAgdGhpcy5vZmZsaW5lQWMuZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSwgZXJyYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9mZmxpbmVBYy5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZXJyYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHByZS1kZWNvZGVkIHBlYWtzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIFBlYWtzIGRhdGFcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGR1cmF0aW9uIEV4cGxpY2l0IGR1cmF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQZWFrcyhwZWFrcywgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXhwbGljaXREdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlYWtzID0gcGVha3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVuZGVyZWQgbGVuZ3RoIChkaWZmZXJlbnQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBhdWRpbylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHJlbmRlcmVkIGxlbmd0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExlbmd0aChsZW5ndGgpIHtcbiAgICAgIC8vIE5vIHJlc2l6ZSwgd2UgY2FuIHByZXNlcnZlIHRoZSBjYWNoZWQgcGVha3MuXG4gICAgICBpZiAodGhpcy5tZXJnZWRQZWFrcyAmJiBsZW5ndGggPT0gMiAqIHRoaXMubWVyZ2VkUGVha3MubGVuZ3RoIC0gMSArIDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNwbGl0UGVha3MgPSBbXTtcbiAgICAgIHRoaXMubWVyZ2VkUGVha3MgPSBbXTsgLy8gU2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHNwYXJzZSBhcnJheSBzbyB0aGUgcGVhayBhcnJheXMgYXJlXG4gICAgICAvLyBhcHByb3ByaWF0ZWx5IHNpemVkIGZvciBvdGhlciBjYWxjdWxhdGlvbnMuXG5cbiAgICAgIHZhciBjaGFubmVscyA9IHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIubnVtYmVyT2ZDaGFubmVscyA6IDE7XG4gICAgICB2YXIgYztcblxuICAgICAgZm9yIChjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgdGhpcy5zcGxpdFBlYWtzW2NdID0gW107XG4gICAgICAgIHRoaXMuc3BsaXRQZWFrc1tjXVsyICogKGxlbmd0aCAtIDEpXSA9IDA7XG4gICAgICAgIHRoaXMuc3BsaXRQZWFrc1tjXVsyICogKGxlbmd0aCAtIDEpICsgMV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lcmdlZFBlYWtzWzIgKiAobGVuZ3RoIC0gMSldID0gMDtcbiAgICAgIHRoaXMubWVyZ2VkUGVha3NbMiAqIChsZW5ndGggLSAxKSArIDFdID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbWF4IGFuZCBtaW4gdmFsdWUgb2YgdGhlIHdhdmVmb3JtIHdoZW4gYnJva2VuIGludG8gPGxlbmd0aD4gc3VicmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBIb3cgbWFueSBzdWJyYW5nZXMgdG8gYnJlYWsgdGhlIHdhdmVmb3JtIGludG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0IEZpcnN0IHNhbXBsZSBpbiB0aGUgcmVxdWlyZWQgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3QgTGFzdCBzYW1wbGUgaW4gdGhlIHJlcXVpcmVkIHJhbmdlLlxuICAgICAqIEByZXR1cm4ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IEFycmF5IG9mIDIqPGxlbmd0aD4gcGVha3Mgb3IgYXJyYXkgb2YgYXJyYXlzIG9mXG4gICAgICogcGVha3MgY29uc2lzdGluZyBvZiAobWF4LCBtaW4pIHZhbHVlcyBmb3IgZWFjaCBzdWJyYW5nZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlYWtzKGxlbmd0aCwgZmlyc3QsIGxhc3QpIHtcbiAgICAgIGlmICh0aGlzLnBlYWtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlYWtzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QgPSBmaXJzdCB8fCAwO1xuICAgICAgbGFzdCA9IGxhc3QgfHwgbGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuc2V0TGVuZ3RoKGxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHMgPyB0aGlzLnNwbGl0UGVha3MgOiB0aGlzLm1lcmdlZFBlYWtzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZm9sbG93aW5nIHNuaXBwZXQgZml4ZXMgYSBidWZmZXJpbmcgZGF0YSBpc3N1ZSBvbiB0aGUgU2FmYXJpXG4gICAgICAgKiBicm93c2VyIHdoaWNoIHJldHVybmVkIHVuZGVmaW5lZCBJdCBjcmVhdGVzIHRoZSBtaXNzaW5nIGJ1ZmZlciBiYXNlZFxuICAgICAgICogb24gMSBjaGFubmVsLCA0MDk2IHNhbXBsZXMgYW5kIHRoZSBzYW1wbGVSYXRlIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAqIHdlYmF1ZGlvIGNvbnRleHQgNDA5NiBzYW1wbGVzIHNlZW1lZCB0byBiZSB0aGUgYmVzdCBmaXQgZm9yIHJlbmRlcmluZ1xuICAgICAgICogd2lsbCByZXZpZXcgdGhpcyBjb2RlIG9uY2UgYSBzdGFibGUgdmVyc2lvbiBvZiBTYWZhcmkgVFAgaXMgb3V0XG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoMSwgNDA5NiwgdGhpcy5zYW1wbGVSYXRlKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXIuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FtcGxlU2l6ZSA9IHRoaXMuYnVmZmVyLmxlbmd0aCAvIGxlbmd0aDtcbiAgICAgIHZhciBzYW1wbGVTdGVwID0gfn4oc2FtcGxlU2l6ZSAvIDEwKSB8fCAxO1xuICAgICAgdmFyIGNoYW5uZWxzID0gdGhpcy5idWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgICAgIHZhciBjO1xuXG4gICAgICBmb3IgKGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuICAgICAgICB2YXIgcGVha3MgPSB0aGlzLnNwbGl0UGVha3NbY107XG4gICAgICAgIHZhciBjaGFuID0gdGhpcy5idWZmZXIuZ2V0Q2hhbm5lbERhdGEoYyk7XG4gICAgICAgIHZhciBpID0gdm9pZCAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgIHZhciBzdGFydCA9IH5+KGkgKiBzYW1wbGVTaXplKTtcbiAgICAgICAgICB2YXIgZW5kID0gfn4oc3RhcnQgKyBzYW1wbGVTaXplKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBtYXggYW5kIG1pbiB0byB0aGUgZmlyc3Qgc2FtcGxlIG9mIHRoaXNcbiAgICAgICAgICAgKiBzdWJyYW5nZSwgc28gdGhhdCBldmVuIGlmIHRoZSBzYW1wbGVzIGFyZSBlbnRpcmVseVxuICAgICAgICAgICAqIG9uIG9uZSBzaWRlIG9mIHplcm8sIHdlIHN0aWxsIHJldHVybiB0aGUgdHJ1ZSBtYXggYW5kXG4gICAgICAgICAgICogbWluIHZhbHVlcyBpbiB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICB2YXIgbWluID0gY2hhbltzdGFydF07XG4gICAgICAgICAgdmFyIG1heCA9IG1pbjtcbiAgICAgICAgICB2YXIgaiA9IHZvaWQgMDtcblxuICAgICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgZW5kOyBqICs9IHNhbXBsZVN0ZXApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5bal07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlYWtzWzIgKiBpXSA9IG1heDtcbiAgICAgICAgICBwZWFrc1syICogaSArIDFdID0gbWluO1xuXG4gICAgICAgICAgaWYgKGMgPT0gMCB8fCBtYXggPiB0aGlzLm1lcmdlZFBlYWtzWzIgKiBpXSkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZWRQZWFrc1syICogaV0gPSBtYXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT0gMCB8fCBtaW4gPCB0aGlzLm1lcmdlZFBlYWtzWzIgKiBpICsgMV0pIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VkUGVha3NbMiAqIGkgKyAxXSA9IG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHMgPyB0aGlzLnNwbGl0UGVha3MgOiB0aGlzLm1lcmdlZFBlYWtzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGZyb20gMCB0byAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBvc2l0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5ZWRQZXJjZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5ZWRQZXJjZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmdldFBsYXllZFBlcmNlbnRzLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdFNvdXJjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0U291cmNlKCkge1xuICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbGwgcmVmZXJlbmNlcyB3aXRoIFdlYkF1ZGlvLCBkaXNjb25uZWN0aW5nIGF1ZGlvIG5vZGVzIGFuZCBjbG9zaW5nIEF1ZGlvIENvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lXZWJBdWRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95V2ViQXVkaW8oKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RGaWx0ZXJzKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RTb3VyY2UoKTtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5zY3JpcHROb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuYW5hbHlzZXIuZGlzY29ubmVjdCgpOyAvLyBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IGlmIGNsb3NlQXVkaW9Db250ZXh0IG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZVxuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuY2xvc2VBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyBBdWRpb0NvbnRleHQuY2xvc2UoKVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYWMuY2xvc2UgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5hYy5zdGF0ZSAhPSAnY2xvc2VkJykge1xuICAgICAgICAgIHRoaXMuYWMuY2xvc2UoKTtcbiAgICAgICAgfSAvLyBjbGVhciB0aGUgcmVmZXJlbmNlIHRvIHRoZSBhdWRpb2NvbnRleHRcblxuXG4gICAgICAgIHRoaXMuYWMgPSBudWxsOyAvLyBjbGVhciB0aGUgYWN0dWFsIGF1ZGlvY29udGV4dCwgZWl0aGVyIHBhc3NlZCBhcyBwYXJhbSBvciB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIHNpbmdsZXRvblxuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyYW1zLmF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH0gLy8gY2xlYXIgdGhlIG9mZmxpbmVBdWRpb0NvbnRleHRcblxuXG4gICAgICAgIHdpbmRvdy5XYXZlU3VyZmVyT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gd2F2ZXN1cmZlciBpcyBkZXN0cm95ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bkFsbCgpO1xuICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kZXN0cm95V2ViQXVkaW8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZGVkIGEgZGVjb2RlZCBhdWRpbyBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBidWZmZXIgRGVjb2RlZCBhdWRpbyBidWZmZXIgdG8gbG9hZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKGJ1ZmZlcikge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMubGFzdFBsYXkgPSB0aGlzLmFjLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZSgpO1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNvdXJjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTb3VyY2UoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RTb3VyY2UoKTtcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5hYy5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgLy8gYWRqdXN0IGZvciBvbGQgYnJvd3NlcnNcblxuICAgICAgdGhpcy5zb3VyY2Uuc3RhcnQgPSB0aGlzLnNvdXJjZS5zdGFydCB8fCB0aGlzLnNvdXJjZS5ub3RlR3JhaW5PbjtcbiAgICAgIHRoaXMuc291cmNlLnN0b3AgPSB0aGlzLnNvdXJjZS5zdG9wIHx8IHRoaXMuc291cmNlLm5vdGVPZmY7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBsYXliYWNrUmF0ZSk7XG4gICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5hbmFseXNlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBzb21lIGJyb3dzZXJzIHJlcXVpcmUgYW4gZXhwbGljaXQgY2FsbCB0byAjcmVzdW1lIGJlZm9yZSB0aGV5IHdpbGwgcGxheSBiYWNrIGF1ZGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXN1bWVBdWRpb0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lQXVkaW9Db250ZXh0KCkge1xuICAgICAgaWYgKHRoaXMuYWMuc3RhdGUgPT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgdGhpcy5hYy5yZXN1bWUgJiYgdGhpcy5hYy5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5pc1BsYXlpbmcoKWAgYW5kIGB3YXZlc3VyZmVyLnBsYXlQYXVzZSgpYFxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyBiYWNrZW5kIGlzIGN1cnJlbnRseSBwYXVzZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzUGF1c2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGF1c2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzW1BMQVlJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLmdldER1cmF0aW9uKClgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IER1cmF0aW9uIG9mIGxvYWRlZCBidWZmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXhwbGljaXREdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5idWZmZXIuZHVyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuc2Vla1RvKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgUG9zaXRpb24gdG8gc3RhcnQgYXQgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgUG9zaXRpb24gdG8gZW5kIGF0IGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSBPYmplY3QgY29udGFpbmluZyBzdGFydCBhbmQgZW5kXG4gICAgICogcG9zaXRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWVrVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla1RvKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjaGVkdWxlZFBhdXNlID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLmdldEN1cnJlbnRUaW1lKCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID49IHRoaXMuZ2V0RHVyYXRpb24oKSkge1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gdGhpcy5nZXREdXJhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydDtcbiAgICAgIHRoaXMubGFzdFBsYXkgPSB0aGlzLmFjLmN1cnJlbnRUaW1lO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXNbRklOSVNIRURdKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoUEFVU0VEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGF5YmFjayBwb3NpdGlvbiBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwbGF5YmFjayBwb3NpdGlvbiBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5ZWRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXllZFRpbWUoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuYWMuY3VycmVudFRpbWUgLSB0aGlzLmxhc3RQbGF5KSAqIHRoaXMucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgbG9hZGVkIGF1ZGlvIHJlZ2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXQgaW4gc2Vjb25kcywgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAqIG9mIGEgY2xpcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFdoZW4gdG8gc3RvcCByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgY2xpcC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbmVlZCB0byByZS1jcmVhdGUgc291cmNlIG9uIGVhY2ggcGxheWJhY2tcblxuXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZSgpO1xuICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRoaXMuc2Vla1RvKHN0YXJ0LCBlbmQpO1xuICAgICAgc3RhcnQgPSBhZGp1c3RlZFRpbWUuc3RhcnQ7XG4gICAgICBlbmQgPSBhZGp1c3RlZFRpbWUuZW5kO1xuICAgICAgdGhpcy5zY2hlZHVsZWRQYXVzZSA9IGVuZDtcbiAgICAgIHRoaXMuc291cmNlLnN0YXJ0KDAsIHN0YXJ0KTtcbiAgICAgIHRoaXMucmVzdW1lQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKFBMQVlJTkcpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBsb2FkZWQgYXVkaW8uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVkUGF1c2UgPSBudWxsO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uICs9IHRoaXMuZ2V0UGxheWVkVGltZSgpO1xuICAgICAgdGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2Uuc3RvcCgwKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoUEFVU0VEKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwYXVzZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyByZWxhdGl2ZSB0byB0aGUgYXVkaW8tY2xpcCdzXG4gICAgICogZHVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VycmVudFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXRDdXJyZW50VGltZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuICgwPW5vIHBsYXliYWNrLCAxPW5vcm1hbCBwbGF5YmFjaylcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXliYWNrUmF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdWRpbyBzb3VyY2UgcGxheWJhY2sgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgcGxheWJhY2sgcmF0ZSB0byB1c2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5YmFja1JhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWUgfHwgMTtcbiAgICAgIHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSh0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5hYy5jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHBvaW50IGluIHNlY29uZHMgZm9yIHBsYXliYWNrIHRvIHN0b3AgYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFBvc2l0aW9uIHRvIGVuZCBhdFxuICAgICAqIEB2ZXJzaW9uIDMuMy4wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXlFbmQoZW5kKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlZFBhdXNlID0gZW5kO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJBdWRpbztcbn0odXRpbC5PYnNlcnZlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYkF1ZGlvO1xuV2ViQXVkaW8uc2NyaXB0QnVmZmVyU2l6ZSA9IDI1Njtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICogYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gKiBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLiBUaGUgZnVuY3Rpb24gYWxzbyBoYXMgYSBwcm9wZXJ0eSAnY2xlYXInIFxuICogdGhhdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgY2xlYXIgdGhlIHRpbWVyIHRvIHByZXZlbnQgcHJldmlvdXNseSBzY2hlZHVsZWQgZXhlY3V0aW9ucy4gXG4gKlxuICogQHNvdXJjZSB1bmRlcnNjb3JlLmpzXG4gKiBAc2VlIGh0dHA6Ly91bnNjcmlwdGFibGUuY29tLzIwMDkvMDMvMjAvZGVib3VuY2luZy1qYXZhc2NyaXB0LW1ldGhvZHMvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBpbiBtcyAoYDEwMGApXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgdG8gZXhlY3V0ZSBhdCB0aGUgYmVnaW5uaW5nIChgZmFsc2VgKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKXtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICBpZiAobnVsbCA9PSB3YWl0KSB3YWl0ID0gMTAwO1xuXG4gIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24oKXtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgZGVib3VuY2VkLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufTtcblxuLy8gQWRkcyBjb21wYXRpYmlsaXR5IGZvciBFUyBtb2R1bGVzXG5kZWJvdW5jZS5kZWJvdW5jZSA9IGRlYm91bmNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy93YXZlc3VyZmVyLmpzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdmVzdXJmZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC93YXZlc3VyZmVyLmpzIiwiLyohXG4gKiB3YXZlc3VyZmVyLmpzIGN1cnNvciBwbHVnaW4gNS4xLjAgKDIwMjEtMDYtMjApXG4gKiBodHRwczovL3dhdmVzdXJmZXItanMub3JnXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJXYXZlU3VyZmVyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIldhdmVTdXJmZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiV2F2ZVN1cmZlclwiXSA9IHJvb3RbXCJXYXZlU3VyZmVyXCJdIHx8IHt9LCByb290W1wiV2F2ZVN1cmZlclwiXVtcImN1cnNvclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL3NyYy9wbHVnaW4vY3Vyc29yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL2N1cnNvci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1cnNvclBsdWdpblBhcmFtc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGVmZXJJbml0IFNldCB0byB0cnVlIHRvIHN0b3AgYXV0byBpbml0IGluIGBhZGRQbHVnaW4oKWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlkZU9uQmx1cj10cnVlIEhpZGUgdGhlIGN1cnNvciB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlXG4gKiB3YXZlZm9ybVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHdpZHRoPScxcHgnIFRoZSB3aWR0aCBvZiB0aGUgY3Vyc29yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3I9J2JsYWNrJyBUaGUgY29sb3Igb2YgdGhlIGN1cnNvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9wYWNpdHk9JzAuMjUnIFRoZSBvcGFjaXR5IG9mIHRoZSBjdXJzb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZT0nc29saWQnIFRoZSBib3JkZXIgc3R5bGUgb2YgdGhlIGN1cnNvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpJbmRleD0zIFRoZSB6LWluZGV4IG9mIHRoZSBjdXJzb3IgZWxlbWVudFxuICogQHByb3BlcnR5IHtvYmplY3R9IGN1c3RvbVN0eWxlIEFuIG9iamVjdCB3aXRoIGN1c3RvbSBzdHlsZXMgd2hpY2ggYXJlIGFwcGxpZWRcbiAqIHRvIHRoZSBjdXJzb3IgZWxlbWVudFxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93VGltZT1mYWxzZSBTaG93IHRoZSB0aW1lIG9uIHRoZSBjdXJzb3IuXG4gKiBAcHJvcGVydHkge29iamVjdH0gY3VzdG9tU2hvd1RpbWVTdHlsZSBBbiBvYmplY3Qgd2l0aCBjdXN0b20gc3R5bGVzIHdoaWNoIGFyZVxuICogYXBwbGllZCB0byB0aGUgY3Vyc29yIHRpbWUgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb2xsb3dDdXJzb3JZPWZhbHNlIFVzZSBgdHJ1ZWAgdG8gbWFrZSB0aGUgdGltZSBvblxuICogdGhlIGN1cnNvciBmb2xsb3cgdGhlIHggYW5kIHRoZSB5LXBvc2l0aW9uIG9mIHRoZSBtb3VzZS4gVXNlIGBmYWxzZWAgdG8gbWFrZSB0aGVcbiAqIGl0IG9ubHkgZm9sbG93IHRoZSB4LXBvc2l0aW9uIG9mIHRoZSBtb3VzZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGZvcm1hdFRpbWVDYWxsYmFjayBGb3JtYXRzIHRoZSB0aW1lc3RhbXAgb24gdGhlIGN1cnNvci5cbiAqL1xuXG4vKipcbiAqIERpc3BsYXlzIGEgdGhpbiBsaW5lIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIG9uIHRoZSB3YXZlZm9ybS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7UGx1Z2luQ2xhc3N9XG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKiBAZXhhbXBsZVxuICogLy8gZXM2XG4gKiBpbXBvcnQgQ3Vyc29yUGx1Z2luIGZyb20gJ3dhdmVzdXJmZXIuY3Vyc29yLmpzJztcbiAqXG4gKiAvLyBjb21tb25qc1xuICogdmFyIEN1cnNvclBsdWdpbiA9IHJlcXVpcmUoJ3dhdmVzdXJmZXIuY3Vyc29yLmpzJyk7XG4gKlxuICogLy8gaWYgeW91IGFyZSB1c2luZyA8c2NyaXB0PiB0YWdzXG4gKiB2YXIgQ3Vyc29yUGx1Z2luID0gd2luZG93LldhdmVTdXJmZXIuY3Vyc29yO1xuICpcbiAqIC8vIC4uLiBpbml0aWFsaXNpbmcgd2F2ZXN1cmZlciB3aXRoIHRoZSBwbHVnaW5cbiAqIHZhciB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xuICogICAvLyB3YXZlc3VyZmVyIG9wdGlvbnMgLi4uXG4gKiAgIHBsdWdpbnM6IFtcbiAqICAgICBDdXJzb3JQbHVnaW4uY3JlYXRlKHtcbiAqICAgICAgIC8vIHBsdWdpbiBvcHRpb25zIC4uLlxuICogICAgIH0pXG4gKiAgIF1cbiAqIH0pO1xuICovXG52YXIgQ3Vyc29yUGx1Z2luID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgcGx1Z2luIGNsYXNzLiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgYEN1cnNvclBsdWdpbi5jcmVhdGVgXG4gICAqIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q3Vyc29yUGx1Z2luUGFyYW1zfSBwYXJhbXMgUGx1Z2luIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IHdzIFdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIEN1cnNvclBsdWdpbihwYXJhbXMsIHdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJzb3JQbHVnaW4pO1xuXG4gICAgdGhpcy5kZWZhdWx0UGFyYW1zID0ge1xuICAgICAgaGlkZU9uQmx1cjogdHJ1ZSxcbiAgICAgIHdpZHRoOiAnMXB4JyxcbiAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgb3BhY2l0eTogJzAuMjUnLFxuICAgICAgc3R5bGU6ICdzb2xpZCcsXG4gICAgICB6SW5kZXg6IDQsXG4gICAgICBjdXN0b21TdHlsZToge30sXG4gICAgICBjdXN0b21TaG93VGltZVN0eWxlOiB7fSxcbiAgICAgIHNob3dUaW1lOiBmYWxzZSxcbiAgICAgIGZvbGxvd0N1cnNvclk6IGZhbHNlLFxuICAgICAgZm9ybWF0VGltZUNhbGxiYWNrOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuX29uTW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBiYm94ID0gX3RoaXMud2F2ZXN1cmZlci5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciB4ID0gZS5jbGllbnRYIC0gYmJveC5sZWZ0O1xuXG4gICAgICB2YXIgZmxpcCA9IGJib3gucmlnaHQgPCBlLmNsaWVudFggKyBfdGhpcy5vdXRlcldpZHRoKF90aGlzLmRpc3BsYXlUaW1lKTtcblxuICAgICAgaWYgKF90aGlzLnBhcmFtcy5zaG93VGltZSAmJiBfdGhpcy5wYXJhbXMuZm9sbG93Q3Vyc29yWSkge1xuICAgICAgICAvLyBmb2xsb3cgeS1wb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgICAgeSA9IGUuY2xpZW50WSAtIChiYm94LnRvcCArIGJib3guaGVpZ2h0IC8gMik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZUN1cnNvclBvc2l0aW9uKHgsIHksIGZsaXApO1xuICAgIH07XG5cbiAgICB0aGlzLl9vbk1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2hvd0N1cnNvcigpO1xuICAgIH07XG5cbiAgICB0aGlzLl9vbk1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaGlkZUN1cnNvcigpO1xuICAgIH07XG5cbiAgICB0aGlzLndhdmVzdXJmZXIgPSB3cztcbiAgICB0aGlzLnN0eWxlID0gd3MudXRpbC5zdHlsZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3Vyc29yIEhUTUwgZWxlbWVudFxuICAgICAqXG4gICAgICogQHR5cGUgez9IVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgdGltZSBuZXh0IHRvIHRoZSBjdXJzb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHs/SFRNTEVsZW1lbnR9XG4gICAgICovXG5cbiAgICB0aGlzLnNob3dUaW1lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgaHRtbCBjb250YWluZXIgdGhhdCB3aWxsIGRpc3BsYXkgdGhlIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHs/SFRNTEVsZW1lbnR9XG4gICAgICovXG5cbiAgICB0aGlzLmRpc3BsYXlUaW1lID0gbnVsbDtcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFBhcmFtcywgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgcGx1Z2luICh1c2VkIGJ5IHRoZSBQbHVnaW4gQVBJKVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDdXJzb3JQbHVnaW4sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IHRoaXMud2F2ZXN1cmZlci5jb250YWluZXI7XG4gICAgICB0aGlzLmN1cnNvciA9IHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1cnNvcicpLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHpJbmRleDogdGhpcy5wYXJhbXMuekluZGV4LFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgd2lkdGg6ICcwJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBib3JkZXJSaWdodFN0eWxlOiB0aGlzLnBhcmFtcy5zdHlsZSxcbiAgICAgICAgYm9yZGVyUmlnaHRXaWR0aDogdGhpcy5wYXJhbXMud2lkdGgsXG4gICAgICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRoaXMucGFyYW1zLmNvbG9yLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLnBhcmFtcy5vcGFjaXR5LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sIHRoaXMucGFyYW1zLmN1c3RvbVN0eWxlKSkpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuc2hvd1RpbWUpIHtcbiAgICAgICAgdGhpcy5zaG93VGltZSA9IHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Nob3dUaXRsZScpLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB6SW5kZXg6IHRoaXMucGFyYW1zLnpJbmRleCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5wYXJhbXMub3BhY2l0eSxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgfSwgdGhpcy5wYXJhbXMuY3VzdG9tU3R5bGUpKSk7XG4gICAgICAgIHRoaXMuZGlzcGxheVRpbWUgPSB0aGlzLnNob3dUaW1lLmFwcGVuZENoaWxkKHRoaXMuc3R5bGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyAvLyBpbml0aWFsIHZhbHVlIHdpbGwgYmUgaGlkZGVuIGp1c3QgZm9yIG1lYXN1cmluZyBwdXJwb3NlXG5cbiAgICAgICAgfSwgdGhpcy5wYXJhbXMuY3VzdG9tU2hvd1RpbWVTdHlsZSkpKTsgLy8gaW5pdGlhbCB2YWx1ZSB0byBtZWFzdXJlIGRpc3BsYXkgd2lkdGhcblxuICAgICAgICB0aGlzLmRpc3BsYXlUaW1lLmlubmVySFRNTCA9IHRoaXMuZm9ybWF0VGltZSgwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2Vtb3ZlKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmhpZGVPbkJsdXIpIHtcbiAgICAgICAgLy8gZW5zdXJlIGVsZW1lbnRzIGFyZSBoaWRkZW4gaW5pdGlhbGx5XG4gICAgICAgIHRoaXMuaGlkZUN1cnNvcigpO1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX29uTW91c2VlbnRlcik7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fb25Nb3VzZWxlYXZlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgcGx1Z2luICh1c2VkIGJ5IHRoZSBQbHVnaW4gQVBJKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLnNob3dUaW1lKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zaG93VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3Vyc29yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jdXJzb3IpO1xuICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2Vtb3ZlKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmhpZGVPbkJsdXIpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9vbk1vdXNlZW50ZXIpO1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uTW91c2VsZWF2ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHBvcyBUaGUgeCBvZmZzZXQgb2YgdGhlIGN1cnNvciBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXBvcyBUaGUgeSBvZmZzZXQgb2YgdGhlIGN1cnNvciBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsaXAgRmxhZyB0byBmbGlwIGR1cmF0aW9uIHRleHQgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDdXJzb3JQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDdXJzb3JQb3NpdGlvbih4cG9zLCB5cG9zKSB7XG4gICAgICB2YXIgZmxpcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMuY3Vyc29yLCB7XG4gICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KHhwb3MsIFwicHhcIilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuc2hvd1RpbWUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgIHZhciBlbGVtZW50V2lkdGggPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndpZHRoIC8gdGhpcy53YXZlc3VyZmVyLnBhcmFtcy5waXhlbFJhdGlvO1xuICAgICAgICB2YXIgc2Nyb2xsV2lkdGggPSB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLmdldFNjcm9sbFgoKTtcbiAgICAgICAgdmFyIHNjcm9sbFRpbWUgPSBkdXJhdGlvbiAvIHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud2lkdGggKiBzY3JvbGxXaWR0aDtcbiAgICAgICAgdmFyIHRpbWVWYWx1ZSA9IE1hdGgubWF4KDAsIHhwb3MgLyBlbGVtZW50V2lkdGggKiBkdXJhdGlvbikgKyBzY3JvbGxUaW1lO1xuICAgICAgICB2YXIgZm9ybWF0VmFsdWUgPSB0aGlzLmZvcm1hdFRpbWUodGltZVZhbHVlKTtcblxuICAgICAgICBpZiAoZmxpcCkge1xuICAgICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gdGhpcy5vdXRlcldpZHRoKHRoaXMuZGlzcGxheVRpbWUpO1xuICAgICAgICAgIHhwb3MgLT0gdGV4dE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy5zaG93VGltZSwge1xuICAgICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KHhwb3MsIFwicHhcIiksXG4gICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdCh5cG9zLCBcInB4XCIpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMuZGlzcGxheVRpbWUsIHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlzcGxheVRpbWUuaW5uZXJIVE1MID0gXCJcIi5jb25jYXQoZm9ybWF0VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBjdXJzb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNob3dDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0N1cnNvcigpIHtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5jdXJzb3IsIHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnNob3dUaW1lKSB7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy5zaG93VGltZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgY3Vyc29yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoaWRlQ3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVDdXJzb3IoKSB7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMuY3Vyc29yLCB7XG4gICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5zaG93VGltZSkge1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMuc2hvd1RpbWUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aGUgdGltZXN0YW1wIGZvciBgY3Vyc29yVGltZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3Vyc29yVGltZSBUaW1lIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgdGltZXN0YW1wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRpbWUoY3Vyc29yVGltZSkge1xuICAgICAgY3Vyc29yVGltZSA9IGlzTmFOKGN1cnNvclRpbWUpID8gMCA6IGN1cnNvclRpbWU7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5mb3JtYXRUaW1lQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmZvcm1hdFRpbWVDYWxsYmFjayhjdXJzb3JUaW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtjdXJzb3JUaW1lXS5tYXAoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmZsb29yKHRpbWUgJSAzNjAwIC8gNjApLCAvLyBtaW51dGVzXG4gICAgICAgICgnMDAnICsgTWF0aC5mbG9vcih0aW1lICUgNjApKS5zbGljZSgtMiksIC8vIHNlY29uZHNcbiAgICAgICAgKCcwMDAnICsgTWF0aC5mbG9vcih0aW1lICUgMSAqIDEwMDApKS5zbGljZSgtMykgLy8gbWlsbGlzZWNvbmRzXG4gICAgICAgIF0uam9pbignOicpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBvdXRlciB3aWR0aCBvZiBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET019IGVsZW1lbnQgRE9NIEVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBvdXRlciB3aWR0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3V0ZXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRlcldpZHRoKGVsZW1lbnQpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICB3aWR0aCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0ICsgc3R5bGUubWFyZ2luUmlnaHQpO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEN1cnNvciBwbHVnaW4gZGVmaW5pdGlvbiBmYWN0b3J5XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBjcmVhdGUgYSBwbHVnaW4gZGVmaW5pdGlvbiB3aGljaCBjYW4gYmVcbiAgICAgKiB1c2VkIGJ5IHdhdmVzdXJmZXIgdG8gY29ycmVjdGx5IGluc3RhbnRpYXRlIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtDdXJzb3JQbHVnaW5QYXJhbXN9IHBhcmFtcyBwYXJhbWV0ZXJzIHVzZSB0byBpbml0aWFsaXNlIHRoZVxuICAgICAqIHBsdWdpblxuICAgICAqIEByZXR1cm4ge1BsdWdpbkRlZmluaXRpb259IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsdWdpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdjdXJzb3InLFxuICAgICAgICBkZWZlckluaXQ6IHBhcmFtcyAmJiBwYXJhbXMuZGVmZXJJbml0ID8gcGFyYW1zLmRlZmVySW5pdCA6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgc3RhdGljUHJvcHM6IHt9LFxuICAgICAgICBpbnN0YW5jZTogQ3Vyc29yUGx1Z2luXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q3Vyc29yUGx1Z2luUGFyYW1zfVxuICAgICAqL1xuXG4gIH1dKTtcblxuICByZXR1cm4gQ3Vyc29yUGx1Z2luO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDdXJzb3JQbHVnaW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3BsdWdpbi9jdXJzb3IvaW5kZXguanNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5jdXJzb3IuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC9wbHVnaW4vd2F2ZXN1cmZlci5jdXJzb3IuanMiLCIvKiFcbiAqIHdhdmVzdXJmZXIuanMgcmVnaW9ucyBwbHVnaW4gNS4xLjAgKDIwMjEtMDYtMjApXG4gKiBodHRwczovL3dhdmVzdXJmZXItanMub3JnXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJXYXZlU3VyZmVyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIldhdmVTdXJmZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiV2F2ZVN1cmZlclwiXSA9IHJvb3RbXCJXYXZlU3VyZmVyXCJdIHx8IHt9LCByb290W1wiV2F2ZVN1cmZlclwiXVtcInJlZ2lvbnNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvcGx1Z2luL3JlZ2lvbnMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL3JlZ2lvbnMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVnaW9uLmpzICovIFwiLi9zcmMvcGx1Z2luL3JlZ2lvbnMvcmVnaW9uLmpzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBSZWdpb25zIGFyZSB2aXN1YWwgb3ZlcmxheXMgb24gd2F2ZWZvcm0gdGhhdCBjYW4gYmUgdXNlZCB0byBwbGF5IGFuZCBsb29wXG4gKiBwb3J0aW9ucyBvZiBhdWRpby4gUmVnaW9ucyBjYW4gYmUgZHJhZ2dlZCBhbmQgcmVzaXplZC5cbiAqXG4gKiBWaXN1YWwgY3VzdG9taXphdGlvbiBpcyBwb3NzaWJsZSB2aWEgQ1NTICh1c2luZyB0aGUgc2VsZWN0b3JzXG4gKiBgLndhdmVzdXJmZXItcmVnaW9uYCBhbmQgYC53YXZlc3VyZmVyLWhhbmRsZWApLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtQbHVnaW5DbGFzc31cbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gZXM2XG4gKiBpbXBvcnQgUmVnaW9uc1BsdWdpbiBmcm9tICd3YXZlc3VyZmVyLnJlZ2lvbnMuanMnO1xuICpcbiAqIC8vIGNvbW1vbmpzXG4gKiB2YXIgUmVnaW9uc1BsdWdpbiA9IHJlcXVpcmUoJ3dhdmVzdXJmZXIucmVnaW9ucy5qcycpO1xuICpcbiAqIC8vIGlmIHlvdSBhcmUgdXNpbmcgPHNjcmlwdD4gdGFnc1xuICogdmFyIFJlZ2lvbnNQbHVnaW4gPSB3aW5kb3cuV2F2ZVN1cmZlci5yZWdpb25zO1xuICpcbiAqIC8vIC4uLiBpbml0aWFsaXNpbmcgd2F2ZXN1cmZlciB3aXRoIHRoZSBwbHVnaW5cbiAqIHZhciB3YXZlc3VyZmVyID0gV2F2ZVN1cmZlci5jcmVhdGUoe1xuICogICAvLyB3YXZlc3VyZmVyIG9wdGlvbnMgLi4uXG4gKiAgIHBsdWdpbnM6IFtcbiAqICAgICBSZWdpb25zUGx1Z2luLmNyZWF0ZSh7XG4gKiAgICAgICAvLyBwbHVnaW4gb3B0aW9ucyAuLi5cbiAqICAgICB9KVxuICogICBdXG4gKiB9KTtcbiAqL1xudmFyIFJlZ2lvbnNQbHVnaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWdpb25zUGx1Z2luKHBhcmFtcywgd3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZ2lvbnNQbHVnaW4pO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy53YXZlc3VyZmVyID0gd3M7XG4gICAgdGhpcy51dGlsID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB3cy51dGlsKSwge30sIHtcbiAgICAgIGdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZTogZnVuY3Rpb24gZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUodmFsdWUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tYXhSZWdpb25zID0gcGFyYW1zLm1heFJlZ2lvbnM7XG4gICAgdGhpcy5yZWdpb25zTWluTGVuZ3RoID0gcGFyYW1zLnJlZ2lvbnNNaW5MZW5ndGggfHwgbnVsbDsgLy8gdHVybiB0aGUgcGx1Z2luIGluc3RhbmNlIGludG8gYW4gb2JzZXJ2ZXJcblxuICAgIHZhciBvYnNlcnZlclByb3RvdHlwZUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlKTtcbiAgICBvYnNlcnZlclByb3RvdHlwZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfcmVnaW9uLlJlZ2lvbi5wcm90b3R5cGVba2V5XSA9IF90aGlzLnV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlW2tleV07XG4gICAgfSk7XG4gICAgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbiA9IF9yZWdpb24uUmVnaW9uOyAvLyBCeSBkZWZhdWx0LCBzY3JvbGwgdGhlIGNvbnRhaW5lciBpZiB0aGUgdXNlciBkcmFncyBhIHJlZ2lvblxuICAgIC8vIHdpdGhpbiA1JSBvZiBpdHMgZWRnZVxuXG4gICAgdmFyIHNjcm9sbFdpZHRoUHJvcG9ydGlvbiA9IDAuMDU7XG5cbiAgICB0aGlzLl9vbkJhY2tlbmRDcmVhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMud3JhcHBlciA9IF90aGlzLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXI7XG4gICAgICBfdGhpcy5vcmllbnRhdGlvbiA9IF90aGlzLndhdmVzdXJmZXIuZHJhd2VyLm9yaWVudGF0aW9uO1xuXG4gICAgICBpZiAoX3RoaXMucGFyYW1zLnJlZ2lvbnMpIHtcbiAgICAgICAgX3RoaXMucGFyYW1zLnJlZ2lvbnMuZm9yRWFjaChmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICAgICAgcmVnaW9uLmVkZ2VTY3JvbGxXaWR0aCA9IF90aGlzLnBhcmFtcy5lZGdlU2Nyb2xsV2lkdGggfHwgX3RoaXMud3JhcHBlci5jbGllbnRXaWR0aCAqIHNjcm9sbFdpZHRoUHJvcG9ydGlvbjtcblxuICAgICAgICAgIF90aGlzLmFkZChyZWdpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9OyAvLyBJZC1iYXNlZCBoYXNoIG9mIHJlZ2lvbnNcblxuXG4gICAgdGhpcy5saXN0ID0ge307XG5cbiAgICB0aGlzLl9vblJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMud3JhcHBlciA9IF90aGlzLndhdmVzdXJmZXIuZHJhd2VyLndyYXBwZXI7XG4gICAgICBfdGhpcy52ZXJ0aWNhbCA9IF90aGlzLndhdmVzdXJmZXIuZHJhd2VyLnBhcmFtcy52ZXJ0aWNhbDtcblxuICAgICAgaWYgKF90aGlzLnBhcmFtcy5kcmFnU2VsZWN0aW9uKSB7XG4gICAgICAgIF90aGlzLmVuYWJsZURyYWdTZWxlY3Rpb24oX3RoaXMucGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmtleXMoX3RoaXMubGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgX3RoaXMubGlzdFtpZF0udXBkYXRlUmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlZ2lvbnNQbHVnaW4sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vIENoZWNrIGlmIHdzIGlzIHJlYWR5XG4gICAgICBpZiAodGhpcy53YXZlc3VyZmVyLmlzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fb25CYWNrZW5kQ3JlYXRlZCgpO1xuXG4gICAgICAgIHRoaXMuX29uUmVhZHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbmNlKCdyZWFkeScsIHRoaXMuX29uUmVhZHkpO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIub25jZSgnYmFja2VuZC1jcmVhdGVkJywgdGhpcy5fb25CYWNrZW5kQ3JlYXRlZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci51bigncmVhZHknLCB0aGlzLl9vblJlYWR5KTtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci51bignYmFja2VuZC1jcmVhdGVkJywgdGhpcy5fb25CYWNrZW5kQ3JlYXRlZCk7XG4gICAgICB0aGlzLmRpc2FibGVEcmFnU2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNoZWNrIHRvIHNlZSBpZiBhZGRpbmcgYSBuZXcgcmVnaW9uIHdvdWxkIGV4Y2VlZCBtYXhSZWdpb25zXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB3ZSBzaG91bGQgcHJvY2VlZCBhbmQgY3JlYXRlIGEgcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndvdWxkRXhjZWVkTWF4UmVnaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3b3VsZEV4Y2VlZE1heFJlZ2lvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXhSZWdpb25zICYmIE9iamVjdC5rZXlzKHRoaXMubGlzdCkubGVuZ3RoID49IHRoaXMubWF4UmVnaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcmVnaW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIFJlZ2lvbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7UmVnaW9ufSBUaGUgY3JlYXRlZCByZWdpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocGFyYW1zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMud291bGRFeGNlZWRNYXhSZWdpb25zKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLm1pbkxlbmd0aCAmJiB0aGlzLnJlZ2lvbnNNaW5MZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgIG1pbkxlbmd0aDogdGhpcy5yZWdpb25zTWluTGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaW9uID0gbmV3IHRoaXMud2F2ZXN1cmZlci5SZWdpb24ocGFyYW1zLCB0aGlzLnV0aWwsIHRoaXMud2F2ZXN1cmZlcik7XG4gICAgICB0aGlzLmxpc3RbcmVnaW9uLmlkXSA9IHJlZ2lvbjtcbiAgICAgIHJlZ2lvbi5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgX3RoaXMyLmxpc3RbcmVnaW9uLmlkXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCByZWdpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3QpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIF90aGlzMy5saXN0W2lkXS5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVEcmFnU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZURyYWdTZWxlY3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5kaXNhYmxlRHJhZ1NlbGVjdGlvbigpO1xuICAgICAgdmFyIHNsb3AgPSBwYXJhbXMuc2xvcCB8fCAyO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgdmFyIHNjcm9sbCA9IHBhcmFtcy5zY3JvbGwgIT09IGZhbHNlICYmIHRoaXMud2F2ZXN1cmZlci5wYXJhbXMuc2Nyb2xsUGFyZW50O1xuICAgICAgdmFyIHNjcm9sbFNwZWVkID0gcGFyYW1zLnNjcm9sbFNwZWVkIHx8IDE7XG4gICAgICB2YXIgc2Nyb2xsVGhyZXNob2xkID0gcGFyYW1zLnNjcm9sbFRocmVzaG9sZCB8fCAxMDtcbiAgICAgIHZhciBkcmFnO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICB2YXIgbWF4U2Nyb2xsO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIHJlZ2lvbjtcbiAgICAgIHZhciB0b3VjaElkO1xuICAgICAgdmFyIHB4TW92ZSA9IDA7XG4gICAgICB2YXIgc2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgdmFyIHdyYXBwZXJSZWN0OyAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuXG4gICAgICB2YXIgZWRnZVNjcm9sbCA9IGZ1bmN0aW9uIGVkZ2VTY3JvbGwoZSkge1xuICAgICAgICBpZiAoIXJlZ2lvbiB8fCAhc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFVwZGF0ZSBzY3JvbGwgcG9zaXRpb25cblxuXG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gX3RoaXM0LndyYXBwZXIuc2Nyb2xsTGVmdCArIHNjcm9sbFNwZWVkICogc2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgICBfdGhpczQud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWluKG1heFNjcm9sbCwgTWF0aC5tYXgoMCwgc2Nyb2xsTGVmdCkpOyAvLyBVcGRhdGUgcmFuZ2VcblxuICAgICAgICB2YXIgZW5kID0gX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUpO1xuXG4gICAgICAgIHJlZ2lvbi51cGRhdGUoe1xuICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbihlbmQgKiBkdXJhdGlvbiwgc3RhcnQgKiBkdXJhdGlvbiksXG4gICAgICAgICAgZW5kOiBNYXRoLm1heChlbmQgKiBkdXJhdGlvbiwgc3RhcnQgKiBkdXJhdGlvbilcbiAgICAgICAgfSk7IC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgbW9yZSB0byBzY3JvbGwgYW5kIHJlcGVhdFxuXG4gICAgICAgIGlmIChzY3JvbGxMZWZ0IDwgbWF4U2Nyb2xsICYmIHNjcm9sbExlZnQgPiAwKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlZGdlU2Nyb2xsKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXZlbnREb3duID0gZnVuY3Rpb24gZXZlbnREb3duKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXM0LndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgdG91Y2hJZCA9IGUudGFyZ2V0VG91Y2hlcyA/IGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyIDogbnVsbDsgLy8gU3RvcmUgZm9yIHNjcm9sbCBjYWxjdWxhdGlvbnNcblxuICAgICAgICBtYXhTY3JvbGwgPSBfdGhpczQud3JhcHBlci5zY3JvbGxXaWR0aCAtIF90aGlzNC53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgICB3cmFwcGVyUmVjdCA9IF90aGlzNC51dGlsLndpdGhPcmllbnRhdGlvbihfdGhpczQud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgX3RoaXM0LnZlcnRpY2FsKTtcbiAgICAgICAgZHJhZyA9IHRydWU7XG4gICAgICAgIHN0YXJ0ID0gX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGUsIHRydWUpO1xuICAgICAgICByZWdpb24gPSBudWxsO1xuICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50RG93bik7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50RG93bik7XG4gICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnREb3duKTtcblxuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudERvd24pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBldmVudFVwID0gZnVuY3Rpb24gZXZlbnRVcChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnID0gZmFsc2U7XG4gICAgICAgIHB4TW92ZSA9IDA7XG4gICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgIF90aGlzNC51dGlsLnByZXZlbnRDbGljaygpO1xuXG4gICAgICAgICAgcmVnaW9uLmZpcmVFdmVudCgndXBkYXRlLWVuZCcsIGUpO1xuXG4gICAgICAgICAgX3RoaXM0LndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tdXBkYXRlLWVuZCcsIHJlZ2lvbiwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpb24gPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBldmVudFVwKTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuICAgICAgdGhpcy5vbignZGlzYWJsZS1kcmFnLXNlbGVjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudFVwKTtcblxuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuXG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcblxuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZXZlbnRVcCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGV2ZW50TW92ZSA9IGZ1bmN0aW9uIGV2ZW50TW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWRyYWcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKytweE1vdmUgPD0gc2xvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciAhPSB0b3VjaElkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGF1dG8tY3JlYXRlIGEgcmVnaW9uIGR1cmluZyBtb3VzZSBkcmFnLCB1bmxlc3MgcmVnaW9uLWNvdW50IHdvdWxkIGV4Y2VlZCBcIm1heFJlZ2lvbnNcIlxuXG5cbiAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICByZWdpb24gPSBfdGhpczQuYWRkKHBhcmFtcyB8fCB7fSk7XG5cbiAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgIHZhciBzdGFydFVwZGF0ZSA9IF90aGlzNC53YXZlc3VyZmVyLnJlZ2lvbnMudXRpbC5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUoc3RhcnQgKiBkdXJhdGlvbik7XG5cbiAgICAgICAgdmFyIGVuZFVwZGF0ZSA9IF90aGlzNC53YXZlc3VyZmVyLnJlZ2lvbnMudXRpbC5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUoZW5kICogZHVyYXRpb24pO1xuXG4gICAgICAgIHJlZ2lvbi51cGRhdGUoe1xuICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbihlbmRVcGRhdGUsIHN0YXJ0VXBkYXRlKSxcbiAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZFVwZGF0ZSwgc3RhcnRVcGRhdGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvcmllbnRlZEV2ZW50ID0gX3RoaXM0LnV0aWwud2l0aE9yaWVudGF0aW9uKGV2ZW50LCBfdGhpczQudmVydGljYWwpOyAvLyBJZiBzY3JvbGxpbmcgaXMgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKHNjcm9sbCAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCBfdGhpczQud3JhcHBlci5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgIC8vIENoZWNrIHRocmVzaG9sZCBiYXNlZCBvbiBtb3VzZVxuICAgICAgICAgIHZhciB4ID0gb3JpZW50ZWRFdmVudC5jbGllbnRYIC0gd3JhcHBlclJlY3QubGVmdDtcblxuICAgICAgICAgIGlmICh4IDw9IHNjcm9sbFRocmVzaG9sZCkge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmICh4ID49IHdyYXBwZXJSZWN0LnJpZ2h0IC0gc2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiAmJiBlZGdlU2Nyb2xsKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGV2ZW50TW92ZSk7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnRNb3ZlKTtcbiAgICAgIHRoaXMub24oJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50TW92ZSk7XG5cbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRNb3ZlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53YXZlc3VyZmVyLm9uKCdyZWdpb24tY3JlYXRlZCcsIGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgaWYgKF90aGlzNC5yZWdpb25zTWluTGVuZ3RoKSB7XG4gICAgICAgICAgcmVnaW9uLm1pbkxlbmd0aCA9IF90aGlzNC5yZWdpb25zTWluTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZURyYWdTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZURyYWdTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnZGlzYWJsZS1kcmFnLXNlbGVjdGlvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCByZWdpb25cbiAgICAgKlxuICAgICAqIFRoZSBzbWFsbGVzdCByZWdpb24gdGhhdCBjb250YWlucyB0aGUgY3VycmVudCB0aW1lLiBJZiBzZXZlcmFsIHN1Y2hcbiAgICAgKiByZWdpb25zIGV4aXN0LCB0YWtlIHRoZSBmaXJzdC4gUmV0dXJuIGBudWxsYCBpZiBub25lIGV4aXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1JlZ2lvbn0gVGhlIGN1cnJlbnQgcmVnaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50UmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRSZWdpb24oKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHRpbWUgPSB0aGlzLndhdmVzdXJmZXIuZ2V0Q3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBtaW4gPSBudWxsO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgY3VyID0gX3RoaXM1Lmxpc3RbaWRdO1xuXG4gICAgICAgIGlmIChjdXIuc3RhcnQgPD0gdGltZSAmJiBjdXIuZW5kID49IHRpbWUpIHtcbiAgICAgICAgICBpZiAoIW1pbiB8fCBjdXIuZW5kIC0gY3VyLnN0YXJ0IDwgbWluLmVuZCAtIG1pbi5zdGFydCkge1xuICAgICAgICAgICAgbWluID0gY3VyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCB0aGUgdmFsdWUgdG8gdGhlIGdyaWQsIGlmIHJlcXVpcmVkXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVnaW9ucyBwbHVnaW4gcGFyYW1zIGhhdmUgYSBzbmFwVG9HcmlkSW50ZXJ2YWwgc2V0LCByZXR1cm4gdGhlXG4gICAgICogdmFsdWUgbWF0Y2hpbmcgdGhlIG5lYXJlc3QgZ3JpZCBpbnRlcnZhbC4gSWYgbm8gc25hcFRvR3JpZEludGVydmFsIGlzIHNldCxcbiAgICAgKiB0aGUgcGFzc2VkIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIHZhbHVlIHRvIHNuYXAgdG8gdGhlIGdyaWQsIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgdGhlIHJlZ2lvbnMgcGx1Z2luIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWdpb25TbmFwVG9HcmlkVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMuc25hcFRvR3JpZEludGVydmFsKSB7XG4gICAgICAgIC8vIHRoZSByZWdpb25zIHNob3VsZCBzbmFwIHRvIGEgZ3JpZFxuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyYW1zLnNuYXBUb0dyaWRPZmZzZXQgfHwgMDtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlIC0gb2Zmc2V0KSAvIHBhcmFtcy5zbmFwVG9HcmlkSW50ZXJ2YWwpICogcGFyYW1zLnNuYXBUb0dyaWRJbnRlcnZhbCArIG9mZnNldDtcbiAgICAgIH0gLy8gbm8gc25hcC10by1ncmlkXG5cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFJlZ2lvbnMgcGx1Z2luIGRlZmluaXRpb24gZmFjdG9yeVxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gY3JlYXRlIGEgcGx1Z2luIGRlZmluaXRpb24gd2hpY2ggY2FuIGJlXG4gICAgICogdXNlZCBieSB3YXZlc3VyZmVyIHRvIGNvcnJlY3RseSBpbnN0YW50aWF0ZSB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdpb25zUGx1Z2luUGFyYW1zfSBwYXJhbXMgcGFyYW1ldGVycyB1c2UgdG8gaW5pdGlhbGlzZSB0aGUgcGx1Z2luXG4gICAgICogQHJldHVybiB7UGx1Z2luRGVmaW5pdGlvbn0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGx1Z2luXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHBhcmFtcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3JlZ2lvbnMnLFxuICAgICAgICBkZWZlckluaXQ6IHBhcmFtcyAmJiBwYXJhbXMuZGVmZXJJbml0ID8gcGFyYW1zLmRlZmVySW5pdCA6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgc3RhdGljUHJvcHM6IHtcbiAgICAgICAgICBhZGRSZWdpb246IGZ1bmN0aW9uIGFkZFJlZ2lvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0LnJlZ2lvbnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbml0UGx1Z2luKCdyZWdpb25zJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbnMuYWRkKG9wdGlvbnMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXJSZWdpb25zOiBmdW5jdGlvbiBjbGVhclJlZ2lvbnMoKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnMgJiYgdGhpcy5yZWdpb25zLmNsZWFyKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmFibGVEcmFnU2VsZWN0aW9uOiBmdW5jdGlvbiBlbmFibGVEcmFnU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QucmVnaW9ucykge1xuICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZWdpb25zLmVuYWJsZURyYWdTZWxlY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNhYmxlRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24gZGlzYWJsZURyYWdTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlOiBSZWdpb25zUGx1Z2luXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWdpb25zUGx1Z2luO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWdpb25zUGx1Z2luO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9yZWdpb25zL3JlZ2lvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL3JlZ2lvbnMvcmVnaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUmVnaW9uID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogIEBzaW5jZSA0LjAuMFxuICpcbiAqIChTaW5nbGUpIFJlZ2lvbiBwbHVnaW4gY2xhc3NcbiAqXG4gKiBNdXN0IGJlIHR1cm5lZCBpbnRvIGFuIG9ic2VydmVyIGJlZm9yZSBpbnN0YW50aWF0aW5nLiBUaGlzIGlzIGRvbmUgaW5cbiAqIGBSZWdpb25zUGx1Z2luYCAobWFpbiBwbHVnaW4gY2xhc3MpLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqL1xudmFyIFJlZ2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlZ2lvbihwYXJhbXMsIHJlZ2lvbnNVdGlscywgd3MpIHtcbiAgICB2YXIgX3BhcmFtcyRzaG93VG9vbHRpcCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZ2lvbik7XG5cbiAgICB0aGlzLndhdmVzdXJmZXIgPSB3cztcbiAgICB0aGlzLndyYXBwZXIgPSB3cy5kcmF3ZXIud3JhcHBlcjtcbiAgICB0aGlzLnV0aWwgPSB3cy51dGlsO1xuICAgIHRoaXMuc3R5bGUgPSB0aGlzLnV0aWwuc3R5bGU7XG4gICAgdGhpcy5yZWdpb25zVXRpbCA9IHJlZ2lvbnNVdGlscztcbiAgICB0aGlzLnZlcnRpY2FsID0gd3MuZHJhd2VyLnBhcmFtcy52ZXJ0aWNhbDtcbiAgICB0aGlzLmlkID0gcGFyYW1zLmlkID09IG51bGwgPyB3cy51dGlsLmdldElkKCkgOiBwYXJhbXMuaWQ7XG4gICAgdGhpcy5zdGFydCA9IE51bWJlcihwYXJhbXMuc3RhcnQpIHx8IDA7XG4gICAgdGhpcy5lbmQgPSBwYXJhbXMuZW5kID09IG51bGwgPyAvLyBzbWFsbCBtYXJrZXItbGlrZSByZWdpb25cbiAgICB0aGlzLnN0YXJ0ICsgNCAvIHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAqIHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpIDogTnVtYmVyKHBhcmFtcy5lbmQpO1xuICAgIHRoaXMucmVzaXplID0gcGFyYW1zLnJlc2l6ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4ocGFyYW1zLnJlc2l6ZSk7XG4gICAgdGhpcy5kcmFnID0gcGFyYW1zLmRyYWcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBCb29sZWFuKHBhcmFtcy5kcmFnKTsgLy8gcmVmbGVjdCByZXNpemUgYW5kIGRyYWcgc3RhdGUgb2YgcmVnaW9uIGZvciByZWdpb24tdXBkYXRlZCBsaXN0ZW5lclxuXG4gICAgdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gQm9vbGVhbihwYXJhbXMubG9vcCk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCAncmdiYSgwLCAwLCAwLCAwLjEpJzsgLy8gVGhlIGxlZnQgYW5kIHJpZ2h0IGhhbmRsZVN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHNldCB0byAnbm9uZScgZm9yXG4gICAgLy8gbm8gc3R5bGluZyBvciBjYW4gYmUgYXNzaWduZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgQ1NTIHByb3BlcnRpZXMuXG5cbiAgICB0aGlzLmhhbmRsZVN0eWxlID0gcGFyYW1zLmhhbmRsZVN0eWxlIHx8IHtcbiAgICAgIGxlZnQ6IHt9LFxuICAgICAgcmlnaHQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUxlZnRFbCA9IG51bGw7XG4gICAgdGhpcy5oYW5kbGVSaWdodEVsID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YSB8fCB7fTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBwYXJhbXMuYXR0cmlidXRlcyB8fCB7fTtcbiAgICB0aGlzLnNob3dUb29sdGlwID0gKF9wYXJhbXMkc2hvd1Rvb2x0aXAgPSBwYXJhbXMuc2hvd1Rvb2x0aXApICE9PSBudWxsICYmIF9wYXJhbXMkc2hvd1Rvb2x0aXAgIT09IHZvaWQgMCA/IF9wYXJhbXMkc2hvd1Rvb2x0aXAgOiB0cnVlO1xuICAgIHRoaXMubWF4TGVuZ3RoID0gcGFyYW1zLm1heExlbmd0aDsgLy8gSXQgYXNzdW1lcyB0aGUgbWluTGVuZ3RoIHBhcmFtZXRlciB2YWx1ZSwgb3IgdGhlIHJlZ2lvbnNNaW5MZW5ndGggcGFyYW1ldGVyIHZhbHVlLCBpZiB0aGUgZmlyc3Qgb25lIG5vdCBwcm92aWRlZFxuXG4gICAgdGhpcy5taW5MZW5ndGggPSBwYXJhbXMubWluTGVuZ3RoO1xuXG4gICAgdGhpcy5fb25SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlUmVuZGVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2Nyb2xsID0gcGFyYW1zLnNjcm9sbCAhPT0gZmFsc2UgJiYgd3MucGFyYW1zLnNjcm9sbFBhcmVudDtcbiAgICB0aGlzLnNjcm9sbFNwZWVkID0gcGFyYW1zLnNjcm9sbFNwZWVkIHx8IDE7XG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSBwYXJhbXMuc2Nyb2xsVGhyZXNob2xkIHx8IDEwOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbnRleHQgbWVudSBpcyBwcmV2ZW50ZWQgZnJvbSBiZWluZyBvcGVuZWQuXG5cbiAgICB0aGlzLnByZXZlbnRDb250ZXh0TWVudSA9IHBhcmFtcy5wcmV2ZW50Q29udGV4dE1lbnUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogQm9vbGVhbihwYXJhbXMucHJldmVudENvbnRleHRNZW51KTsgLy8gc2VsZWN0IGNoYW5uZWwgSUQgdG8gc2V0IHJlZ2lvblxuXG4gICAgdmFyIGNoYW5uZWxJZHggPSBwYXJhbXMuY2hhbm5lbElkeCA9PSBudWxsID8gLTEgOiBwYXJzZUludChwYXJhbXMuY2hhbm5lbElkeCk7XG4gICAgdGhpcy5yZWdpb25IZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5tYXJnaW5Ub3AgPSAnMHB4JztcblxuICAgIGlmIChjaGFubmVsSWR4ICE9PSAtMSkge1xuICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLmJ1ZmZlciAhPSBudWxsID8gdGhpcy53YXZlc3VyZmVyLmJhY2tlbmQuYnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgOiAtMTtcblxuICAgICAgaWYgKGNoYW5uZWxDb3VudCA+PSAwICYmIGNoYW5uZWxJZHggPCBjaGFubmVsQ291bnQpIHtcbiAgICAgICAgdGhpcy5yZWdpb25IZWlnaHQgPSBNYXRoLmZsb29yKDEgLyBjaGFubmVsQ291bnQgKiAxMDApICsgJyUnO1xuICAgICAgICB0aGlzLm1hcmdpblRvcCA9IHRoaXMud2F2ZXN1cmZlci5nZXRIZWlnaHQoKSAqIGNoYW5uZWxJZHggKyAncHgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0VGltZUNhbGxiYWNrID0gcGFyYW1zLmZvcm1hdFRpbWVDYWxsYmFjaztcbiAgICB0aGlzLmVkZ2VTY3JvbGxXaWR0aCA9IHBhcmFtcy5lZGdlU2Nyb2xsV2lkdGg7XG4gICAgdGhpcy5iaW5kSW5PdXQoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMud2F2ZXN1cmZlci5vbignem9vbScsIHRoaXMuX29uUmVkcmF3KTtcbiAgICB0aGlzLndhdmVzdXJmZXIub24oJ3JlZHJhdycsIHRoaXMuX29uUmVkcmF3KTtcbiAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tY3JlYXRlZCcsIHRoaXMpO1xuICB9XG4gIC8qIFVwZGF0ZSByZWdpb24gcGFyYW1zLiAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFJlZ2lvbiwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gTnVtYmVyKHBhcmFtcy5zdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuZW5kICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBOdW1iZXIocGFyYW1zLmVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubG9vcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ocGFyYW1zLmxvb3ApO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5oYW5kbGVTdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU3R5bGUgPSBwYXJhbXMuaGFuZGxlU3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJlc2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzaXplID0gQm9vbGVhbihwYXJhbXMucmVzaXplKTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzUmVzaXplKHRoaXMucmVzaXplKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5kcmFnICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kcmFnID0gQm9vbGVhbihwYXJhbXMuZHJhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubWF4TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBOdW1iZXIocGFyYW1zLm1heExlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMubWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBOdW1iZXIocGFyYW1zLm1pbkxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHBhcmFtcy5hdHRyaWJ1dGVzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcigpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3VwZGF0ZScpO1xuICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXVwZGF0ZWQnLCB0aGlzKTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGEgc2luZ2xlIHJlZ2lvbi4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQuZG9tRWxlbWVudCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdyZW1vdmUnKTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCd6b29tJywgdGhpcy5fb25SZWRyYXcpO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ3JlZHJhdycsIHRoaXMuX29uUmVkcmF3KTtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXJlbW92ZWQnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheSB0aGUgYXVkaW8gcmVnaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBPcHRpb25hbCBvZmZzZXQgdG8gc3RhcnQgcGxheWluZyBhdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHN0YXJ0KSB7XG4gICAgICB2YXIgcyA9IHN0YXJ0IHx8IHRoaXMuc3RhcnQ7XG4gICAgICB0aGlzLndhdmVzdXJmZXIucGxheShzLCB0aGlzLmVuZCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGxheScpO1xuICAgICAgdGhpcy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXBsYXknLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheSB0aGUgYXVkaW8gcmVnaW9uIGluIGEgbG9vcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgT3B0aW9uYWwgb2Zmc2V0IHRvIHN0YXJ0IHBsYXlpbmcgYXRcbiAgICAgKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheUxvb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheUxvb3Aoc3RhcnQpIHtcbiAgICAgIHRoaXMubG9vcCA9IHRydWU7XG4gICAgICB0aGlzLnBsYXkoc3RhcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgbG9vcGluZyBvbi9vZmYuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb29wIFRydWUgaWYgc2hvdWxkIHBsYXkgaW4gbG9vcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9vcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb29wKGxvb3ApIHtcbiAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgfVxuICAgIC8qIFJlbmRlciBhIHJlZ2lvbiBhcyBhIERPTSBlbGVtZW50LiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMudXRpbC53aXRoT3JpZW50YXRpb24odGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlZ2lvbicpKSwgdGhpcy52ZXJ0aWNhbCk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJ3dhdmVzdXJmZXItcmVnaW9uJztcblxuICAgICAgaWYgKHRoaXMuc2hvd1Rvb2x0aXApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnRpdGxlID0gdGhpcy5mb3JtYXRUaW1lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsIHRoaXMuaWQpO1xuXG4gICAgICBmb3IgKHZhciBhdHRybmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1yZWdpb24tJyArIGF0dHJuYW1lLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cm5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHlsZSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHpJbmRleDogMixcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnJlZ2lvbkhlaWdodCxcbiAgICAgICAgdG9wOiB0aGlzLm1hcmdpblRvcFxuICAgICAgfSk7XG4gICAgICAvKiBSZXNpemUgaGFuZGxlcyAqL1xuXG4gICAgICBpZiAodGhpcy5yZXNpemUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVMZWZ0RWwgPSB0aGlzLnV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoYW5kbGUnKSksIHRoaXMudmVydGljYWwpO1xuICAgICAgICB0aGlzLmhhbmRsZVJpZ2h0RWwgPSB0aGlzLnV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoYW5kbGUnKSksIHRoaXMudmVydGljYWwpO1xuICAgICAgICB0aGlzLmhhbmRsZUxlZnRFbC5jbGFzc05hbWUgPSAnd2F2ZXN1cmZlci1oYW5kbGUgd2F2ZXN1cmZlci1oYW5kbGUtc3RhcnQnO1xuICAgICAgICB0aGlzLmhhbmRsZVJpZ2h0RWwuY2xhc3NOYW1lID0gJ3dhdmVzdXJmZXItaGFuZGxlIHdhdmVzdXJmZXItaGFuZGxlLWVuZCc7IC8vIERlZmF1bHQgQ1NTIHByb3BlcnRpZXMgZm9yIGJvdGggaGFuZGxlcy5cblxuICAgICAgICB2YXIgY3NzID0ge1xuICAgICAgICAgIGN1cnNvcjogdGhpcy52ZXJ0aWNhbCA/ICdyb3ctcmVzaXplJyA6ICdjb2wtcmVzaXplJyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6ICcwcHgnLFxuICAgICAgICAgIHdpZHRoOiAnMnB4JyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDEpJ1xuICAgICAgICB9OyAvLyBNZXJnZSBDU1MgcHJvcGVydGllcyBwZXIgaGFuZGxlLlxuXG4gICAgICAgIHZhciBoYW5kbGVMZWZ0Q3NzID0gdGhpcy5oYW5kbGVTdHlsZS5sZWZ0ICE9PSAnbm9uZScgPyBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBsZWZ0OiAnMHB4J1xuICAgICAgICB9LCBjc3MsIHRoaXMuaGFuZGxlU3R5bGUubGVmdCkgOiBudWxsO1xuICAgICAgICB2YXIgaGFuZGxlUmlnaHRDc3MgPSB0aGlzLmhhbmRsZVN0eWxlLnJpZ2h0ICE9PSAnbm9uZScgPyBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICByaWdodDogJzBweCdcbiAgICAgICAgfSwgY3NzLCB0aGlzLmhhbmRsZVN0eWxlLnJpZ2h0KSA6IG51bGw7XG5cbiAgICAgICAgaWYgKGhhbmRsZUxlZnRDc3MpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKHRoaXMuaGFuZGxlTGVmdEVsLCBoYW5kbGVMZWZ0Q3NzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVSaWdodENzcykge1xuICAgICAgICAgIHRoaXMuc3R5bGUodGhpcy5oYW5kbGVSaWdodEVsLCBoYW5kbGVSaWdodENzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVSZW5kZXIoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRpbWUoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHRoaXMuZm9ybWF0VGltZUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRpbWVDYWxsYmFjayhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChzdGFydCA9PSBlbmQgPyBbc3RhcnRdIDogW3N0YXJ0LCBlbmRdKS5tYXAoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmZsb29yKHRpbWUgJSAzNjAwIC8gNjApLCAvLyBtaW51dGVzXG4gICAgICAgICgnMDAnICsgTWF0aC5mbG9vcih0aW1lICUgNjApKS5zbGljZSgtMikgLy8gc2Vjb25kc1xuICAgICAgICBdLmpvaW4oJzonKTtcbiAgICAgIH0pLmpvaW4oJy0nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy53YXZlc3VyZmVyLmRyYXdlci53aWR0aCAvIHRoaXMud2F2ZXN1cmZlci5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICB9XG4gICAgLyogVXBkYXRlIGVsZW1lbnQncyBwb3NpdGlvbiwgd2lkdGgsIGNvbG9yLiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJlbmRlcigpIHtcbiAgICAgIC8vIGR1cmF0aW9uIHZhcmllcyBkdXJpbmcgbG9hZGluZyBwcm9jZXNzLCBzbyBkb24ndCBvdmVyd3JpdGUgaW1wb3J0YW50IGRhdGFcbiAgICAgIHZhciBkdXIgPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBzdGFydExpbWl0ZWQgPSB0aGlzLnN0YXJ0O1xuICAgICAgdmFyIGVuZExpbWl0ZWQgPSB0aGlzLmVuZDtcblxuICAgICAgaWYgKHN0YXJ0TGltaXRlZCA8IDApIHtcbiAgICAgICAgc3RhcnRMaW1pdGVkID0gMDtcbiAgICAgICAgZW5kTGltaXRlZCA9IGVuZExpbWl0ZWQgLSBzdGFydExpbWl0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRMaW1pdGVkID4gZHVyKSB7XG4gICAgICAgIGVuZExpbWl0ZWQgPSBkdXI7XG4gICAgICAgIHN0YXJ0TGltaXRlZCA9IGR1ciAtIChlbmRMaW1pdGVkIC0gc3RhcnRMaW1pdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgZW5kTGltaXRlZCA9IE1hdGgubWF4KHN0YXJ0TGltaXRlZCArIHRoaXMubWluTGVuZ3RoLCBlbmRMaW1pdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF4TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgZW5kTGltaXRlZCA9IE1hdGgubWluKHN0YXJ0TGltaXRlZCArIHRoaXMubWF4TGVuZ3RoLCBlbmRMaW1pdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgd2lkdGggdmFsdWVzIG9mIHRoZSByZWdpb24gc3VjaCB0aGF0XG4gICAgICAgIC8vIG5vIGdhcHMgYXBwZWFyIGJldHdlZW4gcmVnaW9ucy5cbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLnJvdW5kKHN0YXJ0TGltaXRlZCAvIGR1ciAqIHdpZHRoKTtcbiAgICAgICAgdmFyIHJlZ2lvbldpZHRoID0gTWF0aC5yb3VuZChlbmRMaW1pdGVkIC8gZHVyICogd2lkdGgpIC0gbGVmdDtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgICB3aWR0aDogcmVnaW9uV2lkdGggKyAncHgnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBjdXJzb3I6IHRoaXMuZHJhZyA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhdHRybmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXJlZ2lvbi0nICsgYXR0cm5hbWUsIHRoaXMuYXR0cmlidXRlc1thdHRybmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1Rvb2x0aXApIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQudGl0bGUgPSB0aGlzLmZvcm1hdFRpbWUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEJpbmQgYXVkaW8gZXZlbnRzLiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEluT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRJbk91dCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmZpcmVkSW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZmlyZWRPdXQgPSBmYWxzZTtcblxuICAgICAgdmFyIG9uUHJvY2VzcyA9IGZ1bmN0aW9uIG9uUHJvY2Vzcyh0aW1lKSB7XG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgucm91bmQoX3RoaXMyLnN0YXJ0ICogMTApIC8gMTA7XG4gICAgICAgIHZhciBlbmQgPSBNYXRoLnJvdW5kKF90aGlzMi5lbmQgKiAxMCkgLyAxMDtcbiAgICAgICAgdGltZSA9IE1hdGgucm91bmQodGltZSAqIDEwKSAvIDEwO1xuXG4gICAgICAgIGlmICghX3RoaXMyLmZpcmVkT3V0ICYmIF90aGlzMi5maXJlZEluICYmIChzdGFydCA+IHRpbWUgfHwgZW5kIDw9IHRpbWUpKSB7XG4gICAgICAgICAgX3RoaXMyLmZpcmVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpczIuZmlyZWRJbiA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMyLmZpcmVFdmVudCgnb3V0Jyk7XG5cbiAgICAgICAgICBfdGhpczIud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1vdXQnLCBfdGhpczIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfdGhpczIuZmlyZWRJbiAmJiBzdGFydCA8PSB0aW1lICYmIGVuZCA+IHRpbWUpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZWRJbiA9IHRydWU7XG4gICAgICAgICAgX3RoaXMyLmZpcmVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdpbicpO1xuXG4gICAgICAgICAgX3RoaXMyLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24taW4nLCBfdGhpczIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndhdmVzdXJmZXIuYmFja2VuZC5vbignYXVkaW9wcm9jZXNzJywgb25Qcm9jZXNzKTtcbiAgICAgIHRoaXMub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLndhdmVzdXJmZXIuYmFja2VuZC51bignYXVkaW9wcm9jZXNzJywgb25Qcm9jZXNzKTtcbiAgICAgIH0pO1xuICAgICAgLyogTG9vcCBwbGF5YmFjay4gKi9cblxuICAgICAgdGhpcy5vbignb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLmxvb3ApIHtcbiAgICAgICAgICB2YXIgcmVhbFRpbWUgPSBfdGhpczIud2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHJlYWxUaW1lID49IF90aGlzMi5zdGFydCAmJiByZWFsVGltZSA8PSBfdGhpczIuZW5kKSB7XG4gICAgICAgICAgICBfdGhpczIud2F2ZXN1cmZlci5wbGF5KF90aGlzMi5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyogQmluZCBET00gZXZlbnRzLiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwcmV2ZW50Q29udGV4dE1lbnUgPSB0aGlzLnByZXZlbnRDb250ZXh0TWVudTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnbW91c2VlbnRlcicsIGUpO1xuXG4gICAgICAgIF90aGlzMy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW1vdXNlZW50ZXInLCBfdGhpczMsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ21vdXNlbGVhdmUnLCBlKTtcblxuICAgICAgICBfdGhpczMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1tb3VzZWxlYXZlJywgX3RoaXMzLCBlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ2NsaWNrJywgZSk7XG5cbiAgICAgICAgX3RoaXMzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tY2xpY2snLCBfdGhpczMsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnZGJsY2xpY2snLCBlKTtcblxuICAgICAgICBfdGhpczMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1kYmxjbGljaycsIF90aGlzMywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChwcmV2ZW50Q29udGV4dE1lbnUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdjb250ZXh0bWVudScsIGUpO1xuXG4gICAgICAgIF90aGlzMy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLWNvbnRleHRtZW51JywgX3RoaXMzLCBlKTtcbiAgICAgIH0pO1xuICAgICAgLyogRHJhZyBvciByZXNpemUgb24gbW91c2Vtb3ZlLiAqL1xuXG4gICAgICBpZiAodGhpcy5kcmFnIHx8IHRoaXMucmVzaXplKSB7XG4gICAgICAgIHRoaXMuYmluZERyYWdFdmVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZERyYWdFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZERyYWdFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuY29udGFpbmVyO1xuICAgICAgdmFyIHNjcm9sbFNwZWVkID0gdGhpcy5zY3JvbGxTcGVlZDtcbiAgICAgIHZhciBzY3JvbGxUaHJlc2hvbGQgPSB0aGlzLnNjcm9sbFRocmVzaG9sZDtcbiAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICB2YXIgdG91Y2hJZDtcbiAgICAgIHZhciBkcmFnO1xuICAgICAgdmFyIG1heFNjcm9sbDtcbiAgICAgIHZhciByZXNpemU7XG4gICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdmFyIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgIHZhciB3cmFwcGVyUmVjdDtcbiAgICAgIHZhciByZWdpb25MZWZ0SGFsZlRpbWU7XG4gICAgICB2YXIgcmVnaW9uUmlnaHRIYWxmVGltZTsgLy8gU2Nyb2xsIHdoZW4gdGhlIHVzZXIgaXMgZHJhZ2dpbmcgd2l0aGluIHRoZSB0aHJlc2hvbGRcblxuICAgICAgdmFyIGVkZ2VTY3JvbGwgPSBmdW5jdGlvbiBlZGdlU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIHZhciBvcmllbnRlZEV2ZW50ID0gX3RoaXM0LnV0aWwud2l0aE9yaWVudGF0aW9uKGV2ZW50LCBfdGhpczQudmVydGljYWwpO1xuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IF90aGlzNC53YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKCFzY3JvbGxEaXJlY3Rpb24gfHwgIWRyYWcgJiYgIXJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4ID0gb3JpZW50ZWRFdmVudC5jbGllbnRYO1xuICAgICAgICB2YXIgZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UgPSAwO1xuICAgICAgICB2YXIgcmVnaW9uSGFsZlRpbWVXaWR0aCA9IDA7XG4gICAgICAgIHZhciBhZGp1c3RtZW50ID0gMDsgLy8gR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGltZSBhY2NvcmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIHRpbWUgPSBfdGhpczQucmVnaW9uc1V0aWwuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChldmVudCkgKiBkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGRyYWcpIHtcbiAgICAgICAgICAvLyBDb25zaWRlcmluZyB0aGUgcG9pbnQgb2YgY29udGFjdCB3aXRoIHRoZSByZWdpb24gd2hpbGUgZWRnZXNjcm9sbGluZ1xuICAgICAgICAgIGlmIChzY3JvbGxEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICByZWdpb25IYWxmVGltZVdpZHRoID0gcmVnaW9uTGVmdEhhbGZUaW1lICogX3RoaXM0LndhdmVzdXJmZXIucGFyYW1zLm1pblB4UGVyU2VjO1xuICAgICAgICAgICAgZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UgPSB4IC0gd3JhcHBlclJlY3QubGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVnaW9uSGFsZlRpbWVXaWR0aCA9IHJlZ2lvblJpZ2h0SGFsZlRpbWUgKiBfdGhpczQud2F2ZXN1cmZlci5wYXJhbXMubWluUHhQZXJTZWM7XG4gICAgICAgICAgICBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSA9IHdyYXBwZXJSZWN0LnJpZ2h0IC0geDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29uc2lkZXJpbmcgbWluTGVuZ3RoIHdoaWxlIGVkZ2VzY3JvbGxcbiAgICAgICAgICB2YXIgbWluTGVuZ3RoID0gX3RoaXM0Lm1pbkxlbmd0aDtcblxuICAgICAgICAgIGlmICghbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICBtaW5MZW5ndGggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNpemUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID4gX3RoaXM0LmVuZCAtIG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICB0aW1lID0gX3RoaXM0LmVuZCAtIG1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgYWRqdXN0bWVudCA9IHNjcm9sbFNwZWVkICogc2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZSA8IDApIHtcbiAgICAgICAgICAgICAgdGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNpemUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBpZiAodGltZSA8IF90aGlzNC5zdGFydCArIG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICB0aW1lID0gX3RoaXM0LnN0YXJ0ICsgbWluTGVuZ3RoO1xuICAgICAgICAgICAgICBhZGp1c3RtZW50ID0gc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGltZSA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEb24ndCBlZGdlc2Nyb2xsIGlmIHJlZ2lvbiBoYXMgcmVhY2hlZCBtaW4gb3IgbWF4IGxpbWl0XG5cblxuICAgICAgICB2YXIgd3JhcHBlclNjcm9sbExlZnQgPSBfdGhpczQud3JhcHBlci5zY3JvbGxMZWZ0O1xuXG4gICAgICAgIGlmIChzY3JvbGxEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgaWYgKE1hdGgucm91bmQod3JhcHBlclNjcm9sbExlZnQpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE1hdGgucm91bmQod3JhcHBlclNjcm9sbExlZnQgLSByZWdpb25IYWxmVGltZVdpZHRoICsgZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKE1hdGgucm91bmQod3JhcHBlclNjcm9sbExlZnQpID09PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3cmFwcGVyU2Nyb2xsTGVmdCArIHJlZ2lvbkhhbGZUaW1lV2lkdGggLSBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSkgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBzY3JvbGwgcG9zaXRpb25cblxuXG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gd3JhcHBlclNjcm9sbExlZnQgLSBhZGp1c3RtZW50ICsgc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG5cbiAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZExlZnQgPSBNYXRoLm1heCgwICsgcmVnaW9uSGFsZlRpbWVXaWR0aCAtIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlLCBzY3JvbGxMZWZ0KTtcbiAgICAgICAgICBfdGhpczQud3JhcHBlci5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IGNhbGN1bGF0ZWRMZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjYWxjdWxhdGVkUmlnaHQgPSBNYXRoLm1pbihtYXhTY3JvbGwgLSByZWdpb25IYWxmVGltZVdpZHRoICsgZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UsIHNjcm9sbExlZnQpO1xuICAgICAgICAgIF90aGlzNC53cmFwcGVyLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0ID0gY2FsY3VsYXRlZFJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZTsgLy8gQ29udGludWUgZHJhZ2dpbmcgb3IgcmVzaXppbmdcblxuICAgICAgICBkcmFnID8gX3RoaXM0Lm9uRHJhZyhkZWx0YSkgOiBfdGhpczQub25SZXNpemUoZGVsdGEsIHJlc2l6ZSk7IC8vIFJlcGVhdFxuXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVkZ2VTY3JvbGwoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvbkRvd24gPSBmdW5jdGlvbiBvbkRvd24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gX3RoaXM0LndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0b3VjaElkID0gZXZlbnQudGFyZ2V0VG91Y2hlcyA/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciA6IG51bGw7IC8vIHN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLCBpZiB0aGlzIHJlZ2lvbiBpcyByZXNpemFibGUgb3IgZHJhZ2dhYmxlXG4gICAgICAgIC8vIGFuZCB0aGUgZXZlbnQgaXMgdGhlcmVmb3JlIGhhbmRsZWQgaGVyZS5cblxuICAgICAgICBpZiAoX3RoaXM0LmRyYWcgfHwgX3RoaXM0LnJlc2l6ZSkge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSBzZWxlY3RlZCBzdGFydFRpbWUgd2UgYmVndW4gZHJhZ2dpbmcgb3IgcmVzaXppbmdcblxuXG4gICAgICAgIHN0YXJ0VGltZSA9IF90aGlzNC5yZWdpb25zVXRpbC5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUoX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGV2ZW50LCB0cnVlKSAqIGR1cmF0aW9uKTsgLy8gU3RvcmUgdGhlIHNlbGVjdGVkIHBvaW50IG9mIGNvbnRhY3Qgd2hlbiB3ZSBiZWdpbiBkcmFnZ2luZ1xuXG4gICAgICAgIHJlZ2lvbkxlZnRIYWxmVGltZSA9IHN0YXJ0VGltZSAtIF90aGlzNC5zdGFydDtcbiAgICAgICAgcmVnaW9uUmlnaHRIYWxmVGltZSA9IF90aGlzNC5lbmQgLSBzdGFydFRpbWU7IC8vIFN0b3JlIGZvciBzY3JvbGwgY2FsY3VsYXRpb25zXG5cbiAgICAgICAgbWF4U2Nyb2xsID0gX3RoaXM0LndyYXBwZXIuc2Nyb2xsV2lkdGggLSBfdGhpczQud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgd3JhcHBlclJlY3QgPSBfdGhpczQudXRpbC53aXRoT3JpZW50YXRpb24oX3RoaXM0LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIF90aGlzNC52ZXJ0aWNhbCk7XG4gICAgICAgIF90aGlzNC5pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzNC5pc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdoYW5kbGUnKSB7XG4gICAgICAgICAgX3RoaXM0LmlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgIHJlc2l6ZSA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3dhdmVzdXJmZXItaGFuZGxlLXN0YXJ0JykgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM0LmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIGRyYWcgPSB0cnVlO1xuICAgICAgICAgIHJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25VcCA9IGZ1bmN0aW9uIG9uVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWcgfHwgcmVzaXplKSB7XG4gICAgICAgICAgX3RoaXM0LmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpczQuaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGRyYWcgPSBmYWxzZTtcbiAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIHJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpczQudXRpbC5wcmV2ZW50Q2xpY2soKTtcblxuICAgICAgICAgIF90aGlzNC5maXJlRXZlbnQoJ3VwZGF0ZS1lbmQnLCBldmVudCk7XG5cbiAgICAgICAgICBfdGhpczQud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi11cGRhdGUtZW5kJywgX3RoaXM0LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gX3RoaXM0LndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgICB2YXIgb3JpZW50ZWRFdmVudCA9IF90aGlzNC51dGlsLndpdGhPcmllbnRhdGlvbihldmVudCwgX3RoaXM0LnZlcnRpY2FsKTtcblxuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcyAmJiBldmVudC50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgIT0gdG91Y2hJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZHJhZyAmJiAhcmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgICAgdmFyIHRpbWUgPSBfdGhpczQucmVnaW9uc1V0aWwuZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlKF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChldmVudCkgKiBkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGRyYWcpIHtcbiAgICAgICAgICAvLyBUbyBtYWludGFpbiByZWxhdGl2ZSBjdXJzb3Igc3RhcnQgcG9pbnQgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICB2YXIgbWF4RW5kID0gX3RoaXM0LndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgICAgIGlmICh0aW1lID4gbWF4RW5kIC0gcmVnaW9uUmlnaHRIYWxmVGltZSkge1xuICAgICAgICAgICAgdGltZSA9IG1heEVuZCAtIHJlZ2lvblJpZ2h0SGFsZlRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRpbWUgLSByZWdpb25MZWZ0SGFsZlRpbWUgPCAwKSB7XG4gICAgICAgICAgICB0aW1lID0gcmVnaW9uTGVmdEhhbGZUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNpemUpIHtcbiAgICAgICAgICAvLyBUbyBtYWludGFpbiByZWxhdGl2ZSBjdXJzb3Igc3RhcnQgcG9pbnQgd2hpbGUgcmVzaXppbmdcbiAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGhhbmRsZSBmb3IgbWluTGVuZ3RoXG4gICAgICAgICAgdmFyIG1pbkxlbmd0aCA9IF90aGlzNC5taW5MZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIW1pbkxlbmd0aCkge1xuICAgICAgICAgICAgbWluTGVuZ3RoID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzaXplID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICBpZiAodGltZSA+IF90aGlzNC5lbmQgLSBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGltZSA9IF90aGlzNC5lbmQgLSBtaW5MZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc2l6ZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lIDwgX3RoaXM0LnN0YXJ0ICsgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBfdGhpczQuc3RhcnQgKyBtaW5MZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGltZSA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IHRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIHN0YXJ0VGltZSA9IHRpbWU7IC8vIERyYWdcblxuICAgICAgICBpZiAoX3RoaXM0LmRyYWcgJiYgZHJhZykge1xuICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVkIHx8ICEhZGVsdGE7XG5cbiAgICAgICAgICBfdGhpczQub25EcmFnKGRlbHRhKTtcbiAgICAgICAgfSAvLyBSZXNpemVcblxuXG4gICAgICAgIGlmIChfdGhpczQucmVzaXplICYmIHJlc2l6ZSkge1xuICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVkIHx8ICEhZGVsdGE7XG5cbiAgICAgICAgICBfdGhpczQub25SZXNpemUoZGVsdGEsIHJlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM0LnNjcm9sbCAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCBfdGhpczQud3JhcHBlci5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgIC8vIFRyaWdnZXJpbmcgZWRnZXNjcm9sbCBmcm9tIHdpdGhpbiBlZGdlU2Nyb2xsV2lkdGhcbiAgICAgICAgICB2YXIgeCA9IG9yaWVudGVkRXZlbnQuY2xpZW50WDsgLy8gQ2hlY2sgZGlyZWN0aW9uXG5cbiAgICAgICAgICBpZiAoeCA8IHdyYXBwZXJSZWN0LmxlZnQgKyBfdGhpczQuZWRnZVNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHggPiB3cmFwcGVyUmVjdC5yaWdodCAtIF90aGlzNC5lZGdlU2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICAgICAgZWRnZVNjcm9sbChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb3duKTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb3duKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblVwKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblVwKTtcbiAgICAgIHRoaXMub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25VcCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndhdmVzdXJmZXIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblVwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWcoZGVsdGEpIHtcbiAgICAgIHZhciBtYXhFbmQgPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgaWYgKHRoaXMuZW5kICsgZGVsdGEgPiBtYXhFbmQpIHtcbiAgICAgICAgZGVsdGEgPSBtYXhFbmQgLSB0aGlzLmVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgKyBkZWx0YSA8IDApIHtcbiAgICAgICAgZGVsdGEgPSB0aGlzLnN0YXJ0ICogLTE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgKyBkZWx0YSxcbiAgICAgICAgZW5kOiB0aGlzLmVuZCArIGRlbHRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvblJlc2l6ZSgtNSwgJ3N0YXJ0JykgLy8gTW92ZXMgdGhlIHN0YXJ0IHBvaW50IDUgc2Vjb25kcyBiYWNrXG4gICAgICogb25SZXNpemUoMC41LCAnZW5kJykgLy8gTW92ZXMgdGhlIGVuZCBwb2ludCAwLjUgc2Vjb25kcyBmb3J3YXJkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgSG93IG11Y2ggdG8gYWRkIG9yIHN1YnRyYWN0LCBnaXZlbiBpbiBzZWNvbmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnc3RhcnQgJ29yICdlbmQnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc2l6ZShkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAvLyBDaGVjayBpZiBjaGFuZ2luZyB0aGUgc3RhcnQgYnkgdGhlIGdpdmVuIGRlbHRhIHdvdWxkIHJlc3VsdCBpbiB0aGUgcmVnaW9uIGJlaW5nIHNtYWxsZXIgdGhhbiBtaW5MZW5ndGhcbiAgICAgICAgLy8gSWdub3JlIGNhc2VzIHdoZXJlIHdlIGFyZSBtYWtpbmcgdGhlIHJlZ2lvbiB3aWRlciByYXRoZXIgdGhhbiBzaHJpbmtpbmcgaXRcbiAgICAgICAgaWYgKGRlbHRhID4gMCAmJiB0aGlzLmVuZCAtICh0aGlzLnN0YXJ0ICsgZGVsdGEpIDwgdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICBkZWx0YSA9IHRoaXMuZW5kIC0gdGhpcy5taW5MZW5ndGggLSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbHRhIDwgMCAmJiB0aGlzLnN0YXJ0ICsgZGVsdGEgPCAwKSB7XG4gICAgICAgICAgZGVsdGEgPSB0aGlzLnN0YXJ0ICogLTE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhcnQ6IE1hdGgubWluKHRoaXMuc3RhcnQgKyBkZWx0YSwgdGhpcy5lbmQpLFxuICAgICAgICAgIGVuZDogTWF0aC5tYXgodGhpcy5zdGFydCArIGRlbHRhLCB0aGlzLmVuZClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDaGVjayBpZiBjaGFuZ2luZyB0aGUgZW5kIGJ5IHRoZSBnaXZlbiBkZWx0YSB3b3VsZCByZXN1bHQgaW4gdGhlIHJlZ2lvbiBiZWluZyBzbWFsbGVyIHRoYW4gbWluTGVuZ3RoXG4gICAgICAgIC8vIElnbm9yZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbWFraW5nIHRoZSByZWdpb24gd2lkZXIgcmF0aGVyIHRoYW4gc2hyaW5raW5nIGl0XG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgdGhpcy5lbmQgKyBkZWx0YSAtIHRoaXMuc3RhcnQgPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICAgIGRlbHRhID0gdGhpcy5zdGFydCArIHRoaXMubWluTGVuZ3RoIC0gdGhpcy5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGEgPiAwICYmIHRoaXMuZW5kICsgZGVsdGEgPiBkdXJhdGlvbikge1xuICAgICAgICAgIGRlbHRhID0gZHVyYXRpb24gLSB0aGlzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICBzdGFydDogTWF0aC5taW4odGhpcy5lbmQgKyBkZWx0YSwgdGhpcy5zdGFydCksXG4gICAgICAgICAgZW5kOiBNYXRoLm1heCh0aGlzLmVuZCArIGRlbHRhLCB0aGlzLnN0YXJ0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlSGFuZGxlc1Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVIYW5kbGVzUmVzaXplKHJlc2l6ZSkge1xuICAgICAgdmFyIGN1cnNvclN0eWxlO1xuXG4gICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgIGN1cnNvclN0eWxlID0gdGhpcy52ZXJ0aWNhbCA/ICdyb3ctcmVzaXplJyA6ICdjb2wtcmVzaXplJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvclN0eWxlID0gJ2F1dG8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbmRsZUxlZnRFbCAmJiB0aGlzLnN0eWxlKHRoaXMuaGFuZGxlTGVmdEVsLCB7XG4gICAgICAgIGN1cnNvcjogY3Vyc29yU3R5bGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW5kbGVSaWdodEVsICYmIHRoaXMuc3R5bGUodGhpcy5oYW5kbGVSaWdodEVsLCB7XG4gICAgICAgIGN1cnNvcjogY3Vyc29yU3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWdpb247XG59KCk7XG5cbmV4cG9ydHMuUmVnaW9uID0gUmVnaW9uO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvcGx1Z2luL3JlZ2lvbnMvaW5kZXguanNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5yZWdpb25zLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGx1Z2luL3dhdmVzdXJmZXIucmVnaW9ucy5qcyJdLCJzb3VyY2VSb290IjoiIn0=