/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2);

var _WaveformInit = __webpack_require__(3);

var _WaveformInit2 = _interopRequireDefault(_WaveformInit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Load library
H5P = H5P || {};
H5PEditor.widgets.waveformInit = H5PEditor.WaveformInit = _WaveformInit2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _h5pParent = __webpack_require__(4);

var _h5pParent2 = _interopRequireDefault(_h5pParent);

var _globals = __webpack_require__(6);

var _wavesurfer = __webpack_require__(7);

var _wavesurfer2 = _interopRequireDefault(_wavesurfer);

var _wavesurferCursor = __webpack_require__(8);

var _wavesurferCursor2 = _interopRequireDefault(_wavesurferCursor);

var _wavesurferRegions = __webpack_require__(9);

var _wavesurferRegions2 = _interopRequireDefault(_wavesurferRegions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WaveformInit = function WaveformInit(parent, field, params, setValue) {
  this.parent = parent;
  this.field = field;
  this.params = params;
  this.setValue = setValue;

  this.id = null;
  this.crAudioIndex = 0;
  this.container = null;
  this.audioParams = this.parent.parent.parent.params.params;
  this.startTime = this.parent.params.startDuration != undefined ? this.parent.params.startDuration : 0;
  this.endTime = this.parent.params.endDuration != undefined ? this.parent.params.endDuration : 0.2;
  this.audioDuration;
};

WaveformInit.prototype = Object.create(_h5pParent2.default.prototype);
WaveformInit.prototype.constructor = WaveformInit;

WaveformInit.pageBasedWordIndicesUsedInSentence = {};

/**
 * Initialize the waveform editor.
 * @param {*} $wrapper 
 */
WaveformInit.prototype.init = function () {
  var _this = this;

  var self = this;
  if (!self.container || self.container && self.container.length == 0) return;
  var wavesurfer = _wavesurfer2.default.create({
    container: self.container[0],
    waveColor: 'green',
    progressColor: 'grey',
    fillParent: true,
    responsive: true,
    barHeight: 8,
    plugins: [_wavesurferRegions2.default.create({
      regionsMinLength: 0.1,
      maxRegions: 1,
      regions: [{
        start: self.startTime,
        end: self.endTime,
        loop: false,
        color: 'rgba(250, 203, 110, 0.5)'
      }],
      dragSelection: {
        slop: 5
      }
    })]
  });

  (0, _globals.jQuery)('.wavesurfer-handle').css("width", "4px");
  (0, _globals.jQuery)('.wavesurfer-handle').css("background-color", "#707070");

  this.region = undefined;

  self.crAudioIndex = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields.length;
  // let path = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex- 1].params.files ? H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].params.files[0].path : undefined;
  var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[0].parent.params.subContentId;
  var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
  // let id =  self.parent.parent.parent.params.subContentId;
  if (path != undefined && id != undefined) {
    var file = H5P.getPath(path, id);
    _globals.jQuery.get(file).done(function () {
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    }).fail(function () {
      var id = H5PEditor.contentId;
      var file = H5P.getPath(path, id);
      setTimeout(function () {
        wavesurfer.load(file);
      }, 1000);
    });
  }

  wavesurfer.on('ready', function () {
    _this.region = Object.values(wavesurfer.regions.list)[0];
    var width = self.parent.parent.parent.parent.cp.width + self.parent.parent.parent.parent.cp.width * 0.25;
    self.audioDuration = wavesurfer.getDuration();
    // wavesurfer.params.minPxPerSec = width / wavesurfer.getDuration();
    // wavesurfer.drawBuffer();

    // let regionId = self.id + "playRegion"
    // let $playRegionButton = '<button id = '+ regionId +' class = "playRegion">Play</button>'
    // $('#' + self.id).find('.wavesurfer-region').append($playRegionButton)
    // $('#' + regionId).on('click', function (e) {
    //   e.stopPropagation()
    //   if (region != undefined) {
    //     region.play()
    //   }
    // })
  });

  setTimeout(function () {
    if (self.container[0]) {
      // Add event listeners to start and end duration for this wavesurfer instance
      var waveform = self.container[0];
      var waveformParent = waveform.parentElement.parentElement;

      var startDurationField = waveformParent.querySelector('.field-name-startDuration');
      var endDurationField = waveformParent.querySelector('.field-name-endDuration');

      if (startDurationField && endDurationField) {
        var startDurationFieldInput = startDurationField.querySelector('input');
        var endDurationFieldInput = endDurationField.querySelector('input');

        // Add focusout event handlers
        startDurationFieldInput.addEventListener("focusout", function (e) {
          _this.startDurationValueChangeHandler(e.target.value);
        });

        endDurationFieldInput.addEventListener("focusout", function (e) {
          _this.endDurationValueChangeHandler(e.target.value);
        });

        // Set values of start duration and end duration based on previous
        // waveform if it exists
        var waveformElements = document.getElementsByClassName("waveform");
        for (var i = 0; i < waveformElements.length; i++) {
          if (waveformElements[i].id === self.container[0].id && i > 0) {
            var previousWaveformContent = waveformElements[i - 1].parentElement.parentElement;
            var previousEndDurationField = previousWaveformContent.querySelector('.field-name-endDuration');
            if (previousEndDurationField) {
              var previousEndDurationInput = previousEndDurationField.querySelector('input');

              startDurationFieldInput.value = parseFloat(previousEndDurationInput.value) + 0.001;
              endDurationFieldInput.value = parseFloat(previousEndDurationInput.value) + 0.001 + 0.1;

              _this.startDurationValueChangeHandler(startDurationFieldInput.value);
              _this.endDurationValueChangeHandler(endDurationFieldInput.value);
            }
          }
        }
      }

      // Add audio loader observer on this wavesurfer instance
      var filesField = document.getElementsByClassName("field-name-files")[0];
      if (filesField) {
        var filesListElement = filesField.querySelector('ul');

        var observerConfig = { attributes: true, childList: true, subtree: true };

        var observer = new MutationObserver(function (mutationsList, observer) {
          var id = H5PEditor.renderableCommonFields["H5P.CRAudio 1.4"].fields[self.crAudioIndex - 1].parent.params.subContentId;
          var path = self.audioParams.files ? self.audioParams.files[0].path : undefined;
          if (path != undefined && id != undefined) {
            var _file = H5P.getPath(path, id);
            _globals.jQuery.get(_file).done(function () {
              setTimeout(function () {
                wavesurfer.load(_file);
              }, 1000);
            }).fail(function () {
              var id = H5PEditor.contentId;
              var file = H5P.getPath(path, id);
              setTimeout(function () {
                wavesurfer.load(file);
              }, 1000);
            });
          }
          if (_this.region != undefined) {
            var $startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
            var $endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
            $startinput.val(0);
            $endinput.val(0.2);
            _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + 0);
            _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + 0.2);
            var params = {
              start: 0,
              end: 0.2
            };
            _this.region.update(params);
          }
        });

        observer.observe(filesListElement, observerConfig);
      }
    }
  }, 2000);

  wavesurfer.on('region-updated', function (event) {
    _this.start = event.start;
    _this.end = event.end;
    _this.$startinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-startDuration').find('input');
    _this.$endinput = (0, _globals.jQuery)('#' + _this.id).parent().parent().find('.field-name-endDuration').find('input');
    _this.$startinput.val(_this.start.toFixed(4));
    _this.$endinput.val(_this.end.toFixed(4));
    _this.setValue(_this.findField("startDuration", _this.parent.field.fields), "" + _this.start.toFixed(4));
    _this.setValue(_this.findField("endDuration", _this.parent.field.fields), "" + _this.end.toFixed(4));
  });

  if (this.id != null) {
    var regionId = this.id + "playRegion";
    var $playRegionButton = (0, _globals.jQuery)('<button id = ' + regionId + ' class = "playRegion">Play</button>');
    (0, _globals.jQuery)(self.container).parent('div').append($playRegionButton);
    (0, _globals.jQuery)($playRegionButton).on('click', function () {
      if (_this.region != undefined) {
        _this.region.play();
      }
    });
  }
};

WaveformInit.prototype.startDurationValueChangeHandler = function (value) {
  if (this.region != undefined) {
    if (!isNaN(value)) {
      if (parseFloat(value) > this.audioDuration) {
        value = 0.0;
      }
      var inputStartTime = parseFloat(value);
      var inputEndTime = this.region.end <= parseFloat(value) ? parseFloat(value) + 0.2 : this.region.end;
      var params = {
        start: inputStartTime.toFixed(4),
        end: inputEndTime.toFixed(4)
      };
      this.region.update(params);
    } else {
      (0, _globals.jQuery)(this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
    }
  }
};

WaveformInit.prototype.endDurationValueChangeHandler = function (value) {
  if (this.region != undefined) {
    if (!isNaN(value)) {
      if (parseFloat(value) > this.audioDuration) {
        value = self.audioDuration - 0.05;
      }
      var inputStartTime = parseFloat(value) <= this.region.start ? 0 : this.region.start;
      var inputEndTime = parseFloat(value);
      var params = {
        start: inputStartTime.toFixed(4),
        end: inputEndTime.toFixed(4)
      };
      this.region.update(params);
    } else {
      (0, _globals.jQuery)(this).parent().find('.h5p-errors').append("<p>The entered value must be Number not alphabet</p>");
    }
  }
};

/**
 * Append the field to the wrapper.
 * @public
 * @param {H5P.jQuery} $wrapper
 */
WaveformInit.prototype.appendTo = function ($wrapper) {
  var self = this;
  var id = ns.getNextFieldId(this.field);
  var html = H5PEditor.createFieldMarkup(this.field, '<div class="waveform" id="' + id + '" class="h5p-color-picker">', id);
  self.$item = H5PEditor.$(html);
  this.setId(id);
  var wordText = this.parent.params.text != undefined ? this.parent.params.text : '';
  $wrapper.append('<h1 class="test">Select word(s)</h1>');
  // $wrapper.append('<label class="h5peditor-label"><input id="field-words-125" type="checkbox">Will Do Animation</label>')
  //let checkBoxElementForWord=$wrapper.append(this.getSentence(self.parent.parent.parent.parent.cp.slides,self.parent.parent.parent.parent.cp.currentSlideIndex))
  var slides = self.parent.parent.parent.parent.cp.slides;
  var slideIndex = this.parent.parent.parent.params.params.currIndex;
  var paramText = this.parent.params.text;
  var checkBoxElementForWord = $wrapper.append(this.getSentence(slides, slideIndex, paramText));
  self.$item.appendTo($wrapper);
  self.container = self.$item.find('#' + this.id);
  console.log(checkBoxElementForWord);
  (0, _globals.jQuery)(checkBoxElementForWord).on('change', function (event) {
    console.log(event.target);
    console.log(event.target.id);
    console.log(event.target.value);
    var isAlreadyUsed = self.checkIfWordIsUsedInOtherWaveform(slideIndex, event.target.id);
    if ((0, _globals.jQuery)('#' + event.target.id).is(':checked')) {
      if (isAlreadyUsed) {
        (0, _globals.jQuery)('#' + event.target.id).attr('checked', false);
      } else {
        wordText = wordText + ' ' + event.target.value + ' ';
        (0, _globals.jQuery)('#' + event.target.id).attr('checked', true);
        this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
        this.$word.val(wordText.trim().replace(/  +/g, ' '));
        (0, _globals.jQuery)(this.$word).attr('checked', true);
        self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
        WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].push({ 'index': event.target.id.split('_')[1], 'id': event.target.id });
      }
    } else {
      (0, _globals.jQuery)('#' + event.target.id).attr('checked', false);
      var tempWordText = wordText.replace(event.target.value, '');
      wordText = tempWordText;
      this.$word = (0, _globals.jQuery)('#' + id).parent().parent().find('.field-name-text').find('input');
      self.setValue(self.findField("text", self.parent.field.fields), "" + wordText.replace(/  +/g, ' '));
      (0, _globals.jQuery)(this.$word).attr('checked', false);
      this.$word.val(wordText.trim().replace(/  +/g, ' '));
      WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()] = WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].filter(function (obj) {
        return obj.id === event.target.id;
      });
    }
    console.log(WaveformInit.pageBasedWordIndicesUsedInSentence);
  });
  self.setValue(self.findField("text", self.parent.field.fields), "" + this.parent.params.text);
  self.init();
};

WaveformInit.prototype.checkIfWordIsUsedInOtherWaveform = function (slideIndex, inputId) {
  var slideCheckboxInfo = WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()];
  var wordIndex = parseInt(inputId.split('_')[1]);
  if (slideCheckboxInfo !== null && slideCheckboxInfo !== undefined) {
    for (var i = 0; i < slideCheckboxInfo.length; i++) {
      if (slideCheckboxInfo[i].index === wordIndex) {
        return true;
      }
    }
  } else {
    WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()] = [];
  }
  return false;
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.setId = function (id) {
  this.id = id;
};

WaveformInit.prototype.findField = function (name, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === name) {
      return fields[i];
    }
  }
};

WaveformInit.prototype.validate = function () {
  // this.hide();
  // return (this.params !== undefined && this.params.length !== 0);
};

WaveformInit.prototype.getSentence = function (slides, slideIndex, prevData) {
  var sentenceWords = [];
  var splittedPrevData = prevData != undefined ? prevData.split(' ') : [];
  var alreadyFoundSplittedPrevDataWord = false;

  for (var i = 0; i < slides[slideIndex].elements.length; i++) {
    if (slides[slideIndex].elements[i].action.library.split(' ')[0] == "H5P.CRAdvancedText") {
      var checkBoxWord = '';
      sentenceWords = (0, _globals.jQuery)(slides[slideIndex].elements[i].action.params.text)[0].innerText.split(' ');
      for (var j = 0; j < sentenceWords.length; j++) {
        var def = splittedPrevData.indexOf(sentenceWords[j]) !== -1 ? true : false;
        if (sentenceWords[j].replace(/  +/g, ' ') != '') {
          if (def && !alreadyFoundSplittedPrevDataWord && !this.checkIfWordIsUsedInOtherWaveform(slideIndex, this.id + j)) {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + "_" + j + ' type="checkbox" value="' + sentenceWords[j] + '"checked>' + sentenceWords[j] + '</label>';
            alreadyFoundSplittedPrevDataWord = true;
            WaveformInit.pageBasedWordIndicesUsedInSentence[slideIndex.toString()].push({ "index": j, "id": this.id + j });
          } else {
            checkBoxWord = checkBoxWord + '<label class="h5peditor-label id =' + this.id + j + '"><input id=' + this.id + "_" + j + ' type="checkbox" value="' + sentenceWords[j] + '">' + sentenceWords[j] + '</label>';
          }
        }
      }
    }
  }
  console.log(WaveformInit.pageBasedWordIndicesUsedInSentence);
  return checkBoxWord;
};

WaveformInit.prototype.remove = function () {};
exports.default = WaveformInit;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Child = __webpack_require__(5);
var EventDispatcher = H5P.EventDispatcher;

/**
 * @class
 */
function Parent(constructor, parameters) {
  var self = this;
  EventDispatcher.call(self);

  self.children = [];

  /**
   * Update the internal indexes of the children.
   *
   * @private
   * @param {number} from Where to start
   */
  var updateIndexes = function updateIndexes(from) {
    for (var i = from; i < self.children.length; i++) {
      self.children[i].index = i;
    }
  };

  /**
   * Give a new child to this parent.
   *
   * @param {*} childParameters Launch parameters
   */
  self.addChild = function (childParameters, index) {
    if (index === undefined) {
      index = self.children.length;
    }

    // Create a new child with the current instance as its parent
    var instance = new Child(index, self);

    if (index === self.children.length) {
      // Added at the end
      self.children.push(instance);
    } else {
      // Inserted at a specific location
      self.children.splice(index, 0, instance);
      updateIndexes(index);
    }

    // Run original constructor
    constructor.call(instance, childParameters);

    return instance;
  };

  /**
   * Remova a new child from its parent.
   *
   * @param {number} index
   */
  self.removeChild = function (index) {
    // Remove from array
    self.children.splice(index, 1);

    // Update internal indexes
    updateIndexes(index);
  };

  /**
   * Move the child into a new position
   *
   * @param {number} oldIndex
   * @param {number} newIndex
   */
  self.moveChild = function (oldIndex, newIndex) {
    var child = self.children.splice(oldIndex, 1)[0];
    self.children.splice(newIndex, 0, child);

    updateIndexes(newIndex < oldIndex ? newIndex : oldIndex);
  };

  if (parameters) {
    for (var i = 0; i < parameters.length; i++) {
      self.addChild(parameters[i]);
    }
  }
}

Parent.prototype = Object.create(EventDispatcher.prototype);
Parent.prototype.constructor = Parent;

module.exports = Parent;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @class
 */
function Child(index, parent) {
  var self = this;

  self.index = index;
  self.parent = parent;
}

module.exports = Child;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var jQuery = exports.jQuery = H5P.jQuery;
var EventDispatcher = exports.EventDispatcher = H5P.EventDispatcher;
var JoubelUI = exports.JoubelUI = H5P.JoubelUI;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/var __webpack_modules__ = {

        /***/"./src/drawer.canvasentry.js":
        /*!***********************************!*\
          !*** ./src/drawer.canvasentry.js ***!
          \***********************************/
        /***/function srcDrawerCanvasentryJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _style = _interopRequireDefault(__webpack_require__( /*! ./util/style */"./src/util/style.js"));

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./util/get-id */"./src/util/get-id.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * The `CanvasEntry` class represents an element consisting of a wave `canvas`
           * and an (optional) progress wave `canvas`.
           *
           * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
           * render a waveform, depending on the zoom level.
           */
          var CanvasEntry = /*#__PURE__*/function () {
            function CanvasEntry() {
              _classCallCheck(this, CanvasEntry);

              /**
               * The wave node
               *
               * @type {HTMLCanvasElement}
               */
              this.wave = null;
              /**
               * The wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.waveCtx = null;
              /**
               * The (optional) progress wave node
               *
               * @type {HTMLCanvasElement}
               */

              this.progress = null;
              /**
               * The (optional) progress wave canvas rendering context
               *
               * @type {CanvasRenderingContext2D}
               */

              this.progressCtx = null;
              /**
               * Start of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.start = 0;
              /**
               * End of the area the canvas should render, between 0 and 1
               *
               * @type {number}
               */

              this.end = 1;
              /**
               * Unique identifier for this entry
               *
               * @type {string}
               */

              this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
              /**
               * Canvas 2d context attributes
               *
               * @type {object}
               */

              this.canvasContextAttributes = {};
            }
            /**
             * Store the wave canvas element and create the 2D rendering context
             *
             * @param {HTMLCanvasElement} element The wave `canvas` element.
             */

            _createClass(CanvasEntry, [{
              key: "initWave",
              value: function initWave(element) {
                this.wave = element;
                this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Store the progress wave canvas element and create the 2D rendering
               * context
               *
               * @param {HTMLCanvasElement} element The progress wave `canvas` element.
               */

            }, {
              key: "initProgress",
              value: function initProgress(element) {
                this.progress = element;
                this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
              }
              /**
               * Update the dimensions
               *
               * @param {number} elementWidth Width of the entry
               * @param {number} totalWidth Total width of the multi canvas renderer
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(elementWidth, totalWidth, width, height) {
                // where the canvas starts and ends in the waveform, represented as a
                // decimal between 0 and 1
                this.start = this.wave.offsetLeft / totalWidth || 0;
                this.end = this.start + elementWidth / totalWidth; // set wave canvas dimensions

                this.wave.width = width;
                this.wave.height = height;
                var elementSize = {
                  width: elementWidth + 'px'
                };
                (0, _style.default)(this.wave, elementSize);

                if (this.hasProgressCanvas) {
                  // set progress canvas dimensions
                  this.progress.width = width;
                  this.progress.height = height;
                  (0, _style.default)(this.progress, elementSize);
                }
              }
              /**
               * Clear the wave and progress rendering contexts
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                // wave
                this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height); // progress

                if (this.hasProgressCanvas) {
                  this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
                }
              }
              /**
               * Set the fill styles for wave and progress
               *
               * @param {string} waveColor Fill color for the wave canvas
               * @param {?string} progressColor Fill color for the progress canvas
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(waveColor, progressColor) {
                this.waveCtx.fillStyle = waveColor;

                if (this.hasProgressCanvas) {
                  this.progressCtx.fillStyle = progressColor;
                }
              }
              /**
               * Set the canvas transforms for wave and progress
               *
               * @param {boolean} vertical Whether to render vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(vertical) {
                if (vertical) {
                  // Reflect the waveform across the line y = -x
                  this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);

                  if (this.hasProgressCanvas) {
                    this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);
                  }
                }
              }
              /**
               * Draw a rectangle for wave and progress
               *
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRects",
              value: function fillRects(x, y, width, height, radius) {
                this.fillRectToContext(this.waveCtx, x, y, width, height, radius);

                if (this.hasProgressCanvas) {
                  this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
                }
              }
              /**
               * Draw the actual rectangle on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number} x X start position
               * @param {number} y Y start position
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               */

            }, {
              key: "fillRectToContext",
              value: function fillRectToContext(ctx, x, y, width, height, radius) {
                if (!ctx) {
                  return;
                }

                if (radius) {
                  this.drawRoundedRect(ctx, x, y, width, height, radius);
                } else {
                  ctx.fillRect(x, y, width, height);
                }
              }
              /**
               * Draw a rounded rectangle on Canvas
               *
               * @param {CanvasRenderingContext2D} ctx Canvas context
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               *
               * @return {void}
               * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
               */

            }, {
              key: "drawRoundedRect",
              value: function drawRoundedRect(ctx, x, y, width, height, radius) {
                if (height === 0) {
                  return;
                } // peaks are float values from -1 to 1. Use absolute height values in
                // order to correctly calculate rounded rectangle coordinates


                if (height < 0) {
                  height *= -1;
                  y -= height;
                }

                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Render the actual wave and progress lines
               *
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLines",
              value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
                this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);

                if (this.hasProgressCanvas) {
                  this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
                }
              }
              /**
               * Render the actual waveform line on a `canvas` element
               *
               * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
               * @param {number[]} peaks Array with peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               */

            }, {
              key: "drawLineToContext",
              value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
                if (!ctx) {
                  return;
                }

                var length = peaks.length / 2;
                var first = Math.round(length * this.start); // use one more peak value to make sure we join peaks at ends -- unless,
                // of course, this is the last canvas

                var last = Math.round(length * this.end) + 1;
                var canvasStart = first;
                var canvasEnd = last;
                var scale = this.wave.width / (canvasEnd - canvasStart - 1); // optimization

                var halfOffset = halfH + offsetY;
                var absmaxHalf = absmax / halfH;
                ctx.beginPath();
                ctx.moveTo((canvasStart - first) * scale, halfOffset);
                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
                var i, peak, h;

                for (i = canvasStart; i < canvasEnd; i++) {
                  peak = peaks[2 * i] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
                } // draw the bottom edge going backwards, to make a single
                // closed hull to fill


                var j = canvasEnd - 1;

                for (j; j >= canvasStart; j--) {
                  peak = peaks[2 * j + 1] || 0;
                  h = Math.round(peak / absmaxHalf);
                  ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
                }

                ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
                ctx.closePath();
                ctx.fill();
              }
              /**
               * Destroys this entry
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.waveCtx = null;
                this.wave = null;
                this.progressCtx = null;
                this.progress = null;
              }
              /**
               * Return image data of the wave `canvas` element
               *
               * When using a `type` of `'blob'`, this will return a `Promise` that
               * resolves with a `Blob` instance.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|Promise} When using the default `'dataURL'` `type` this
               * returns a data URL. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with a `Blob` instance.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                var _this = this;

                if (type === 'blob') {
                  return new Promise(function (resolve) {
                    _this.wave.toBlob(resolve, format, quality);
                  });
                } else if (type === 'dataURL') {
                  return this.wave.toDataURL(format, quality);
                }
              }
            }]);

            return CanvasEntry;
          }();

          exports.default = CanvasEntry;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.js":
        /*!***********************!*\
          !*** ./src/drawer.js ***!
          \***********************/
        /***/function srcDrawerJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * Parent class for renderers
           *
           * @extends {Observer}
           */
          var Drawer = /*#__PURE__*/function (_util$Observer) {
            _inherits(Drawer, _util$Observer);

            var _super = _createSuper(Drawer);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function Drawer(container, params) {
              var _this;

              _classCallCheck(this, Drawer);

              _this = _super.call(this);
              _this.container = util.withOrientation(container, params.vertical);
              /**
               * @type {WavesurferParams}
               */

              _this.params = params;
              /**
               * The width of the renderer
               * @type {number}
               */

              _this.width = 0;
              /**
               * The height of the renderer
               * @type {number}
               */

              _this.height = params.height * _this.params.pixelRatio;
              _this.lastPos = 0;
              /**
               * The `<wave>` element which is added to the container
               * @type {HTMLElement}
               */

              _this.wrapper = null;
              return _this;
            }
            /**
             * Alias of `util.style`
             *
             * @param {HTMLElement} el The element that the styles will be applied to
             * @param {Object} styles The map of propName: attribute, both are used as-is
             * @return {HTMLElement} el
             */

            _createClass(Drawer, [{
              key: "style",
              value: function style(el, styles) {
                return util.style(el, styles);
              }
              /**
               * Create the wrapper `<wave>` element, style it and set up the events for
               * interaction
               */

            }, {
              key: "createWrapper",
              value: function createWrapper() {
                this.wrapper = util.withOrientation(this.container.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.wrapper, {
                  display: 'block',
                  position: 'relative',
                  userSelect: 'none',
                  webkitUserSelect: 'none',
                  height: this.params.height + 'px'
                });

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: '100%',
                    overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
                    overflowY: 'hidden'
                  });
                }

                this.setupWrapperEvents();
              }
              /**
               * Handle click event
               *
               * @param {Event} e Click event
               * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
               * @return {number} Playback position from 0 to 1
               */

            }, {
              key: "handleEvent",
              value: function handleEvent(e, noPrevent) {
                !noPrevent && e.preventDefault();
                var clientX = util.withOrientation(e.targetTouches ? e.targetTouches[0] : e, this.params.vertical).clientX;
                var bbox = this.wrapper.getBoundingClientRect();
                var nominalWidth = this.width;
                var parentWidth = this.getWidth();
                var progressPixels = this.getProgressPixels(bbox, clientX);
                var progress;

                if (!this.params.fillParent && nominalWidth < parentWidth) {
                  progress = progressPixels * (this.params.pixelRatio / nominalWidth) || 0;
                } else {
                  progress = (progressPixels + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
                }

                return util.clamp(progress, 0, 1);
              }
            }, {
              key: "getProgressPixels",
              value: function getProgressPixels(wrapperBbox, clientX) {
                if (this.params.rtl) {
                  return wrapperBbox.right - clientX;
                } else {
                  return clientX - wrapperBbox.left;
                }
              }
            }, {
              key: "setupWrapperEvents",
              value: function setupWrapperEvents() {
                var _this2 = this;

                this.wrapper.addEventListener('click', function (e) {
                  var orientedEvent = util.withOrientation(e, _this2.params.vertical);
                  var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

                  if (scrollbarHeight !== 0) {
                    // scrollbar is visible.  Check if click was on it
                    var bbox = _this2.wrapper.getBoundingClientRect();

                    if (orientedEvent.clientY >= bbox.bottom - scrollbarHeight) {
                      // ignore mousedown as it was on the scrollbar
                      return;
                    }
                  }

                  if (_this2.params.interact) {
                    _this2.fireEvent('click', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('dblclick', function (e) {
                  if (_this2.params.interact) {
                    _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
                  }
                });
                this.wrapper.addEventListener('scroll', function (e) {
                  return _this2.fireEvent('scroll', e);
                });
              }
              /**
               * Draw peaks on the canvas
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} length The width of the area that should be drawn
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawPeaks",
              value: function drawPeaks(peaks, length, start, end) {
                if (!this.setWidth(length)) {
                  this.clearWave();
                }

                this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
              }
              /**
               * Scroll to the beginning
               */

            }, {
              key: "resetScroll",
              value: function resetScroll() {
                if (this.wrapper !== null) {
                  this.wrapper.scrollLeft = 0;
                }
              }
              /**
               * Recenter the view-port at a certain percent of the waveform
               *
               * @param {number} percent Value from 0 to 1 on the waveform
               */

            }, {
              key: "recenter",
              value: function recenter(percent) {
                var position = this.wrapper.scrollWidth * percent;
                this.recenterOnPosition(position, true);
              }
              /**
               * Recenter the view-port on a position, either scroll there immediately or
               * in steps of 5 pixels
               *
               * @param {number} position X-offset in pixels
               * @param {boolean} immediate Set to true to immediately scroll somewhere
               */

            }, {
              key: "recenterOnPosition",
              value: function recenterOnPosition(position, immediate) {
                var scrollLeft = this.wrapper.scrollLeft;
                var half = ~~(this.wrapper.clientWidth / 2);
                var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
                var target = position - half;
                var offset = target - scrollLeft;

                if (maxScroll == 0) {
                  // no need to continue if scrollbar is not there
                  return;
                } // if the cursor is currently visible...


                if (!immediate && -half <= offset && offset < half) {
                  // set rate at which waveform is centered
                  var rate = this.params.autoCenterRate; // make rate depend on width of view and length of waveform

                  rate /= half;
                  rate *= maxScroll;
                  offset = Math.max(-rate, Math.min(rate, offset));
                  target = scrollLeft + offset;
                } // limit target to valid range (0 to maxScroll)


                target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

                if (target != scrollLeft) {
                  this.wrapper.scrollLeft = target;
                }
              }
              /**
               * Get the current scroll position in pixels
               *
               * @return {number} Horizontal scroll position in pixels
               */

            }, {
              key: "getScrollX",
              value: function getScrollX() {
                var x = 0;

                if (this.wrapper) {
                  var pixelRatio = this.params.pixelRatio;
                  x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
                  // scroll beyond the limits of the container
                  // Calculate and floor the scrollable extent to make sure an out
                  // of bounds value is not returned
                  // Ticket #1312

                  if (this.params.scrollParent) {
                    var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
                    x = Math.min(maxScroll, Math.max(0, x));
                  }
                }

                return x;
              }
              /**
               * Get the width of the container
               *
               * @return {number} The width of the container
               */

            }, {
              key: "getWidth",
              value: function getWidth() {
                return Math.round(this.container.clientWidth * this.params.pixelRatio);
              }
              /**
               * Set the width of the container
               *
               * @param {number} width The new width of the container
               * @return {boolean} Whether the width of the container was updated or not
               */

            }, {
              key: "setWidth",
              value: function setWidth(width) {
                if (this.width == width) {
                  return false;
                }

                this.width = width;

                if (this.params.fillParent || this.params.scrollParent) {
                  this.style(this.wrapper, {
                    width: ''
                  });
                } else {
                  var newWidth = ~~(this.width / this.params.pixelRatio) + 'px';
                  this.style(this.wrapper, {
                    width: newWidth
                  });
                }

                this.updateSize();
                return true;
              }
              /**
               * Set the height of the container
               *
               * @param {number} height The new height of the container.
               * @return {boolean} Whether the height of the container was updated or not
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                if (height == this.height) {
                  return false;
                }

                this.height = height;
                this.style(this.wrapper, {
                  height: ~~(this.height / this.params.pixelRatio) + 'px'
                });
                this.updateSize();
                return true;
              }
              /**
               * Called by wavesurfer when progress should be rendered
               *
               * @param {number} progress From 0 to 1
               */

            }, {
              key: "progress",
              value: function progress(_progress) {
                var minPxDelta = 1 / this.params.pixelRatio;
                var pos = Math.round(_progress * this.width) * minPxDelta;

                if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
                  this.lastPos = pos;

                  if (this.params.scrollParent && this.params.autoCenter) {
                    var newPos = ~~(this.wrapper.scrollWidth * _progress);
                    this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
                  }

                  this.updateProgress(pos);
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.unAll();

                if (this.wrapper) {
                  if (this.wrapper.parentNode == this.container.domElement) {
                    this.container.removeChild(this.wrapper.domElement);
                  }

                  this.wrapper = null;
                }
              }
              /* Renderer-specific methods */

              /**
               * Called after cursor related params have changed.
               *
               * @abstract
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {}
              /**
               * Called when the size of the container changes so the renderer can adjust
               *
               * @abstract
               */

            }, {
              key: "updateSize",
              value: function updateSize() {}
              /**
               * Draw a waveform with bars
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {}
              /**
               * Draw a waveform
               *
               * @abstract
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
               * rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {}
              /**
               * Clear the waveform
               *
               * @abstract
               */

            }, {
              key: "clearWave",
              value: function clearWave() {}
              /**
               * Render the new progress
               *
               * @abstract
               * @param {number} position X-Offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {}
            }]);

            return Drawer;
          }(util.Observer);

          exports.default = Drawer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/drawer.multicanvas.js":
        /*!***********************************!*\
          !*** ./src/drawer.multicanvas.js ***!
          \***********************************/
        /***/function srcDrawerMulticanvasJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer */"./src/drawer.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer2 = _interopRequireDefault(__webpack_require__( /*! ./drawer.canvasentry */"./src/drawer.canvasentry.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MultiCanvas renderer for wavesurfer. Is currently the default and sole
           * builtin renderer.
           *
           * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
           * on the zoom level.
           */
          var MultiCanvas = /*#__PURE__*/function (_Drawer) {
            _inherits(MultiCanvas, _Drawer);

            var _super = _createSuper(MultiCanvas);

            /**
             * @param {HTMLElement} container The container node of the wavesurfer instance
             * @param {WavesurferParams} params The wavesurfer initialisation options
             */
            function MultiCanvas(container, params) {
              var _this;

              _classCallCheck(this, MultiCanvas);

              _this = _super.call(this, container, params);
              /**
               * @type {number}
               */

              _this.maxCanvasWidth = params.maxCanvasWidth;
              /**
               * @type {number}
               */

              _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
              /**
               * Whether or not the progress wave is rendered. If the `waveColor`
               * and `progressColor` are the same color it is not.
               *
               * @type {boolean}
               */

              _this.hasProgressCanvas = params.waveColor != params.progressColor;
              /**
               * @type {number}
               */

              _this.halfPixel = 0.5 / params.pixelRatio;
              /**
               * List of `CanvasEntry` instances.
               *
               * @type {Array}
               */

              _this.canvases = [];
              /**
               * @type {HTMLElement}
               */

              _this.progressWave = null;
              /**
               * Class used to generate entries.
               *
               * @type {function}
               */

              _this.EntryClass = _drawer2.default;
              /**
               * Canvas 2d context attributes.
               *
               * @type {object}
               */

              _this.canvasContextAttributes = params.drawingContextAttributes;
              /**
               * Overlap added between entries to prevent vertical white stripes
               * between `canvas` elements.
               *
               * @type {number}
               */

              _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
              /**
               * The radius of the wave bars. Makes bars rounded
               *
               * @type {number}
               */

              _this.barRadius = params.barRadius || 0;
              /**
               * Whether to render the waveform vertically. Defaults to false.
               *
               * @type {boolean}
               */

              _this.vertical = params.vertical;
              return _this;
            }
            /**
             * Initialize the drawer
             */

            _createClass(MultiCanvas, [{
              key: "init",
              value: function init() {
                this.createWrapper();
                this.createElements();
              }
              /**
               * Create the canvas elements and style them
               *
               */

            }, {
              key: "createElements",
              value: function createElements() {
                this.progressWave = util.withOrientation(this.wrapper.appendChild(document.createElement('wave')), this.params.vertical);
                this.style(this.progressWave, {
                  position: 'absolute',
                  zIndex: 3,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  overflow: 'hidden',
                  width: '0',
                  display: 'none',
                  boxSizing: 'border-box',
                  borderRightStyle: 'solid',
                  pointerEvents: 'none'
                });
                this.addCanvas();
                this.updateCursor();
              }
              /**
               * Update cursor style
               */

            }, {
              key: "updateCursor",
              value: function updateCursor() {
                this.style(this.progressWave, {
                  borderRightWidth: this.params.cursorWidth + 'px',
                  borderRightColor: this.params.cursorColor
                });
              }
              /**
               * Adjust to the updated size by adding or removing canvases
               */

            }, {
              key: "updateSize",
              value: function updateSize() {
                var _this2 = this;

                var totalWidth = Math.round(this.width / this.params.pixelRatio);
                var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap)); // add required canvases

                while (this.canvases.length < requiredCanvases) {
                  this.addCanvas();
                } // remove older existing canvases, if any


                while (this.canvases.length > requiredCanvases) {
                  this.removeCanvas();
                }

                var canvasWidth = this.maxCanvasWidth + this.overlap;
                var lastCanvas = this.canvases.length - 1;
                this.canvases.forEach(function (entry, i) {
                  if (i == lastCanvas) {
                    canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
                  }

                  _this2.updateDimensions(entry, canvasWidth, _this2.height);

                  entry.clearWave();
                });
              }
              /**
               * Add a canvas to the canvas list
               *
               */

            }, {
              key: "addCanvas",
              value: function addCanvas() {
                var entry = new this.EntryClass();
                entry.canvasContextAttributes = this.canvasContextAttributes;
                entry.hasProgressCanvas = this.hasProgressCanvas;
                entry.halfPixel = this.halfPixel;
                var leftOffset = this.maxCanvasElementWidth * this.canvases.length; // wave

                var wave = util.withOrientation(this.wrapper.appendChild(document.createElement('canvas')), this.params.vertical);
                this.style(wave, {
                  position: 'absolute',
                  zIndex: 2,
                  left: leftOffset + 'px',
                  top: 0,
                  bottom: 0,
                  height: '100%',
                  pointerEvents: 'none'
                });
                entry.initWave(wave); // progress

                if (this.hasProgressCanvas) {
                  var progress = util.withOrientation(this.progressWave.appendChild(document.createElement('canvas')), this.params.vertical);
                  this.style(progress, {
                    position: 'absolute',
                    left: leftOffset + 'px',
                    top: 0,
                    bottom: 0,
                    height: '100%'
                  });
                  entry.initProgress(progress);
                }

                this.canvases.push(entry);
              }
              /**
               * Pop single canvas from the list
               *
               */

            }, {
              key: "removeCanvas",
              value: function removeCanvas() {
                var lastEntry = this.canvases[this.canvases.length - 1]; // wave

                lastEntry.wave.parentElement.removeChild(lastEntry.wave.domElement); // progress

                if (this.hasProgressCanvas) {
                  lastEntry.progress.parentElement.removeChild(lastEntry.progress.domElement);
                } // cleanup


                if (lastEntry) {
                  lastEntry.destroy();
                  lastEntry = null;
                }

                this.canvases.pop();
              }
              /**
               * Update the dimensions of a canvas element
               *
               * @param {CanvasEntry} entry Target entry
               * @param {number} width The new width of the element
               * @param {number} height The new height of the element
               */

            }, {
              key: "updateDimensions",
              value: function updateDimensions(entry, width, height) {
                var elementWidth = Math.round(width / this.params.pixelRatio);
                var totalWidth = Math.round(this.width / this.params.pixelRatio); // update canvas dimensions

                entry.updateDimensions(elementWidth, totalWidth, width, height); // style element

                this.style(this.progressWave, {
                  display: 'block'
                });
              }
              /**
               * Clear the whole multi-canvas
               */

            }, {
              key: "clearWave",
              value: function clearWave() {
                var _this3 = this;

                util.frame(function () {
                  _this3.canvases.forEach(function (entry) {
                    return entry.clearWave();
                  });
                })();
              }
              /**
               * Draw a waveform with bars
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0. Must be an integer.
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawBars",
              value: function drawBars(peaks, channelIndex, start, end) {
                var _this4 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
                  var absmax = _ref.absmax,
                      hasMinVals = _ref.hasMinVals,
                      height = _ref.height,
                      offsetY = _ref.offsetY,
                      halfH = _ref.halfH,
                      peaks = _ref.peaks,
                      ch = _ref.channelIndex;

                  // if drawBars was called within ws.empty we don't pass a start and
                  // don't want anything to happen
                  if (start === undefined) {
                    return;
                  } // Skip every other value if there are negatives.


                  var peakIndexScale = hasMinVals ? 2 : 1;
                  var length = peaks.length / peakIndexScale;
                  var bar = _this4.params.barWidth * _this4.params.pixelRatio;
                  var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
                  var step = bar + gap;
                  var scale = length / _this4.width;
                  var first = start;
                  var last = end;
                  var i = first;

                  for (i; i < last; i += step) {
                    var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
                    var h = Math.round(peak / absmax * halfH);
                    /* in case of silences, allow the user to specify that we
                     * always draw *something* (normally a 1px high bar) */

                    if (h == 0 && _this4.params.barMinHeight) {
                      h = _this4.params.barMinHeight;
                    }

                    _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius, ch);
                  }
                });
              }
              /**
               * Draw a waveform
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
               * for split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered (If this isn't set only a flat line is rendered)
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @returns {void}
               */

            }, {
              key: "drawWave",
              value: function drawWave(peaks, channelIndex, start, end) {
                var _this5 = this;

                return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
                  var absmax = _ref2.absmax,
                      hasMinVals = _ref2.hasMinVals,
                      height = _ref2.height,
                      offsetY = _ref2.offsetY,
                      halfH = _ref2.halfH,
                      peaks = _ref2.peaks,
                      channelIndex = _ref2.channelIndex;

                  if (!hasMinVals) {
                    var reflectedPeaks = [];
                    var len = peaks.length;
                    var i = 0;

                    for (i; i < len; i++) {
                      reflectedPeaks[2 * i] = peaks[i];
                      reflectedPeaks[2 * i + 1] = -peaks[i];
                    }

                    peaks = reflectedPeaks;
                  } // if drawWave was called within ws.empty we don't pass a start and
                  // end and simply want a flat line


                  if (start !== undefined) {
                    _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
                  } // always draw a median line


                  _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius, channelIndex);
                });
              }
              /**
               * Tell the canvas entries to render their portion of the waveform
               *
               * @param {number[]} peaks Peaks data
               * @param {number} absmax Maximum peak value (absolute)
               * @param {number} halfH Half the height of the waveform
               * @param {number} offsetY Offset to the top
               * @param {number} start The x-offset of the beginning of the area that
               * should be rendered
               * @param {number} end The x-offset of the end of the area that
               * should be rendered
               * @param {channelIndex} channelIndex The channel index of the line drawn
               */

            }, {
              key: "drawLine",
              value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
                var _this6 = this;

                var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                    waveColor = _ref3.waveColor,
                    progressColor = _ref3.progressColor;

                this.canvases.forEach(function (entry, i) {
                  _this6.setFillStyles(entry, waveColor, progressColor);

                  _this6.applyCanvasTransforms(entry, _this6.params.vertical);

                  entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
                });
              }
              /**
               * Draw a rectangle on the multi-canvas
               *
               * @param {number} x X-position of the rectangle
               * @param {number} y Y-position of the rectangle
               * @param {number} width Width of the rectangle
               * @param {number} height Height of the rectangle
               * @param {number} radius Radius of the rectangle
               * @param {channelIndex} channelIndex The channel index of the bar drawn
               */

            }, {
              key: "fillRect",
              value: function fillRect(x, y, width, height, radius, channelIndex) {
                var startCanvas = Math.floor(x / this.maxCanvasWidth);
                var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
                var i = startCanvas;

                for (i; i < endCanvas; i++) {
                  var entry = this.canvases[i];
                  var leftOffset = i * this.maxCanvasWidth;
                  var intersection = {
                    x1: Math.max(x, i * this.maxCanvasWidth),
                    y1: y,
                    x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
                    y2: y + height
                  };

                  if (intersection.x1 < intersection.x2) {
                    var _ref4 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
                        waveColor = _ref4.waveColor,
                        progressColor = _ref4.progressColor;

                    this.setFillStyles(entry, waveColor, progressColor);
                    this.applyCanvasTransforms(entry, this.params.vertical);
                    entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
                  }
                }
              }
              /**
               * Returns whether to hide the channel from being drawn based on params.
               *
               * @param {number} channelIndex The index of the current channel.
               * @returns {bool} True to hide the channel, false to draw.
               */

            }, {
              key: "hideChannel",
              value: function hideChannel(channelIndex) {
                return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
              }
              /**
               * Performs preparation tasks and calculations which are shared by `drawBars`
               * and `drawWave`
               *
               * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
               * split channel rendering
               * @param {number} channelIndex The index of the current channel. Normally
               * should be 0
               * @param {number?} start The x-offset of the beginning of the area that
               * should be rendered. If this isn't set only a flat line is rendered
               * @param {number?} end The x-offset of the end of the area that should be
               * rendered
               * @param {function} fn The render function to call, e.g. `drawWave`
               * @param {number} drawIndex The index of the current channel after filtering.
               * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
               * @returns {void}
               */

            }, {
              key: "prepareDraw",
              value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
                var _this7 = this;

                return util.frame(function () {
                  // Split channels and call this function with the channelIndex set
                  if (peaks[0] instanceof Array) {
                    var channels = peaks;

                    if (_this7.params.splitChannels) {
                      var filteredChannels = channels.filter(function (c, i) {
                        return !_this7.hideChannel(i);
                      });

                      if (!_this7.params.splitChannelsOptions.overlay) {
                        _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
                      }

                      var overallAbsMax;

                      if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
                        // calculate maximum peak across channels to use for normalization
                        overallAbsMax = util.max(channels.map(function (channelPeaks) {
                          return util.absMax(channelPeaks);
                        }));
                      }

                      return channels.forEach(function (channelPeaks, i) {
                        return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
                      });
                    }

                    peaks = channels[0];
                  } // Return and do not draw channel peaks if hidden.


                  if (_this7.hideChannel(channelIndex)) {
                    return;
                  } // calculate maximum modulation value, either from the barHeight
                  // parameter or if normalize=true from the largest value in the peak
                  // set


                  var absmax = 1 / _this7.params.barHeight;

                  if (_this7.params.normalize) {
                    absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
                  } // Bar wave draws the bottom only as a reflection of the top,
                  // so we don't need negative values


                  var hasMinVals = [].some.call(peaks, function (val) {
                    return val < 0;
                  });
                  var height = _this7.params.height * _this7.params.pixelRatio;
                  var halfH = height / 2;
                  var offsetY = height * drawIndex || 0; // Override offsetY if overlay is true

                  if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.overlay) {
                    offsetY = 0;
                  }

                  return fn({
                    absmax: absmax,
                    hasMinVals: hasMinVals,
                    height: height,
                    offsetY: offsetY,
                    halfH: halfH,
                    peaks: peaks,
                    channelIndex: channelIndex
                  });
                })();
              }
              /**
               * Set the fill styles for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {string} waveColor Wave color to draw this entry
               * @param {string} progressColor Progress color to draw this entry
               */

            }, {
              key: "setFillStyles",
              value: function setFillStyles(entry) {
                var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
                var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
                entry.setFillStyles(waveColor, progressColor);
              }
              /**
               * Set the canvas transforms for a certain entry (wave and progress)
               *
               * @param {CanvasEntry} entry Target entry
               * @param {boolean} vertical Whether to render the waveform vertically
               */

            }, {
              key: "applyCanvasTransforms",
              value: function applyCanvasTransforms(entry) {
                var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                entry.applyCanvasTransforms(vertical);
              }
              /**
               * Return image data of the multi-canvas
               *
               * When using a `type` of `'blob'`, this will return a `Promise`.
               *
               * @param {string} format='image/png' An optional value of a format type.
               * @param {number} quality=0.92 An optional value between 0 and 1.
               * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
               * @return {string|string[]|Promise} When using the default `'dataURL'`
               * `type` this returns a single data URL or an array of data URLs,
               * one for each canvas. When using the `'blob'` `type` this returns a
               * `Promise` that resolves with an array of `Blob` instances, one for each
               * canvas.
               */

            }, {
              key: "getImage",
              value: function getImage(format, quality, type) {
                if (type === 'blob') {
                  return Promise.all(this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  }));
                } else if (type === 'dataURL') {
                  var images = this.canvases.map(function (entry) {
                    return entry.getImage(format, quality, type);
                  });
                  return images.length > 1 ? images : images[0];
                }
              }
              /**
               * Render the new progress
               *
               * @param {number} position X-offset of progress position in pixels
               */

            }, {
              key: "updateProgress",
              value: function updateProgress(position) {
                this.style(this.progressWave, {
                  width: position + 'px'
                });
              }
            }]);

            return MultiCanvas;
          }(_drawer.default);

          exports.default = MultiCanvas;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement-webaudio.js":
        /*!**************************************!*\
          !*** ./src/mediaelement-webaudio.js ***!
          \**************************************/
        /***/function srcMediaelementWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
           * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
           * buffer the entire file in one request, and you still get the filtering and scripting functionality
           * of the webaudio API.
           * Note that in order to use range requests and prevent buffering, you must provide peak data.
           *
           * @since 3.2.0
           */
          var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
            _inherits(MediaElementWebAudio, _MediaElement);

            var _super = _createSuper(MediaElementWebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElementWebAudio(params) {
              var _this;

              _classCallCheck(this, MediaElementWebAudio);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /** @private */

              _this.sourceMediaElement = null;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElementWebAudio, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
              }
              /**
               * Private method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);

                this.createMediaElementSource(media);
              }
              /**
               * Create MediaElementSource node
               *
               * @since 3.2.0
               * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
               */

            }, {
              key: "createMediaElementSource",
              value: function createMediaElementSource(mediaElement) {
                this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
                this.sourceMediaElement.connect(this.analyser);
              }
            }, {
              key: "play",
              value: function play(start, end) {
                this.resumeAudioContext();
                return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);

                this.destroyWebAudio();
              }
            }]);

            return MediaElementWebAudio;
          }(_mediaelement.default);

          exports.default = MediaElementWebAudio;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/mediaelement.js":
        /*!*****************************!*\
          !*** ./src/mediaelement.js ***!
          \*****************************/
        /***/function srcMediaelementJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {
                  return desc.get.call(receiver);
                }return desc.value;
              };
            }return _get(target, property, receiver || target);
          }

          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);if (object === null) break;
            }return object;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          /**
           * MediaElement backend
           */
          var MediaElement = /*#__PURE__*/function (_WebAudio) {
            _inherits(MediaElement, _WebAudio);

            var _super = _createSuper(MediaElement);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function MediaElement(params) {
              var _this;

              _classCallCheck(this, MediaElement);

              _this = _super.call(this, params);
              /** @private */

              _this.params = params;
              /**
               * Initially a dummy media element to catch errors. Once `_load` is
               * called, this will contain the actual `HTMLMediaElement`.
               * @private
               */

              _this.media = {
                currentTime: 0,
                duration: 0,
                paused: true,
                playbackRate: 1,
                play: function play() {},
                pause: function pause() {},
                volume: 0
              };
              /** @private */

              _this.mediaType = params.mediaType.toLowerCase();
              /** @private */

              _this.elementPosition = params.elementPosition;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** @private */

              _this.volume = 1;
              /** @private */

              _this.isMuted = false;
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.onPlayEnd = null;
              /** @private */

              _this.mediaListeners = {};
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(MediaElement, [{
              key: "init",
              value: function init() {
                this.setPlaybackRate(this.params.audioRate);
                this.createTimer();
              }
              /**
               * Attach event listeners to media element.
               */

            }, {
              key: "_setupMediaListeners",
              value: function _setupMediaListeners() {
                var _this2 = this;

                this.mediaListeners.error = function () {
                  _this2.fireEvent('error', 'Error loading media element');
                };

                this.mediaListeners.canplay = function () {
                  _this2.fireEvent('canplay');
                };

                this.mediaListeners.ended = function () {
                  _this2.fireEvent('finish');
                }; // listen to and relay play, pause and seeked events to enable
                // playback control from the external media element


                this.mediaListeners.play = function () {
                  _this2.fireEvent('play');
                };

                this.mediaListeners.pause = function () {
                  _this2.fireEvent('pause');
                };

                this.mediaListeners.seeked = function (event) {
                  _this2.fireEvent('seek');
                };

                this.mediaListeners.volumechange = function (event) {
                  _this2.isMuted = _this2.media.muted;

                  if (_this2.isMuted) {
                    _this2.volume = 0;
                  } else {
                    _this2.volume = _this2.media.volume;
                  }

                  _this2.fireEvent('volume');
                }; // reset event listeners


                Object.keys(this.mediaListeners).forEach(function (id) {
                  _this2.media.removeEventListener(id, _this2.mediaListeners[id]);

                  _this2.media.addEventListener(id, _this2.mediaListeners[id]);
                });
              }
              /**
               * Create a timer to provide a more precise `audioprocess` event.
               */

            }, {
              key: "createTimer",
              value: function createTimer() {
                var _this3 = this;

                var onAudioProcess = function onAudioProcess() {
                  if (_this3.isPaused()) {
                    return;
                  }

                  _this3.fireEvent('audioprocess', _this3.getCurrentTime()); // Call again in the next frame


                  util.frame(onAudioProcess)();
                };

                this.on('play', onAudioProcess); // Update the progress one more time to prevent it from being stuck in
                // case of lower framerates

                this.on('pause', function () {
                  _this3.fireEvent('audioprocess', _this3.getCurrentTime());
                });
              }
              /**
               * Create media element with url as its source,
               * and append to container element.
               *
               * @param {string} url Path to media file
               * @param {HTMLElement} container HTML element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `url` argument is not a valid media
               * element.
               */

            }, {
              key: "load",
              value: function load(url, container, peaks, preload) {
                var media = document.createElement(this.mediaType);
                media.controls = this.params.mediaControls;
                media.autoplay = this.params.autoplay || false;
                media.preload = preload == null ? 'auto' : preload;
                media.src = url;
                media.style.width = '100%';
                var prevMedia = container.querySelector(this.mediaType);

                if (prevMedia) {
                  container.removeChild(prevMedia);
                }

                container.appendChild(media);

                this._load(media, peaks, preload);
              }
              /**
               * Load existing media element.
               *
               * @param {HTMLMediaElement} elt HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               */

            }, {
              key: "loadElt",
              value: function loadElt(elt, peaks) {
                elt.controls = this.params.mediaControls;
                elt.autoplay = this.params.autoplay || false;

                this._load(elt, peaks, elt.preload);
              }
              /**
               * Method called by both `load` (from url)
               * and `loadElt` (existing media element) methods.
               *
               * @param {HTMLMediaElement} media HTML5 Audio or Video element
               * @param {number[]|Number.<Array[]>} peaks Array of peak data
               * @param {string} preload HTML 5 preload attribute value
               * @throws Will throw an error if the `media` argument is not a valid media
               * element.
               * @private
               */

            }, {
              key: "_load",
              value: function _load(media, peaks, preload) {
                // verify media element is valid
                if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
                  throw new Error('media parameter is not a valid media element');
                } // load must be called manually on iOS, otherwise peaks won't draw
                // until a user interaction triggers load --> 'ready' event
                //
                // note that we avoid calling media.load here when given peaks and preload == 'none'
                // as this almost always triggers some browser fetch of the media.


                if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
                  // Resets the media element and restarts the media resource. Any
                  // pending events are discarded. How much media data is fetched is
                  // still affected by the preload attribute.
                  media.load();
                }

                this.media = media;

                this._setupMediaListeners();

                this.peaks = peaks;
                this.onPlayEnd = null;
                this.buffer = null;
                this.isMuted = media.muted;
                this.setPlaybackRate(this.playbackRate);
                this.setVolume(this.volume);
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Media paused or not
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return !this.media || this.media.paused;
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                var duration = (this.buffer || this.media).duration;

                if (duration >= Infinity) {
                  // streaming audio
                  duration = this.media.seekable.end(0);
                }

                return duration;
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} Current time
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.media && this.media.currentTime;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Current position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.getCurrentTime() / this.getDuration() || 0;
              }
              /**
               * Get the audio source playback rate.
               *
               * @return {number} Playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate || this.media.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value Playback rate
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.media.playbackRate = this.playbackRate;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               */

            }, {
              key: "seekTo",
              value: function seekTo(start) {
                if (start != null) {
                  this.media.currentTime = start;
                }

                this.clearPlayEnd();
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop, relative to the beginning of a clip.
               * @emits MediaElement#play
               * @return {Promise} Result
               */

            }, {
              key: "play",
              value: function play(start, end) {
                this.seekTo(start);
                var promise = this.media.play();
                end && this.setPlayEnd(end);
                return promise;
              }
              /**
               * Pauses the loaded audio.
               *
               * @emits MediaElement#pause
               * @return {Promise} Result
               */

            }, {
              key: "pause",
              value: function pause() {
                var promise;

                if (this.media) {
                  promise = this.media.pause();
                }

                this.clearPlayEnd();
                return promise;
              }
              /**
               * Set the play end
               *
               * @param {number} end Where to end
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                var _this4 = this;

                this.clearPlayEnd();

                this._onPlayEnd = function (time) {
                  if (time >= end) {
                    _this4.pause();

                    _this4.seekTo(end);
                  }
                };

                this.on('audioprocess', this._onPlayEnd);
              }
              /** @private */

            }, {
              key: "clearPlayEnd",
              value: function clearPlayEnd() {
                if (this._onPlayEnd) {
                  this.un('audioprocess', this._onPlayEnd);
                  this._onPlayEnd = null;
                }
              }
              /**
               * Compute the max and min value of the waveform when broken into
               * <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
               * arrays of peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.buffer) {
                  return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
                }

                return this.peaks || [];
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  if (!this.media.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  return this.media.setSinkId(deviceId);
                }

                return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.volume;
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.volume = value; // no need to change when it's already at that volume

                if (this.media.volume !== this.volume) {
                  this.media.volume = this.volume;
                }
              }
              /**
               * Enable or disable muted audio
               *
               * @since 4.0.0
               * @param {boolean} muted Specify `true` to mute audio.
               */

            }, {
              key: "setMute",
              value: function setMute(muted) {
                // This causes a volume change to be emitted too through the
                // volumechange event listener.
                this.isMuted = this.media.muted = muted;
              }
              /**
               * This is called when wavesurfer is destroyed
               *
               */

            }, {
              key: "destroy",
              value: function destroy() {
                var _this5 = this;

                this.pause();
                this.unAll();
                this.destroyed = true; // cleanup media event listeners

                Object.keys(this.mediaListeners).forEach(function (id) {
                  if (_this5.media) {
                    _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
                  }
                });

                if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
                  this.media.parentNode.removeChild(this.media);
                }

                this.media = null;
              }
            }]);

            return MediaElement;
          }(_webaudio.default);

          exports.default = MediaElement;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/peakcache.js":
        /*!**************************!*\
          !*** ./src/peakcache.js ***!
          \**************************/
        /***/function srcPeakcacheJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Caches the decoded peaks data to improve rendering speed for large audio
           *
           * Is used if the option parameter `partialRender` is set to `true`
           */
          var PeakCache = /*#__PURE__*/function () {
            /**
             * Instantiate cache
             */
            function PeakCache() {
              _classCallCheck(this, PeakCache);

              this.clearPeakCache();
            }
            /**
             * Empty the cache
             */

            _createClass(PeakCache, [{
              key: "clearPeakCache",
              value: function clearPeakCache() {
                /**
                 * Flat array with entries that are always in pairs to mark the
                 * beginning and end of each subrange.  This is a convenience so we can
                 * iterate over the pairs for easy set difference operations.
                 * @private
                 */
                this.peakCacheRanges = [];
                /**
                 * Length of the entire cachable region, used for resetting the cache
                 * when this changes (zoom events, for instance).
                 * @private
                 */

                this.peakCacheLength = -1;
              }
              /**
               * Add a range of peaks to the cache
               *
               * @param {number} length The length of the range
               * @param {number} start The x offset of the start of the range
               * @param {number} end The x offset of the end of the range
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "addRangeToPeakCache",
              value: function addRangeToPeakCache(length, start, end) {
                if (length != this.peakCacheLength) {
                  this.clearPeakCache();
                  this.peakCacheLength = length;
                } // Return ranges that weren't in the cache before the call.


                var uncachedRanges = [];
                var i = 0; // Skip ranges before the current start.

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
                  i++;
                } // If |i| is even, |start| falls after an existing range.  Otherwise,
                // |start| falls between an existing range, and the uncached region
                // starts when we encounter the next node in |peakCacheRanges| or
                // |end|, whichever comes first.


                if (i % 2 == 0) {
                  uncachedRanges.push(start);
                }

                while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
                  uncachedRanges.push(this.peakCacheRanges[i]);
                  i++;
                } // If |i| is even, |end| is after all existing ranges.


                if (i % 2 == 0) {
                  uncachedRanges.push(end);
                } // Filter out the 0-length ranges.


                uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Merge the two ranges together, uncachedRanges will either contain
                // wholly new points, or duplicates of points in peakCacheRanges.  If
                // duplicates are detected, remove both and extend the range.

                this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
                this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
                  return a - b;
                }).filter(function (item, pos, arr) {
                  if (pos == 0) {
                    return item != arr[pos + 1];
                  } else if (pos == arr.length - 1) {
                    return item != arr[pos - 1];
                  }

                  return item != arr[pos - 1] && item != arr[pos + 1];
                }); // Push the uncached ranges into an array of arrays for ease of
                // iteration in the functions that call this.

                var uncachedRangePairs = [];

                for (i = 0; i < uncachedRanges.length; i += 2) {
                  uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
                }

                return uncachedRangePairs;
              }
              /**
               * For testing
               *
               * @return {Number.<Array[]>} Array with arrays of numbers
               */

            }, {
              key: "getCacheRanges",
              value: function getCacheRanges() {
                var peakCacheRangePairs = [];
                var i;

                for (i = 0; i < this.peakCacheRanges.length; i += 2) {
                  peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
                }

                return peakCacheRangePairs;
              }
            }]);

            return PeakCache;
          }();

          exports.default = PeakCache;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/absMax.js":
        /*!****************************!*\
          !*** ./src/util/absMax.js ***!
          \****************************/
        /***/function srcUtilAbsMaxJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = absMax;

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Get the largest absolute value in an array
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
           * @since 4.3.0
           */
          function absMax(values) {
            var max = (0, _max.default)(values);
            var min = (0, _min.default)(values);
            return -min > max ? -min : max;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/clamp.js":
        /*!***************************!*\
          !*** ./src/util/clamp.js ***!
          \***************************/
        /***/function srcUtilClampJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = clamp;

          /**
           * Returns a number limited to the given range.
           *
           * @param {number} val The number to be limited to a range
           * @param {number} min The lower boundary of the limit range
           * @param {number} max The upper boundary of the limit range
           * @returns {number} A number in the range [min, max]
           */
          function clamp(val, min, max) {
            return Math.min(Math.max(min, val), max);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/fetch.js":
        /*!***************************!*\
          !*** ./src/util/fetch.js ***!
          \***************************/
        /***/function srcUtilFetchJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = fetchFile;

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          var ProgressHandler = /*#__PURE__*/function () {
            /**
             * Instantiate ProgressHandler
             *
             * @param {Observer} instance The `fetchFile` observer instance.
             * @param {Number} contentLength Content length.
             * @param {Response} response Response object.
             */
            function ProgressHandler(instance, contentLength, response) {
              _classCallCheck(this, ProgressHandler);

              this.instance = instance;
              this.instance._reader = response.body.getReader();
              this.total = parseInt(contentLength, 10);
              this.loaded = 0;
            }
            /**
             * A method that is called once, immediately after the `ReadableStream``
             * is constructed.
             *
             * @param {ReadableStreamDefaultController} controller Controller instance
             *     used to control the stream.
             */

            _createClass(ProgressHandler, [{
              key: "start",
              value: function start(controller) {
                var _this = this;

                var read = function read() {
                  // instance._reader.read() returns a promise that resolves
                  // when a value has been received
                  _this.instance._reader.read().then(function (_ref) {
                    var done = _ref.done,
                        value = _ref.value;

                    // result objects contain two properties:
                    // done  - true if the stream has already given you all its data.
                    // value - some data. Always undefined when done is true.
                    if (done) {
                      // ensure onProgress called when content-length=0
                      if (_this.total === 0) {
                        _this.instance.onProgress.call(_this.instance, {
                          loaded: _this.loaded,
                          total: _this.total,
                          lengthComputable: false
                        });
                      } // no more data needs to be consumed, close the stream


                      controller.close();
                      return;
                    }

                    _this.loaded += value.byteLength;

                    _this.instance.onProgress.call(_this.instance, {
                      loaded: _this.loaded,
                      total: _this.total,
                      lengthComputable: !(_this.total === 0)
                    }); // enqueue the next data chunk into our target stream


                    controller.enqueue(value);
                    read();
                  }).catch(function (error) {
                    controller.error(error);
                  });
                };

                read();
              }
            }]);

            return ProgressHandler;
          }();
          /**
           * Load a file using `fetch`.
           *
           * @param {object} options Request options to use. See example below.
           * @returns {Observer} Observer instance
           * @example
           * // default options
           * let options = {
           *     url: undefined,
           *     method: 'GET',
           *     mode: 'cors',
           *     credentials: 'same-origin',
           *     cache: 'default',
           *     responseType: 'json',
           *     requestHeaders: [],
           *     redirect: 'follow',
           *     referrer: 'client'
           * };
           *
           * // override some options
           * options.url = '../media/demo.wav';
          
           * // available types: 'arraybuffer', 'blob', 'json' or 'text'
           * options.responseType = 'arraybuffer';
           *
           * // make fetch call
           * let request = util.fetchFile(options);
           *
           * // listen for events
           * request.on('progress', e => {
           *     console.log('progress', e);
           * });
           *
           * request.on('success', data => {
           *     console.log('success!', data);
           * });
           *
           * request.on('error', e => {
           *     console.warn('fetchFile error: ', e);
           * });
           */

          function fetchFile(options) {
            if (!options) {
              throw new Error('fetch options missing');
            } else if (!options.url) {
              throw new Error('fetch url missing');
            }

            var instance = new _observer.default();
            var fetchHeaders = new Headers();
            var fetchRequest = new Request(options.url); // add ability to abort

            instance.controller = new AbortController(); // check if headers have to be added

            if (options && options.requestHeaders) {
              // add custom request headers
              options.requestHeaders.forEach(function (header) {
                fetchHeaders.append(header.key, header.value);
              });
            } // parse fetch options


            var responseType = options.responseType || 'json';
            var fetchOptions = {
              method: options.method || 'GET',
              headers: fetchHeaders,
              mode: options.mode || 'cors',
              credentials: options.credentials || 'same-origin',
              cache: options.cache || 'default',
              redirect: options.redirect || 'follow',
              referrer: options.referrer || 'client',
              signal: instance.controller.signal
            };
            fetch(fetchRequest, fetchOptions).then(function (response) {
              // store response reference
              instance.response = response;
              var progressAvailable = true;

              if (!response.body) {
                // ReadableStream is not yet supported in this browser
                // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
                progressAvailable = false;
              } // Server must send CORS header "Access-Control-Expose-Headers: content-length"


              var contentLength = response.headers.get('content-length');

              if (contentLength === null) {
                // Content-Length server response header missing.
                // Don't evaluate download progress if we can't compare against a total size
                // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
                progressAvailable = false;
              }

              if (!progressAvailable) {
                // not able to check download progress so skip it
                return response;
              } // fire progress event when during load


              instance.onProgress = function (e) {
                instance.fireEvent('progress', e);
              };

              return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
            }).then(function (response) {
              var errMsg;

              if (response.ok) {
                switch (responseType) {
                  case 'arraybuffer':
                    return response.arrayBuffer();

                  case 'json':
                    return response.json();

                  case 'blob':
                    return response.blob();

                  case 'text':
                    return response.text();

                  default:
                    errMsg = 'Unknown responseType: ' + responseType;
                    break;
                }
              }

              if (!errMsg) {
                errMsg = 'HTTP error status: ' + response.status;
              }

              throw new Error(errMsg);
            }).then(function (response) {
              instance.fireEvent('success', response);
            }).catch(function (error) {
              instance.fireEvent('error', error);
            }); // return the fetch request

            instance.fetchRequest = fetchRequest;
            return instance;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/frame.js":
        /*!***************************!*\
          !*** ./src/util/frame.js ***!
          \***************************/
        /***/function srcUtilFrameJs(module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = frame;

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /**
           * Create a function which will be called at the next requestAnimationFrame
           * cycle
           *
           * @param {function} func The function to call
           *
           * @return {func} The function wrapped within a requestAnimationFrame
           */
          function frame(func) {
            return function () {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return (0, _requestAnimationFrame.default)(function () {
                return func.apply(void 0, args);
              });
            };
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/get-id.js":
        /*!****************************!*\
          !*** ./src/util/get-id.js ***!
          \****************************/
        /***/function srcUtilGetIdJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = getId;

          /**
           * Get a random prefixed ID
           *
           * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
           * @returns {String} Random prefixed ID
           * @example
           * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
           *
           * let prefix = 'foo-';
           * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
           */
          function getId(prefix) {
            if (prefix === undefined) {
              prefix = 'wavesurfer_';
            }

            return prefix + Math.random().toString(32).substring(2);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/index.js":
        /*!***************************!*\
          !*** ./src/util/index.js ***!
          \***************************/
        /***/function srcUtilIndexJs(__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          Object.defineProperty(exports, "getId", {
            enumerable: true,
            get: function get() {
              return _getId.default;
            }
          });
          Object.defineProperty(exports, "max", {
            enumerable: true,
            get: function get() {
              return _max.default;
            }
          });
          Object.defineProperty(exports, "min", {
            enumerable: true,
            get: function get() {
              return _min.default;
            }
          });
          Object.defineProperty(exports, "absMax", {
            enumerable: true,
            get: function get() {
              return _absMax.default;
            }
          });
          Object.defineProperty(exports, "Observer", {
            enumerable: true,
            get: function get() {
              return _observer.default;
            }
          });
          Object.defineProperty(exports, "style", {
            enumerable: true,
            get: function get() {
              return _style.default;
            }
          });
          Object.defineProperty(exports, "requestAnimationFrame", {
            enumerable: true,
            get: function get() {
              return _requestAnimationFrame.default;
            }
          });
          Object.defineProperty(exports, "frame", {
            enumerable: true,
            get: function get() {
              return _frame.default;
            }
          });
          Object.defineProperty(exports, "debounce", {
            enumerable: true,
            get: function get() {
              return _debounce.default;
            }
          });
          Object.defineProperty(exports, "preventClick", {
            enumerable: true,
            get: function get() {
              return _preventClick.default;
            }
          });
          Object.defineProperty(exports, "fetchFile", {
            enumerable: true,
            get: function get() {
              return _fetch.default;
            }
          });
          Object.defineProperty(exports, "clamp", {
            enumerable: true,
            get: function get() {
              return _clamp.default;
            }
          });
          Object.defineProperty(exports, "withOrientation", {
            enumerable: true,
            get: function get() {
              return _orientation.default;
            }
          });

          var _getId = _interopRequireDefault(__webpack_require__( /*! ./get-id */"./src/util/get-id.js"));

          var _max = _interopRequireDefault(__webpack_require__( /*! ./max */"./src/util/max.js"));

          var _min = _interopRequireDefault(__webpack_require__( /*! ./min */"./src/util/min.js"));

          var _absMax = _interopRequireDefault(__webpack_require__( /*! ./absMax */"./src/util/absMax.js"));

          var _observer = _interopRequireDefault(__webpack_require__( /*! ./observer */"./src/util/observer.js"));

          var _style = _interopRequireDefault(__webpack_require__( /*! ./style */"./src/util/style.js"));

          var _requestAnimationFrame = _interopRequireDefault(__webpack_require__( /*! ./request-animation-frame */"./src/util/request-animation-frame.js"));

          var _frame = _interopRequireDefault(__webpack_require__( /*! ./frame */"./src/util/frame.js"));

          var _debounce = _interopRequireDefault(__webpack_require__( /*! debounce */"./node_modules/debounce/index.js"));

          var _preventClick = _interopRequireDefault(__webpack_require__( /*! ./prevent-click */"./src/util/prevent-click.js"));

          var _fetch = _interopRequireDefault(__webpack_require__( /*! ./fetch */"./src/util/fetch.js"));

          var _clamp = _interopRequireDefault(__webpack_require__( /*! ./clamp */"./src/util/clamp.js"));

          var _orientation = _interopRequireDefault(__webpack_require__( /*! ./orientation */"./src/util/orientation.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          /***/
        },

        /***/"./src/util/max.js":
        /*!*************************!*\
          !*** ./src/util/max.js ***!
          \*************************/
        /***/function srcUtilMaxJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = max;

          /**
           * Get the largest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Largest number found
           * @example console.log(max([1, 2, 3])); // logs 3
           */
          function max(values) {
            var largest = -Infinity;
            Object.keys(values).forEach(function (i) {
              if (values[i] > largest) {
                largest = values[i];
              }
            });
            return largest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/min.js":
        /*!*************************!*\
          !*** ./src/util/min.js ***!
          \*************************/
        /***/function srcUtilMinJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = min;

          /**
           * Get the smallest value
           *
           * @param   {Array} values Array of numbers
           * @returns {Number} Smallest number found
           * @example console.log(min([1, 2, 3])); // logs 1
           */
          function min(values) {
            var smallest = Number(Infinity);
            Object.keys(values).forEach(function (i) {
              if (values[i] < smallest) {
                smallest = values[i];
              }
            });
            return smallest;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/observer.js":
        /*!******************************!*\
          !*** ./src/util/observer.js ***!
          \******************************/
        /***/function srcUtilObserverJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} ListenerDescriptor
           * @property {string} name The name of the event
           * @property {function} callback The callback
           * @property {function} un The function to call to remove the listener
           */

          /**
           * Observer class
           */
          var Observer = /*#__PURE__*/function () {
            /**
             * Instantiate Observer
             */
            function Observer() {
              _classCallCheck(this, Observer);

              /**
               * @private
               * @todo Initialise the handlers here already and remove the conditional
               * assignment in `on()`
               */
              this._disabledEventEmissions = [];
              this.handlers = null;
            }
            /**
             * Attach a handler function for an event.
             *
             * @param {string} event Name of the event to listen to
             * @param {function} fn The callback to trigger when the event is fired
             * @return {ListenerDescriptor} The event descriptor
             */

            _createClass(Observer, [{
              key: "on",
              value: function on(event, fn) {
                var _this = this;

                if (!this.handlers) {
                  this.handlers = {};
                }

                var handlers = this.handlers[event];

                if (!handlers) {
                  handlers = this.handlers[event] = [];
                }

                handlers.push(fn); // Return an event descriptor

                return {
                  name: event,
                  callback: fn,
                  un: function un(e, fn) {
                    return _this.un(e, fn);
                  }
                };
              }
              /**
               * Remove an event handler.
               *
               * @param {string} event Name of the event the listener that should be
               * removed listens to
               * @param {function} fn The callback that should be removed
               */

            }, {
              key: "un",
              value: function un(event, fn) {
                if (!this.handlers) {
                  return;
                }

                var handlers = this.handlers[event];
                var i;

                if (handlers) {
                  if (fn) {
                    for (i = handlers.length - 1; i >= 0; i--) {
                      if (handlers[i] == fn) {
                        handlers.splice(i, 1);
                      }
                    }
                  } else {
                    handlers.length = 0;
                  }
                }
              }
              /**
               * Remove all event handlers.
               */

            }, {
              key: "unAll",
              value: function unAll() {
                this.handlers = null;
              }
              /**
               * Attach a handler to an event. The handler is executed at most once per
               * event type.
               *
               * @param {string} event The event to listen to
               * @param {function} handler The callback that is only to be called once
               * @return {ListenerDescriptor} The event descriptor
               */

            }, {
              key: "once",
              value: function once(event, handler) {
                var _this2 = this;

                var fn = function fn() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  /*  eslint-disable no-invalid-this */
                  handler.apply(_this2, args);
                  /*  eslint-enable no-invalid-this */

                  setTimeout(function () {
                    _this2.un(event, fn);
                  }, 0);
                };

                return this.on(event, fn);
              }
              /**
               * Disable firing a list of events by name. When specified, event handlers for any event type
               * passed in here will not be called.
               *
               * @since 4.0.0
               * @param {string[]} eventNames an array of event names to disable emissions for
               * @example
               * // disable seek and interaction events
               * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
               */

            }, {
              key: "setDisabledEventEmissions",
              value: function setDisabledEventEmissions(eventNames) {
                this._disabledEventEmissions = eventNames;
              }
              /**
               * plugins borrow part of this class without calling the constructor,
               * so we have to be careful about _disabledEventEmissions
               */

            }, {
              key: "_isDisabledEventEmission",
              value: function _isDisabledEventEmission(event) {
                return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
              }
              /**
               * Manually fire an event
               *
               * @param {string} event The event to fire manually
               * @param {...any} args The arguments with which to call the listeners
               */

            }, {
              key: "fireEvent",
              value: function fireEvent(event) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }

                if (!this.handlers || this._isDisabledEventEmission(event)) {
                  return;
                }

                var handlers = this.handlers[event];
                handlers && handlers.forEach(function (fn) {
                  fn.apply(void 0, args);
                });
              }
            }]);

            return Observer;
          }();

          exports.default = Observer;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/orientation.js":
        /*!*********************************!*\
          !*** ./src/util/orientation.js ***!
          \*********************************/
        /***/function srcUtilOrientationJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = withOrientation;
          var verticalPropMap = {
            width: 'height',
            height: 'width',
            overflowX: 'overflowY',
            overflowY: 'overflowX',
            clientWidth: 'clientHeight',
            clientHeight: 'clientWidth',
            clientX: 'clientY',
            clientY: 'clientX',
            scrollWidth: 'scrollHeight',
            scrollLeft: 'scrollTop',
            offsetLeft: 'offsetTop',
            offsetTop: 'offsetLeft',
            offsetHeight: 'offsetWidth',
            offsetWidth: 'offsetHeight',
            left: 'top',
            right: 'bottom',
            top: 'left',
            bottom: 'right',
            borderRightStyle: 'borderBottomStyle',
            borderRightWidth: 'borderBottomWidth',
            borderRightColor: 'borderBottomColor'
          };
          /**
           * Convert a horizontally-oriented property name to a vertical one.
           *
           * @param {string} prop A property name
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {string} prop, converted appropriately
           */

          function mapProp(prop, vertical) {
            if (Object.prototype.hasOwnProperty.call(verticalPropMap, prop)) {
              return vertical ? verticalPropMap[prop] : prop;
            } else {
              return prop;
            }
          }

          var isProxy = Symbol("isProxy");
          /**
           * Returns an appropriately oriented object based on vertical.
           * If vertical is true, attribute getting and setting will be mapped through
           * verticalPropMap, so that e.g. getting the object's .width will give its
           * .height instead.
           * Certain methods of an oriented object will return oriented objects as well.
           * Oriented objects can't be added to the DOM directly since they are Proxy objects
           * and thus fail typechecks. Use domElement to get the actual element for this.
           *
           * @param {object} target The object to be wrapped and oriented
           * @param {bool} vertical Whether the element is oriented vertically
           * @returns {Proxy} An oriented object with attr translation via verticalAttrMap
           * @since 5.0.0
           */

          function withOrientation(target, vertical) {
            if (target[isProxy]) {
              return target;
            } else {
              return new Proxy(target, {
                get: function get(obj, prop, receiver) {
                  if (prop === isProxy) {
                    return true;
                  } else if (prop === 'domElement') {
                    return obj;
                  } else if (prop === 'style') {
                    return withOrientation(obj.style, vertical);
                  } else if (prop === 'canvas') {
                    return withOrientation(obj.canvas, vertical);
                  } else if (prop === 'getBoundingClientRect') {
                    return function () {
                      return withOrientation(obj.getBoundingClientRect.apply(obj, arguments), vertical);
                    };
                  } else if (prop === 'getContext') {
                    return function () {
                      return withOrientation(obj.getContext.apply(obj, arguments), vertical);
                    };
                  } else {
                    var value = obj[mapProp(prop, vertical)];
                    return typeof value == 'function' ? value.bind(obj) : value;
                  }
                },
                set: function set(obj, prop, value) {
                  obj[mapProp(prop, vertical)] = value;
                  return true;
                }
              });
            }
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/prevent-click.js":
        /*!***********************************!*\
          !*** ./src/util/prevent-click.js ***!
          \***********************************/
        /***/function srcUtilPreventClickJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = preventClick;

          /**
           * Stops propagation of click event and removes event listener
           *
           * @private
           * @param {object} event The click event
           */
          function preventClickHandler(event) {
            event.stopPropagation();
            document.body.removeEventListener('click', preventClickHandler, true);
          }
          /**
           * Starts listening for click event and prevent propagation
           *
           * @param {object} values Values
           */

          function preventClick(values) {
            document.body.addEventListener('click', preventClickHandler, true);
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/request-animation-frame.js":
        /*!*********************************************!*\
          !*** ./src/util/request-animation-frame.js ***!
          \*********************************************/
        /***/function srcUtilRequestAnimationFrameJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          /* eslint-disable valid-jsdoc */

          /**
           * Returns the `requestAnimationFrame` function for the browser, or a shim with
           * `setTimeout` if the function is not found
           *
           * @return {function} Available `requestAnimationFrame` function for the browser
           */
          var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
            return setTimeout(callback, 1000 / 60);
          }).bind(window);

          exports.default = _default;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/util/style.js":
        /*!***************************!*\
          !*** ./src/util/style.js ***!
          \***************************/
        /***/function srcUtilStyleJs(module, exports) {

          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = style;

          /**
           * Apply a map of styles to an element
           *
           * @param {HTMLElement} el The element that the styles will be applied to
           * @param {Object} styles The map of propName: attribute, both are used as-is
           *
           * @return {HTMLElement} el
           */
          function style(el, styles) {
            Object.keys(styles).forEach(function (prop) {
              if (el.style[prop] !== styles[prop]) {
                el.style[prop] = styles[prop];
              }
            });
            return el;
          }

          module.exports = exports.default;

          /***/
        },

        /***/"./src/wavesurfer.js":
        /*!***************************!*\
          !*** ./src/wavesurfer.js ***!
          \***************************/
        /***/function srcWavesurferJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          var _drawer = _interopRequireDefault(__webpack_require__( /*! ./drawer.multicanvas */"./src/drawer.multicanvas.js"));

          var _webaudio = _interopRequireDefault(__webpack_require__( /*! ./webaudio */"./src/webaudio.js"));

          var _mediaelement = _interopRequireDefault(__webpack_require__( /*! ./mediaelement */"./src/mediaelement.js"));

          var _peakcache = _interopRequireDefault(__webpack_require__( /*! ./peakcache */"./src/peakcache.js"));

          var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__( /*! ./mediaelement-webaudio */"./src/mediaelement-webaudio.js"));

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /*
           * This work is licensed under a BSD-3-Clause License.
           */

          /** @external {HTMLElement} https://developer.mozilla.org/en/docs/Web/API/HTMLElement */

          /** @external {OfflineAudioContext} https://developer.mozilla.org/en-US/docs/Web/API/OfflineAudioContext */

          /** @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File */

          /** @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob */

          /** @external {CanvasRenderingContext2D} https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D */

          /** @external {MediaStreamConstraints} https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints */

          /** @external {AudioNode} https://developer.mozilla.org/de/docs/Web/API/AudioNode */

          /**
           * @typedef {Object} WavesurferParams
           * @property {AudioContext} audioContext=null Use your own previously
           * initialized AudioContext or leave blank.
           * @property {number} audioRate=1 Speed at which to play audio. Lower number is
           * slower.
           * @property {ScriptProcessorNode} audioScriptProcessor=null Use your own previously
           * initialized ScriptProcessorNode or leave blank.
           * @property {boolean} autoCenter=true If a scrollbar is present, center the
           * waveform on current progress
           * @property {number} autoCenterRate=5 If autoCenter is active, rate at which the
           * waveform is centered
           * @property {boolean} autoCenterImmediately=false If autoCenter is active, immediately
           * center waveform on current progress
           * @property {string} backend='WebAudio' `'WebAudio'|'MediaElement'|'MediaElementWebAudio'` In most cases
           * you don't have to set this manually. MediaElement is a fallback for unsupported browsers.
           * MediaElementWebAudio allows to use WebAudio API also with big audio files, loading audio like with
           * MediaElement backend (HTML5 audio tag). You have to use the same methods of MediaElement backend for loading and
           * playback, giving also peaks, so the audio data are not decoded. In this way you can use WebAudio features, like filters,
           * also with audio with big duration. For example:
           * ` wavesurfer.load(url | HTMLMediaElement, peaks, preload, duration);
           *   wavesurfer.play();
           *   wavesurfer.setFilter(customFilter);
           * `
           * @property {string} backgroundColor=null Change background color of the
           * waveform container.
           * @property {number} barHeight=1 The height of the wave bars.
           * @property {number} barRadius=0 The radius of the wave bars. Makes bars rounded
           * @property {number} barGap=null The optional spacing between bars of the wave,
           * if not provided will be calculated in legacy format.
           * @property {number} barWidth=null Draw the waveform using bars.
           * @property {number} barMinHeight=null If specified, draw at least a bar of this height,
           * eliminating waveform gaps
           * @property {boolean} closeAudioContext=false Close and nullify all audio
           * contexts when the destroy method is called.
           * @property {!string|HTMLElement} container CSS selector or HTML element where
           * the waveform should be drawn. This is the only required parameter.
           * @property {string} cursorColor='#333' The fill color of the cursor indicating
           * the playhead position.
           * @property {number} cursorWidth=1 Measured in pixels.
           * @property {object} drawingContextAttributes={desynchronized: false} Drawing context
           * attributes.
           * @property {number} duration=null Optional audio length so pre-rendered peaks
           * can be display immediately for example.
           * @property {boolean} fillParent=true Whether to fill the entire container or
           * draw only according to `minPxPerSec`.
           * @property {boolean} forceDecode=false Force decoding of audio using web audio
           * when zooming to get a more detailed waveform.
           * @property {number} height=128 The height of the waveform. Measured in
           * pixels.
           * @property {boolean} hideScrollbar=false Whether to hide the horizontal
           * scrollbar when one would normally be shown.
           * @property {boolean} interact=true Whether the mouse interaction will be
           * enabled at initialization. You can switch this parameter at any time later
           * on.
           * @property {boolean} loopSelection=true (Use with regions plugin) Enable
           * looping of selected regions
           * @property {number} maxCanvasWidth=4000 Maximum width of a single canvas in
           * pixels, excluding a small overlap (2 * `pixelRatio`, rounded up to the next
           * even integer). If the waveform is longer than this value, additional canvases
           * will be used to render the waveform, which is useful for very large waveforms
           * that may be too wide for browsers to draw on a single canvas.
           * @property {boolean} mediaControls=false (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * this enables the native controls for the media element
           * @property {string} mediaType='audio' (Use with backend `MediaElement` or `MediaElementWebAudio`)
           * `'audio'|'video'` ('video' only for `MediaElement`)
           * @property {number} minPxPerSec=20 Minimum number of pixels per second of
           * audio.
           * @property {boolean} normalize=false If true, normalize by the maximum peak
           * instead of 1.0.
           * @property {boolean} partialRender=false Use the PeakCache to improve
           * rendering speed of large waveforms
           * @property {number} pixelRatio=window.devicePixelRatio The pixel ratio used to
           * calculate display
           * @property {PluginDefinition[]} plugins=[] An array of plugin definitions to
           * register during instantiation, they will be directly initialised unless they
           * are added with the `deferInit` property set to true.
           * @property {string} progressColor='#555' The fill color of the part of the
           * waveform behind the cursor. When `progressColor` and `waveColor` are the same
           * the progress wave is not rendered at all.
           * @property {boolean} removeMediaElementOnDestroy=true Set to false to keep the
           * media element in the DOM when the player is destroyed. This is useful when
           * reusing an existing media element via the `loadMediaElement` method.
           * @property {Object} renderer=MultiCanvas Can be used to inject a custom
           * renderer.
           * @property {boolean|number} responsive=false If set to `true` resize the
           * waveform, when the window is resized. This is debounced with a `100ms`
           * timeout by default. If this parameter is a number it represents that timeout.
           * @property {boolean} rtl=false If set to `true`, renders waveform from
           * right-to-left.
           * @property {boolean} scrollParent=false Whether to scroll the container with a
           * lengthy waveform. Otherwise the waveform is shrunk to the container width
           * (see fillParent).
           * @property {number} skipLength=2 Number of seconds to skip with the
           * skipForward() and skipBackward() methods.
           * @property {boolean} splitChannels=false Render with separate waveforms for
           * the channels of the audio
           * @property {SplitChannelOptions} splitChannelsOptions={} Options for splitChannel rendering
           * @property {boolean} vertical=false Render the waveform vertically instead of horizontally.
           * @property {string} waveColor='#999' The fill color of the waveform after the
           * cursor.
           * @property {object} xhr={} XHR options. For example:
           * `let xhr = {
           *     cache: 'default',
           *     mode: 'cors',
           *     method: 'GET',
           *     credentials: 'same-origin',
           *     redirect: 'follow',
           *     referrer: 'client',
           *     requestHeaders: [
           *         {
           *             key: 'Authorization',
           *             value: 'my-token'
           *         }
           *     ]
           * };`
           */

          /**
           * @typedef {Object} PluginDefinition
           * @desc The Object used to describe a plugin
           * @example wavesurfer.addPlugin(pluginDefinition);
           * @property {string} name The name of the plugin, the plugin instance will be
           * added as a property to the wavesurfer instance under this name
           * @property {?Object} staticProps The properties that should be added to the
           * wavesurfer instance as static properties
           * @property {?boolean} deferInit Don't initialise plugin
           * automatically
           * @property {Object} params={} The plugin parameters, they are the first parameter
           * passed to the plugin class constructor function
           * @property {PluginClass} instance The plugin instance factory, is called with
           * the dependency specified in extends. Returns the plugin class.
           */

          /**
           * @typedef {Object} SplitChannelOptions
           * @desc parameters applied when splitChannels option is true
           * @property {boolean} overlay=false determines whether channels are rendered on top of each other or on separate tracks
           * @property {object} channelColors={} object describing color for each channel. Example:
           * {
           *     0: {
           *         progressColor: 'green',
           *         waveColor: 'pink'
           *     },
           *     1: {
           *         progressColor: 'orange',
           *         waveColor: 'purple'
           *     }
           * }
           * @property {number[]} filterChannels=[] indexes of channels to be hidden from rendering
           * @property {boolean} relativeNormalization=false determines whether
           * normalization is done per channel or maintains proportionality between
           * channels. Only applied when normalize and splitChannels are both true.
           * @since 4.3.0
           */

          /**
           * @interface PluginClass
           *
           * @desc This is the interface which is implemented by all plugin classes. Note
           * that this only turns into an observer after being passed through
           * `wavesurfer.addPlugin`.
           *
           * @extends {Observer}
           */
          var PluginClass = /*#__PURE__*/function () {
            /**
             * Construct the plugin
             *
             * @param {Object} params={} The plugin params (specific to the plugin)
             * @param {Object} ws The wavesurfer instance
             */
            function PluginClass(params, ws) {
              _classCallCheck(this, PluginClass);
            }
            /**
             * Initialise the plugin
             *
             * Start doing something. This is called by
             * `wavesurfer.initPlugin(pluginName)`
             */

            _createClass(PluginClass, [{
              key: "create",
              value:
              /**
               * Plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * It returns a `PluginDefinition` object representing the plugin.
               *
               * @param {Object} params={} The plugin params (specific to the plugin)
               */
              function create(params) {}
            }, {
              key: "init",
              value: function init() {}
              /**
               * Destroy the plugin instance
               *
               * Stop doing something. This is called by
               * `wavesurfer.destroyPlugin(pluginName)`
               */

            }, {
              key: "destroy",
              value: function destroy() {}
            }]);

            return PluginClass;
          }();
          /**
           * WaveSurfer core library class
           *
           * @extends {Observer}
           * @example
           * const params = {
           *   container: '#waveform',
           *   waveColor: 'violet',
           *   progressColor: 'purple'
           * };
           *
           * // initialise like this
           * const wavesurfer = WaveSurfer.create(params);
           *
           * // or like this ...
           * const wavesurfer = new WaveSurfer(params);
           * wavesurfer.init();
           *
           * // load audio file
           * wavesurfer.load('example/media/demo.wav');
           */

          var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
            _inherits(WaveSurfer, _util$Observer);

            var _super = _createSuper(WaveSurfer);

            /**
             * Initialise wavesurfer instance
             *
             * @param {WavesurferParams} params Instantiation options for wavesurfer
             * @example
             * const wavesurfer = new WaveSurfer(params);
             * @returns {this} Wavesurfer instance
             */
            function WaveSurfer(params) {
              var _this;

              _classCallCheck(this, WaveSurfer);

              _this = _super.call(this);
              /**
               * Extract relevant parameters (or defaults)
               * @private
               */

              _this.defaultParams = {
                audioContext: null,
                audioScriptProcessor: null,
                audioRate: 1,
                autoCenter: true,
                autoCenterRate: 5,
                autoCenterImmediately: false,
                backend: 'WebAudio',
                backgroundColor: null,
                barHeight: 1,
                barRadius: 0,
                barGap: null,
                barMinHeight: null,
                container: null,
                cursorColor: '#333',
                cursorWidth: 1,
                dragSelection: true,
                drawingContextAttributes: {
                  // Boolean that hints the user agent to reduce the latency
                  // by desynchronizing the canvas paint cycle from the event
                  // loop
                  desynchronized: false
                },
                duration: null,
                fillParent: true,
                forceDecode: false,
                height: 128,
                hideScrollbar: false,
                interact: true,
                loopSelection: true,
                maxCanvasWidth: 4000,
                mediaContainer: null,
                mediaControls: false,
                mediaType: 'audio',
                minPxPerSec: 20,
                normalize: false,
                partialRender: false,
                pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
                plugins: [],
                progressColor: '#555',
                removeMediaElementOnDestroy: true,
                renderer: _drawer.default,
                responsive: false,
                rtl: false,
                scrollParent: false,
                skipLength: 2,
                splitChannels: false,
                splitChannelsOptions: {
                  overlay: false,
                  channelColors: {},
                  filterChannels: [],
                  relativeNormalization: false
                },
                vertical: false,
                waveColor: '#999',
                xhr: {}
              };
              _this.backends = {
                MediaElement: _mediaelement.default,
                WebAudio: _webaudio.default,
                MediaElementWebAudio: _mediaelementWebaudio.default
              };
              _this.util = util;
              _this.params = _extends({}, _this.defaultParams, params);
              _this.params.splitChannelsOptions = _extends({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
              /** @private */

              _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;

              if (!_this.container) {
                throw new Error('Container element not found');
              }

              if (_this.params.mediaContainer == null) {
                /** @private */
                _this.mediaContainer = _this.container;
              } else if (typeof _this.params.mediaContainer == 'string') {
                /** @private */
                _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
              } else {
                /** @private */
                _this.mediaContainer = _this.params.mediaContainer;
              }

              if (!_this.mediaContainer) {
                throw new Error('Media Container element not found');
              }

              if (_this.params.maxCanvasWidth <= 1) {
                throw new Error('maxCanvasWidth must be greater than 1');
              } else if (_this.params.maxCanvasWidth % 2 == 1) {
                throw new Error('maxCanvasWidth must be an even number');
              }

              if (_this.params.rtl === true) {
                if (_this.params.vertical === true) {
                  util.style(_this.container, {
                    transform: 'rotateX(180deg)'
                  });
                } else {
                  util.style(_this.container, {
                    transform: 'rotateY(180deg)'
                  });
                }
              }

              if (_this.params.backgroundColor) {
                _this.setBackgroundColor(_this.params.backgroundColor);
              }
              /**
               * @private Used to save the current volume when muting so we can
               * restore once unmuted
               * @type {number}
               */

              _this.savedVolume = 0;
              /**
               * @private The current muted state
               * @type {boolean}
               */

              _this.isMuted = false;
              /**
               * @private Will hold a list of event descriptors that need to be
               * canceled on subsequent loads of audio
               * @type {Object[]}
               */

              _this.tmpEvents = [];
              /**
               * @private Holds any running audio downloads
               * @type {Observer}
               */

              _this.currentRequest = null;
              /** @private */

              _this.arraybuffer = null;
              /** @private */

              _this.drawer = null;
              /** @private */

              _this.backend = null;
              /** @private */

              _this.peakCache = null; // cache constructor objects

              if (typeof _this.params.renderer !== 'function') {
                throw new Error('Renderer parameter is invalid');
              }
              /**
               * @private The uninitialised Drawer class
               */

              _this.Drawer = _this.params.renderer;
              /**
               * @private The uninitialised Backend class
               */
              // Back compat

              if (_this.params.backend == 'AudioElement') {
                _this.params.backend = 'MediaElement';
              }

              if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
                _this.params.backend = 'MediaElement';
              }

              _this.Backend = _this.backends[_this.params.backend];
              /**
               * @private map of plugin names that are currently initialised
               */

              _this.initialisedPluginList = {};
              /** @private */

              _this.isDestroyed = false;
              /**
               * Get the current ready status.
               *
               * @example const isReady = wavesurfer.isReady;
               * @return {boolean}
               */

              _this.isReady = false; // responsive debounced event listener. If this.params.responsive is not
              // set, this is never called. Use 100ms or this.params.responsive as
              // timeout for the debounce function.

              var prevWidth = 0;
              _this._onResize = util.debounce(function () {
                if (prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
                  prevWidth = _this.drawer.wrapper.clientWidth;

                  _this.drawer.fireEvent('redraw');
                }
              }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
              return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
            }
            /**
             * Initialise the wave
             *
             * @example
             * var wavesurfer = new WaveSurfer(params);
             * wavesurfer.init();
             * @return {this} The wavesurfer instance
             */

            _createClass(WaveSurfer, [{
              key: "init",
              value: function init() {
                this.registerPlugins(this.params.plugins);
                this.createDrawer();
                this.createBackend();
                this.createPeakCache();
                return this;
              }
              /**
               * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
               * this function is called in the init function of wavesurfer
               *
               * @param {PluginDefinition[]} plugins An array of plugin definitions
               * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "registerPlugins",
              value: function registerPlugins(plugins) {
                var _this2 = this;

                // first instantiate all the plugins
                plugins.forEach(function (plugin) {
                  return _this2.addPlugin(plugin);
                }); // now run the init functions

                plugins.forEach(function (plugin) {
                  // call init function of the plugin if deferInit is falsey
                  // in that case you would manually use initPlugins()
                  if (!plugin.deferInit) {
                    _this2.initPlugin(plugin.name);
                  }
                });
                this.fireEvent('plugins-registered', plugins);
                return this;
              }
              /**
               * Get a map of plugin names that are currently initialised
               *
               * @example wavesurfer.getPlugins();
               * @return {Object} Object with plugin names
               */

            }, {
              key: "getActivePlugins",
              value: function getActivePlugins() {
                return this.initialisedPluginList;
              }
              /**
               * Add a plugin object to wavesurfer
               *
               * @param {PluginDefinition} plugin A plugin definition
               * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
               * @example wavesurfer.addPlugin(WaveSurfer.minimap());
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "addPlugin",
              value: function addPlugin(plugin) {
                var _this3 = this;

                if (!plugin.name) {
                  throw new Error('Plugin does not have a name!');
                }

                if (!plugin.instance) {
                  throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
                } // staticProps properties are applied to wavesurfer instance


                if (plugin.staticProps) {
                  Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
                    /**
                     * Properties defined in a plugin definition's `staticProps` property are added as
                     * staticProps properties of the WaveSurfer instance
                     */
                    _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
                  });
                }

                var Instance = plugin.instance; // turn the plugin instance into an observer

                var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
                observerPrototypeKeys.forEach(function (key) {
                  Instance.prototype[key] = util.Observer.prototype[key];
                });
                /**
                 * Instantiated plugin classes are added as a property of the wavesurfer
                 * instance
                 * @type {Object}
                 */

                this[plugin.name] = new Instance(plugin.params || {}, this);
                this.fireEvent('plugin-added', plugin.name);
                return this;
              }
              /**
               * Initialise a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-initialised
               * @example wavesurfer.initPlugin('minimap');
               * @return {this} The wavesurfer instance
               */

            }, {
              key: "initPlugin",
              value: function initPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet!"));
                }

                if (this.initialisedPluginList[name]) {
                  // destroy any already initialised plugins
                  this.destroyPlugin(name);
                }

                this[name].init();
                this.initialisedPluginList[name] = true;
                this.fireEvent('plugin-initialised', name);
                return this;
              }
              /**
               * Destroy a plugin
               *
               * @param {string} name A plugin name
               * @emits WaveSurfer#plugin-destroyed
               * @example wavesurfer.destroyPlugin('minimap');
               * @returns {this} The wavesurfer instance
               */

            }, {
              key: "destroyPlugin",
              value: function destroyPlugin(name) {
                if (!this[name]) {
                  throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
                }

                if (!this.initialisedPluginList[name]) {
                  throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
                }

                if (typeof this[name].destroy !== 'function') {
                  throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
                }

                this[name].destroy();
                delete this.initialisedPluginList[name];
                this.fireEvent('plugin-destroyed', name);
                return this;
              }
              /**
               * Destroy all initialised plugins. Convenience function to use when
               * wavesurfer is removed
               *
               * @private
               */

            }, {
              key: "destroyAllPlugins",
              value: function destroyAllPlugins() {
                var _this4 = this;

                Object.keys(this.initialisedPluginList).forEach(function (name) {
                  return _this4.destroyPlugin(name);
                });
              }
              /**
               * Create the drawer and draw the waveform
               *
               * @private
               * @emits WaveSurfer#drawer-created
               */

            }, {
              key: "createDrawer",
              value: function createDrawer() {
                var _this5 = this;

                this.drawer = new this.Drawer(this.container, this.params);
                this.drawer.init();
                this.fireEvent('drawer-created', this.drawer);

                if (this.params.responsive !== false) {
                  window.addEventListener('resize', this._onResize, true);
                  window.addEventListener('orientationchange', this._onResize, true);
                }

                this.drawer.on('redraw', function () {
                  _this5.drawBuffer();

                  _this5.drawer.progress(_this5.backend.getPlayedPercents());
                }); // Click-to-seek

                this.drawer.on('click', function (e, progress) {
                  setTimeout(function () {
                    return _this5.seekTo(progress);
                  }, 0);
                }); // Relay the scroll event from the drawer

                this.drawer.on('scroll', function (e) {
                  if (_this5.params.partialRender) {
                    _this5.drawBuffer();
                  }

                  _this5.fireEvent('scroll', e);
                });
              }
              /**
               * Create the backend
               *
               * @private
               * @emits WaveSurfer#backend-created
               */

            }, {
              key: "createBackend",
              value: function createBackend() {
                var _this6 = this;

                if (this.backend) {
                  this.backend.destroy();
                }

                this.backend = new this.Backend(this.params);
                this.backend.init();
                this.fireEvent('backend-created', this.backend);
                this.backend.on('finish', function () {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('finish');
                });
                this.backend.on('play', function () {
                  return _this6.fireEvent('play');
                });
                this.backend.on('pause', function () {
                  return _this6.fireEvent('pause');
                });
                this.backend.on('audioprocess', function (time) {
                  _this6.drawer.progress(_this6.backend.getPlayedPercents());

                  _this6.fireEvent('audioprocess', time);
                }); // only needed for MediaElement and MediaElementWebAudio backend

                if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
                  this.backend.on('seek', function () {
                    _this6.drawer.progress(_this6.backend.getPlayedPercents());
                  });
                  this.backend.on('volume', function () {
                    var newVolume = _this6.getVolume();

                    _this6.fireEvent('volume', newVolume);

                    if (_this6.backend.isMuted !== _this6.isMuted) {
                      _this6.isMuted = _this6.backend.isMuted;

                      _this6.fireEvent('mute', _this6.isMuted);
                    }
                  });
                }
              }
              /**
               * Create the peak cache
               *
               * @private
               */

            }, {
              key: "createPeakCache",
              value: function createPeakCache() {
                if (this.params.partialRender) {
                  this.peakCache = new _peakcache.default();
                }
              }
              /**
               * Get the duration of the audio clip
               *
               * @example const duration = wavesurfer.getDuration();
               * @return {number} Duration in seconds
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                return this.backend.getDuration();
              }
              /**
               * Get the current playback position
               *
               * @example const currentTime = wavesurfer.getCurrentTime();
               * @return {number} Playback position in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.backend.getCurrentTime();
              }
              /**
               * Set the current play time in seconds.
               *
               * @param {number} seconds A positive number in seconds. E.g. 10 means 10
               * seconds, 60 means 1 minute
               */

            }, {
              key: "setCurrentTime",
              value: function setCurrentTime(seconds) {
                if (seconds >= this.getDuration()) {
                  this.seekTo(1);
                } else {
                  this.seekTo(seconds / this.getDuration());
                }
              }
              /**
               * Starts playback from the current position. Optional start and end
               * measured in seconds can be used to set the range of audio to play.
               *
               * @param {?number} start Position to start at
               * @param {?number} end Position to end at
               * @emits WaveSurfer#interaction
               * @return {Promise} Result of the backend play method
               * @example
               * // play from second 1 to 5
               * wavesurfer.play(1, 5);
               */

            }, {
              key: "play",
              value: function play(start, end) {
                var _this7 = this;

                this.fireEvent('interaction', function () {
                  return _this7.play(start, end);
                });
                return this.backend.play(start, end);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} position Position (in seconds) to stop at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(position) {
                this.backend.setPlayEnd(position);
              }
              /**
               * Stops and pauses playback
               *
               * @example wavesurfer.pause();
               * @return {Promise} Result of the backend pause method
               */

            }, {
              key: "pause",
              value: function pause() {
                if (!this.backend.isPaused()) {
                  return this.backend.pause();
                }
              }
              /**
               * Toggle playback
               *
               * @example wavesurfer.playPause();
               * @return {Promise} Result of the backend play or pause method
               */

            }, {
              key: "playPause",
              value: function playPause() {
                return this.backend.isPaused() ? this.play() : this.pause();
              }
              /**
               * Get the current playback state
               *
               * @example const isPlaying = wavesurfer.isPlaying();
               * @return {boolean} False if paused, true if playing
               */

            }, {
              key: "isPlaying",
              value: function isPlaying() {
                return !this.backend.isPaused();
              }
              /**
               * Skip backward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipBackward();
               */

            }, {
              key: "skipBackward",
              value: function skipBackward(seconds) {
                this.skip(-seconds || -this.params.skipLength);
              }
              /**
               * Skip forward
               *
               * @param {?number} seconds Amount to skip back, if not specified `skipLength`
               * is used
               * @example wavesurfer.skipForward();
               */

            }, {
              key: "skipForward",
              value: function skipForward(seconds) {
                this.skip(seconds || this.params.skipLength);
              }
              /**
               * Skip a number of seconds from the current position (use a negative value
               * to go backwards).
               *
               * @param {number} offset Amount to skip back or forwards
               * @example
               * // go back 2 seconds
               * wavesurfer.skip(-2);
               */

            }, {
              key: "skip",
              value: function skip(offset) {
                var duration = this.getDuration() || 1;
                var position = this.getCurrentTime() || 0;
                position = Math.max(0, Math.min(duration, position + (offset || 0)));
                this.seekAndCenter(position / duration);
              }
              /**
               * Seeks to a position and centers the view
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @example
               * // seek and go to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekAndCenter",
              value: function seekAndCenter(progress) {
                this.seekTo(progress);
                this.drawer.recenter(progress);
              }
              /**
               * Seeks to a position
               *
               * @param {number} progress Between 0 (=beginning) and 1 (=end)
               * @emits WaveSurfer#interaction
               * @emits WaveSurfer#seek
               * @example
               * // seek to the middle of the audio
               * wavesurfer.seekTo(0.5);
               */

            }, {
              key: "seekTo",
              value: function seekTo(progress) {
                var _this8 = this;

                // return an error if progress is not a number between 0 and 1
                if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
                  throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
                }

                this.fireEvent('interaction', function () {
                  return _this8.seekTo(progress);
                });
                var isWebAudioBackend = this.params.backend === 'WebAudio';
                var paused = this.backend.isPaused();

                if (isWebAudioBackend && !paused) {
                  this.backend.pause();
                } // avoid small scrolls while paused seeking


                var oldScrollParent = this.params.scrollParent;
                this.params.scrollParent = false;
                this.backend.seekTo(progress * this.getDuration());
                this.drawer.progress(progress);

                if (isWebAudioBackend && !paused) {
                  this.backend.play();
                }

                this.params.scrollParent = oldScrollParent;
                this.fireEvent('seek', progress);
              }
              /**
               * Stops and goes to the beginning.
               *
               * @example wavesurfer.stop();
               */

            }, {
              key: "stop",
              value: function stop() {
                this.pause();
                this.seekTo(0);
                this.drawer.progress(0);
              }
              /**
               * Sets the ID of the audio device to use for output and returns a Promise.
               *
               * @param {string} deviceId String value representing underlying output
               * device
               * @returns {Promise} `Promise` that resolves to `undefined` when there are
               * no errors detected.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                return this.backend.setSinkId(deviceId);
              }
              /**
               * Set the playback volume.
               *
               * @param {number} newVolume A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               * @emits WaveSurfer#volume
               */

            }, {
              key: "setVolume",
              value: function setVolume(newVolume) {
                this.backend.setVolume(newVolume);
                this.fireEvent('volume', newVolume);
              }
              /**
               * Get the playback volume.
               *
               * @return {number} A value between 0 and 1, 0 being no
               * volume and 1 being full volume.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.backend.getVolume();
              }
              /**
               * Set the playback rate.
               *
               * @param {number} rate A positive number. E.g. 0.5 means half the normal
               * speed, 2 means double speed and so on.
               * @example wavesurfer.setPlaybackRate(2);
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(rate) {
                this.backend.setPlaybackRate(rate);
              }
              /**
               * Get the playback rate.
               *
               * @return {number} The current playback rate.
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.backend.getPlaybackRate();
              }
              /**
               * Toggle the volume on and off. If not currently muted it will save the
               * current volume value and turn the volume off. If currently muted then it
               * will restore the volume to the saved value, and then rest the saved
               * value.
               *
               * @example wavesurfer.toggleMute();
               */

            }, {
              key: "toggleMute",
              value: function toggleMute() {
                this.setMute(!this.isMuted);
              }
              /**
               * Enable or disable muted audio
               *
               * @param {boolean} mute Specify `true` to mute audio.
               * @emits WaveSurfer#volume
               * @emits WaveSurfer#mute
               * @example
               * // unmute
               * wavesurfer.setMute(false);
               * console.log(wavesurfer.getMute()) // logs false
               */

            }, {
              key: "setMute",
              value: function setMute(mute) {
                // ignore all muting requests if the audio is already in that state
                if (mute === this.isMuted) {
                  this.fireEvent('mute', this.isMuted);
                  return;
                }

                if (this.backend.setMute) {
                  // Backends such as the MediaElement backend have their own handling
                  // of mute, let them handle it.
                  this.backend.setMute(mute);
                  this.isMuted = mute;
                } else {
                  if (mute) {
                    // If currently not muted then save current volume,
                    // turn off the volume and update the mute properties
                    this.savedVolume = this.backend.getVolume();
                    this.backend.setVolume(0);
                    this.isMuted = true;
                    this.fireEvent('volume', 0);
                  } else {
                    // If currently muted then restore to the saved volume
                    // and update the mute properties
                    this.backend.setVolume(this.savedVolume);
                    this.isMuted = false;
                    this.fireEvent('volume', this.savedVolume);
                  }
                }

                this.fireEvent('mute', this.isMuted);
              }
              /**
               * Get the current mute status.
               *
               * @example const isMuted = wavesurfer.getMute();
               * @return {boolean} Current mute status
               */

            }, {
              key: "getMute",
              value: function getMute() {
                return this.isMuted;
              }
              /**
               * Get the list of current set filters as an array.
               *
               * Filters must be set with setFilters method first
               *
               * @return {array} List of enabled filters
               */

            }, {
              key: "getFilters",
              value: function getFilters() {
                return this.backend.filters || [];
              }
              /**
               * Toggles `scrollParent` and redraws
               *
               * @example wavesurfer.toggleScroll();
               */

            }, {
              key: "toggleScroll",
              value: function toggleScroll() {
                this.params.scrollParent = !this.params.scrollParent;
                this.drawBuffer();
              }
              /**
               * Toggle mouse interaction
               *
               * @example wavesurfer.toggleInteraction();
               */

            }, {
              key: "toggleInteraction",
              value: function toggleInteraction() {
                this.params.interact = !this.params.interact;
              }
              /**
               * Get the fill color of the waveform after the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getWaveColor",
              value: function getWaveColor() {
                return this.params.waveColor;
              }
              /**
               * Set the fill color of the waveform after the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setWaveColor('#ddd');
               */

            }, {
              key: "setWaveColor",
              value: function setWaveColor(color) {
                this.params.waveColor = color;
                this.drawBuffer();
              }
              /**
               * Get the fill color of the waveform behind the cursor.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getProgressColor",
              value: function getProgressColor() {
                return this.params.progressColor;
              }
              /**
               * Set the fill color of the waveform behind the cursor.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setProgressColor('#400');
               */

            }, {
              key: "setProgressColor",
              value: function setProgressColor(color) {
                this.params.progressColor = color;
                this.drawBuffer();
              }
              /**
               * Get the background color of the waveform container.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getBackgroundColor",
              value: function getBackgroundColor() {
                return this.params.backgroundColor;
              }
              /**
               * Set the background color of the waveform container.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setBackgroundColor('#FF00FF');
               */

            }, {
              key: "setBackgroundColor",
              value: function setBackgroundColor(color) {
                this.params.backgroundColor = color;
                util.style(this.container, {
                  background: this.params.backgroundColor
                });
              }
              /**
               * Get the fill color of the cursor indicating the playhead
               * position.
               *
               * @return {string} A CSS color string.
               */

            }, {
              key: "getCursorColor",
              value: function getCursorColor() {
                return this.params.cursorColor;
              }
              /**
               * Set the fill color of the cursor indicating the playhead
               * position.
               *
               * @param {string} color A CSS color string.
               * @example wavesurfer.setCursorColor('#222');
               */

            }, {
              key: "setCursorColor",
              value: function setCursorColor(color) {
                this.params.cursorColor = color;
                this.drawer.updateCursor();
              }
              /**
               * Get the height of the waveform.
               *
               * @return {number} Height measured in pixels.
               */

            }, {
              key: "getHeight",
              value: function getHeight() {
                return this.params.height;
              }
              /**
               * Set the height of the waveform.
               *
               * @param {number} height Height measured in pixels.
               * @example wavesurfer.setHeight(200);
               */

            }, {
              key: "setHeight",
              value: function setHeight(height) {
                this.params.height = height;
                this.drawer.setHeight(height * this.params.pixelRatio);
                this.drawBuffer();
              }
              /**
               * Hide channels from being drawn on the waveform if splitting channels.
               *
               * For example, if we want to draw only the peaks for the right stereo channel:
               *
               * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
               * wavesurfer.load('stereo_audio.mp3');
               *
               * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
               *
               * @param {array} channelIndices Channels to be filtered out from drawing.
               * @version 4.0.0
               */

            }, {
              key: "setFilteredChannels",
              value: function setFilteredChannels(channelIndices) {
                this.params.splitChannelsOptions.filterChannels = channelIndices;
                this.drawBuffer();
              }
              /**
               * Get the correct peaks for current wave view-port and render wave
               *
               * @private
               * @emits WaveSurfer#redraw
               */

            }, {
              key: "drawBuffer",
              value: function drawBuffer() {
                var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
                var parentWidth = this.drawer.getWidth();
                var width = nominalWidth; // always start at 0 after zooming for scrolling : issue redraw left part

                var start = 0;
                var end = Math.max(start + parentWidth, width); // Fill container

                if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
                  width = parentWidth;
                  start = 0;
                  end = width;
                }

                var peaks;

                if (this.params.partialRender) {
                  var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
                  var i;

                  for (i = 0; i < newRanges.length; i++) {
                    peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
                    this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
                  }
                } else {
                  peaks = this.backend.getPeaks(width, start, end);
                  this.drawer.drawPeaks(peaks, width, start, end);
                }

                this.fireEvent('redraw', peaks, width);
              }
              /**
               * Horizontally zooms the waveform in and out. It also changes the parameter
               * `minPxPerSec` and enables the `scrollParent` option. Calling the function
               * with a falsey parameter will reset the zoom state.
               *
               * @param {?number} pxPerSec Number of horizontal pixels per second of
               * audio, if none is set the waveform returns to unzoomed state
               * @emits WaveSurfer#zoom
               * @example wavesurfer.zoom(20);
               */

            }, {
              key: "zoom",
              value: function zoom(pxPerSec) {
                if (!pxPerSec) {
                  this.params.minPxPerSec = this.defaultParams.minPxPerSec;
                  this.params.scrollParent = false;
                } else {
                  this.params.minPxPerSec = pxPerSec;
                  this.params.scrollParent = true;
                }

                this.drawBuffer();
                this.drawer.progress(this.backend.getPlayedPercents());
                this.drawer.recenter(this.getCurrentTime() / this.getDuration());
                this.fireEvent('zoom', pxPerSec);
              }
              /**
               * Decode buffer and load
               *
               * @private
               * @param {ArrayBuffer} arraybuffer Buffer to process
               */

            }, {
              key: "loadArrayBuffer",
              value: function loadArrayBuffer(arraybuffer) {
                var _this9 = this;

                this.decodeArrayBuffer(arraybuffer, function (data) {
                  if (!_this9.isDestroyed) {
                    _this9.loadDecodedBuffer(data);
                  }
                });
              }
              /**
               * Directly load an externally decoded AudioBuffer
               *
               * @private
               * @param {AudioBuffer} buffer Buffer to process
               * @emits WaveSurfer#ready
               */

            }, {
              key: "loadDecodedBuffer",
              value: function loadDecodedBuffer(buffer) {
                this.backend.load(buffer);
                this.drawBuffer();
                this.isReady = true;
                this.fireEvent('ready');
              }
              /**
               * Loads audio data from a Blob or File object
               *
               * @param {Blob|File} blob Audio data
               * @example
               */

            }, {
              key: "loadBlob",
              value: function loadBlob(blob) {
                var _this10 = this;

                // Create file reader
                var reader = new FileReader();
                reader.addEventListener('progress', function (e) {
                  return _this10.onProgress(e);
                });
                reader.addEventListener('load', function (e) {
                  return _this10.loadArrayBuffer(e.target.result);
                });
                reader.addEventListener('error', function () {
                  return _this10.fireEvent('error', 'Error reading file');
                });
                reader.readAsArrayBuffer(blob);
                this.empty();
              }
              /**
               * Loads audio and re-renders the waveform.
               *
               * @param {string|HTMLMediaElement} url The url of the audio file or the
               * audio element with the audio
               * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
               * the audio to render the waveform if this is specified
               * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
               * `'none'|'metadata'|'auto'` Preload attribute for the media element
               * @param {?number} duration The duration of the audio. This is used to
               * render the peaks data in the correct size for the audio duration (as
               * befits the current `minPxPerSec` and zoom value) without having to decode
               * the audio.
               * @returns {void}
               * @throws Will throw an error if the `url` argument is empty.
               * @example
               * // uses fetch or media element to load file (depending on backend)
               * wavesurfer.load('http://example.com/demo.wav');
               *
               * // setting preload attribute with media element backend and supplying
               * // peaks
               * wavesurfer.load(
               *   'http://example.com/demo.wav',
               *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
               *   true
               * );
               */

            }, {
              key: "load",
              value: function load(url, peaks, preload, duration) {
                if (!url) {
                  throw new Error('url parameter cannot be empty');
                }

                this.empty();

                if (preload) {
                  // check whether the preload attribute will be usable and if not log
                  // a warning listing the reasons why not and nullify the variable
                  var preloadIgnoreReasons = {
                    "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
                    'Peaks are not provided': !peaks,
                    "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
                    'Url is not of type string': typeof url !== 'string'
                  };
                  var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
                    return preloadIgnoreReasons[reason];
                  });

                  if (activeReasons.length) {
                    // eslint-disable-next-line no-console
                    console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- ')); // stop invalid values from being used

                    preload = null;
                  }
                } // loadBuffer(url, peaks, duration) requires that url is a string
                // but users can pass in a HTMLMediaElement to WaveSurfer


                if (this.params.backend === 'WebAudio' && url instanceof HTMLMediaElement) {
                  url = url.src;
                }

                switch (this.params.backend) {
                  case 'WebAudio':
                    return this.loadBuffer(url, peaks, duration);

                  case 'MediaElement':
                  case 'MediaElementWebAudio':
                    return this.loadMediaElement(url, peaks, preload, duration);
                }
              }
              /**
               * Loads audio using Web Audio buffer backend.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string} url URL of audio file
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Optional duration of audio file
               * @returns {void}
               */

            }, {
              key: "loadBuffer",
              value: function loadBuffer(url, peaks, duration) {
                var _this11 = this;

                var load = function load(action) {
                  if (action) {
                    _this11.tmpEvents.push(_this11.once('ready', action));
                  }

                  return _this11.getArrayBuffer(url, function (data) {
                    return _this11.loadArrayBuffer(data);
                  });
                };

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                  this.tmpEvents.push(this.once('interaction', load));
                } else {
                  return load();
                }
              }
              /**
               * Either create a media element, or load an existing media element.
               *
               * @private
               * @emits WaveSurfer#waveform-ready
               * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
               * existing HTML5 Audio/Video Element
               * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
               * dependency
               * @param {?boolean} preload Set to true if the preload attribute of the
               * audio element should be enabled
               * @param {?number} duration Optional duration of audio file
               */

            }, {
              key: "loadMediaElement",
              value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
                var _this12 = this;

                var url = urlOrElt;

                if (typeof urlOrElt === 'string') {
                  this.backend.load(url, this.mediaContainer, peaks, preload);
                } else {
                  var elt = urlOrElt;
                  this.backend.loadElt(elt, peaks); // If peaks are not provided,
                  // url = element.src so we can get peaks with web audio

                  url = elt.src;
                }

                this.tmpEvents.push(this.backend.once('canplay', function () {
                  // ignore when backend was already destroyed
                  if (!_this12.backend.destroyed) {
                    _this12.drawBuffer();

                    _this12.isReady = true;

                    _this12.fireEvent('ready');
                  }
                }), this.backend.once('error', function (err) {
                  return _this12.fireEvent('error', err);
                })); // If peaks are provided, render them and fire the `waveform-ready` event.

                if (peaks) {
                  this.backend.setPeaks(peaks, duration);
                  this.drawBuffer();
                  this.fireEvent('waveform-ready');
                } // If no pre-decoded peaks are provided, or are provided with
                // forceDecode flag, attempt to download the audio file and decode it
                // with Web Audio.


                if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
                  this.getArrayBuffer(url, function (arraybuffer) {
                    _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
                      _this12.backend.buffer = buffer;

                      _this12.backend.setPeaks(null);

                      _this12.drawBuffer();

                      _this12.fireEvent('waveform-ready');
                    });
                  });
                }
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {Object} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback) {
                var _this13 = this;

                this.arraybuffer = arraybuffer;
                this.backend.decodeArrayBuffer(arraybuffer, function (data) {
                  // Only use the decoded data if we haven't been destroyed or
                  // another decode started in the meantime
                  if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
                    callback(data);
                    _this13.arraybuffer = null;
                  }
                }, function () {
                  return _this13.fireEvent('error', 'Error decoding audiobuffer');
                });
              }
              /**
               * Load an array buffer using fetch and pass the result to a callback
               *
               * @param {string} url The URL of the file object
               * @param {function} callback The function to call on complete
               * @returns {util.fetchFile} fetch call
               * @private
               */

            }, {
              key: "getArrayBuffer",
              value: function getArrayBuffer(url, callback) {
                var _this14 = this;

                var options = _extends({
                  url: url,
                  responseType: 'arraybuffer'
                }, this.params.xhr);
                var request = util.fetchFile(options);
                this.currentRequest = request;
                this.tmpEvents.push(request.on('progress', function (e) {
                  _this14.onProgress(e);
                }), request.on('success', function (data) {
                  callback(data);
                  _this14.currentRequest = null;
                }), request.on('error', function (e) {
                  _this14.fireEvent('error', e);

                  _this14.currentRequest = null;
                }));
                return request;
              }
              /**
               * Called while the audio file is loading
               *
               * @private
               * @param {Event} e Progress event
               * @emits WaveSurfer#loading
               */

            }, {
              key: "onProgress",
              value: function onProgress(e) {
                var percentComplete;

                if (e.lengthComputable) {
                  percentComplete = e.loaded / e.total;
                } else {
                  // Approximate progress with an asymptotic
                  // function, and assume downloads in the 1-3 MB range.
                  percentComplete = e.loaded / (e.loaded + 1000000);
                }

                this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
              }
              /**
               * Exports PCM data into a JSON array and optionally opens in a new window
               * as valid JSON Blob instance.
               *
               * @param {number} length=1024 The scale in which to export the peaks
               * @param {number} accuracy=10000
               * @param {?boolean} noWindow Set to true to disable opening a new
               * window with the JSON
               * @param {number} start Start index
               * @param {number} end End index
               * @return {Promise} Promise that resolves with array of peaks
               */

            }, {
              key: "exportPCM",
              value: function exportPCM(length, accuracy, noWindow, start, end) {
                length = length || 1024;
                start = start || 0;
                accuracy = accuracy || 10000;
                noWindow = noWindow || false;
                var peaks = this.backend.getPeaks(length, start, end);
                var arr = [].map.call(peaks, function (val) {
                  return Math.round(val * accuracy) / accuracy;
                });
                return new Promise(function (resolve, reject) {
                  if (!noWindow) {
                    var blobJSON = new Blob([JSON.stringify(arr)], {
                      type: 'application/json;charset=utf-8'
                    });
                    var objURL = URL.createObjectURL(blobJSON);
                    window.open(objURL);
                    URL.revokeObjectURL(objURL);
                  }

                  resolve(arr);
                });
              }
              /**
               * Save waveform image as data URI.
               *
               * The default format is `'image/png'`. Other supported types are
               * `'image/jpeg'` and `'image/webp'`.
               *
               * @param {string} format='image/png' A string indicating the image format.
               * The default format type is `'image/png'`.
               * @param {number} quality=1 A number between 0 and 1 indicating the image
               * quality to use for image formats that use lossy compression such as
               * `'image/jpeg'`` and `'image/webp'`.
               * @param {string} type Image data type to return. Either 'dataURL' (default)
               * or 'blob'.
               * @return {string|string[]|Promise} When using `'dataURL'` type this returns
               * a single data URL or an array of data URLs, one for each canvas. When using
               * `'blob'` type this returns a `Promise` resolving with an array of `Blob`
               * instances, one for each canvas.
               */

            }, {
              key: "exportImage",
              value: function exportImage(format, quality, type) {
                if (!format) {
                  format = 'image/png';
                }

                if (!quality) {
                  quality = 1;
                }

                if (!type) {
                  type = 'dataURL';
                }

                return this.drawer.getImage(format, quality, type);
              }
              /**
               * Cancel any fetch request currently in progress
               */

            }, {
              key: "cancelAjax",
              value: function cancelAjax() {
                if (this.currentRequest && this.currentRequest.controller) {
                  // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
                  // See: Wavesurfer issue #2042
                  // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
                  if (this.currentRequest._reader) {
                    // Ignoring exceptions thrown by call to cancel()
                    this.currentRequest._reader.cancel().catch(function (err) {});
                  }

                  this.currentRequest.controller.abort();
                  this.currentRequest = null;
                }
              }
              /**
               * @private
               */

            }, {
              key: "clearTmpEvents",
              value: function clearTmpEvents() {
                this.tmpEvents.forEach(function (e) {
                  return e.un();
                });
              }
              /**
               * Display empty waveform.
               */

            }, {
              key: "empty",
              value: function empty() {
                if (!this.backend.isPaused()) {
                  this.stop();
                  this.backend.disconnectSource();
                }

                this.isReady = false;
                this.cancelAjax();
                this.clearTmpEvents(); // empty drawer

                this.drawer.progress(0);
                this.drawer.setWidth(0);
                this.drawer.drawPeaks({
                  length: this.drawer.getWidth()
                }, 0);
              }
              /**
               * Remove events, elements and disconnect WebAudio nodes.
               *
               * @emits WaveSurfer#destroy
               */

            }, {
              key: "destroy",
              value: function destroy() {
                this.destroyAllPlugins();
                this.fireEvent('destroy');
                this.cancelAjax();
                this.clearTmpEvents();
                this.unAll();

                if (this.params.responsive !== false) {
                  window.removeEventListener('resize', this._onResize, true);
                  window.removeEventListener('orientationchange', this._onResize, true);
                }

                if (this.backend) {
                  this.backend.destroy(); // clears memory usage

                  this.backend = null;
                }

                if (this.drawer) {
                  this.drawer.destroy();
                }

                this.isDestroyed = true;
                this.isReady = false;
                this.arraybuffer = null;
              }
            }], [{
              key: "create",
              value:
              /** @private */

              /** @private */

              /**
               * Instantiate this class, call its `init` function and returns it
               *
               * @param {WavesurferParams} params The wavesurfer parameters
               * @return {Object} WaveSurfer instance
               * @example const wavesurfer = WaveSurfer.create(params);
               */
              function create(params) {
                var wavesurfer = new WaveSurfer(params);
                return wavesurfer.init();
              }
              /**
               * The library version number is available as a static property of the
               * WaveSurfer class
               *
               * @type {String}
               * @example
               * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
               */

            }]);

            return WaveSurfer;
          }(util.Observer);

          exports.default = WaveSurfer;
          WaveSurfer.VERSION = "5.1.0";
          WaveSurfer.util = util;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/webaudio.js":
        /*!*************************!*\
          !*** ./src/webaudio.js ***!
          \*************************/
        /***/function srcWebaudioJs(module, exports, __webpack_require__) {

          "use strict";

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
              _typeof = function _typeof(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
              };
            }return _typeof(obj);
          }

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var util = _interopRequireWildcard(__webpack_require__( /*! ./util */"./src/util/index.js"));

          function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
              return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
          }

          function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
              return obj;
            }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
              return { default: obj };
            }var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {
              return cache.get(obj);
            }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
                  Object.defineProperty(newObj, key, desc);
                } else {
                  newObj[key] = obj[key];
                }
              }
            }newObj.default = obj;if (cache) {
              cache.set(obj, newObj);
            }return newObj;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;return o;
            };return _setPrototypeOf(o, p);
          }

          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }return _possibleConstructorReturn(this, result);
            };
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            }return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return self;
          }

          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;
            } catch (e) {
              return false;
            }
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };return _getPrototypeOf(o);
          }

          // using constants to prevent someone writing the string wrong
          var PLAYING = 'playing';
          var PAUSED = 'paused';
          var FINISHED = 'finished';
          /**
           * WebAudio backend
           *
           * @extends {Observer}
           */

          var WebAudio = /*#__PURE__*/function (_util$Observer) {
            _inherits(WebAudio, _util$Observer);

            var _super = _createSuper(WebAudio);

            /**
             * Construct the backend
             *
             * @param {WavesurferParams} params Wavesurfer parameters
             */
            function WebAudio(params) {
              var _this$stateBehaviors, _this$states;

              var _this;

              _classCallCheck(this, WebAudio);

              _this = _super.call(this);
              /** @private */

              _this.audioContext = null;
              _this.offlineAudioContext = null;
              _this.stateBehaviors = (_this$stateBehaviors = {}, _defineProperty(_this$stateBehaviors, PLAYING, {
                init: function init() {
                  this.addOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition + this.getPlayedTime();
                }
              }), _defineProperty(_this$stateBehaviors, PAUSED, {
                init: function init() {
                  this.removeOnAudioProcess();
                },
                getPlayedPercents: function getPlayedPercents() {
                  var duration = this.getDuration();
                  return this.getCurrentTime() / duration || 0;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.startPosition;
                }
              }), _defineProperty(_this$stateBehaviors, FINISHED, {
                init: function init() {
                  this.removeOnAudioProcess();
                  this.fireEvent('finish');
                },
                getPlayedPercents: function getPlayedPercents() {
                  return 1;
                },
                getCurrentTime: function getCurrentTime() {
                  return this.getDuration();
                }
              }), _this$stateBehaviors);
              _this.params = params;
              /** ac: Audio Context instance */

              _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
              /**@private */

              _this.lastPlay = _this.ac.currentTime;
              /** @private */

              _this.startPosition = 0;
              /** @private */

              _this.scheduledPause = null;
              /** @private */

              _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
              /** @private */

              _this.buffer = null;
              /** @private */

              _this.filters = [];
              /** gainNode: allows to control audio volume */

              _this.gainNode = null;
              /** @private */

              _this.mergedPeaks = null;
              /** @private */

              _this.offlineAc = null;
              /** @private */

              _this.peaks = null;
              /** @private */

              _this.playbackRate = 1;
              /** analyser: provides audio analysis information */

              _this.analyser = null;
              /** scriptNode: allows processing audio */

              _this.scriptNode = null;
              /** @private */

              _this.source = null;
              /** @private */

              _this.splitPeaks = [];
              /** @private */

              _this.state = null;
              /** @private */

              _this.explicitDuration = params.duration;
              /**
               * Boolean indicating if the backend was destroyed.
               */

              _this.destroyed = false;
              return _this;
            }
            /**
             * Initialise the backend, called in `wavesurfer.createBackend()`
             */

            _createClass(WebAudio, [{
              key: "supportsWebAudio",
              value:
              /** scriptBufferSize: size of the processing buffer */

              /** audioContext: allows to process audio with WebAudio API */

              /** @private */

              /** @private */

              /**
               * Does the browser support this backend
               *
               * @return {boolean} Whether or not this browser supports this backend
               */
              function supportsWebAudio() {
                return !!(window.AudioContext || window.webkitAudioContext);
              }
              /**
               * Get the audio context used by this backend or create one
               *
               * @return {AudioContext} Existing audio context, or creates a new one
               */

            }, {
              key: "getAudioContext",
              value: function getAudioContext() {
                if (!window.WaveSurferAudioContext) {
                  window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                return window.WaveSurferAudioContext;
              }
              /**
               * Get the offline audio context used by this backend or create one
               *
               * @param {number} sampleRate The sample rate to use
               * @return {OfflineAudioContext} Existing offline audio context, or creates
               * a new one
               */

            }, {
              key: "getOfflineAudioContext",
              value: function getOfflineAudioContext(sampleRate) {
                if (!window.WaveSurferOfflineAudioContext) {
                  window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
                }

                return window.WaveSurferOfflineAudioContext;
              }
            }, {
              key: "init",
              value: function init() {
                this.createVolumeNode();
                this.createScriptNode();
                this.createAnalyserNode();
                this.setState(PAUSED);
                this.setPlaybackRate(this.params.audioRate);
                this.setLength(0);
              }
              /** @private */

            }, {
              key: "disconnectFilters",
              value: function disconnectFilters() {
                if (this.filters) {
                  this.filters.forEach(function (filter) {
                    filter && filter.disconnect();
                  });
                  this.filters = null; // Reconnect direct path

                  this.analyser.connect(this.gainNode);
                }
              }
              /**
               * @private
               *
               * @param {string} state The new state
               */

            }, {
              key: "setState",
              value: function setState(state) {
                if (this.state !== this.states[state]) {
                  this.state = this.states[state];
                  this.state.init.call(this);
                }
              }
              /**
               * Unpacked `setFilters()`
               *
               * @param {...AudioNode} filters One or more filters to set
               */

            }, {
              key: "setFilter",
              value: function setFilter() {
                for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
                  filters[_key] = arguments[_key];
                }

                this.setFilters(filters);
              }
              /**
               * Insert custom Web Audio nodes into the graph
               *
               * @param {AudioNode[]} filters Packed filters array
               * @example
               * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
               * wavesurfer.backend.setFilter(lowpass);
               */

            }, {
              key: "setFilters",
              value: function setFilters(filters) {
                // Remove existing filters
                this.disconnectFilters(); // Insert filters if filter array not empty

                if (filters && filters.length) {
                  this.filters = filters; // Disconnect direct path before inserting filters

                  this.analyser.disconnect(); // Connect each filter in turn

                  filters.reduce(function (prev, curr) {
                    prev.connect(curr);
                    return curr;
                  }, this.analyser).connect(this.gainNode);
                }
              }
              /** Create ScriptProcessorNode to process audio */

            }, {
              key: "createScriptNode",
              value: function createScriptNode() {
                if (this.params.audioScriptProcessor) {
                  this.scriptNode = this.params.audioScriptProcessor;
                } else {
                  if (this.ac.createScriptProcessor) {
                    this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
                  } else {
                    this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
                  }
                }

                this.scriptNode.connect(this.ac.destination);
              }
              /** @private */

            }, {
              key: "addOnAudioProcess",
              value: function addOnAudioProcess() {
                var _this2 = this;

                this.scriptNode.onaudioprocess = function () {
                  var time = _this2.getCurrentTime();

                  if (time >= _this2.getDuration()) {
                    _this2.setState(FINISHED);

                    _this2.fireEvent('pause');
                  } else if (time >= _this2.scheduledPause) {
                    _this2.pause();
                  } else if (_this2.state === _this2.states[PLAYING]) {
                    _this2.fireEvent('audioprocess', time);
                  }
                };
              }
              /** @private */

            }, {
              key: "removeOnAudioProcess",
              value: function removeOnAudioProcess() {
                this.scriptNode.onaudioprocess = null;
              }
              /** Create analyser node to perform audio analysis */

            }, {
              key: "createAnalyserNode",
              value: function createAnalyserNode() {
                this.analyser = this.ac.createAnalyser();
                this.analyser.connect(this.gainNode);
              }
              /**
               * Create the gain node needed to control the playback volume.
               *
               */

            }, {
              key: "createVolumeNode",
              value: function createVolumeNode() {
                // Create gain node using the AudioContext
                if (this.ac.createGain) {
                  this.gainNode = this.ac.createGain();
                } else {
                  this.gainNode = this.ac.createGainNode();
                } // Add the gain node to the graph


                this.gainNode.connect(this.ac.destination);
              }
              /**
               * Set the sink id for the media player
               *
               * @param {string} deviceId String value representing audio device id.
               * @returns {Promise} A Promise that resolves to `undefined` when there
               * are no errors.
               */

            }, {
              key: "setSinkId",
              value: function setSinkId(deviceId) {
                if (deviceId) {
                  /**
                   * The webaudio API doesn't currently support setting the device
                   * output. Here we create an HTMLAudioElement, connect the
                   * webaudio stream to that element and setSinkId there.
                   */
                  var audio = new window.Audio();

                  if (!audio.setSinkId) {
                    return Promise.reject(new Error('setSinkId is not supported in your browser'));
                  }

                  audio.autoplay = true;
                  var dest = this.ac.createMediaStreamDestination();
                  this.gainNode.disconnect();
                  this.gainNode.connect(dest);
                  audio.srcObject = dest.stream;
                  return audio.setSinkId(deviceId);
                } else {
                  return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
                }
              }
              /**
               * Set the audio volume
               *
               * @param {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "setVolume",
              value: function setVolume(value) {
                this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
              }
              /**
               * Get the current volume
               *
               * @return {number} value A floating point value between 0 and 1.
               */

            }, {
              key: "getVolume",
              value: function getVolume() {
                return this.gainNode.gain.value;
              }
              /**
               * Decode an array buffer and pass data to a callback
               *
               * @private
               * @param {ArrayBuffer} arraybuffer The array buffer to decode
               * @param {function} callback The function to call on complete.
               * @param {function} errback The function to call on error.
               */

            }, {
              key: "decodeArrayBuffer",
              value: function decodeArrayBuffer(arraybuffer, callback, errback) {
                if (!this.offlineAc) {
                  this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
                }

                if ('webkitAudioContext' in window) {
                  // Safari: no support for Promise-based decodeAudioData enabled
                  // Enable it in Safari using the Experimental Features > Modern WebAudio API option
                  this.offlineAc.decodeAudioData(arraybuffer, function (data) {
                    return callback(data);
                  }, errback);
                } else {
                  this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
                    return callback(data);
                  }).catch(function (err) {
                    return errback(err);
                  });
                }
              }
              /**
               * Set pre-decoded peaks
               *
               * @param {number[]|Number.<Array[]>} peaks Peaks data
               * @param {?number} duration Explicit duration
               */

            }, {
              key: "setPeaks",
              value: function setPeaks(peaks, duration) {
                if (duration != null) {
                  this.explicitDuration = duration;
                }

                this.peaks = peaks;
              }
              /**
               * Set the rendered length (different from the length of the audio)
               *
               * @param {number} length The rendered length
               */

            }, {
              key: "setLength",
              value: function setLength(length) {
                // No resize, we can preserve the cached peaks.
                if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
                  return;
                }

                this.splitPeaks = [];
                this.mergedPeaks = []; // Set the last element of the sparse array so the peak arrays are
                // appropriately sized for other calculations.

                var channels = this.buffer ? this.buffer.numberOfChannels : 1;
                var c;

                for (c = 0; c < channels; c++) {
                  this.splitPeaks[c] = [];
                  this.splitPeaks[c][2 * (length - 1)] = 0;
                  this.splitPeaks[c][2 * (length - 1) + 1] = 0;
                }

                this.mergedPeaks[2 * (length - 1)] = 0;
                this.mergedPeaks[2 * (length - 1) + 1] = 0;
              }
              /**
               * Compute the max and min value of the waveform when broken into <length> subranges.
               *
               * @param {number} length How many subranges to break the waveform into.
               * @param {number} first First sample in the required range.
               * @param {number} last Last sample in the required range.
               * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
               * peaks consisting of (max, min) values for each subrange.
               */

            }, {
              key: "getPeaks",
              value: function getPeaks(length, first, last) {
                if (this.peaks) {
                  return this.peaks;
                }

                if (!this.buffer) {
                  return [];
                }

                first = first || 0;
                last = last || length - 1;
                this.setLength(length);

                if (!this.buffer) {
                  return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
                }
                /**
                 * The following snippet fixes a buffering data issue on the Safari
                 * browser which returned undefined It creates the missing buffer based
                 * on 1 channel, 4096 samples and the sampleRate from the current
                 * webaudio context 4096 samples seemed to be the best fit for rendering
                 * will review this code once a stable version of Safari TP is out
                 */

                if (!this.buffer.length) {
                  var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
                  this.buffer = newBuffer.buffer;
                }

                var sampleSize = this.buffer.length / length;
                var sampleStep = ~~(sampleSize / 10) || 1;
                var channels = this.buffer.numberOfChannels;
                var c;

                for (c = 0; c < channels; c++) {
                  var peaks = this.splitPeaks[c];
                  var chan = this.buffer.getChannelData(c);
                  var i = void 0;

                  for (i = first; i <= last; i++) {
                    var start = ~~(i * sampleSize);
                    var end = ~~(start + sampleSize);
                    /**
                     * Initialize the max and min to the first sample of this
                     * subrange, so that even if the samples are entirely
                     * on one side of zero, we still return the true max and
                     * min values in the subrange.
                     */

                    var min = chan[start];
                    var max = min;
                    var j = void 0;

                    for (j = start; j < end; j += sampleStep) {
                      var value = chan[j];

                      if (value > max) {
                        max = value;
                      }

                      if (value < min) {
                        min = value;
                      }
                    }

                    peaks[2 * i] = max;
                    peaks[2 * i + 1] = min;

                    if (c == 0 || max > this.mergedPeaks[2 * i]) {
                      this.mergedPeaks[2 * i] = max;
                    }

                    if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
                      this.mergedPeaks[2 * i + 1] = min;
                    }
                  }
                }

                return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
              }
              /**
               * Get the position from 0 to 1
               *
               * @return {number} Position
               */

            }, {
              key: "getPlayedPercents",
              value: function getPlayedPercents() {
                return this.state.getPlayedPercents.call(this);
              }
              /** @private */

            }, {
              key: "disconnectSource",
              value: function disconnectSource() {
                if (this.source) {
                  this.source.disconnect();
                }
              }
              /**
               * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
               */

            }, {
              key: "destroyWebAudio",
              value: function destroyWebAudio() {
                this.disconnectFilters();
                this.disconnectSource();
                this.gainNode.disconnect();
                this.scriptNode.disconnect();
                this.analyser.disconnect(); // close the audioContext if closeAudioContext option is set to true

                if (this.params.closeAudioContext) {
                  // check if browser supports AudioContext.close()
                  if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
                    this.ac.close();
                  } // clear the reference to the audiocontext


                  this.ac = null; // clear the actual audiocontext, either passed as param or the
                  // global singleton

                  if (!this.params.audioContext) {
                    window.WaveSurferAudioContext = null;
                  } else {
                    this.params.audioContext = null;
                  } // clear the offlineAudioContext


                  window.WaveSurferOfflineAudioContext = null;
                }
              }
              /**
               * This is called when wavesurfer is destroyed
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (!this.isPaused()) {
                  this.pause();
                }

                this.unAll();
                this.buffer = null;
                this.destroyed = true;
                this.destroyWebAudio();
              }
              /**
               * Loaded a decoded audio buffer
               *
               * @param {Object} buffer Decoded audio buffer to load
               */

            }, {
              key: "load",
              value: function load(buffer) {
                this.startPosition = 0;
                this.lastPlay = this.ac.currentTime;
                this.buffer = buffer;
                this.createSource();
              }
              /** @private */

            }, {
              key: "createSource",
              value: function createSource() {
                this.disconnectSource();
                this.source = this.ac.createBufferSource(); // adjust for old browsers

                this.source.start = this.source.start || this.source.noteGrainOn;
                this.source.stop = this.source.stop || this.source.noteOff;
                this.setPlaybackRate(this.playbackRate);
                this.source.buffer = this.buffer;
                this.source.connect(this.analyser);
              }
              /**
               * @private
               *
               * some browsers require an explicit call to #resume before they will play back audio
               */

            }, {
              key: "resumeAudioContext",
              value: function resumeAudioContext() {
                if (this.ac.state == 'suspended') {
                  this.ac.resume && this.ac.resume();
                }
              }
              /**
               * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
               *
               * @return {boolean} Whether or not this backend is currently paused
               */

            }, {
              key: "isPaused",
              value: function isPaused() {
                return this.state !== this.states[PLAYING];
              }
              /**
               * Used by `wavesurfer.getDuration()`
               *
               * @return {number} Duration of loaded buffer
               */

            }, {
              key: "getDuration",
              value: function getDuration() {
                if (this.explicitDuration) {
                  return this.explicitDuration;
                }

                if (!this.buffer) {
                  return 0;
                }

                return this.buffer.duration;
              }
              /**
               * Used by `wavesurfer.seekTo()`
               *
               * @param {number} start Position to start at in seconds
               * @param {number} end Position to end at in seconds
               * @return {{start: number, end: number}} Object containing start and end
               * positions
               */

            }, {
              key: "seekTo",
              value: function seekTo(start, end) {
                if (!this.buffer) {
                  return;
                }

                this.scheduledPause = null;

                if (start == null) {
                  start = this.getCurrentTime();

                  if (start >= this.getDuration()) {
                    start = 0;
                  }
                }

                if (end == null) {
                  end = this.getDuration();
                }

                this.startPosition = start;
                this.lastPlay = this.ac.currentTime;

                if (this.state === this.states[FINISHED]) {
                  this.setState(PAUSED);
                }

                return {
                  start: start,
                  end: end
                };
              }
              /**
               * Get the playback position in seconds
               *
               * @return {number} The playback position in seconds
               */

            }, {
              key: "getPlayedTime",
              value: function getPlayedTime() {
                return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
              }
              /**
               * Plays the loaded audio region.
               *
               * @param {number} start Start offset in seconds, relative to the beginning
               * of a clip.
               * @param {number} end When to stop relative to the beginning of a clip.
               */

            }, {
              key: "play",
              value: function play(start, end) {
                if (!this.buffer) {
                  return;
                } // need to re-create source on each playback


                this.createSource();
                var adjustedTime = this.seekTo(start, end);
                start = adjustedTime.start;
                end = adjustedTime.end;
                this.scheduledPause = end;
                this.source.start(0, start);
                this.resumeAudioContext();
                this.setState(PLAYING);
                this.fireEvent('play');
              }
              /**
               * Pauses the loaded audio.
               */

            }, {
              key: "pause",
              value: function pause() {
                this.scheduledPause = null;
                this.startPosition += this.getPlayedTime();
                this.source && this.source.stop(0);
                this.setState(PAUSED);
                this.fireEvent('pause');
              }
              /**
               * Returns the current time in seconds relative to the audio-clip's
               * duration.
               *
               * @return {number} The current time in seconds
               */

            }, {
              key: "getCurrentTime",
              value: function getCurrentTime() {
                return this.state.getCurrentTime.call(this);
              }
              /**
               * Returns the current playback rate. (0=no playback, 1=normal playback)
               *
               * @return {number} The current playback rate
               */

            }, {
              key: "getPlaybackRate",
              value: function getPlaybackRate() {
                return this.playbackRate;
              }
              /**
               * Set the audio source playback rate.
               *
               * @param {number} value The playback rate to use
               */

            }, {
              key: "setPlaybackRate",
              value: function setPlaybackRate(value) {
                this.playbackRate = value || 1;
                this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
              }
              /**
               * Set a point in seconds for playback to stop at.
               *
               * @param {number} end Position to end at
               * @version 3.3.0
               */

            }, {
              key: "setPlayEnd",
              value: function setPlayEnd(end) {
                this.scheduledPause = end;
              }
            }]);

            return WebAudio;
          }(util.Observer);

          exports.default = WebAudio;
          WebAudio.scriptBufferSize = 256;
          module.exports = exports.default;

          /***/
        },

        /***/"./node_modules/debounce/index.js":
        /*!****************************************!*\
          !*** ./node_modules/debounce/index.js ***!
          \****************************************/
        /***/function node_modulesDebounceIndexJs(module) {

          /**
           * Returns a function, that, as long as it continues to be invoked, will not
           * be triggered. The function will be called after it stops being called for
           * N milliseconds. If `immediate` is passed, trigger the function on the
           * leading edge, instead of the trailing. The function also has a property 'clear' 
           * that is a function which will clear the timer to prevent previously scheduled executions. 
           *
           * @source underscore.js
           * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
           * @param {Function} function to wrap
           * @param {Number} timeout in ms (`100`)
           * @param {Boolean} whether to execute at the beginning (`false`)
           * @api public
           */
          function debounce(func, wait, immediate) {
            var timeout, args, context, timestamp, result;
            if (null == wait) wait = 100;

            function later() {
              var last = Date.now() - timestamp;

              if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
              } else {
                timeout = null;
                if (!immediate) {
                  result = func.apply(context, args);
                  context = args = null;
                }
              }
            };

            var debounced = function debounced() {
              context = this;
              args = arguments;
              timestamp = Date.now();
              var callNow = immediate && !timeout;
              if (!timeout) timeout = setTimeout(later, wait);
              if (callNow) {
                result = func.apply(context, args);
                context = args = null;
              }

              return result;
            };

            debounced.clear = function () {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
            };

            debounced.flush = function () {
              if (timeout) {
                result = func.apply(context, args);
                context = args = null;

                clearTimeout(timeout);
                timeout = null;
              }
            };

            return debounced;
          };

          // Adds compatibility for ES modules
          debounce.debounce = debounce;

          module.exports = debounce;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/wavesurfer.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js cursor plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["cursor"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/cursor/index.js":
        /*!************************************!*\
          !*** ./src/plugin/cursor/index.js ***!
          \************************************/
        /***/function srcPluginCursorIndexJs(module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * @typedef {Object} CursorPluginParams
           * @property {?boolean} deferInit Set to true to stop auto init in `addPlugin()`
           * @property {boolean} hideOnBlur=true Hide the cursor when the mouse leaves the
           * waveform
           * @property {string} width='1px' The width of the cursor
           * @property {string} color='black' The color of the cursor
           * @property {string} opacity='0.25' The opacity of the cursor
           * @property {string} style='solid' The border style of the cursor
           * @property {number} zIndex=3 The z-index of the cursor element
           * @property {object} customStyle An object with custom styles which are applied
           * to the cursor element
           * @property {boolean} showTime=false Show the time on the cursor.
           * @property {object} customShowTimeStyle An object with custom styles which are
           * applied to the cursor time element.
           * @property {string} followCursorY=false Use `true` to make the time on
           * the cursor follow the x and the y-position of the mouse. Use `false` to make the
           * it only follow the x-position of the mouse.
           * @property {function} formatTimeCallback Formats the timestamp on the cursor.
           */

          /**
           * Displays a thin line at the position of the cursor on the waveform.
           *
           * @implements {PluginClass}
           * @extends {Observer}
           * @example
           * // es6
           * import CursorPlugin from 'wavesurfer.cursor.js';
           *
           * // commonjs
           * var CursorPlugin = require('wavesurfer.cursor.js');
           *
           * // if you are using <script> tags
           * var CursorPlugin = window.WaveSurfer.cursor;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     CursorPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var CursorPlugin = /*#__PURE__*/function () {
            /**
             * Construct the plugin class. You probably want to use `CursorPlugin.create`
             * instead.
             *
             * @param {CursorPluginParams} params Plugin parameters
             * @param {object} ws Wavesurfer instance
             */
            function CursorPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, CursorPlugin);

              this.defaultParams = {
                hideOnBlur: true,
                width: '1px',
                color: 'black',
                opacity: '0.25',
                style: 'solid',
                zIndex: 4,
                customStyle: {},
                customShowTimeStyle: {},
                showTime: false,
                followCursorY: false,
                formatTimeCallback: null
              };

              this._onMousemove = function (e) {
                var bbox = _this.wavesurfer.container.getBoundingClientRect();

                var y = 0;
                var x = e.clientX - bbox.left;

                var flip = bbox.right < e.clientX + _this.outerWidth(_this.displayTime);

                if (_this.params.showTime && _this.params.followCursorY) {
                  // follow y-position of the mouse
                  y = e.clientY - (bbox.top + bbox.height / 2);
                }

                _this.updateCursorPosition(x, y, flip);
              };

              this._onMouseenter = function () {
                return _this.showCursor();
              };

              this._onMouseleave = function () {
                return _this.hideCursor();
              };

              this.wavesurfer = ws;
              this.style = ws.util.style;
              /**
               * The cursor HTML element
               *
               * @type {?HTMLElement}
               */

              this.cursor = null;
              /**
               * displays the time next to the cursor
               *
               * @type {?HTMLElement}
               */

              this.showTime = null;
              /**
               * The html container that will display the time
               *
               * @type {?HTMLElement}
               */

              this.displayTime = null;
              this.params = _extends({}, this.defaultParams, params);
            }
            /**
             * Initialise the plugin (used by the Plugin API)
             */

            _createClass(CursorPlugin, [{
              key: "init",
              value: function init() {
                this.wrapper = this.wavesurfer.container;
                this.cursor = this.wrapper.appendChild(this.style(document.createElement('cursor'), _extends({
                  position: 'absolute',
                  zIndex: this.params.zIndex,
                  left: 0,
                  top: 0,
                  bottom: 0,
                  width: '0',
                  display: 'flex',
                  borderRightStyle: this.params.style,
                  borderRightWidth: this.params.width,
                  borderRightColor: this.params.color,
                  opacity: this.params.opacity,
                  pointerEvents: 'none'
                }, this.params.customStyle)));

                if (this.params.showTime) {
                  this.showTime = this.wrapper.appendChild(this.style(document.createElement('showTitle'), _extends({
                    position: 'absolute',
                    zIndex: this.params.zIndex,
                    left: 0,
                    top: 0,
                    bottom: 0,
                    width: 'auto',
                    display: 'flex',
                    opacity: this.params.opacity,
                    pointerEvents: 'none',
                    height: '100%'
                  }, this.params.customStyle)));
                  this.displayTime = this.showTime.appendChild(this.style(document.createElement('div'), _extends({
                    display: 'inline',
                    pointerEvents: 'none',
                    margin: 'auto',
                    visibility: 'hidden' // initial value will be hidden just for measuring purpose

                  }, this.params.customShowTimeStyle))); // initial value to measure display width

                  this.displayTime.innerHTML = this.formatTime(0);
                }

                this.wrapper.addEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  // ensure elements are hidden initially
                  this.hideCursor();
                  this.wrapper.addEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.addEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Destroy the plugin (used by the Plugin API)
               */

            }, {
              key: "destroy",
              value: function destroy() {
                if (this.params.showTime) {
                  this.cursor.parentNode.removeChild(this.showTime);
                }

                this.cursor.parentNode.removeChild(this.cursor);
                this.wrapper.removeEventListener('mousemove', this._onMousemove);

                if (this.params.hideOnBlur) {
                  this.wrapper.removeEventListener('mouseenter', this._onMouseenter);
                  this.wrapper.removeEventListener('mouseleave', this._onMouseleave);
                }
              }
              /**
               * Update the cursor position
               *
               * @param {number} xpos The x offset of the cursor in pixels
               * @param {number} ypos The y offset of the cursor in pixels
               * @param {boolean} flip Flag to flip duration text from right to left
               */

            }, {
              key: "updateCursorPosition",
              value: function updateCursorPosition(xpos, ypos) {
                var flip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                this.style(this.cursor, {
                  left: "".concat(xpos, "px")
                });

                if (this.params.showTime) {
                  var duration = this.wavesurfer.getDuration();
                  var elementWidth = this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
                  var scrollWidth = this.wavesurfer.drawer.getScrollX();
                  var scrollTime = duration / this.wavesurfer.drawer.width * scrollWidth;
                  var timeValue = Math.max(0, xpos / elementWidth * duration) + scrollTime;
                  var formatValue = this.formatTime(timeValue);

                  if (flip) {
                    var textOffset = this.outerWidth(this.displayTime);
                    xpos -= textOffset;
                  }

                  this.style(this.showTime, {
                    left: "".concat(xpos, "px"),
                    top: "".concat(ypos, "px")
                  });
                  this.style(this.displayTime, {
                    visibility: 'visible'
                  });
                  this.displayTime.innerHTML = "".concat(formatValue);
                }
              }
              /**
               * Show the cursor
               */

            }, {
              key: "showCursor",
              value: function showCursor() {
                this.style(this.cursor, {
                  display: 'flex'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'flex'
                  });
                }
              }
              /**
               * Hide the cursor
               */

            }, {
              key: "hideCursor",
              value: function hideCursor() {
                this.style(this.cursor, {
                  display: 'none'
                });

                if (this.params.showTime) {
                  this.style(this.showTime, {
                    display: 'none'
                  });
                }
              }
              /**
               * Format the timestamp for `cursorTime`.
               *
               * @param {number} cursorTime Time in seconds
               * @returns {string} Formatted timestamp
               */

            }, {
              key: "formatTime",
              value: function formatTime(cursorTime) {
                cursorTime = isNaN(cursorTime) ? 0 : cursorTime;

                if (this.params.formatTimeCallback) {
                  return this.params.formatTimeCallback(cursorTime);
                }

                return [cursorTime].map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2), // seconds
                  ('000' + Math.floor(time % 1 * 1000)).slice(-3) // milliseconds
                  ].join(':');
                });
              }
              /**
               * Get outer width of given element.
               *
               * @param {DOM} element DOM Element
               * @returns {number} outer width
               */

            }, {
              key: "outerWidth",
              value: function outerWidth(element) {
                if (!element) {
                  return 0;
                }

                var width = element.offsetWidth;
                var style = getComputedStyle(element);
                width += parseInt(style.marginLeft + style.marginRight);
                return width;
              }
            }], [{
              key: "create",
              value:
              /**
               * Cursor plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param  {CursorPluginParams} params parameters use to initialise the
               * plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'cursor',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {},
                  instance: CursorPlugin
                };
              }
              /**
               * @type {CursorPluginParams}
               */

            }]);

            return CursorPlugin;
          }();

          exports.default = CursorPlugin;
          module.exports = exports.default;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/cursor/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.cursor.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * wavesurfer.js regions plugin 5.1.0 (2021-06-20)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["WaveSurfer"] = factory();else root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["regions"] = factory();
})(undefined, function () {
  return (/******/function () {
      // webpackBootstrap
      /******/"use strict";
      /******/
      var __webpack_modules__ = {

        /***/"./src/plugin/regions/index.js":
        /*!*************************************!*\
          !*** ./src/plugin/regions/index.js ***!
          \*************************************/
        /***/function srcPluginRegionsIndexJs(module, exports, __webpack_require__) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _region = __webpack_require__( /*! ./region.js */"./src/plugin/regions/region.js");

          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {
                symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              }keys.push.apply(keys, symbols);
            }return keys;
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           * Regions are visual overlays on waveform that can be used to play and loop
           * portions of audio. Regions can be dragged and resized.
           *
           * Visual customization is possible via CSS (using the selectors
           * `.wavesurfer-region` and `.wavesurfer-handle`).
           *
           * @implements {PluginClass}
           * @extends {Observer}
           *
           * @example
           * // es6
           * import RegionsPlugin from 'wavesurfer.regions.js';
           *
           * // commonjs
           * var RegionsPlugin = require('wavesurfer.regions.js');
           *
           * // if you are using <script> tags
           * var RegionsPlugin = window.WaveSurfer.regions;
           *
           * // ... initialising wavesurfer with the plugin
           * var wavesurfer = WaveSurfer.create({
           *   // wavesurfer options ...
           *   plugins: [
           *     RegionsPlugin.create({
           *       // plugin options ...
           *     })
           *   ]
           * });
           */
          var RegionsPlugin = /*#__PURE__*/function () {
            function RegionsPlugin(params, ws) {
              var _this = this;

              _classCallCheck(this, RegionsPlugin);

              this.params = params;
              this.wavesurfer = ws;
              this.util = _objectSpread(_objectSpread({}, ws.util), {}, {
                getRegionSnapToGridValue: function getRegionSnapToGridValue(value) {
                  return _this.getRegionSnapToGridValue(value, params);
                }
              });
              this.maxRegions = params.maxRegions;
              this.regionsMinLength = params.regionsMinLength || null; // turn the plugin instance into an observer

              var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
              observerPrototypeKeys.forEach(function (key) {
                _region.Region.prototype[key] = _this.util.Observer.prototype[key];
              });
              this.wavesurfer.Region = _region.Region; // By default, scroll the container if the user drags a region
              // within 5% of its edge

              var scrollWidthProportion = 0.05;

              this._onBackendCreated = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.orientation = _this.wavesurfer.drawer.orientation;

                if (_this.params.regions) {
                  _this.params.regions.forEach(function (region) {
                    region.edgeScrollWidth = _this.params.edgeScrollWidth || _this.wrapper.clientWidth * scrollWidthProportion;

                    _this.add(region);
                  });
                }
              }; // Id-based hash of regions


              this.list = {};

              this._onReady = function () {
                _this.wrapper = _this.wavesurfer.drawer.wrapper;
                _this.vertical = _this.wavesurfer.drawer.params.vertical;

                if (_this.params.dragSelection) {
                  _this.enableDragSelection(_this.params);
                }

                Object.keys(_this.list).forEach(function (id) {
                  _this.list[id].updateRender();
                });
              };
            }

            _createClass(RegionsPlugin, [{
              key: "init",
              value: function init() {
                // Check if ws is ready
                if (this.wavesurfer.isReady) {
                  this._onBackendCreated();

                  this._onReady();
                } else {
                  this.wavesurfer.once('ready', this._onReady);
                  this.wavesurfer.once('backend-created', this._onBackendCreated);
                }
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.wavesurfer.un('ready', this._onReady);
                this.wavesurfer.un('backend-created', this._onBackendCreated);
                this.disableDragSelection();
                this.clear();
              }
              /**
               * check to see if adding a new region would exceed maxRegions
               * @return {boolean} whether we should proceed and create a region
               * @private
               */

            }, {
              key: "wouldExceedMaxRegions",
              value: function wouldExceedMaxRegions() {
                return this.maxRegions && Object.keys(this.list).length >= this.maxRegions;
              }
              /**
               * Add a region
               *
               * @param {object} params Region parameters
               * @return {Region} The created region
               */

            }, {
              key: "add",
              value: function add(params) {
                var _this2 = this;

                if (this.wouldExceedMaxRegions()) {
                  return null;
                }

                if (!params.minLength && this.regionsMinLength) {
                  params = _objectSpread(_objectSpread({}, params), {}, {
                    minLength: this.regionsMinLength
                  });
                }

                var region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);
                this.list[region.id] = region;
                region.on('remove', function () {
                  delete _this2.list[region.id];
                });
                return region;
              }
              /**
               * Remove all regions
               */

            }, {
              key: "clear",
              value: function clear() {
                var _this3 = this;

                Object.keys(this.list).forEach(function (id) {
                  _this3.list[id].remove();
                });
              }
            }, {
              key: "enableDragSelection",
              value: function enableDragSelection(params) {
                var _this4 = this;

                this.disableDragSelection();
                var slop = params.slop || 2;
                var container = this.wavesurfer.drawer.container;
                var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
                var scrollSpeed = params.scrollSpeed || 1;
                var scrollThreshold = params.scrollThreshold || 10;
                var drag;
                var duration = this.wavesurfer.getDuration();
                var maxScroll;
                var start;
                var region;
                var touchId;
                var pxMove = 0;
                var scrollDirection;
                var wrapperRect; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(e) {
                  if (!region || !scrollDirection) {
                    return;
                  } // Update scroll position


                  var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
                  _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range

                  var end = _this4.wavesurfer.drawer.handleEvent(e);

                  region.update({
                    start: Math.min(end * duration, start * duration),
                    end: Math.max(end * duration, start * duration)
                  }); // Check that there is more to scroll and repeat

                  if (scrollLeft < maxScroll && scrollLeft > 0) {
                    window.requestAnimationFrame(function () {
                      edgeScroll(e);
                    });
                  }
                };

                var eventDown = function eventDown(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  duration = _this4.wavesurfer.getDuration();
                  touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  drag = true;
                  start = _this4.wavesurfer.drawer.handleEvent(e, true);
                  region = null;
                  scrollDirection = null;
                };

                this.wrapper.addEventListener('mousedown', eventDown);
                this.wrapper.addEventListener('touchstart', eventDown);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchstart', eventDown);

                  _this4.wrapper.removeEventListener('mousedown', eventDown);
                });

                var eventUp = function eventUp(e) {
                  if (e.touches && e.touches.length > 1) {
                    return;
                  }

                  drag = false;
                  pxMove = 0;
                  scrollDirection = null;

                  if (region) {
                    _this4.util.preventClick();

                    region.fireEvent('update-end', e);

                    _this4.wavesurfer.fireEvent('region-update-end', region, e);
                  }

                  region = null;
                };

                this.wrapper.addEventListener('mouseleave', eventUp);
                this.wrapper.addEventListener('mouseup', eventUp);
                this.wrapper.addEventListener('touchend', eventUp);
                document.body.addEventListener('mouseup', eventUp);
                document.body.addEventListener('touchend', eventUp);
                this.on('disable-drag-selection', function () {
                  document.body.removeEventListener('mouseup', eventUp);
                  document.body.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('touchend', eventUp);

                  _this4.wrapper.removeEventListener('mouseup', eventUp);

                  _this4.wrapper.removeEventListener('mouseleave', eventUp);
                });

                var eventMove = function eventMove(event) {
                  if (!drag) {
                    return;
                  }

                  if (++pxMove <= slop) {
                    return;
                  }

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  } // auto-create a region during mouse drag, unless region-count would exceed "maxRegions"


                  if (!region) {
                    region = _this4.add(params || {});

                    if (!region) {
                      return;
                    }
                  }

                  var end = _this4.wavesurfer.drawer.handleEvent(event);

                  var startUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(start * duration);

                  var endUpdate = _this4.wavesurfer.regions.util.getRegionSnapToGridValue(end * duration);

                  region.update({
                    start: Math.min(endUpdate, startUpdate),
                    end: Math.max(endUpdate, startUpdate)
                  });

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical); // If scrolling is enabled


                  if (scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Check threshold based on mouse
                    var x = orientedEvent.clientX - wrapperRect.left;

                    if (x <= scrollThreshold) {
                      scrollDirection = -1;
                    } else if (x >= wrapperRect.right - scrollThreshold) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    scrollDirection && edgeScroll(event);
                  }
                };

                this.wrapper.addEventListener('mousemove', eventMove);
                this.wrapper.addEventListener('touchmove', eventMove);
                this.on('disable-drag-selection', function () {
                  _this4.wrapper.removeEventListener('touchmove', eventMove);

                  _this4.wrapper.removeEventListener('mousemove', eventMove);
                });
                this.wavesurfer.on('region-created', function (region) {
                  if (_this4.regionsMinLength) {
                    region.minLength = _this4.regionsMinLength;
                  }
                });
              }
            }, {
              key: "disableDragSelection",
              value: function disableDragSelection() {
                this.fireEvent('disable-drag-selection');
              }
              /**
               * Get current region
               *
               * The smallest region that contains the current time. If several such
               * regions exist, take the first. Return `null` if none exist.
               *
               * @returns {Region} The current region
               */

            }, {
              key: "getCurrentRegion",
              value: function getCurrentRegion() {
                var _this5 = this;

                var time = this.wavesurfer.getCurrentTime();
                var min = null;
                Object.keys(this.list).forEach(function (id) {
                  var cur = _this5.list[id];

                  if (cur.start <= time && cur.end >= time) {
                    if (!min || cur.end - cur.start < min.end - min.start) {
                      min = cur;
                    }
                  }
                });
                return min;
              }
              /**
               * Match the value to the grid, if required
               *
               * If the regions plugin params have a snapToGridInterval set, return the
               * value matching the nearest grid interval. If no snapToGridInterval is set,
               * the passed value will be returned without modification.
               *
               * @param {number} value the value to snap to the grid, if needed
               * @param {Object} params the regions plugin params
               * @returns {number} value
               */

            }, {
              key: "getRegionSnapToGridValue",
              value: function getRegionSnapToGridValue(value, params) {
                if (params.snapToGridInterval) {
                  // the regions should snap to a grid
                  var offset = params.snapToGridOffset || 0;
                  return Math.round((value - offset) / params.snapToGridInterval) * params.snapToGridInterval + offset;
                } // no snap-to-grid


                return value;
              }
            }], [{
              key: "create",
              value:
              /**
               * Regions plugin definition factory
               *
               * This function must be used to create a plugin definition which can be
               * used by wavesurfer to correctly instantiate the plugin.
               *
               * @param {RegionsPluginParams} params parameters use to initialise the plugin
               * @return {PluginDefinition} an object representing the plugin
               */
              function create(params) {
                return {
                  name: 'regions',
                  deferInit: params && params.deferInit ? params.deferInit : false,
                  params: params,
                  staticProps: {
                    addRegion: function addRegion(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      return this.regions.add(options);
                    },
                    clearRegions: function clearRegions() {
                      this.regions && this.regions.clear();
                    },
                    enableDragSelection: function enableDragSelection(options) {
                      if (!this.initialisedPluginList.regions) {
                        this.initPlugin('regions');
                      }

                      this.regions.enableDragSelection(options);
                    },
                    disableDragSelection: function disableDragSelection() {
                      this.regions.disableDragSelection();
                    }
                  },
                  instance: RegionsPlugin
                };
              }
            }]);

            return RegionsPlugin;
          }();

          exports.default = RegionsPlugin;
          module.exports = exports.default;

          /***/
        },

        /***/"./src/plugin/regions/region.js":
        /*!**************************************!*\
          !*** ./src/plugin/regions/region.js ***!
          \**************************************/
        /***/function srcPluginRegionsRegionJs(__unused_webpack_module, exports) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Region = void 0;

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
          }

          /**
           *  @since 4.0.0
           *
           * (Single) Region plugin class
           *
           * Must be turned into an observer before instantiating. This is done in
           * `RegionsPlugin` (main plugin class).
           *
           * @extends {Observer}
           */
          var Region = /*#__PURE__*/function () {
            function Region(params, regionsUtils, ws) {
              var _params$showTooltip,
                  _this = this;

              _classCallCheck(this, Region);

              this.wavesurfer = ws;
              this.wrapper = ws.drawer.wrapper;
              this.util = ws.util;
              this.style = this.util.style;
              this.regionsUtil = regionsUtils;
              this.vertical = ws.drawer.params.vertical;
              this.id = params.id == null ? ws.util.getId() : params.id;
              this.start = Number(params.start) || 0;
              this.end = params.end == null ? // small marker-like region
              this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
              this.resize = params.resize === undefined ? true : Boolean(params.resize);
              this.drag = params.drag === undefined ? true : Boolean(params.drag); // reflect resize and drag state of region for region-updated listener

              this.isResizing = false;
              this.isDragging = false;
              this.loop = Boolean(params.loop);
              this.color = params.color || 'rgba(0, 0, 0, 0.1)'; // The left and right handleStyle properties can be set to 'none' for
              // no styling or can be assigned an object containing CSS properties.

              this.handleStyle = params.handleStyle || {
                left: {},
                right: {}
              };
              this.handleLeftEl = null;
              this.handleRightEl = null;
              this.data = params.data || {};
              this.attributes = params.attributes || {};
              this.showTooltip = (_params$showTooltip = params.showTooltip) !== null && _params$showTooltip !== void 0 ? _params$showTooltip : true;
              this.maxLength = params.maxLength; // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided

              this.minLength = params.minLength;

              this._onRedraw = function () {
                return _this.updateRender();
              };

              this.scroll = params.scroll !== false && ws.params.scrollParent;
              this.scrollSpeed = params.scrollSpeed || 1;
              this.scrollThreshold = params.scrollThreshold || 10; // Determines whether the context menu is prevented from being opened.

              this.preventContextMenu = params.preventContextMenu === undefined ? false : Boolean(params.preventContextMenu); // select channel ID to set region

              var channelIdx = params.channelIdx == null ? -1 : parseInt(params.channelIdx);
              this.regionHeight = '100%';
              this.marginTop = '0px';

              if (channelIdx !== -1) {
                var channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : -1;

                if (channelCount >= 0 && channelIdx < channelCount) {
                  this.regionHeight = Math.floor(1 / channelCount * 100) + '%';
                  this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';
                }
              }

              this.formatTimeCallback = params.formatTimeCallback;
              this.edgeScrollWidth = params.edgeScrollWidth;
              this.bindInOut();
              this.render();
              this.wavesurfer.on('zoom', this._onRedraw);
              this.wavesurfer.on('redraw', this._onRedraw);
              this.wavesurfer.fireEvent('region-created', this);
            }
            /* Update region params. */

            _createClass(Region, [{
              key: "update",
              value: function update(params) {
                if (params.start != null) {
                  this.start = Number(params.start);
                }

                if (params.end != null) {
                  this.end = Number(params.end);
                }

                if (params.loop != null) {
                  this.loop = Boolean(params.loop);
                }

                if (params.color != null) {
                  this.color = params.color;
                }

                if (params.handleStyle != null) {
                  this.handleStyle = params.handleStyle;
                }

                if (params.data != null) {
                  this.data = params.data;
                }

                if (params.resize != null) {
                  this.resize = Boolean(params.resize);
                  this.updateHandlesResize(this.resize);
                }

                if (params.drag != null) {
                  this.drag = Boolean(params.drag);
                }

                if (params.maxLength != null) {
                  this.maxLength = Number(params.maxLength);
                }

                if (params.minLength != null) {
                  this.minLength = Number(params.minLength);
                }

                if (params.attributes != null) {
                  this.attributes = params.attributes;
                }

                this.updateRender();
                this.fireEvent('update');
                this.wavesurfer.fireEvent('region-updated', this);
              }
              /* Remove a single region. */

            }, {
              key: "remove",
              value: function remove() {
                if (this.element) {
                  this.wrapper.removeChild(this.element.domElement);
                  this.element = null;
                  this.fireEvent('remove');
                  this.wavesurfer.un('zoom', this._onRedraw);
                  this.wavesurfer.un('redraw', this._onRedraw);
                  this.wavesurfer.fireEvent('region-removed', this);
                }
              }
              /**
               * Play the audio region.
               * @param {number} start Optional offset to start playing at
               */

            }, {
              key: "play",
              value: function play(start) {
                var s = start || this.start;
                this.wavesurfer.play(s, this.end);
                this.fireEvent('play');
                this.wavesurfer.fireEvent('region-play', this);
              }
              /**
               * Play the audio region in a loop.
               * @param {number} start Optional offset to start playing at
               * */

            }, {
              key: "playLoop",
              value: function playLoop(start) {
                this.loop = true;
                this.play(start);
              }
              /**
               * Set looping on/off.
               * @param {boolean} loop True if should play in loop
               */

            }, {
              key: "setLoop",
              value: function setLoop(loop) {
                this.loop = loop;
              }
              /* Render a region as a DOM element. */

            }, {
              key: "render",
              value: function render() {
                this.element = this.util.withOrientation(this.wrapper.appendChild(document.createElement('region')), this.vertical);
                this.element.className = 'wavesurfer-region';

                if (this.showTooltip) {
                  this.element.title = this.formatTime(this.start, this.end);
                }

                this.element.setAttribute('data-id', this.id);

                for (var attrname in this.attributes) {
                  this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                }

                this.style(this.element, {
                  position: 'absolute',
                  zIndex: 2,
                  height: this.regionHeight,
                  top: this.marginTop
                });
                /* Resize handles */

                if (this.resize) {
                  this.handleLeftEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleRightEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);
                  this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';
                  this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end'; // Default CSS properties for both handles.

                  var css = {
                    cursor: this.vertical ? 'row-resize' : 'col-resize',
                    position: 'absolute',
                    top: '0px',
                    width: '2px',
                    height: '100%',
                    backgroundColor: 'rgba(0, 0, 0, 1)'
                  }; // Merge CSS properties per handle.

                  var handleLeftCss = this.handleStyle.left !== 'none' ? _extends({
                    left: '0px'
                  }, css, this.handleStyle.left) : null;
                  var handleRightCss = this.handleStyle.right !== 'none' ? _extends({
                    right: '0px'
                  }, css, this.handleStyle.right) : null;

                  if (handleLeftCss) {
                    this.style(this.handleLeftEl, handleLeftCss);
                  }

                  if (handleRightCss) {
                    this.style(this.handleRightEl, handleRightCss);
                  }
                }

                this.updateRender();
                this.bindEvents();
              }
            }, {
              key: "formatTime",
              value: function formatTime(start, end) {
                if (this.formatTimeCallback) {
                  return this.formatTimeCallback(start, end);
                }

                return (start == end ? [start] : [start, end]).map(function (time) {
                  return [Math.floor(time % 3600 / 60), // minutes
                  ('00' + Math.floor(time % 60)).slice(-2) // seconds
                  ].join(':');
                }).join('-');
              }
            }, {
              key: "getWidth",
              value: function getWidth() {
                return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
              }
              /* Update element's position, width, color. */

            }, {
              key: "updateRender",
              value: function updateRender() {
                // duration varies during loading process, so don't overwrite important data
                var dur = this.wavesurfer.getDuration();
                var width = this.getWidth();
                var startLimited = this.start;
                var endLimited = this.end;

                if (startLimited < 0) {
                  startLimited = 0;
                  endLimited = endLimited - startLimited;
                }

                if (endLimited > dur) {
                  endLimited = dur;
                  startLimited = dur - (endLimited - startLimited);
                }

                if (this.minLength != null) {
                  endLimited = Math.max(startLimited + this.minLength, endLimited);
                }

                if (this.maxLength != null) {
                  endLimited = Math.min(startLimited + this.maxLength, endLimited);
                }

                if (this.element != null) {
                  // Calculate the left and width values of the region such that
                  // no gaps appear between regions.
                  var left = Math.round(startLimited / dur * width);
                  var regionWidth = Math.round(endLimited / dur * width) - left;
                  this.style(this.element, {
                    left: left + 'px',
                    width: regionWidth + 'px',
                    backgroundColor: this.color,
                    cursor: this.drag ? 'move' : 'default'
                  });

                  for (var attrname in this.attributes) {
                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
                  }

                  if (this.showTooltip) {
                    this.element.title = this.formatTime(this.start, this.end);
                  }
                }
              }
              /* Bind audio events. */

            }, {
              key: "bindInOut",
              value: function bindInOut() {
                var _this2 = this;

                this.firedIn = false;
                this.firedOut = false;

                var onProcess = function onProcess(time) {
                  var start = Math.round(_this2.start * 10) / 10;
                  var end = Math.round(_this2.end * 10) / 10;
                  time = Math.round(time * 10) / 10;

                  if (!_this2.firedOut && _this2.firedIn && (start > time || end <= time)) {
                    _this2.firedOut = true;
                    _this2.firedIn = false;

                    _this2.fireEvent('out');

                    _this2.wavesurfer.fireEvent('region-out', _this2);
                  }

                  if (!_this2.firedIn && start <= time && end > time) {
                    _this2.firedIn = true;
                    _this2.firedOut = false;

                    _this2.fireEvent('in');

                    _this2.wavesurfer.fireEvent('region-in', _this2);
                  }
                };

                this.wavesurfer.backend.on('audioprocess', onProcess);
                this.on('remove', function () {
                  _this2.wavesurfer.backend.un('audioprocess', onProcess);
                });
                /* Loop playback. */

                this.on('out', function () {
                  if (_this2.loop) {
                    var realTime = _this2.wavesurfer.getCurrentTime();

                    if (realTime >= _this2.start && realTime <= _this2.end) {
                      _this2.wavesurfer.play(_this2.start);
                    }
                  }
                });
              }
              /* Bind DOM events. */

            }, {
              key: "bindEvents",
              value: function bindEvents() {
                var _this3 = this;

                var preventContextMenu = this.preventContextMenu;
                this.element.addEventListener('mouseenter', function (e) {
                  _this3.fireEvent('mouseenter', e);

                  _this3.wavesurfer.fireEvent('region-mouseenter', _this3, e);
                });
                this.element.addEventListener('mouseleave', function (e) {
                  _this3.fireEvent('mouseleave', e);

                  _this3.wavesurfer.fireEvent('region-mouseleave', _this3, e);
                });
                this.element.addEventListener('click', function (e) {
                  e.preventDefault();

                  _this3.fireEvent('click', e);

                  _this3.wavesurfer.fireEvent('region-click', _this3, e);
                });
                this.element.addEventListener('dblclick', function (e) {
                  e.stopPropagation();
                  e.preventDefault();

                  _this3.fireEvent('dblclick', e);

                  _this3.wavesurfer.fireEvent('region-dblclick', _this3, e);
                });
                this.element.addEventListener('contextmenu', function (e) {
                  if (preventContextMenu) {
                    e.preventDefault();
                  }

                  _this3.fireEvent('contextmenu', e);

                  _this3.wavesurfer.fireEvent('region-contextmenu', _this3, e);
                });
                /* Drag or resize on mousemove. */

                if (this.drag || this.resize) {
                  this.bindDragEvents();
                }
              }
            }, {
              key: "bindDragEvents",
              value: function bindDragEvents() {
                var _this4 = this;

                var container = this.wavesurfer.drawer.container;
                var scrollSpeed = this.scrollSpeed;
                var scrollThreshold = this.scrollThreshold;
                var startTime;
                var touchId;
                var drag;
                var maxScroll;
                var resize;
                var updated = false;
                var scrollDirection;
                var wrapperRect;
                var regionLeftHalfTime;
                var regionRightHalfTime; // Scroll when the user is dragging within the threshold

                var edgeScroll = function edgeScroll(event) {
                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  var duration = _this4.wavesurfer.getDuration();

                  if (!scrollDirection || !drag && !resize) {
                    return;
                  }

                  var x = orientedEvent.clientX;
                  var distanceBetweenCursorAndWrapperEdge = 0;
                  var regionHalfTimeWidth = 0;
                  var adjustment = 0; // Get the currently selected time according to the mouse position

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // Considering the point of contact with the region while edgescrolling
                    if (scrollDirection === -1) {
                      regionHalfTimeWidth = regionLeftHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;
                    } else {
                      regionHalfTimeWidth = regionRightHalfTime * _this4.wavesurfer.params.minPxPerSec;
                      distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;
                    }
                  } else {
                    // Considering minLength while edgescroll
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                        adjustment = scrollSpeed * scrollDirection;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  } // Don't edgescroll if region has reached min or max limit


                  var wrapperScrollLeft = _this4.wrapper.scrollLeft;

                  if (scrollDirection === -1) {
                    if (Math.round(wrapperScrollLeft) === 0) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {
                      return;
                    }
                  } else {
                    if (Math.round(wrapperScrollLeft) === maxScroll) {
                      return;
                    }

                    if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {
                      return;
                    }
                  } // Update scroll position


                  var scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;

                  if (scrollDirection === -1) {
                    var calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedLeft;
                  } else {
                    var calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);
                    _this4.wrapper.scrollLeft = scrollLeft = calculatedRight;
                  }

                  var delta = time - startTime;
                  startTime = time; // Continue dragging or resizing

                  drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize); // Repeat

                  window.requestAnimationFrame(function () {
                    edgeScroll(event);
                  });
                };

                var onDown = function onDown(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  touchId = event.targetTouches ? event.targetTouches[0].identifier : null; // stop the event propagation, if this region is resizable or draggable
                  // and the event is therefore handled here.

                  if (_this4.drag || _this4.resize) {
                    event.stopPropagation();
                  } // Store the selected startTime we begun dragging or resizing


                  startTime = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event, true) * duration); // Store the selected point of contact when we begin dragging

                  regionLeftHalfTime = startTime - _this4.start;
                  regionRightHalfTime = _this4.end - startTime; // Store for scroll calculations

                  maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
                  wrapperRect = _this4.util.withOrientation(_this4.wrapper.getBoundingClientRect(), _this4.vertical);
                  _this4.isResizing = false;
                  _this4.isDragging = false;

                  if (event.target.tagName.toLowerCase() === 'handle') {
                    _this4.isResizing = true;
                    resize = event.target.classList.contains('wavesurfer-handle-start') ? 'start' : 'end';
                  } else {
                    _this4.isDragging = true;
                    drag = true;
                    resize = false;
                  }
                };

                var onUp = function onUp(event) {
                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (drag || resize) {
                    _this4.isDragging = false;
                    _this4.isResizing = false;
                    drag = false;
                    scrollDirection = null;
                    resize = false;
                  }

                  if (updated) {
                    updated = false;

                    _this4.util.preventClick();

                    _this4.fireEvent('update-end', event);

                    _this4.wavesurfer.fireEvent('region-update-end', _this4, event);
                  }
                };

                var onMove = function onMove(event) {
                  var duration = _this4.wavesurfer.getDuration();

                  var orientedEvent = _this4.util.withOrientation(event, _this4.vertical);

                  if (event.touches && event.touches.length > 1) {
                    return;
                  }

                  if (event.targetTouches && event.targetTouches[0].identifier != touchId) {
                    return;
                  }

                  if (!drag && !resize) {
                    return;
                  }

                  var oldTime = startTime;

                  var time = _this4.regionsUtil.getRegionSnapToGridValue(_this4.wavesurfer.drawer.handleEvent(event) * duration);

                  if (drag) {
                    // To maintain relative cursor start point while dragging
                    var maxEnd = _this4.wavesurfer.getDuration();

                    if (time > maxEnd - regionRightHalfTime) {
                      time = maxEnd - regionRightHalfTime;
                    }

                    if (time - regionLeftHalfTime < 0) {
                      time = regionLeftHalfTime;
                    }
                  }

                  if (resize) {
                    // To maintain relative cursor start point while resizing
                    // we have to handle for minLength
                    var minLength = _this4.minLength;

                    if (!minLength) {
                      minLength = 0;
                    }

                    if (resize === 'start') {
                      if (time > _this4.end - minLength) {
                        time = _this4.end - minLength;
                      }

                      if (time < 0) {
                        time = 0;
                      }
                    } else if (resize === 'end') {
                      if (time < _this4.start + minLength) {
                        time = _this4.start + minLength;
                      }

                      if (time > duration) {
                        time = duration;
                      }
                    }
                  }

                  var delta = time - startTime;
                  startTime = time; // Drag

                  if (_this4.drag && drag) {
                    updated = updated || !!delta;

                    _this4.onDrag(delta);
                  } // Resize


                  if (_this4.resize && resize) {
                    updated = updated || !!delta;

                    _this4.onResize(delta, resize);
                  }

                  if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
                    // Triggering edgescroll from within edgeScrollWidth
                    var x = orientedEvent.clientX; // Check direction

                    if (x < wrapperRect.left + _this4.edgeScrollWidth) {
                      scrollDirection = -1;
                    } else if (x > wrapperRect.right - _this4.edgeScrollWidth) {
                      scrollDirection = 1;
                    } else {
                      scrollDirection = null;
                    }

                    if (scrollDirection) {
                      edgeScroll(event);
                    }
                  }
                };

                this.element.addEventListener('mousedown', onDown);
                this.element.addEventListener('touchstart', onDown);
                document.body.addEventListener('mousemove', onMove);
                document.body.addEventListener('touchmove', onMove, {
                  passive: false
                });
                document.addEventListener('mouseup', onUp);
                document.body.addEventListener('touchend', onUp);
                this.on('remove', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                  document.body.removeEventListener('mousemove', onMove);
                  document.body.removeEventListener('touchmove', onMove);
                });
                this.wavesurfer.on('destroy', function () {
                  document.removeEventListener('mouseup', onUp);
                  document.body.removeEventListener('touchend', onUp);
                });
              }
            }, {
              key: "onDrag",
              value: function onDrag(delta) {
                var maxEnd = this.wavesurfer.getDuration();

                if (this.end + delta > maxEnd) {
                  delta = maxEnd - this.end;
                }

                if (this.start + delta < 0) {
                  delta = this.start * -1;
                }

                this.update({
                  start: this.start + delta,
                  end: this.end + delta
                });
              }
              /**
               * @example
               * onResize(-5, 'start') // Moves the start point 5 seconds back
               * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward
               *
               * @param {number} delta How much to add or subtract, given in seconds
               * @param {string} direction 'start 'or 'end'
               */

            }, {
              key: "onResize",
              value: function onResize(delta, direction) {
                var duration = this.wavesurfer.getDuration();

                if (direction === 'start') {
                  // Check if changing the start by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta > 0 && this.end - (this.start + delta) < this.minLength) {
                    delta = this.end - this.minLength - this.start;
                  }

                  if (delta < 0 && this.start + delta < 0) {
                    delta = this.start * -1;
                  }

                  this.update({
                    start: Math.min(this.start + delta, this.end),
                    end: Math.max(this.start + delta, this.end)
                  });
                } else {
                  // Check if changing the end by the given delta would result in the region being smaller than minLength
                  // Ignore cases where we are making the region wider rather than shrinking it
                  if (delta < 0 && this.end + delta - this.start < this.minLength) {
                    delta = this.start + this.minLength - this.end;
                  }

                  if (delta > 0 && this.end + delta > duration) {
                    delta = duration - this.end;
                  }

                  this.update({
                    start: Math.min(this.end + delta, this.start),
                    end: Math.max(this.end + delta, this.start)
                  });
                }
              }
            }, {
              key: "updateHandlesResize",
              value: function updateHandlesResize(resize) {
                var cursorStyle;

                if (resize) {
                  cursorStyle = this.vertical ? 'row-resize' : 'col-resize';
                } else {
                  cursorStyle = 'auto';
                }

                this.handleLeftEl && this.style(this.handleLeftEl, {
                  cursor: cursorStyle
                });
                this.handleRightEl && this.style(this.handleRightEl, {
                  cursor: cursorStyle
                });
              }
            }]);

            return Region;
          }();

          exports.Region = Region;

          /***/
        }

        /******/ };
      /************************************************************************/
      /******/ // The module cache
      /******/var __webpack_module_cache__ = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/var cachedModule = __webpack_module_cache__[moduleId];
        /******/if (cachedModule !== undefined) {
          /******/return cachedModule.exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = __webpack_module_cache__[moduleId] = {
          /******/ // no module.id needed
          /******/ // no module.loaded needed
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /************************************************************************/
      /******/
      /******/ // startup
      /******/ // Load entry module and return exports
      /******/ // This entry module is referenced by other modules so it can't be inlined
      /******/var __webpack_exports__ = __webpack_require__("./src/plugin/regions/index.js");
      /******/
      /******/return __webpack_exports__;
      /******/
    }()
  );
});
//# sourceMappingURL=wavesurfer.regions.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTkyMTYxZjQyMmI3ZDc1MGUxMTQiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0LmpzIiwid2VicGFjazovLy8uL3N0eWxlcy93YXZlZm9ybS5jc3M/M2MzZCIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL1dhdmVmb3JtSW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaDVwLXBhcmVudC9zcmMvcGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oNXAtcGFyZW50L3NyYy9jaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3Qvd2F2ZXN1cmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJsIiwiaSIsIkg1UCIsIkg1UEVkaXRvciIsIndpZGdldHMiLCJ3YXZlZm9ybUluaXQiLCJXYXZlZm9ybUluaXQiLCJwYXJlbnQiLCJmaWVsZCIsInBhcmFtcyIsInNldFZhbHVlIiwiaWQiLCJjckF1ZGlvSW5kZXgiLCJjb250YWluZXIiLCJhdWRpb1BhcmFtcyIsInN0YXJ0VGltZSIsInN0YXJ0RHVyYXRpb24iLCJ1bmRlZmluZWQiLCJlbmRUaW1lIiwiZW5kRHVyYXRpb24iLCJhdWRpb0R1cmF0aW9uIiwicHJvdG90eXBlIiwiY3JlYXRlIiwiUGFyZW50IiwiY29uc3RydWN0b3IiLCJwYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlIiwiaW5pdCIsInNlbGYiLCJsZW5ndGgiLCJ3YXZlc3VyZmVyIiwiV2F2ZVN1cmZlciIsIndhdmVDb2xvciIsInByb2dyZXNzQ29sb3IiLCJmaWxsUGFyZW50IiwicmVzcG9uc2l2ZSIsImJhckhlaWdodCIsInBsdWdpbnMiLCJSZWdpb25zUGx1Z2luIiwicmVnaW9uc01pbkxlbmd0aCIsIm1heFJlZ2lvbnMiLCJyZWdpb25zIiwic3RhcnQiLCJlbmQiLCJsb29wIiwiY29sb3IiLCJkcmFnU2VsZWN0aW9uIiwic2xvcCIsImNzcyIsInJlZ2lvbiIsInJlbmRlcmFibGVDb21tb25GaWVsZHMiLCJmaWVsZHMiLCJzdWJDb250ZW50SWQiLCJwYXRoIiwiZmlsZXMiLCJmaWxlIiwiZ2V0UGF0aCIsIiQiLCJkb25lIiwic2V0VGltZW91dCIsImxvYWQiLCJmYWlsIiwiY29udGVudElkIiwib24iLCJ2YWx1ZXMiLCJsaXN0Iiwid2lkdGgiLCJjcCIsImdldER1cmF0aW9uIiwid2F2ZWZvcm0iLCJ3YXZlZm9ybVBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJzdGFydER1cmF0aW9uRmllbGQiLCJxdWVyeVNlbGVjdG9yIiwiZW5kRHVyYXRpb25GaWVsZCIsInN0YXJ0RHVyYXRpb25GaWVsZElucHV0IiwiZW5kRHVyYXRpb25GaWVsZElucHV0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdGFydER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyIiwidGFyZ2V0IiwidmFsdWUiLCJlbmREdXJhdGlvblZhbHVlQ2hhbmdlSGFuZGxlciIsIndhdmVmb3JtRWxlbWVudHMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJwcmV2aW91c1dhdmVmb3JtQ29udGVudCIsInByZXZpb3VzRW5kRHVyYXRpb25GaWVsZCIsInByZXZpb3VzRW5kRHVyYXRpb25JbnB1dCIsInBhcnNlRmxvYXQiLCJmaWxlc0ZpZWxkIiwiZmlsZXNMaXN0RWxlbWVudCIsIm9ic2VydmVyQ29uZmlnIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnNMaXN0IiwiJHN0YXJ0aW5wdXQiLCJmaW5kIiwiJGVuZGlucHV0IiwidmFsIiwiZmluZEZpZWxkIiwidXBkYXRlIiwib2JzZXJ2ZSIsImV2ZW50IiwidG9GaXhlZCIsInJlZ2lvbklkIiwiJHBsYXlSZWdpb25CdXR0b24iLCJhcHBlbmQiLCJwbGF5IiwiaXNOYU4iLCJpbnB1dFN0YXJ0VGltZSIsImlucHV0RW5kVGltZSIsImFwcGVuZFRvIiwiJHdyYXBwZXIiLCJucyIsImdldE5leHRGaWVsZElkIiwiaHRtbCIsImNyZWF0ZUZpZWxkTWFya3VwIiwiJGl0ZW0iLCJzZXRJZCIsIndvcmRUZXh0IiwidGV4dCIsInNsaWRlcyIsInNsaWRlSW5kZXgiLCJjdXJySW5kZXgiLCJwYXJhbVRleHQiLCJjaGVja0JveEVsZW1lbnRGb3JXb3JkIiwiZ2V0U2VudGVuY2UiLCJjb25zb2xlIiwibG9nIiwiaXNBbHJlYWR5VXNlZCIsImNoZWNrSWZXb3JkSXNVc2VkSW5PdGhlcldhdmVmb3JtIiwiaXMiLCJhdHRyIiwiJHdvcmQiLCJ0cmltIiwicmVwbGFjZSIsInRvU3RyaW5nIiwicHVzaCIsInNwbGl0IiwidGVtcFdvcmRUZXh0IiwiZmlsdGVyIiwib2JqIiwiaW5wdXRJZCIsInNsaWRlQ2hlY2tib3hJbmZvIiwid29yZEluZGV4IiwicGFyc2VJbnQiLCJpbmRleCIsIm5hbWUiLCJ2YWxpZGF0ZSIsInByZXZEYXRhIiwic2VudGVuY2VXb3JkcyIsInNwbGl0dGVkUHJldkRhdGEiLCJhbHJlYWR5Rm91bmRTcGxpdHRlZFByZXZEYXRhV29yZCIsImVsZW1lbnRzIiwiYWN0aW9uIiwibGlicmFyeSIsImNoZWNrQm94V29yZCIsImlubmVyVGV4dCIsImoiLCJkZWYiLCJpbmRleE9mIiwicmVtb3ZlIiwiQ2hpbGQiLCJyZXF1aXJlIiwiRXZlbnREaXNwYXRjaGVyIiwicGFyYW1ldGVycyIsImNhbGwiLCJ1cGRhdGVJbmRleGVzIiwiZnJvbSIsImFkZENoaWxkIiwiY2hpbGRQYXJhbWV0ZXJzIiwiaW5zdGFuY2UiLCJzcGxpY2UiLCJyZW1vdmVDaGlsZCIsIm1vdmVDaGlsZCIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJjaGlsZCIsImpRdWVyeSIsIkpvdWJlbFVJIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZGVmYXVsdCIsIl9zdHlsZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZ2V0SWQiLCJfX2VzTW9kdWxlIiwiX2NsYXNzQ2FsbENoZWNrIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiQ2FudmFzRW50cnkiLCJ3YXZlIiwid2F2ZUN0eCIsInByb2dyZXNzIiwicHJvZ3Jlc3NDdHgiLCJ0b0xvd2VyQ2FzZSIsImNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzIiwiaW5pdFdhdmUiLCJlbGVtZW50IiwiZ2V0Q29udGV4dCIsImluaXRQcm9ncmVzcyIsInVwZGF0ZURpbWVuc2lvbnMiLCJlbGVtZW50V2lkdGgiLCJ0b3RhbFdpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0TGVmdCIsImVsZW1lbnRTaXplIiwiaGFzUHJvZ3Jlc3NDYW52YXMiLCJjbGVhcldhdmUiLCJjbGVhclJlY3QiLCJjYW52YXMiLCJzZXRGaWxsU3R5bGVzIiwiZmlsbFN0eWxlIiwiYXBwbHlDYW52YXNUcmFuc2Zvcm1zIiwidmVydGljYWwiLCJzZXRUcmFuc2Zvcm0iLCJmaWxsUmVjdHMiLCJ4IiwieSIsInJhZGl1cyIsImZpbGxSZWN0VG9Db250ZXh0IiwiY3R4IiwiZHJhd1JvdW5kZWRSZWN0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiY2xvc2VQYXRoIiwiZmlsbCIsImRyYXdMaW5lcyIsInBlYWtzIiwiYWJzbWF4IiwiaGFsZkgiLCJvZmZzZXRZIiwiZHJhd0xpbmVUb0NvbnRleHQiLCJmaXJzdCIsIk1hdGgiLCJyb3VuZCIsImxhc3QiLCJjYW52YXNTdGFydCIsImNhbnZhc0VuZCIsInNjYWxlIiwiaGFsZk9mZnNldCIsImFic21heEhhbGYiLCJwZWFrIiwiaCIsImhhbGZQaXhlbCIsImRlc3Ryb3kiLCJnZXRJbWFnZSIsImZvcm1hdCIsInF1YWxpdHkiLCJ0eXBlIiwiX3RoaXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvQmxvYiIsInRvRGF0YVVSTCIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsInV0aWwiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5vZGVJbnRlcm9wIiwiV2Vha01hcCIsImNhY2hlQmFiZWxJbnRlcm9wIiwiY2FjaGVOb2RlSW50ZXJvcCIsImNhY2hlIiwiaGFzIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGFzT3duUHJvcGVydHkiLCJkZXNjIiwic2V0IiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJEcmF3ZXIiLCJfdXRpbCRPYnNlcnZlciIsIl9zdXBlciIsIndpdGhPcmllbnRhdGlvbiIsInBpeGVsUmF0aW8iLCJsYXN0UG9zIiwid3JhcHBlciIsInN0eWxlIiwiZWwiLCJzdHlsZXMiLCJjcmVhdGVXcmFwcGVyIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheSIsInBvc2l0aW9uIiwidXNlclNlbGVjdCIsIndlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxQYXJlbnQiLCJvdmVyZmxvd1giLCJoaWRlU2Nyb2xsYmFyIiwib3ZlcmZsb3dZIiwic2V0dXBXcmFwcGVyRXZlbnRzIiwiaGFuZGxlRXZlbnQiLCJub1ByZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImNsaWVudFgiLCJ0YXJnZXRUb3VjaGVzIiwiYmJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm5vbWluYWxXaWR0aCIsInBhcmVudFdpZHRoIiwiZ2V0V2lkdGgiLCJwcm9ncmVzc1BpeGVscyIsImdldFByb2dyZXNzUGl4ZWxzIiwic2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwiY2xhbXAiLCJ3cmFwcGVyQmJveCIsInJ0bCIsInJpZ2h0IiwibGVmdCIsIl90aGlzMiIsIm9yaWVudGVkRXZlbnQiLCJzY3JvbGxiYXJIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRZIiwiYm90dG9tIiwiaW50ZXJhY3QiLCJmaXJlRXZlbnQiLCJkcmF3UGVha3MiLCJzZXRXaWR0aCIsImJhcldpZHRoIiwiZHJhd0JhcnMiLCJkcmF3V2F2ZSIsInJlc2V0U2Nyb2xsIiwicmVjZW50ZXIiLCJwZXJjZW50IiwicmVjZW50ZXJPblBvc2l0aW9uIiwiaW1tZWRpYXRlIiwiaGFsZiIsImNsaWVudFdpZHRoIiwibWF4U2Nyb2xsIiwib2Zmc2V0IiwicmF0ZSIsImF1dG9DZW50ZXJSYXRlIiwibWF4IiwibWluIiwiZ2V0U2Nyb2xsWCIsIm5ld1dpZHRoIiwidXBkYXRlU2l6ZSIsInNldEhlaWdodCIsIl9wcm9ncmVzcyIsIm1pblB4RGVsdGEiLCJwb3MiLCJhdXRvQ2VudGVyIiwibmV3UG9zIiwiYXV0b0NlbnRlckltbWVkaWF0ZWx5IiwidXBkYXRlUHJvZ3Jlc3MiLCJ1bkFsbCIsInBhcmVudE5vZGUiLCJkb21FbGVtZW50IiwidXBkYXRlQ3Vyc29yIiwiY2hhbm5lbEluZGV4IiwiT2JzZXJ2ZXIiLCJfZHJhd2VyIiwiX2RyYXdlcjIiLCJNdWx0aUNhbnZhcyIsIl9EcmF3ZXIiLCJtYXhDYW52YXNXaWR0aCIsIm1heENhbnZhc0VsZW1lbnRXaWR0aCIsImNhbnZhc2VzIiwicHJvZ3Jlc3NXYXZlIiwiRW50cnlDbGFzcyIsImRyYXdpbmdDb250ZXh0QXR0cmlidXRlcyIsIm92ZXJsYXAiLCJjZWlsIiwiYmFyUmFkaXVzIiwiY3JlYXRlRWxlbWVudHMiLCJ6SW5kZXgiLCJ0b3AiLCJvdmVyZmxvdyIsImJveFNpemluZyIsImJvcmRlclJpZ2h0U3R5bGUiLCJwb2ludGVyRXZlbnRzIiwiYWRkQ2FudmFzIiwiYm9yZGVyUmlnaHRXaWR0aCIsImN1cnNvcldpZHRoIiwiYm9yZGVyUmlnaHRDb2xvciIsImN1cnNvckNvbG9yIiwicmVxdWlyZWRDYW52YXNlcyIsInJlbW92ZUNhbnZhcyIsImNhbnZhc1dpZHRoIiwibGFzdENhbnZhcyIsImZvckVhY2giLCJlbnRyeSIsImxlZnRPZmZzZXQiLCJsYXN0RW50cnkiLCJwb3AiLCJfdGhpczMiLCJmcmFtZSIsIl90aGlzNCIsInByZXBhcmVEcmF3IiwiX3JlZiIsImhhc01pblZhbHMiLCJjaCIsInBlYWtJbmRleFNjYWxlIiwiYmFyIiwiZ2FwIiwiYmFyR2FwIiwic3RlcCIsImZsb29yIiwiYmFyTWluSGVpZ2h0IiwiX3RoaXM1IiwiX3JlZjIiLCJyZWZsZWN0ZWRQZWFrcyIsImxlbiIsImRyYXdMaW5lIiwiX3RoaXM2IiwiX3JlZjMiLCJzcGxpdENoYW5uZWxzT3B0aW9ucyIsImNoYW5uZWxDb2xvcnMiLCJzdGFydENhbnZhcyIsImVuZENhbnZhcyIsImludGVyc2VjdGlvbiIsIngxIiwieTEiLCJ4MiIsInkyIiwiX3JlZjQiLCJoaWRlQ2hhbm5lbCIsInNwbGl0Q2hhbm5lbHMiLCJmaWx0ZXJDaGFubmVscyIsImluY2x1ZGVzIiwiZm4iLCJkcmF3SW5kZXgiLCJub3JtYWxpemVkTWF4IiwiX3RoaXM3IiwiQXJyYXkiLCJjaGFubmVscyIsImZpbHRlcmVkQ2hhbm5lbHMiLCJjIiwib3ZlcmxheSIsIm92ZXJhbGxBYnNNYXgiLCJyZWxhdGl2ZU5vcm1hbGl6YXRpb24iLCJtYXAiLCJjaGFubmVsUGVha3MiLCJhYnNNYXgiLCJub3JtYWxpemUiLCJzb21lIiwiYWxsIiwiaW1hZ2VzIiwiX21lZGlhZWxlbWVudCIsIl9nZXQiLCJwcm9wZXJ0eSIsInJlY2VpdmVyIiwiYmFzZSIsIl9zdXBlclByb3BCYXNlIiwib2JqZWN0IiwiTWVkaWFFbGVtZW50V2ViQXVkaW8iLCJfTWVkaWFFbGVtZW50Iiwic291cmNlTWVkaWFFbGVtZW50Iiwic2V0UGxheWJhY2tSYXRlIiwiYXVkaW9SYXRlIiwiY3JlYXRlVGltZXIiLCJjcmVhdGVWb2x1bWVOb2RlIiwiY3JlYXRlU2NyaXB0Tm9kZSIsImNyZWF0ZUFuYWx5c2VyTm9kZSIsIl9sb2FkIiwibWVkaWEiLCJwcmVsb2FkIiwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlIiwibWVkaWFFbGVtZW50IiwiYWMiLCJjb25uZWN0IiwiYW5hbHlzZXIiLCJyZXN1bWVBdWRpb0NvbnRleHQiLCJkZXN0cm95V2ViQXVkaW8iLCJfd2ViYXVkaW8iLCJNZWRpYUVsZW1lbnQiLCJfV2ViQXVkaW8iLCJjdXJyZW50VGltZSIsImR1cmF0aW9uIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicGF1c2UiLCJ2b2x1bWUiLCJtZWRpYVR5cGUiLCJlbGVtZW50UG9zaXRpb24iLCJpc011dGVkIiwiYnVmZmVyIiwib25QbGF5RW5kIiwibWVkaWFMaXN0ZW5lcnMiLCJfc2V0dXBNZWRpYUxpc3RlbmVycyIsImVycm9yIiwiY2FucGxheSIsImVuZGVkIiwic2Vla2VkIiwidm9sdW1lY2hhbmdlIiwibXV0ZWQiLCJrZXlzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uQXVkaW9Qcm9jZXNzIiwiaXNQYXVzZWQiLCJnZXRDdXJyZW50VGltZSIsInVybCIsImNvbnRyb2xzIiwibWVkaWFDb250cm9scyIsImF1dG9wbGF5Iiwic3JjIiwicHJldk1lZGlhIiwibG9hZEVsdCIsImVsdCIsIkhUTUxNZWRpYUVsZW1lbnQiLCJFcnJvciIsInNldFZvbHVtZSIsImV4cGxpY2l0RHVyYXRpb24iLCJJbmZpbml0eSIsInNlZWthYmxlIiwiZ2V0UGxheWVkUGVyY2VudHMiLCJnZXRQbGF5YmFja1JhdGUiLCJzZWVrVG8iLCJjbGVhclBsYXlFbmQiLCJwcm9taXNlIiwic2V0UGxheUVuZCIsIl9vblBsYXlFbmQiLCJ0aW1lIiwidW4iLCJnZXRQZWFrcyIsInNldFNpbmtJZCIsImRldmljZUlkIiwicmVqZWN0IiwiZ2V0Vm9sdW1lIiwic2V0TXV0ZSIsImRlc3Ryb3llZCIsInJlbW92ZU1lZGlhRWxlbWVudE9uRGVzdHJveSIsIlBlYWtDYWNoZSIsImNsZWFyUGVha0NhY2hlIiwicGVha0NhY2hlUmFuZ2VzIiwicGVha0NhY2hlTGVuZ3RoIiwiYWRkUmFuZ2VUb1BlYWtDYWNoZSIsInVuY2FjaGVkUmFuZ2VzIiwiaXRlbSIsImFyciIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsInVuY2FjaGVkUmFuZ2VQYWlycyIsImdldENhY2hlUmFuZ2VzIiwicGVha0NhY2hlUmFuZ2VQYWlycyIsIl9tYXgiLCJfbWluIiwiZmV0Y2hGaWxlIiwiX29ic2VydmVyIiwiUHJvZ3Jlc3NIYW5kbGVyIiwiY29udGVudExlbmd0aCIsInJlc3BvbnNlIiwiX3JlYWRlciIsImJvZHkiLCJnZXRSZWFkZXIiLCJ0b3RhbCIsImxvYWRlZCIsImNvbnRyb2xsZXIiLCJyZWFkIiwidGhlbiIsIm9uUHJvZ3Jlc3MiLCJsZW5ndGhDb21wdXRhYmxlIiwiY2xvc2UiLCJieXRlTGVuZ3RoIiwiZW5xdWV1ZSIsImNhdGNoIiwib3B0aW9ucyIsImZldGNoSGVhZGVycyIsIkhlYWRlcnMiLCJmZXRjaFJlcXVlc3QiLCJSZXF1ZXN0IiwiQWJvcnRDb250cm9sbGVyIiwicmVxdWVzdEhlYWRlcnMiLCJoZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJmZXRjaE9wdGlvbnMiLCJtZXRob2QiLCJoZWFkZXJzIiwibW9kZSIsImNyZWRlbnRpYWxzIiwicmVkaXJlY3QiLCJyZWZlcnJlciIsInNpZ25hbCIsImZldGNoIiwicHJvZ3Jlc3NBdmFpbGFibGUiLCJSZXNwb25zZSIsIlJlYWRhYmxlU3RyZWFtIiwiZXJyTXNnIiwib2siLCJhcnJheUJ1ZmZlciIsImpzb24iLCJibG9iIiwic3RhdHVzIiwiX3JlcXVlc3RBbmltYXRpb25GcmFtZSIsImZ1bmMiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJnZXRJZCIsInByZWZpeCIsInJhbmRvbSIsInN1YnN0cmluZyIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX2Fic01heCIsIl9mcmFtZSIsIl9kZWJvdW5jZSIsIl9wcmV2ZW50Q2xpY2siLCJfZmV0Y2giLCJfY2xhbXAiLCJfb3JpZW50YXRpb24iLCJsYXJnZXN0Iiwic21hbGxlc3QiLCJOdW1iZXIiLCJfZGlzYWJsZWRFdmVudEVtaXNzaW9ucyIsImhhbmRsZXJzIiwiY2FsbGJhY2siLCJvbmNlIiwiaGFuZGxlciIsInNldERpc2FibGVkRXZlbnRFbWlzc2lvbnMiLCJldmVudE5hbWVzIiwiX2lzRGlzYWJsZWRFdmVudEVtaXNzaW9uIiwiX2xlbjIiLCJfa2V5MiIsInZlcnRpY2FsUHJvcE1hcCIsIm9mZnNldFRvcCIsIm9mZnNldFdpZHRoIiwibWFwUHJvcCIsInByb3AiLCJpc1Byb3h5IiwiYmluZCIsInByZXZlbnRDbGljayIsInByZXZlbnRDbGlja0hhbmRsZXIiLCJzdG9wUHJvcGFnYXRpb24iLCJfZGVmYXVsdCIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9wZWFrY2FjaGUiLCJfbWVkaWFlbGVtZW50V2ViYXVkaW8iLCJQbHVnaW5DbGFzcyIsIndzIiwiZGVmYXVsdFBhcmFtcyIsImF1ZGlvQ29udGV4dCIsImF1ZGlvU2NyaXB0UHJvY2Vzc29yIiwiYmFja2VuZCIsImJhY2tncm91bmRDb2xvciIsImRlc3luY2hyb25pemVkIiwiZm9yY2VEZWNvZGUiLCJsb29wU2VsZWN0aW9uIiwibWVkaWFDb250YWluZXIiLCJtaW5QeFBlclNlYyIsInBhcnRpYWxSZW5kZXIiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwicmVuZGVyZXIiLCJza2lwTGVuZ3RoIiwieGhyIiwiYmFja2VuZHMiLCJXZWJBdWRpbyIsInRyYW5zZm9ybSIsInNldEJhY2tncm91bmRDb2xvciIsInNhdmVkVm9sdW1lIiwidG1wRXZlbnRzIiwiY3VycmVudFJlcXVlc3QiLCJhcnJheWJ1ZmZlciIsImRyYXdlciIsInBlYWtDYWNoZSIsInN1cHBvcnRzV2ViQXVkaW8iLCJCYWNrZW5kIiwiaW5pdGlhbGlzZWRQbHVnaW5MaXN0IiwiaXNEZXN0cm95ZWQiLCJpc1JlYWR5IiwicHJldldpZHRoIiwiX29uUmVzaXplIiwiZGVib3VuY2UiLCJyZWdpc3RlclBsdWdpbnMiLCJjcmVhdGVEcmF3ZXIiLCJjcmVhdGVCYWNrZW5kIiwiY3JlYXRlUGVha0NhY2hlIiwicGx1Z2luIiwiYWRkUGx1Z2luIiwiZGVmZXJJbml0IiwiaW5pdFBsdWdpbiIsImdldEFjdGl2ZVBsdWdpbnMiLCJwbHVnaW5TdGF0aWNQcm9wIiwiSW5zdGFuY2UiLCJvYnNlcnZlclByb3RvdHlwZUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVzdHJveVBsdWdpbiIsImRlc3Ryb3lBbGxQbHVnaW5zIiwiZHJhd0J1ZmZlciIsIm5ld1ZvbHVtZSIsInNldEN1cnJlbnRUaW1lIiwic2Vjb25kcyIsInBsYXlQYXVzZSIsImlzUGxheWluZyIsInNraXBCYWNrd2FyZCIsInNraXAiLCJza2lwRm9yd2FyZCIsInNlZWtBbmRDZW50ZXIiLCJfdGhpczgiLCJpc0Zpbml0ZSIsImlzV2ViQXVkaW9CYWNrZW5kIiwib2xkU2Nyb2xsUGFyZW50Iiwic3RvcCIsInRvZ2dsZU11dGUiLCJtdXRlIiwiZ2V0TXV0ZSIsImdldEZpbHRlcnMiLCJmaWx0ZXJzIiwidG9nZ2xlU2Nyb2xsIiwidG9nZ2xlSW50ZXJhY3Rpb24iLCJnZXRXYXZlQ29sb3IiLCJzZXRXYXZlQ29sb3IiLCJnZXRQcm9ncmVzc0NvbG9yIiwic2V0UHJvZ3Jlc3NDb2xvciIsImdldEJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmQiLCJnZXRDdXJzb3JDb2xvciIsInNldEN1cnNvckNvbG9yIiwiZ2V0SGVpZ2h0Iiwic2V0RmlsdGVyZWRDaGFubmVscyIsImNoYW5uZWxJbmRpY2VzIiwibmV3UmFuZ2VzIiwiem9vbSIsInB4UGVyU2VjIiwibG9hZEFycmF5QnVmZmVyIiwiX3RoaXM5IiwiZGVjb2RlQXJyYXlCdWZmZXIiLCJkYXRhIiwibG9hZERlY29kZWRCdWZmZXIiLCJsb2FkQmxvYiIsIl90aGlzMTAiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJlbXB0eSIsInByZWxvYWRJZ25vcmVSZWFzb25zIiwiYWN0aXZlUmVhc29ucyIsInJlYXNvbiIsIndhcm4iLCJqb2luIiwibG9hZEJ1ZmZlciIsImxvYWRNZWRpYUVsZW1lbnQiLCJfdGhpczExIiwiZ2V0QXJyYXlCdWZmZXIiLCJzZXRQZWFrcyIsInVybE9yRWx0IiwiX3RoaXMxMiIsImVyciIsIl90aGlzMTMiLCJfdGhpczE0IiwicmVxdWVzdCIsInBlcmNlbnRDb21wbGV0ZSIsImV4cG9ydFBDTSIsImFjY3VyYWN5Iiwibm9XaW5kb3ciLCJibG9iSlNPTiIsIkJsb2IiLCJKU09OIiwic3RyaW5naWZ5Iiwib2JqVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwib3BlbiIsInJldm9rZU9iamVjdFVSTCIsImV4cG9ydEltYWdlIiwiY2FuY2VsQWpheCIsImNhbmNlbCIsImFib3J0IiwiY2xlYXJUbXBFdmVudHMiLCJkaXNjb25uZWN0U291cmNlIiwiVkVSU0lPTiIsIl9kZWZpbmVQcm9wZXJ0eSIsIlBMQVlJTkciLCJQQVVTRUQiLCJGSU5JU0hFRCIsIl90aGlzJHN0YXRlQmVoYXZpb3JzIiwiX3RoaXMkc3RhdGVzIiwib2ZmbGluZUF1ZGlvQ29udGV4dCIsInN0YXRlQmVoYXZpb3JzIiwiYWRkT25BdWRpb1Byb2Nlc3MiLCJzdGFydFBvc2l0aW9uIiwiZ2V0UGxheWVkVGltZSIsInJlbW92ZU9uQXVkaW9Qcm9jZXNzIiwiZ2V0QXVkaW9Db250ZXh0IiwibGFzdFBsYXkiLCJzY2hlZHVsZWRQYXVzZSIsInN0YXRlcyIsImdhaW5Ob2RlIiwibWVyZ2VkUGVha3MiLCJvZmZsaW5lQWMiLCJzY3JpcHROb2RlIiwic291cmNlIiwic3BsaXRQZWFrcyIsInN0YXRlIiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiV2F2ZVN1cmZlckF1ZGlvQ29udGV4dCIsImdldE9mZmxpbmVBdWRpb0NvbnRleHQiLCJzYW1wbGVSYXRlIiwiV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQiLCJPZmZsaW5lQXVkaW9Db250ZXh0Iiwid2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCIsInNldFN0YXRlIiwic2V0TGVuZ3RoIiwiZGlzY29ubmVjdEZpbHRlcnMiLCJkaXNjb25uZWN0Iiwic2V0RmlsdGVyIiwic2V0RmlsdGVycyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwiY3JlYXRlU2NyaXB0UHJvY2Vzc29yIiwic2NyaXB0QnVmZmVyU2l6ZSIsImNyZWF0ZUphdmFTY3JpcHROb2RlIiwiZGVzdGluYXRpb24iLCJvbmF1ZGlvcHJvY2VzcyIsImNyZWF0ZUFuYWx5c2VyIiwiY3JlYXRlR2FpbiIsImNyZWF0ZUdhaW5Ob2RlIiwiYXVkaW8iLCJBdWRpbyIsImRlc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwic3JjT2JqZWN0Iiwic3RyZWFtIiwiZ2FpbiIsInNldFZhbHVlQXRUaW1lIiwiZXJyYmFjayIsImRlY29kZUF1ZGlvRGF0YSIsIm51bWJlck9mQ2hhbm5lbHMiLCJuZXdCdWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJzYW1wbGVTaXplIiwic2FtcGxlU3RlcCIsImNoYW4iLCJnZXRDaGFubmVsRGF0YSIsImNsb3NlQXVkaW9Db250ZXh0IiwiY3JlYXRlU291cmNlIiwiY3JlYXRlQnVmZmVyU291cmNlIiwibm90ZUdyYWluT24iLCJub3RlT2ZmIiwicmVzdW1lIiwiYWRqdXN0ZWRUaW1lIiwid2FpdCIsInRpbWVvdXQiLCJjb250ZXh0IiwidGltZXN0YW1wIiwibGF0ZXIiLCJEYXRlIiwibm93IiwiZGVib3VuY2VkIiwiY2FsbE5vdyIsImNsZWFyIiwiY2xlYXJUaW1lb3V0IiwiZmx1c2giLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJDdXJzb3JQbHVnaW4iLCJoaWRlT25CbHVyIiwib3BhY2l0eSIsImN1c3RvbVN0eWxlIiwiY3VzdG9tU2hvd1RpbWVTdHlsZSIsInNob3dUaW1lIiwiZm9sbG93Q3Vyc29yWSIsImZvcm1hdFRpbWVDYWxsYmFjayIsIl9vbk1vdXNlbW92ZSIsImZsaXAiLCJvdXRlcldpZHRoIiwiZGlzcGxheVRpbWUiLCJ1cGRhdGVDdXJzb3JQb3NpdGlvbiIsIl9vbk1vdXNlZW50ZXIiLCJzaG93Q3Vyc29yIiwiX29uTW91c2VsZWF2ZSIsImhpZGVDdXJzb3IiLCJjdXJzb3IiLCJtYXJnaW4iLCJ2aXNpYmlsaXR5IiwiaW5uZXJIVE1MIiwiZm9ybWF0VGltZSIsInhwb3MiLCJ5cG9zIiwic2Nyb2xsVGltZSIsInRpbWVWYWx1ZSIsImZvcm1hdFZhbHVlIiwidGV4dE9mZnNldCIsImN1cnNvclRpbWUiLCJzbGljZSIsImdldENvbXB1dGVkU3R5bGUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJfcmVnaW9uIiwib3duS2V5cyIsImVudW1lcmFibGVPbmx5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bSIsIl9vYmplY3RTcHJlYWQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZSIsIlJlZ2lvbiIsInNjcm9sbFdpZHRoUHJvcG9ydGlvbiIsIl9vbkJhY2tlbmRDcmVhdGVkIiwib3JpZW50YXRpb24iLCJlZGdlU2Nyb2xsV2lkdGgiLCJhZGQiLCJfb25SZWFkeSIsImVuYWJsZURyYWdTZWxlY3Rpb24iLCJ1cGRhdGVSZW5kZXIiLCJkaXNhYmxlRHJhZ1NlbGVjdGlvbiIsIndvdWxkRXhjZWVkTWF4UmVnaW9ucyIsIm1pbkxlbmd0aCIsInNjcm9sbCIsInNjcm9sbFNwZWVkIiwic2Nyb2xsVGhyZXNob2xkIiwiZHJhZyIsInRvdWNoSWQiLCJweE1vdmUiLCJzY3JvbGxEaXJlY3Rpb24iLCJ3cmFwcGVyUmVjdCIsImVkZ2VTY3JvbGwiLCJldmVudERvd24iLCJ0b3VjaGVzIiwiaWRlbnRpZmllciIsImV2ZW50VXAiLCJldmVudE1vdmUiLCJzdGFydFVwZGF0ZSIsImVuZFVwZGF0ZSIsImdldEN1cnJlbnRSZWdpb24iLCJjdXIiLCJzbmFwVG9HcmlkSW50ZXJ2YWwiLCJzbmFwVG9HcmlkT2Zmc2V0IiwiYWRkUmVnaW9uIiwiY2xlYXJSZWdpb25zIiwicmVnaW9uc1V0aWxzIiwiX3BhcmFtcyRzaG93VG9vbHRpcCIsInJlZ2lvbnNVdGlsIiwicmVzaXplIiwiaXNSZXNpemluZyIsImlzRHJhZ2dpbmciLCJoYW5kbGVTdHlsZSIsImhhbmRsZUxlZnRFbCIsImhhbmRsZVJpZ2h0RWwiLCJzaG93VG9vbHRpcCIsIm1heExlbmd0aCIsIl9vblJlZHJhdyIsInByZXZlbnRDb250ZXh0TWVudSIsImNoYW5uZWxJZHgiLCJyZWdpb25IZWlnaHQiLCJtYXJnaW5Ub3AiLCJjaGFubmVsQ291bnQiLCJiaW5kSW5PdXQiLCJyZW5kZXIiLCJ1cGRhdGVIYW5kbGVzUmVzaXplIiwicyIsInBsYXlMb29wIiwic2V0TG9vcCIsImNsYXNzTmFtZSIsInRpdGxlIiwic2V0QXR0cmlidXRlIiwiYXR0cm5hbWUiLCJoYW5kbGVMZWZ0Q3NzIiwiaGFuZGxlUmlnaHRDc3MiLCJiaW5kRXZlbnRzIiwiZHVyIiwic3RhcnRMaW1pdGVkIiwiZW5kTGltaXRlZCIsInJlZ2lvbldpZHRoIiwiZmlyZWRJbiIsImZpcmVkT3V0Iiwib25Qcm9jZXNzIiwicmVhbFRpbWUiLCJiaW5kRHJhZ0V2ZW50cyIsInVwZGF0ZWQiLCJyZWdpb25MZWZ0SGFsZlRpbWUiLCJyZWdpb25SaWdodEhhbGZUaW1lIiwiZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UiLCJyZWdpb25IYWxmVGltZVdpZHRoIiwiYWRqdXN0bWVudCIsIndyYXBwZXJTY3JvbGxMZWZ0IiwiY2FsY3VsYXRlZExlZnQiLCJjYWxjdWxhdGVkUmlnaHQiLCJkZWx0YSIsIm9uRHJhZyIsIm9uUmVzaXplIiwib25Eb3duIiwidGFnTmFtZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwib25VcCIsIm9uTW92ZSIsIm9sZFRpbWUiLCJtYXhFbmQiLCJwYXNzaXZlIiwiZGlyZWN0aW9uIiwiY3Vyc29yU3R5bGUiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztR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N3ZDcUMsRUFBM0I7QUE4dkNWO0FBQ0EsY0Fqd0N1QixDQWl3Q2I7QUFDVixjQUFVLElBQUkvQywyQkFBMkIsRUFBL0I7QUFDVjtBQUNBLGNBcHdDdUIsQ0Fvd0NiO0FBQ1YsY0FBVSxTQUFTanRCLG1CQUFULENBQTZCa3RCLFFBQTdCLEVBQXVDO0FBQ2pELGdCQURpRCxDQUN0QztBQUNYLGdCQUFXLElBQUlDLGVBQWVGLHlCQUF5QkMsUUFBekIsQ0FBbkI7QUFDWCxnQkFBVyxJQUFJQyxpQkFBaUI5M0IsU0FBckIsRUFBZ0M7QUFDM0Msa0JBQVksT0FBTzgzQixhQUFheDVCLE9BQXBCO0FBQ1o7QUFBWTtBQUNaLGdCQU5pRCxDQU10QztBQUNYLGdCQUFXLElBQUlELFNBQVN1NUIseUJBQXlCQyxRQUF6QixJQUFxQztBQUM3RCxrQkFENkQsQ0FDakQ7QUFDWixrQkFGNkQsQ0FFakQ7QUFDWixrQkFBWXY1QixTQUFTO0FBQ3JCLGtCQUo2RCxFQUFsRDtBQUtYO0FBQ0EsZ0JBYmlELENBYXRDO0FBQ1gsZ0JBQVdvTSxvQkFBb0JtdEIsUUFBcEIsRUFBOEJ4NUIsTUFBOUIsRUFBc0NBLE9BQU9DLE9BQTdDLEVBQXNEcU0sbUJBQXREO0FBQ1g7QUFDQSxnQkFoQmlELENBZ0J0QztBQUNYLGdCQUFXLE9BQU90TSxPQUFPQyxPQUFkO0FBQ1g7QUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBM3hDdUIsQ0EyeENiO0FBQ1YsY0E1eEN1QixDQTR4Q2I7QUFDVixjQTd4Q3VCLENBNnhDYjtBQUNWLGNBQVUsSUFBSXk1QixzQkFBc0JwdEIsb0JBQW9CLCtCQUFwQixDQUExQjtBQUNWO0FBQ0EsY0FBVSxPQUFPb3RCLG1CQUFQO0FBQ1Y7QUFBVSxLQWp5Q007QUFBaEI7QUFteUNDLENBN3lDRDtBQTh5Q0EsOEMiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGE5MjE2MWY0MjJiN2Q3NTBlMTE0IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsImltcG9ydCAnLi9zdHlsZXMvd2F2ZWZvcm0uY3NzJ1xyXG5pbXBvcnQgV2F2ZWZvcm1Jbml0IGZyb20gXCIuL3NjcmlwdHMvV2F2ZWZvcm1Jbml0XCI7XHJcblxyXG4vLyBMb2FkIGxpYnJhcnlcclxuSDVQID0gSDVQIHx8IHt9O1xyXG5INVBFZGl0b3Iud2lkZ2V0cy53YXZlZm9ybUluaXQgPSBINVBFZGl0b3IuV2F2ZWZvcm1Jbml0ID0gV2F2ZWZvcm1Jbml0O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kaXN0LmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy93YXZlZm9ybS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBhcmVudCBmcm9tICdoNXAtcGFyZW50JztcclxuaW1wb3J0IHtcclxuICBqUXVlcnkgYXMgJFxyXG59IGZyb20gJy4uL2dsb2JhbHMnO1xyXG5pbXBvcnQgV2F2ZVN1cmZlciBmcm9tICd3YXZlc3VyZmVyLmpzJztcclxuaW1wb3J0IEN1cnNvclBsdWdpbiBmcm9tIFwid2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qc1wiO1xyXG5pbXBvcnQgUmVnaW9uc1BsdWdpbiBmcm9tIFwid2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLnJlZ2lvbnMuanNcIjtcclxuXHJcbmxldCBXYXZlZm9ybUluaXQgPSBmdW5jdGlvbiAocGFyZW50LCBmaWVsZCwgcGFyYW1zLCBzZXRWYWx1ZSkge1xyXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICB0aGlzLnNldFZhbHVlID0gc2V0VmFsdWU7XHJcblxyXG4gIHRoaXMuaWQgPSBudWxsO1xyXG4gIHRoaXMuY3JBdWRpb0luZGV4ID0gMDtcclxuICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgdGhpcy5hdWRpb1BhcmFtcyA9IHRoaXMucGFyZW50LnBhcmVudC5wYXJlbnQucGFyYW1zLnBhcmFtcztcclxuICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMucGFyZW50LnBhcmFtcy5zdGFydER1cmF0aW9uICE9IHVuZGVmaW5lZCA/IHRoaXMucGFyZW50LnBhcmFtcy5zdGFydER1cmF0aW9uIDogMDtcclxuICB0aGlzLmVuZFRpbWUgPSB0aGlzLnBhcmVudC5wYXJhbXMuZW5kRHVyYXRpb24gIT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnQucGFyYW1zLmVuZER1cmF0aW9uIDogMC4yO1xyXG4gIHRoaXMuYXVkaW9EdXJhdGlvbjtcclxufVxyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYXZlZm9ybUluaXQ7XHJcblxyXG5XYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIHdhdmVmb3JtIGVkaXRvci5cclxuICogQHBhcmFtIHsqfSAkd3JhcHBlciBcclxuICovXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgaWYgKCFzZWxmLmNvbnRhaW5lciB8fCAoc2VsZi5jb250YWluZXIgJiYgc2VsZi5jb250YWluZXIubGVuZ3RoID09IDApKSByZXR1cm47XHJcbiAgdmFyIHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZSh7XHJcbiAgICBjb250YWluZXI6IHNlbGYuY29udGFpbmVyWzBdLFxyXG4gICAgd2F2ZUNvbG9yOiAnZ3JlZW4nLFxyXG4gICAgcHJvZ3Jlc3NDb2xvcjogJ2dyZXknLFxyXG4gICAgZmlsbFBhcmVudDogdHJ1ZSxcclxuICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICBiYXJIZWlnaHQ6IDgsXHJcbiAgICBwbHVnaW5zOiBbXHJcbiAgICAgIFJlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcclxuICAgICAgICByZWdpb25zTWluTGVuZ3RoOiAwLjEsXHJcbiAgICAgICAgbWF4UmVnaW9uczogMSxcclxuICAgICAgICByZWdpb25zOiBbe1xyXG4gICAgICAgICAgc3RhcnQ6IHNlbGYuc3RhcnRUaW1lLFxyXG4gICAgICAgICAgZW5kOiBzZWxmLmVuZFRpbWUsXHJcbiAgICAgICAgICBsb29wOiBmYWxzZSxcclxuICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTAsIDIwMywgMTEwLCAwLjUpJ1xyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIGRyYWdTZWxlY3Rpb246IHtcclxuICAgICAgICAgIHNsb3A6IDVcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICBdXHJcbiAgfSk7XHJcblxyXG4gICQoJy53YXZlc3VyZmVyLWhhbmRsZScpLmNzcyhcIndpZHRoXCIsIFwiNHB4XCIpO1xyXG4gICQoJy53YXZlc3VyZmVyLWhhbmRsZScpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjNzA3MDcwXCIpO1xyXG5cclxuICB0aGlzLnJlZ2lvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgc2VsZi5jckF1ZGlvSW5kZXggPSBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHMubGVuZ3RoO1xyXG4gIC8vIGxldCBwYXRoID0gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzW3NlbGYuY3JBdWRpb0luZGV4LSAxXS5wYXJhbXMuZmlsZXMgPyBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHNbc2VsZi5jckF1ZGlvSW5kZXggLSAxXS5wYXJhbXMuZmlsZXNbMF0ucGF0aCA6IHVuZGVmaW5lZDtcclxuICBsZXQgaWQgPSBINVBFZGl0b3IucmVuZGVyYWJsZUNvbW1vbkZpZWxkc1tcIkg1UC5DUkF1ZGlvIDEuNFwiXS5maWVsZHNbMF0ucGFyZW50LnBhcmFtcy5zdWJDb250ZW50SWQ7XHJcbiAgbGV0IHBhdGggPSBzZWxmLmF1ZGlvUGFyYW1zLmZpbGVzID8gc2VsZi5hdWRpb1BhcmFtcy5maWxlc1swXS5wYXRoIDogdW5kZWZpbmVkO1xyXG4gIC8vIGxldCBpZCA9ICBzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmFtcy5zdWJDb250ZW50SWQ7XHJcbiAgaWYgKHBhdGggIT0gdW5kZWZpbmVkICYmIGlkICE9IHVuZGVmaW5lZCkge1xyXG4gICAgbGV0IGZpbGUgPSBINVAuZ2V0UGF0aChwYXRoLCBpZCk7XHJcbiAgICAkLmdldChmaWxlKS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2F2ZXN1cmZlci5sb2FkKGZpbGUpO1xyXG4gICAgICB9LCAxMDAwKVxyXG4gICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGxldCBpZCA9IEg1UEVkaXRvci5jb250ZW50SWQ7XHJcbiAgICAgIGxldCBmaWxlID0gSDVQLmdldFBhdGgocGF0aCwgaWQpO1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3YXZlc3VyZmVyLmxvYWQoZmlsZSk7XHJcbiAgICAgIH0sIDEwMDApXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcblxyXG4gIHdhdmVzdXJmZXIub24oJ3JlYWR5JywgKCkgPT4ge1xyXG4gICAgdGhpcy5yZWdpb24gPSBPYmplY3QudmFsdWVzKHdhdmVzdXJmZXIucmVnaW9ucy5saXN0KVswXTtcclxuICAgIGxldCB3aWR0aCA9IHNlbGYucGFyZW50LnBhcmVudC5wYXJlbnQucGFyZW50LmNwLndpZHRoICsgKHNlbGYucGFyZW50LnBhcmVudC5wYXJlbnQucGFyZW50LmNwLndpZHRoICogMC4yNSk7XHJcbiAgICBzZWxmLmF1ZGlvRHVyYXRpb24gPSB3YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XHJcbiAgICAvLyB3YXZlc3VyZmVyLnBhcmFtcy5taW5QeFBlclNlYyA9IHdpZHRoIC8gd2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xyXG4gICAgLy8gd2F2ZXN1cmZlci5kcmF3QnVmZmVyKCk7XHJcblxyXG4gICAgLy8gbGV0IHJlZ2lvbklkID0gc2VsZi5pZCArIFwicGxheVJlZ2lvblwiXHJcbiAgICAvLyBsZXQgJHBsYXlSZWdpb25CdXR0b24gPSAnPGJ1dHRvbiBpZCA9ICcrIHJlZ2lvbklkICsnIGNsYXNzID0gXCJwbGF5UmVnaW9uXCI+UGxheTwvYnV0dG9uPidcclxuICAgIC8vICQoJyMnICsgc2VsZi5pZCkuZmluZCgnLndhdmVzdXJmZXItcmVnaW9uJykuYXBwZW5kKCRwbGF5UmVnaW9uQnV0dG9uKVxyXG4gICAgLy8gJCgnIycgKyByZWdpb25JZCkub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIC8vICAgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgLy8gICBpZiAocmVnaW9uICE9IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gICAgIHJlZ2lvbi5wbGF5KClcclxuICAgIC8vICAgfVxyXG4gICAgLy8gfSlcclxuICB9KTtcclxuXHJcbiAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBpZiAoc2VsZi5jb250YWluZXJbMF0pIHtcclxuICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byBzdGFydCBhbmQgZW5kIGR1cmF0aW9uIGZvciB0aGlzIHdhdmVzdXJmZXIgaW5zdGFuY2VcclxuICAgICAgbGV0IHdhdmVmb3JtID0gc2VsZi5jb250YWluZXJbMF07XHJcbiAgICAgIGxldCB3YXZlZm9ybVBhcmVudCA9IHdhdmVmb3JtLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuXHJcbiAgICAgIGxldCBzdGFydER1cmF0aW9uRmllbGQgPSB3YXZlZm9ybVBhcmVudC5xdWVyeVNlbGVjdG9yKCcuZmllbGQtbmFtZS1zdGFydER1cmF0aW9uJyk7XHJcbiAgICAgIGxldCBlbmREdXJhdGlvbkZpZWxkID0gd2F2ZWZvcm1QYXJlbnQucXVlcnlTZWxlY3RvcignLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKTtcclxuXHJcbiAgICAgIGlmIChzdGFydER1cmF0aW9uRmllbGQgJiYgZW5kRHVyYXRpb25GaWVsZCkge1xyXG4gICAgICAgIGxldCBzdGFydER1cmF0aW9uRmllbGRJbnB1dCA9IHN0YXJ0RHVyYXRpb25GaWVsZC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xyXG4gICAgICAgIGxldCBlbmREdXJhdGlvbkZpZWxkSW5wdXQgPSBlbmREdXJhdGlvbkZpZWxkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGZvY3Vzb3V0IGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgc3RhcnREdXJhdGlvbkZpZWxkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0RHVyYXRpb25WYWx1ZUNoYW5nZUhhbmRsZXIoZS50YXJnZXQudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgICBlbmREdXJhdGlvbkZpZWxkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmVuZER1cmF0aW9uVmFsdWVDaGFuZ2VIYW5kbGVyKGUudGFyZ2V0LnZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHZhbHVlcyBvZiBzdGFydCBkdXJhdGlvbiBhbmQgZW5kIGR1cmF0aW9uIGJhc2VkIG9uIHByZXZpb3VzXHJcbiAgICAgICAgLy8gd2F2ZWZvcm0gaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgbGV0IHdhdmVmb3JtRWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2F2ZWZvcm1cIik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YXZlZm9ybUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAod2F2ZWZvcm1FbGVtZW50c1tpXS5pZCA9PT0gc2VsZi5jb250YWluZXJbMF0uaWQgJiYgaSA+IDApIHtcclxuICAgICAgICAgICAgbGV0IHByZXZpb3VzV2F2ZWZvcm1Db250ZW50ID0gd2F2ZWZvcm1FbGVtZW50c1tpIC0gMV0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgcHJldmlvdXNFbmREdXJhdGlvbkZpZWxkID0gcHJldmlvdXNXYXZlZm9ybUNvbnRlbnQucXVlcnlTZWxlY3RvcignLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzRW5kRHVyYXRpb25GaWVsZCkge1xyXG4gICAgICAgICAgICAgIGxldCBwcmV2aW91c0VuZER1cmF0aW9uSW5wdXQgPSBwcmV2aW91c0VuZER1cmF0aW9uRmllbGQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuXHJcbiAgICAgICAgICAgICAgc3RhcnREdXJhdGlvbkZpZWxkSW5wdXQudmFsdWUgPSBwYXJzZUZsb2F0KHByZXZpb3VzRW5kRHVyYXRpb25JbnB1dC52YWx1ZSkgKyAwLjAwMTtcclxuICAgICAgICAgICAgICBlbmREdXJhdGlvbkZpZWxkSW5wdXQudmFsdWUgPSBwYXJzZUZsb2F0KHByZXZpb3VzRW5kRHVyYXRpb25JbnB1dC52YWx1ZSkgKyAwLjAwMSArIDAuMTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHVyYXRpb25WYWx1ZUNoYW5nZUhhbmRsZXIoc3RhcnREdXJhdGlvbkZpZWxkSW5wdXQudmFsdWUpO1xyXG4gICAgICAgICAgICAgIHRoaXMuZW5kRHVyYXRpb25WYWx1ZUNoYW5nZUhhbmRsZXIoZW5kRHVyYXRpb25GaWVsZElucHV0LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGF1ZGlvIGxvYWRlciBvYnNlcnZlciBvbiB0aGlzIHdhdmVzdXJmZXIgaW5zdGFuY2VcclxuICAgICAgbGV0IGZpbGVzRmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmllbGQtbmFtZS1maWxlc1wiKVswXTtcclxuICAgICAgaWYgKGZpbGVzRmllbGQpIHtcclxuICAgICAgICBsZXQgZmlsZXNMaXN0RWxlbWVudCA9IGZpbGVzRmllbGQucXVlcnlTZWxlY3RvcigndWwnKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xyXG5cclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgbGV0IGlkID0gSDVQRWRpdG9yLnJlbmRlcmFibGVDb21tb25GaWVsZHNbXCJINVAuQ1JBdWRpbyAxLjRcIl0uZmllbGRzW3NlbGYuY3JBdWRpb0luZGV4IC0gMV0ucGFyZW50LnBhcmFtcy5zdWJDb250ZW50SWQ7XHJcbiAgICAgICAgICBsZXQgcGF0aCA9IHNlbGYuYXVkaW9QYXJhbXMuZmlsZXMgPyBzZWxmLmF1ZGlvUGFyYW1zLmZpbGVzWzBdLnBhdGggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBpZiAocGF0aCAhPSB1bmRlZmluZWQgJiYgaWQgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlID0gSDVQLmdldFBhdGgocGF0aCwgaWQpO1xyXG4gICAgICAgICAgICAkLmdldChmaWxlKS5kb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHdhdmVzdXJmZXIubG9hZChmaWxlKTtcclxuICAgICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGlkID0gSDVQRWRpdG9yLmNvbnRlbnRJZDtcclxuICAgICAgICAgICAgICBsZXQgZmlsZSA9IEg1UC5nZXRQYXRoKHBhdGgsIGlkKTtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHdhdmVzdXJmZXIubG9hZChmaWxlKTtcclxuICAgICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGV0ICRzdGFydGlucHV0ID0gJCgnIycgKyB0aGlzLmlkKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuZmllbGQtbmFtZS1zdGFydER1cmF0aW9uJykuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgbGV0ICRlbmRpbnB1dCA9ICQoJyMnICsgdGhpcy5pZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtZW5kRHVyYXRpb24nKS5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgICAgICAkc3RhcnRpbnB1dC52YWwoMCk7XHJcbiAgICAgICAgICAgICRlbmRpbnB1dC52YWwoMC4yKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcInN0YXJ0RHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIDApO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuZmluZEZpZWxkKFwiZW5kRHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIDAuMik7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgICAgZW5kOiAwLjJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb24udXBkYXRlKHBhcmFtcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZmlsZXNMaXN0RWxlbWVudCwgb2JzZXJ2ZXJDb25maWcpO1xyXG5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIDIwMDApO1xyXG5cclxuICB3YXZlc3VyZmVyLm9uKCdyZWdpb24tdXBkYXRlZCcsIChldmVudCkgPT4ge1xyXG4gICAgdGhpcy5zdGFydCA9IGV2ZW50LnN0YXJ0O1xyXG4gICAgdGhpcy5lbmQgPSBldmVudC5lbmQ7XHJcbiAgICB0aGlzLiRzdGFydGlucHV0ID0gJCgnIycgKyB0aGlzLmlkKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuZmllbGQtbmFtZS1zdGFydER1cmF0aW9uJykuZmluZCgnaW5wdXQnKTtcclxuICAgIHRoaXMuJGVuZGlucHV0ID0gJCgnIycgKyB0aGlzLmlkKS5wYXJlbnQoKS5wYXJlbnQoKS5maW5kKCcuZmllbGQtbmFtZS1lbmREdXJhdGlvbicpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICB0aGlzLiRzdGFydGlucHV0LnZhbCh0aGlzLnN0YXJ0LnRvRml4ZWQoNCkpO1xyXG4gICAgdGhpcy4kZW5kaW5wdXQudmFsKHRoaXMuZW5kLnRvRml4ZWQoNCkpO1xyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmZpbmRGaWVsZChcInN0YXJ0RHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMuc3RhcnQudG9GaXhlZCg0KSk7XHJcbiAgICB0aGlzLnNldFZhbHVlKHRoaXMuZmluZEZpZWxkKFwiZW5kRHVyYXRpb25cIiwgdGhpcy5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMuZW5kLnRvRml4ZWQoNCkpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAodGhpcy5pZCAhPSBudWxsKSB7XHJcbiAgICBsZXQgcmVnaW9uSWQgPSB0aGlzLmlkICsgXCJwbGF5UmVnaW9uXCI7XHJcbiAgICBsZXQgJHBsYXlSZWdpb25CdXR0b24gPSAkKCc8YnV0dG9uIGlkID0gJyArIHJlZ2lvbklkICsgJyBjbGFzcyA9IFwicGxheVJlZ2lvblwiPlBsYXk8L2J1dHRvbj4nKTtcclxuICAgICQoc2VsZi5jb250YWluZXIpLnBhcmVudCgnZGl2JykuYXBwZW5kKCRwbGF5UmVnaW9uQnV0dG9uKTtcclxuICAgICQoJHBsYXlSZWdpb25CdXR0b24pLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMucmVnaW9uICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMucmVnaW9uLnBsYXkoKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuc3RhcnREdXJhdGlvblZhbHVlQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgaWYgKHRoaXMucmVnaW9uICE9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgaWYgKHBhcnNlRmxvYXQodmFsdWUpID4gdGhpcy5hdWRpb0R1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFsdWUgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGlucHV0U3RhcnRUaW1lID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgIGxldCBpbnB1dEVuZFRpbWUgPSB0aGlzLnJlZ2lvbi5lbmQgPD0gcGFyc2VGbG9hdCh2YWx1ZSkgPyBwYXJzZUZsb2F0KHZhbHVlKSArIDAuMiA6IHRoaXMucmVnaW9uLmVuZDtcclxuICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICBzdGFydDogaW5wdXRTdGFydFRpbWUudG9GaXhlZCg0KSxcclxuICAgICAgICBlbmQ6IGlucHV0RW5kVGltZS50b0ZpeGVkKDQpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucmVnaW9uLnVwZGF0ZShwYXJhbXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJCh0aGlzKS5wYXJlbnQoKS5maW5kKCcuaDVwLWVycm9ycycpLmFwcGVuZChcIjxwPlRoZSBlbnRlcmVkIHZhbHVlIG11c3QgYmUgTnVtYmVyIG5vdCBhbHBoYWJldDwvcD5cIilcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZW5kRHVyYXRpb25WYWx1ZUNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gIGlmICh0aGlzLnJlZ2lvbiAhPSB1bmRlZmluZWQpIHtcclxuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgIGlmIChwYXJzZUZsb2F0KHZhbHVlKSA+IHRoaXMuYXVkaW9EdXJhdGlvbikge1xyXG4gICAgICAgIHZhbHVlID0gc2VsZi5hdWRpb0R1cmF0aW9uIC0gMC4wNTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgaW5wdXRTdGFydFRpbWUgPSBwYXJzZUZsb2F0KHZhbHVlKSA8PSB0aGlzLnJlZ2lvbi5zdGFydCA/IDAgOiB0aGlzLnJlZ2lvbi5zdGFydDtcclxuICAgICAgbGV0IGlucHV0RW5kVGltZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgIHN0YXJ0OiBpbnB1dFN0YXJ0VGltZS50b0ZpeGVkKDQpLFxyXG4gICAgICAgIGVuZDogaW5wdXRFbmRUaW1lLnRvRml4ZWQoNClcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5yZWdpb24udXBkYXRlKHBhcmFtcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoJy5oNXAtZXJyb3JzJykuYXBwZW5kKFwiPHA+VGhlIGVudGVyZWQgdmFsdWUgbXVzdCBiZSBOdW1iZXIgbm90IGFscGhhYmV0PC9wPlwiKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGVuZCB0aGUgZmllbGQgdG8gdGhlIHdyYXBwZXIuXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtINVAualF1ZXJ5fSAkd3JhcHBlclxyXG4gKi9cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uICgkd3JhcHBlcikge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBjb25zdCBpZCA9IG5zLmdldE5leHRGaWVsZElkKHRoaXMuZmllbGQpO1xyXG4gIHZhciBodG1sID0gSDVQRWRpdG9yLmNyZWF0ZUZpZWxkTWFya3VwKHRoaXMuZmllbGQsICc8ZGl2IGNsYXNzPVwid2F2ZWZvcm1cIiBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cImg1cC1jb2xvci1waWNrZXJcIj4nLCBpZCk7XHJcbiAgc2VsZi4kaXRlbSA9IEg1UEVkaXRvci4kKGh0bWwpO1xyXG4gIHRoaXMuc2V0SWQoaWQpO1xyXG4gIGxldCB3b3JkVGV4dCA9ICh0aGlzLnBhcmVudC5wYXJhbXMudGV4dCAhPSB1bmRlZmluZWQpID8gdGhpcy5wYXJlbnQucGFyYW1zLnRleHQgOiAnJ1xyXG4gICR3cmFwcGVyLmFwcGVuZCgnPGgxIGNsYXNzPVwidGVzdFwiPlNlbGVjdCB3b3JkKHMpPC9oMT4nKVxyXG4gIC8vICR3cmFwcGVyLmFwcGVuZCgnPGxhYmVsIGNsYXNzPVwiaDVwZWRpdG9yLWxhYmVsXCI+PGlucHV0IGlkPVwiZmllbGQtd29yZHMtMTI1XCIgdHlwZT1cImNoZWNrYm94XCI+V2lsbCBEbyBBbmltYXRpb248L2xhYmVsPicpXHJcbiAgLy9sZXQgY2hlY2tCb3hFbGVtZW50Rm9yV29yZD0kd3JhcHBlci5hcHBlbmQodGhpcy5nZXRTZW50ZW5jZShzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC5zbGlkZXMsc2VsZi5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQuY3AuY3VycmVudFNsaWRlSW5kZXgpKVxyXG4gIGxldCBzbGlkZXMgPSBzZWxmLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudC5jcC5zbGlkZXM7XHJcbiAgbGV0IHNsaWRlSW5kZXggPSB0aGlzLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmFtcy5wYXJhbXMuY3VyckluZGV4O1xyXG4gIGxldCBwYXJhbVRleHQgPSB0aGlzLnBhcmVudC5wYXJhbXMudGV4dDtcclxuICBsZXQgY2hlY2tCb3hFbGVtZW50Rm9yV29yZCA9ICR3cmFwcGVyLmFwcGVuZCh0aGlzLmdldFNlbnRlbmNlKHNsaWRlcywgc2xpZGVJbmRleCwgcGFyYW1UZXh0KSk7XHJcbiAgc2VsZi4kaXRlbS5hcHBlbmRUbygkd3JhcHBlcik7XHJcbiAgc2VsZi5jb250YWluZXIgPSBzZWxmLiRpdGVtLmZpbmQoJyMnICsgdGhpcy5pZCk7XHJcbiAgY29uc29sZS5sb2coY2hlY2tCb3hFbGVtZW50Rm9yV29yZCk7XHJcbiAgJChjaGVja0JveEVsZW1lbnRGb3JXb3JkKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQpO1xyXG4gICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0LmlkKTtcclxuICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldC52YWx1ZSk7XHJcbiAgICBsZXQgaXNBbHJlYWR5VXNlZCA9IHNlbGYuY2hlY2tJZldvcmRJc1VzZWRJbk90aGVyV2F2ZWZvcm0oc2xpZGVJbmRleCwgZXZlbnQudGFyZ2V0LmlkKTtcclxuICAgIGlmICgkKCcjJyArIGV2ZW50LnRhcmdldC5pZCkuaXMoJzpjaGVja2VkJykpIHtcclxuICAgICAgaWYgKGlzQWxyZWFkeVVzZWQpIHtcclxuICAgICAgICAkKCcjJyArIGV2ZW50LnRhcmdldC5pZCkuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3b3JkVGV4dCA9IHdvcmRUZXh0ICsgJyAnICsgZXZlbnQudGFyZ2V0LnZhbHVlICsgJyAnO1xyXG4gICAgICAgICQoJyMnICsgZXZlbnQudGFyZ2V0LmlkKS5hdHRyKCdjaGVja2VkJywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy4kd29yZCA9ICQoJyMnICsgaWQpLnBhcmVudCgpLnBhcmVudCgpLmZpbmQoJy5maWVsZC1uYW1lLXRleHQnKS5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgIHRoaXMuJHdvcmQudmFsKCh3b3JkVGV4dC50cmltKCkpLnJlcGxhY2UoLyAgKy9nLCAnICcpKTtcclxuICAgICAgICAkKHRoaXMuJHdvcmQpLmF0dHIoJ2NoZWNrZWQnLCB0cnVlKTtcclxuICAgICAgICBzZWxmLnNldFZhbHVlKHNlbGYuZmluZEZpZWxkKFwidGV4dFwiLCBzZWxmLnBhcmVudC5maWVsZC5maWVsZHMpLCBcIlwiICsgd29yZFRleHQucmVwbGFjZSgvICArL2csICcgJykpO1xyXG4gICAgICAgIFdhdmVmb3JtSW5pdC5wYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlW3NsaWRlSW5kZXgudG9TdHJpbmcoKV0ucHVzaCh7J2luZGV4JzogZXZlbnQudGFyZ2V0LmlkLnNwbGl0KCdfJylbMV0sICdpZCc6IGV2ZW50LnRhcmdldC5pZH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkKCcjJyArIGV2ZW50LnRhcmdldC5pZCkuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgbGV0IHRlbXBXb3JkVGV4dCA9IHdvcmRUZXh0LnJlcGxhY2UoZXZlbnQudGFyZ2V0LnZhbHVlLCAnJyk7XHJcbiAgICAgIHdvcmRUZXh0ID0gdGVtcFdvcmRUZXh0O1xyXG4gICAgICB0aGlzLiR3b3JkID0gJCgnIycgKyBpZCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmZpZWxkLW5hbWUtdGV4dCcpLmZpbmQoJ2lucHV0Jyk7XHJcbiAgICAgIHNlbGYuc2V0VmFsdWUoc2VsZi5maW5kRmllbGQoXCJ0ZXh0XCIsIHNlbGYucGFyZW50LmZpZWxkLmZpZWxkcyksIFwiXCIgKyB3b3JkVGV4dC5yZXBsYWNlKC8gICsvZywgJyAnKSk7XHJcbiAgICAgICQodGhpcy4kd29yZCkuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgdGhpcy4kd29yZC52YWwoKHdvcmRUZXh0LnRyaW0oKSkucmVwbGFjZSgvICArL2csICcgJykpO1xyXG4gICAgICBXYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZVtzbGlkZUluZGV4LnRvU3RyaW5nKCldID0gV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2Vbc2xpZGVJbmRleC50b1N0cmluZygpXS5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2JqLmlkID09PSBldmVudC50YXJnZXQuaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coV2F2ZWZvcm1Jbml0LnBhZ2VCYXNlZFdvcmRJbmRpY2VzVXNlZEluU2VudGVuY2UpO1xyXG4gIH0pXHJcbiAgc2VsZi5zZXRWYWx1ZShzZWxmLmZpbmRGaWVsZChcInRleHRcIiwgc2VsZi5wYXJlbnQuZmllbGQuZmllbGRzKSwgXCJcIiArIHRoaXMucGFyZW50LnBhcmFtcy50ZXh0KTtcclxuICBzZWxmLmluaXQoKTtcclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuY2hlY2tJZldvcmRJc1VzZWRJbk90aGVyV2F2ZWZvcm0gPSBmdW5jdGlvbiAoc2xpZGVJbmRleCwgaW5wdXRJZCkge1xyXG4gIGxldCBzbGlkZUNoZWNrYm94SW5mbyA9IFdhdmVmb3JtSW5pdC5wYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlW3NsaWRlSW5kZXgudG9TdHJpbmcoKV07XHJcbiAgbGV0IHdvcmRJbmRleCA9IHBhcnNlSW50KGlucHV0SWQuc3BsaXQoJ18nKVsxXSk7XHJcbiAgaWYgKHNsaWRlQ2hlY2tib3hJbmZvICE9PSBudWxsICYmIHNsaWRlQ2hlY2tib3hJbmZvICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVDaGVja2JveEluZm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHNsaWRlQ2hlY2tib3hJbmZvW2ldLmluZGV4ID09PSB3b3JkSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBXYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZVtzbGlkZUluZGV4LnRvU3RyaW5nKCldID0gW107XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5maW5kRmllbGQgPSBmdW5jdGlvbiAobmFtZSwgZmllbGRzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChmaWVsZHNbaV0ubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICByZXR1cm4gZmllbGRzW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICB0aGlzLmlkID0gaWQ7XHJcbn1cclxuXHJcbldhdmVmb3JtSW5pdC5wcm90b3R5cGUuZmluZEZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIGZpZWxkcykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoZmllbGRzW2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIGZpZWxkc1tpXTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIC8vIHRoaXMuaGlkZSgpO1xyXG4gIC8vIHJldHVybiAodGhpcy5wYXJhbXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmFtcy5sZW5ndGggIT09IDApO1xyXG59O1xyXG5cclxuV2F2ZWZvcm1Jbml0LnByb3RvdHlwZS5nZXRTZW50ZW5jZSA9IGZ1bmN0aW9uIChzbGlkZXMsIHNsaWRlSW5kZXgsIHByZXZEYXRhKSB7XHJcbiAgdmFyIHNlbnRlbmNlV29yZHMgPSBbXTtcclxuICB2YXIgc3BsaXR0ZWRQcmV2RGF0YSA9IChwcmV2RGF0YSAhPSB1bmRlZmluZWQpID8gcHJldkRhdGEuc3BsaXQoJyAnKSA6IFtdO1xyXG4gIGxldCBhbHJlYWR5Rm91bmRTcGxpdHRlZFByZXZEYXRhV29yZCA9IGZhbHNlO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc1tzbGlkZUluZGV4XS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHNsaWRlc1tzbGlkZUluZGV4XS5lbGVtZW50c1tpXS5hY3Rpb24ubGlicmFyeS5zcGxpdCgnICcpWzBdID09IFwiSDVQLkNSQWR2YW5jZWRUZXh0XCIpIHtcclxuICAgICAgdmFyIGNoZWNrQm94V29yZCA9ICcnO1xyXG4gICAgICBzZW50ZW5jZVdvcmRzID0gJChzbGlkZXNbc2xpZGVJbmRleF0uZWxlbWVudHNbaV0uYWN0aW9uLnBhcmFtcy50ZXh0KVswXS5pbm5lclRleHQuc3BsaXQoJyAnKTtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZW50ZW5jZVdvcmRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IChzcGxpdHRlZFByZXZEYXRhLmluZGV4T2Yoc2VudGVuY2VXb3Jkc1tqXSkgIT09IC0xKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICBpZiAoc2VudGVuY2VXb3Jkc1tqXS5yZXBsYWNlKC8gICsvZywgJyAnKSAhPSAnJykge1xyXG4gICAgICAgICAgaWYgKGRlZiAmJiAhYWxyZWFkeUZvdW5kU3BsaXR0ZWRQcmV2RGF0YVdvcmQgJiYgIXRoaXMuY2hlY2tJZldvcmRJc1VzZWRJbk90aGVyV2F2ZWZvcm0oc2xpZGVJbmRleCwgdGhpcy5pZCArIGopKSB7XHJcbiAgICAgICAgICAgIGNoZWNrQm94V29yZCA9IGNoZWNrQm94V29yZCArICc8bGFiZWwgY2xhc3M9XCJoNXBlZGl0b3ItbGFiZWwgaWQgPScgKyB0aGlzLmlkICsgaiArICdcIj48aW5wdXQgaWQ9JyArIHRoaXMuaWQgKyBcIl9cIiArIGogKyAnIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiJyArIHNlbnRlbmNlV29yZHNbal0gKyAnXCJjaGVja2VkPicgKyBzZW50ZW5jZVdvcmRzW2pdICsgJzwvbGFiZWw+JztcclxuICAgICAgICAgICAgYWxyZWFkeUZvdW5kU3BsaXR0ZWRQcmV2RGF0YVdvcmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBXYXZlZm9ybUluaXQucGFnZUJhc2VkV29yZEluZGljZXNVc2VkSW5TZW50ZW5jZVtzbGlkZUluZGV4LnRvU3RyaW5nKCldLnB1c2goe1wiaW5kZXhcIjogaiwgXCJpZFwiOiB0aGlzLmlkICsgan0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hlY2tCb3hXb3JkID0gY2hlY2tCb3hXb3JkICsgJzxsYWJlbCBjbGFzcz1cImg1cGVkaXRvci1sYWJlbCBpZCA9JyArIHRoaXMuaWQgKyBqICsgJ1wiPjxpbnB1dCBpZD0nICsgdGhpcy5pZCArIFwiX1wiICsgaiArICcgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCInICsgc2VudGVuY2VXb3Jkc1tqXSArICdcIj4nICsgc2VudGVuY2VXb3Jkc1tqXSArICc8L2xhYmVsPic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnNvbGUubG9nKFdhdmVmb3JtSW5pdC5wYWdlQmFzZWRXb3JkSW5kaWNlc1VzZWRJblNlbnRlbmNlKTtcclxuICByZXR1cm4gY2hlY2tCb3hXb3JkO1xyXG59XHJcblxyXG5XYXZlZm9ybUluaXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IFdhdmVmb3JtSW5pdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL1dhdmVmb3JtSW5pdC5qcyIsImNvbnN0IENoaWxkID0gcmVxdWlyZSgnLi9jaGlsZC5qcycpO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXIgPSBINVAuRXZlbnREaXNwYXRjaGVyO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gUGFyZW50KGNvbnN0cnVjdG9yLCBwYXJhbWV0ZXJzKSB7XHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnREaXNwYXRjaGVyLmNhbGwoc2VsZik7XHJcblxyXG4gIHNlbGYuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBpbmRleGVzIG9mIHRoZSBjaGlsZHJlbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gV2hlcmUgdG8gc3RhcnRcclxuICAgKi9cclxuICB2YXIgdXBkYXRlSW5kZXhlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XHJcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHNlbGYuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2VsZi5jaGlsZHJlbltpXS5pbmRleCA9IGk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZSBhIG5ldyBjaGlsZCB0byB0aGlzIHBhcmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRQYXJhbWV0ZXJzIExhdW5jaCBwYXJhbWV0ZXJzXHJcbiAgICovXHJcbiAgc2VsZi5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZFBhcmFtZXRlcnMsIGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpbmRleCA9IHNlbGYuY2hpbGRyZW4ubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNoaWxkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2UgYXMgaXRzIHBhcmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2hpbGQoaW5kZXgsIHNlbGYpO1xyXG5cclxuICAgIGlmIChpbmRleCA9PT0gc2VsZi5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgLy8gQWRkZWQgYXQgdGhlIGVuZFxyXG4gICAgICBzZWxmLmNoaWxkcmVuLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIEluc2VydGVkIGF0IGEgc3BlY2lmaWMgbG9jYXRpb25cclxuICAgICAgc2VsZi5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGluc3RhbmNlKTtcclxuICAgICAgdXBkYXRlSW5kZXhlcyhpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUnVuIG9yaWdpbmFsIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBjaGlsZFBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmEgYSBuZXcgY2hpbGQgZnJvbSBpdHMgcGFyZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgc2VsZi5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgLy8gUmVtb3ZlIGZyb20gYXJyYXlcclxuICAgIHNlbGYuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgaW5kZXhlc1xyXG4gICAgdXBkYXRlSW5kZXhlcyhpbmRleCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgY2hpbGQgaW50byBhIG5ldyBwb3NpdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZEluZGV4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4XHJcbiAgICovXHJcbiAgc2VsZi5tb3ZlQ2hpbGQgPSBmdW5jdGlvbiAob2xkSW5kZXgsIG5ld0luZGV4KSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IHNlbGYuY2hpbGRyZW4uc3BsaWNlKG9sZEluZGV4LCAxKVswXTtcclxuICAgIHNlbGYuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBjaGlsZCk7XHJcblxyXG4gICAgdXBkYXRlSW5kZXhlcyhuZXdJbmRleCA8IG9sZEluZGV4ID8gbmV3SW5kZXggOiBvbGRJbmRleCk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHBhcmFtZXRlcnMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzZWxmLmFkZENoaWxkKHBhcmFtZXRlcnNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuUGFyZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSk7XHJcblBhcmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmVudDtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL3BhcmVudC5qcyIsIi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIENoaWxkKGluZGV4LCBwYXJlbnQpIHtcclxuICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgc2VsZi5pbmRleCA9IGluZGV4O1xyXG4gIHNlbGYucGFyZW50ID0gcGFyZW50O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaDVwLXBhcmVudC9zcmMvY2hpbGQuanMiLCJleHBvcnQgY29uc3QgalF1ZXJ5ID0gSDVQLmpRdWVyeTtcclxuZXhwb3J0IGNvbnN0IEV2ZW50RGlzcGF0Y2hlciA9IEg1UC5FdmVudERpc3BhdGNoZXI7XHJcbmV4cG9ydCBjb25zdCBKb3ViZWxVSSA9IEg1UC5Kb3ViZWxVSTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZ2xvYmFscy5qcyIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyA1LjEuMCAoMjAyMS0wNi0yMClcbiAqIGh0dHBzOi8vd2F2ZXN1cmZlci1qcy5vcmdcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIldhdmVTdXJmZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiV2F2ZVN1cmZlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJXYXZlU3VyZmVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvZHJhd2VyLmNhbnZhc2VudHJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kcmF3ZXIuY2FudmFzZW50cnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvc3R5bGUgKi8gXCIuL3NyYy91dGlsL3N0eWxlLmpzXCIpKTtcblxudmFyIF9nZXRJZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2dldC1pZCAqLyBcIi4vc3JjL3V0aWwvZ2V0LWlkLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIFRoZSBgQ2FudmFzRW50cnlgIGNsYXNzIHJlcHJlc2VudHMgYW4gZWxlbWVudCBjb25zaXN0aW5nIG9mIGEgd2F2ZSBgY2FudmFzYFxuICogYW5kIGFuIChvcHRpb25hbCkgcHJvZ3Jlc3Mgd2F2ZSBgY2FudmFzYC5cbiAqXG4gKiBUaGUgYE11bHRpQ2FudmFzYCByZW5kZXJlciB1c2VzIG9uZSBvciBtb3JlIGBDYW52YXNFbnRyeWAgaW5zdGFuY2VzIHRvXG4gKiByZW5kZXIgYSB3YXZlZm9ybSwgZGVwZW5kaW5nIG9uIHRoZSB6b29tIGxldmVsLlxuICovXG52YXIgQ2FudmFzRW50cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYW52YXNFbnRyeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzRW50cnkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdhdmUgbm9kZVxuICAgICAqXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMud2F2ZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogVGhlIHdhdmUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuXG4gICAgdGhpcy53YXZlQ3R4ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgKG9wdGlvbmFsKSBwcm9ncmVzcyB3YXZlIG5vZGVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMucHJvZ3Jlc3MgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSAob3B0aW9uYWwpIHByb2dyZXNzIHdhdmUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9ncmVzc0N0eCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU3RhcnQgb2YgdGhlIGFyZWEgdGhlIGNhbnZhcyBzaG91bGQgcmVuZGVyLCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAvKipcbiAgICAgKiBFbmQgb2YgdGhlIGFyZWEgdGhlIGNhbnZhcyBzaG91bGQgcmVuZGVyLCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmVuZCA9IDE7XG4gICAgLyoqXG4gICAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZW50cnlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLmlkID0gKDAsIF9nZXRJZC5kZWZhdWx0KSh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICE9PSAndW5kZWZpbmVkJyA/IHRoaXMuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpICsgJ18nIDogJ2NhbnZhc2VudHJ5XycpO1xuICAgIC8qKlxuICAgICAqIENhbnZhcyAyZCBjb250ZXh0IGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG5cbiAgICB0aGlzLmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSB3YXZlIGNhbnZhcyBlbGVtZW50IGFuZCBjcmVhdGUgdGhlIDJEIHJlbmRlcmluZyBjb250ZXh0XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnQgVGhlIHdhdmUgYGNhbnZhc2AgZWxlbWVudC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2FudmFzRW50cnksIFt7XG4gICAga2V5OiBcImluaXRXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRXYXZlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMud2F2ZSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLndhdmVDdHggPSB0aGlzLndhdmUuZ2V0Q29udGV4dCgnMmQnLCB0aGlzLmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIHByb2dyZXNzIHdhdmUgY2FudmFzIGVsZW1lbnQgYW5kIGNyZWF0ZSB0aGUgMkQgcmVuZGVyaW5nXG4gICAgICogY29udGV4dFxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCBUaGUgcHJvZ3Jlc3Mgd2F2ZSBgY2FudmFzYCBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQcm9ncmVzcyhlbGVtZW50KSB7XG4gICAgICB0aGlzLnByb2dyZXNzID0gZWxlbWVudDtcbiAgICAgIHRoaXMucHJvZ3Jlc3NDdHggPSB0aGlzLnByb2dyZXNzLmdldENvbnRleHQoJzJkJywgdGhpcy5jYW52YXNDb250ZXh0QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGltZW5zaW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVsZW1lbnRXaWR0aCBXaWR0aCBvZiB0aGUgZW50cnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxXaWR0aCBUb3RhbCB3aWR0aCBvZiB0aGUgbXVsdGkgY2FudmFzIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbnMoZWxlbWVudFdpZHRoLCB0b3RhbFdpZHRoLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyB3aGVyZSB0aGUgY2FudmFzIHN0YXJ0cyBhbmQgZW5kcyBpbiB0aGUgd2F2ZWZvcm0sIHJlcHJlc2VudGVkIGFzIGFcbiAgICAgIC8vIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy53YXZlLm9mZnNldExlZnQgLyB0b3RhbFdpZHRoIHx8IDA7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyBlbGVtZW50V2lkdGggLyB0b3RhbFdpZHRoOyAvLyBzZXQgd2F2ZSBjYW52YXMgZGltZW5zaW9uc1xuXG4gICAgICB0aGlzLndhdmUud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMud2F2ZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgZWxlbWVudFNpemUgPSB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50V2lkdGggKyAncHgnXG4gICAgICB9O1xuICAgICAgKDAsIF9zdHlsZS5kZWZhdWx0KSh0aGlzLndhdmUsIGVsZW1lbnRTaXplKTtcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgLy8gc2V0IHByb2dyZXNzIGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMucHJvZ3Jlc3Mud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICgwLCBfc3R5bGUuZGVmYXVsdCkodGhpcy5wcm9ncmVzcywgZWxlbWVudFNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgd2F2ZSBhbmQgcHJvZ3Jlc3MgcmVuZGVyaW5nIGNvbnRleHRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhcldhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJXYXZlKCkge1xuICAgICAgLy8gd2F2ZVxuICAgICAgdGhpcy53YXZlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndhdmVDdHguY2FudmFzLndpZHRoLCB0aGlzLndhdmVDdHguY2FudmFzLmhlaWdodCk7IC8vIHByb2dyZXNzXG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMucHJvZ3Jlc3NDdHguY2FudmFzLndpZHRoLCB0aGlzLnByb2dyZXNzQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbGwgc3R5bGVzIGZvciB3YXZlIGFuZCBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhdmVDb2xvciBGaWxsIGNvbG9yIGZvciB0aGUgd2F2ZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHByb2dyZXNzQ29sb3IgRmlsbCBjb2xvciBmb3IgdGhlIHByb2dyZXNzIGNhbnZhc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsbFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWxsU3R5bGVzKHdhdmVDb2xvciwgcHJvZ3Jlc3NDb2xvcikge1xuICAgICAgdGhpcy53YXZlQ3R4LmZpbGxTdHlsZSA9IHdhdmVDb2xvcjtcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0N0eC5maWxsU3R5bGUgPSBwcm9ncmVzc0NvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbnZhcyB0cmFuc2Zvcm1zIGZvciB3YXZlIGFuZCBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2ZXJ0aWNhbCBXaGV0aGVyIHRvIHJlbmRlciB2ZXJ0aWNhbGx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUNhbnZhc1RyYW5zZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlDYW52YXNUcmFuc2Zvcm1zKHZlcnRpY2FsKSB7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgLy8gUmVmbGVjdCB0aGUgd2F2ZWZvcm0gYWNyb3NzIHRoZSBsaW5lIHkgPSAteFxuICAgICAgICB0aGlzLndhdmVDdHguc2V0VHJhbnNmb3JtKDAsIDEsIDEsIDAsIDAsIDApO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgICAgdGhpcy5wcm9ncmVzc0N0eC5zZXRUcmFuc2Zvcm0oMCwgMSwgMSwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJlY3RhbmdsZSBmb3Igd2F2ZSBhbmQgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbFJlY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxSZWN0cyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgIHRoaXMuZmlsbFJlY3RUb0NvbnRleHQodGhpcy53YXZlQ3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuXG4gICAgICBpZiAodGhpcy5oYXNQcm9ncmVzc0NhbnZhcykge1xuICAgICAgICB0aGlzLmZpbGxSZWN0VG9Db250ZXh0KHRoaXMucHJvZ3Jlc3NDdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGFjdHVhbCByZWN0YW5nbGUgb24gYSBgY2FudmFzYCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFJlbmRlcmluZyBjb250ZXh0IG9mIHRhcmdldCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbGxSZWN0VG9Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxSZWN0VG9Db250ZXh0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyYWRpdXMpIHtcbiAgICAgICAgdGhpcy5kcmF3Um91bmRlZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcm91bmRlZCByZWN0YW5nbGUgb24gQ2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENhbnZhcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWC1wb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS1wb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAZXhhbXBsZSBkcmF3Um91bmRlZFJlY3QoY3R4LCA1MCwgNTAsIDUsIDEwLCAzKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1JvdW5kZWRSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSb3VuZGVkUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgICAgaWYgKGhlaWdodCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHBlYWtzIGFyZSBmbG9hdCB2YWx1ZXMgZnJvbSAtMSB0byAxLiBVc2UgYWJzb2x1dGUgaGVpZ2h0IHZhbHVlcyBpblxuICAgICAgLy8gb3JkZXIgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSByb3VuZGVkIHJlY3RhbmdsZSBjb29yZGluYXRlc1xuXG5cbiAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIGhlaWdodCAqPSAtMTtcbiAgICAgICAgeSAtPSBoZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGFjdHVhbCB3YXZlIGFuZCBwcm9ncmVzcyBsaW5lc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGVha3MgQXJyYXkgd2l0aCBwZWFrcyBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFic21heCBNYXhpbXVtIHBlYWsgdmFsdWUgKGFic29sdXRlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYWxmSCBIYWxmIHRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgT2Zmc2V0IHRvIHRoZSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xpbmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lcyhwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5kcmF3TGluZVRvQ29udGV4dCh0aGlzLndhdmVDdHgsIHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgdGhpcy5kcmF3TGluZVRvQ29udGV4dCh0aGlzLnByb2dyZXNzQ3R4LCBwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgYWN0dWFsIHdhdmVmb3JtIGxpbmUgb24gYSBgY2FudmFzYCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFJlbmRlcmluZyBjb250ZXh0IG9mIHRhcmdldCBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwZWFrcyBBcnJheSB3aXRoIHBlYWtzIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWJzbWF4IE1heGltdW0gcGVhayB2YWx1ZSAoYWJzb2x1dGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbGZIIEhhbGYgdGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBPZmZzZXQgdG8gdGhlIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGluZVRvQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGluZVRvQ29udGV4dChjdHgsIHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBwZWFrcy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGZpcnN0ID0gTWF0aC5yb3VuZChsZW5ndGggKiB0aGlzLnN0YXJ0KTsgLy8gdXNlIG9uZSBtb3JlIHBlYWsgdmFsdWUgdG8gbWFrZSBzdXJlIHdlIGpvaW4gcGVha3MgYXQgZW5kcyAtLSB1bmxlc3MsXG4gICAgICAvLyBvZiBjb3Vyc2UsIHRoaXMgaXMgdGhlIGxhc3QgY2FudmFzXG5cbiAgICAgIHZhciBsYXN0ID0gTWF0aC5yb3VuZChsZW5ndGggKiB0aGlzLmVuZCkgKyAxO1xuICAgICAgdmFyIGNhbnZhc1N0YXJ0ID0gZmlyc3Q7XG4gICAgICB2YXIgY2FudmFzRW5kID0gbGFzdDtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMud2F2ZS53aWR0aCAvIChjYW52YXNFbmQgLSBjYW52YXNTdGFydCAtIDEpOyAvLyBvcHRpbWl6YXRpb25cblxuICAgICAgdmFyIGhhbGZPZmZzZXQgPSBoYWxmSCArIG9mZnNldFk7XG4gICAgICB2YXIgYWJzbWF4SGFsZiA9IGFic21heCAvIGhhbGZIO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygoY2FudmFzU3RhcnQgLSBmaXJzdCkgKiBzY2FsZSwgaGFsZk9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKChjYW52YXNTdGFydCAtIGZpcnN0KSAqIHNjYWxlLCBoYWxmT2Zmc2V0IC0gTWF0aC5yb3VuZCgocGVha3NbMiAqIGNhbnZhc1N0YXJ0XSB8fCAwKSAvIGFic21heEhhbGYpKTtcbiAgICAgIHZhciBpLCBwZWFrLCBoO1xuXG4gICAgICBmb3IgKGkgPSBjYW52YXNTdGFydDsgaSA8IGNhbnZhc0VuZDsgaSsrKSB7XG4gICAgICAgIHBlYWsgPSBwZWFrc1syICogaV0gfHwgMDtcbiAgICAgICAgaCA9IE1hdGgucm91bmQocGVhayAvIGFic21heEhhbGYpO1xuICAgICAgICBjdHgubGluZVRvKChpIC0gZmlyc3QpICogc2NhbGUgKyB0aGlzLmhhbGZQaXhlbCwgaGFsZk9mZnNldCAtIGgpO1xuICAgICAgfSAvLyBkcmF3IHRoZSBib3R0b20gZWRnZSBnb2luZyBiYWNrd2FyZHMsIHRvIG1ha2UgYSBzaW5nbGVcbiAgICAgIC8vIGNsb3NlZCBodWxsIHRvIGZpbGxcblxuXG4gICAgICB2YXIgaiA9IGNhbnZhc0VuZCAtIDE7XG5cbiAgICAgIGZvciAoajsgaiA+PSBjYW52YXNTdGFydDsgai0tKSB7XG4gICAgICAgIHBlYWsgPSBwZWFrc1syICogaiArIDFdIHx8IDA7XG4gICAgICAgIGggPSBNYXRoLnJvdW5kKHBlYWsgLyBhYnNtYXhIYWxmKTtcbiAgICAgICAgY3R4LmxpbmVUbygoaiAtIGZpcnN0KSAqIHNjYWxlICsgdGhpcy5oYWxmUGl4ZWwsIGhhbGZPZmZzZXQgLSBoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVUbygoY2FudmFzU3RhcnQgLSBmaXJzdCkgKiBzY2FsZSwgaGFsZk9mZnNldCAtIE1hdGgucm91bmQoKHBlYWtzWzIgKiBjYW52YXNTdGFydCArIDFdIHx8IDApIC8gYWJzbWF4SGFsZikpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBlbnRyeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy53YXZlQ3R4ID0gbnVsbDtcbiAgICAgIHRoaXMud2F2ZSA9IG51bGw7XG4gICAgICB0aGlzLnByb2dyZXNzQ3R4ID0gbnVsbDtcbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gaW1hZ2UgZGF0YSBvZiB0aGUgd2F2ZSBgY2FudmFzYCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIGEgYHR5cGVgIG9mIGAnYmxvYidgLCB0aGlzIHdpbGwgcmV0dXJuIGEgYFByb21pc2VgIHRoYXRcbiAgICAgKiByZXNvbHZlcyB3aXRoIGEgYEJsb2JgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdD0naW1hZ2UvcG5nJyBBbiBvcHRpb25hbCB2YWx1ZSBvZiBhIGZvcm1hdCB0eXBlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5PTAuOTIgQW4gb3B0aW9uYWwgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlPSdkYXRhVVJMJyBFaXRoZXIgJ2RhdGFVUkwnIG9yICdibG9iJy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZX0gV2hlbiB1c2luZyB0aGUgZGVmYXVsdCBgJ2RhdGFVUkwnYCBgdHlwZWAgdGhpc1xuICAgICAqIHJldHVybnMgYSBkYXRhIFVSTC4gV2hlbiB1c2luZyB0aGUgYCdibG9iJ2AgYHR5cGVgIHRoaXMgcmV0dXJucyBhXG4gICAgICogYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIGBCbG9iYCBpbnN0YW5jZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEltYWdlKGZvcm1hdCwgcXVhbGl0eSwgdHlwZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBfdGhpcy53YXZlLnRvQmxvYihyZXNvbHZlLCBmb3JtYXQsIHF1YWxpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RhdGFVUkwnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhdmUudG9EYXRhVVJMKGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhc0VudHJ5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNFbnRyeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kcmF3ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RyYXdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy91dGlsL2luZGV4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciByZW5kZXJlcnNcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKi9cbnZhciBEcmF3ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF91dGlsJE9ic2VydmVyKSB7XG4gIF9pbmhlcml0cyhEcmF3ZXIsIF91dGlsJE9ic2VydmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERyYXdlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIG5vZGUgb2YgdGhlIHdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgVGhlIHdhdmVzdXJmZXIgaW5pdGlhbGlzYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRHJhd2VyKGNvbnRhaW5lciwgcGFyYW1zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYXdlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IHV0aWwud2l0aE9yaWVudGF0aW9uKGNvbnRhaW5lciwgcGFyYW1zLnZlcnRpY2FsKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2F2ZXN1cmZlclBhcmFtc31cbiAgICAgKi9cblxuICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHJlbmRlcmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLndpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXJlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5oZWlnaHQgPSBwYXJhbXMuaGVpZ2h0ICogX3RoaXMucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgX3RoaXMubGFzdFBvcyA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGA8d2F2ZT5gIGVsZW1lbnQgd2hpY2ggaXMgYWRkZWQgdG8gdGhlIGNvbnRhaW5lclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICAgIF90aGlzLndyYXBwZXIgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQWxpYXMgb2YgYHV0aWwuc3R5bGVgXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRoYXQgdGhlIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBUaGUgbWFwIG9mIHByb3BOYW1lOiBhdHRyaWJ1dGUsIGJvdGggYXJlIHVzZWQgYXMtaXNcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IGVsXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKERyYXdlciwgW3tcbiAgICBrZXk6IFwic3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3R5bGUoZWwsIHN0eWxlcykge1xuICAgICAgcmV0dXJuIHV0aWwuc3R5bGUoZWwsIHN0eWxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgd3JhcHBlciBgPHdhdmU+YCBlbGVtZW50LCBzdHlsZSBpdCBhbmQgc2V0IHVwIHRoZSBldmVudHMgZm9yXG4gICAgICogaW50ZXJhY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVdyYXBwZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlV3JhcHBlcigpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IHV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3dhdmUnKSksIHRoaXMucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIHdlYmtpdFVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnBhcmFtcy5oZWlnaHQgKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbGxQYXJlbnQgfHwgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLCB7XG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBvdmVyZmxvd1g6IHRoaXMucGFyYW1zLmhpZGVTY3JvbGxiYXIgPyAnaGlkZGVuJyA6ICdhdXRvJyxcbiAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldHVwV3JhcHBlckV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2xpY2sgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgQ2xpY2sgZXZlbnRcbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBub1ByZXZlbnQgU2V0IHRvIHRydWUgdG8gbm90IGNhbGwgYGUucHJldmVudERlZmF1bHQoKWBcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBsYXliYWNrIHBvc2l0aW9uIGZyb20gMCB0byAxXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFdmVudChlLCBub1ByZXZlbnQpIHtcbiAgICAgICFub1ByZXZlbnQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGNsaWVudFggPSB1dGlsLndpdGhPcmllbnRhdGlvbihlLnRhcmdldFRvdWNoZXMgPyBlLnRhcmdldFRvdWNoZXNbMF0gOiBlLCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCkuY2xpZW50WDtcbiAgICAgIHZhciBiYm94ID0gdGhpcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5vbWluYWxXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICB2YXIgcHJvZ3Jlc3NQaXhlbHMgPSB0aGlzLmdldFByb2dyZXNzUGl4ZWxzKGJib3gsIGNsaWVudFgpO1xuICAgICAgdmFyIHByb2dyZXNzO1xuXG4gICAgICBpZiAoIXRoaXMucGFyYW1zLmZpbGxQYXJlbnQgJiYgbm9taW5hbFdpZHRoIDwgcGFyZW50V2lkdGgpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBwcm9ncmVzc1BpeGVscyAqICh0aGlzLnBhcmFtcy5waXhlbFJhdGlvIC8gbm9taW5hbFdpZHRoKSB8fCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSAocHJvZ3Jlc3NQaXhlbHMgKyB0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCkgLyB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggfHwgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHV0aWwuY2xhbXAocHJvZ3Jlc3MsIDAsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9ncmVzc1BpeGVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9ncmVzc1BpeGVscyh3cmFwcGVyQmJveCwgY2xpZW50WCkge1xuICAgICAgaWYgKHRoaXMucGFyYW1zLnJ0bCkge1xuICAgICAgICByZXR1cm4gd3JhcHBlckJib3gucmlnaHQgLSBjbGllbnRYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFggLSB3cmFwcGVyQmJveC5sZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cFdyYXBwZXJFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBXcmFwcGVyRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBvcmllbnRlZEV2ZW50ID0gdXRpbC53aXRoT3JpZW50YXRpb24oZSwgX3RoaXMyLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICAgIHZhciBzY3JvbGxiYXJIZWlnaHQgPSBfdGhpczIud3JhcHBlci5vZmZzZXRIZWlnaHQgLSBfdGhpczIud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHNjcm9sbGJhckhlaWdodCAhPT0gMCkge1xuICAgICAgICAgIC8vIHNjcm9sbGJhciBpcyB2aXNpYmxlLiAgQ2hlY2sgaWYgY2xpY2sgd2FzIG9uIGl0XG4gICAgICAgICAgdmFyIGJib3ggPSBfdGhpczIud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgIGlmIChvcmllbnRlZEV2ZW50LmNsaWVudFkgPj0gYmJveC5ib3R0b20gLSBzY3JvbGxiYXJIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBtb3VzZWRvd24gYXMgaXQgd2FzIG9uIHRoZSBzY3JvbGxiYXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMyLnBhcmFtcy5pbnRlcmFjdCkge1xuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2NsaWNrJywgZSwgX3RoaXMyLmhhbmRsZUV2ZW50KGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoX3RoaXMyLnBhcmFtcy5pbnRlcmFjdCkge1xuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2RibGNsaWNrJywgZSwgX3RoaXMyLmhhbmRsZUV2ZW50KGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5maXJlRXZlbnQoJ3Njcm9sbCcsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgcGVha3Mgb24gdGhlIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXNcbiAgICAgKiBmb3Igc3BsaXQgY2hhbm5lbCByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSB3aWR0aCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZSBkcmF3blxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGVha3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BlYWtzKHBlYWtzLCBsZW5ndGgsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghdGhpcy5zZXRXaWR0aChsZW5ndGgpKSB7XG4gICAgICAgIHRoaXMuY2xlYXJXYXZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyYW1zLmJhcldpZHRoID8gdGhpcy5kcmF3QmFycyhwZWFrcywgMCwgc3RhcnQsIGVuZCkgOiB0aGlzLmRyYXdXYXZlKHBlYWtzLCAwLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0U2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U2Nyb2xsKCkge1xuICAgICAgaWYgKHRoaXMud3JhcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2VudGVyIHRoZSB2aWV3LXBvcnQgYXQgYSBjZXJ0YWluIHBlcmNlbnQgb2YgdGhlIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudCBWYWx1ZSBmcm9tIDAgdG8gMSBvbiB0aGUgd2F2ZWZvcm1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlY2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VudGVyKHBlcmNlbnQpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCAqIHBlcmNlbnQ7XG4gICAgICB0aGlzLnJlY2VudGVyT25Qb3NpdGlvbihwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY2VudGVyIHRoZSB2aWV3LXBvcnQgb24gYSBwb3NpdGlvbiwgZWl0aGVyIHNjcm9sbCB0aGVyZSBpbW1lZGlhdGVseSBvclxuICAgICAqIGluIHN0ZXBzIG9mIDUgcGl4ZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gWC1vZmZzZXQgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbW1lZGlhdGUgU2V0IHRvIHRydWUgdG8gaW1tZWRpYXRlbHkgc2Nyb2xsIHNvbWV3aGVyZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVjZW50ZXJPblBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VudGVyT25Qb3NpdGlvbihwb3NpdGlvbiwgaW1tZWRpYXRlKSB7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0O1xuICAgICAgdmFyIGhhbGYgPSB+fih0aGlzLndyYXBwZXIuY2xpZW50V2lkdGggLyAyKTtcbiAgICAgIHZhciBtYXhTY3JvbGwgPSB0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggLSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgdGFyZ2V0ID0gcG9zaXRpb24gLSBoYWxmO1xuICAgICAgdmFyIG9mZnNldCA9IHRhcmdldCAtIHNjcm9sbExlZnQ7XG5cbiAgICAgIGlmIChtYXhTY3JvbGwgPT0gMCkge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGNvbnRpbnVlIGlmIHNjcm9sbGJhciBpcyBub3QgdGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSB2aXNpYmxlLi4uXG5cblxuICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgLWhhbGYgPD0gb2Zmc2V0ICYmIG9mZnNldCA8IGhhbGYpIHtcbiAgICAgICAgLy8gc2V0IHJhdGUgYXQgd2hpY2ggd2F2ZWZvcm0gaXMgY2VudGVyZWRcbiAgICAgICAgdmFyIHJhdGUgPSB0aGlzLnBhcmFtcy5hdXRvQ2VudGVyUmF0ZTsgLy8gbWFrZSByYXRlIGRlcGVuZCBvbiB3aWR0aCBvZiB2aWV3IGFuZCBsZW5ndGggb2Ygd2F2ZWZvcm1cblxuICAgICAgICByYXRlIC89IGhhbGY7XG4gICAgICAgIHJhdGUgKj0gbWF4U2Nyb2xsO1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgtcmF0ZSwgTWF0aC5taW4ocmF0ZSwgb2Zmc2V0KSk7XG4gICAgICAgIHRhcmdldCA9IHNjcm9sbExlZnQgKyBvZmZzZXQ7XG4gICAgICB9IC8vIGxpbWl0IHRhcmdldCB0byB2YWxpZCByYW5nZSAoMCB0byBtYXhTY3JvbGwpXG5cblxuICAgICAgdGFyZ2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4U2Nyb2xsLCB0YXJnZXQpKTsgLy8gbm8gdXNlIGF0dGVtcHRpbmcgdG8gc2Nyb2xsIGlmIHdlJ3JlIG5vdCBtb3ZpbmdcblxuICAgICAgaWYgKHRhcmdldCAhPSBzY3JvbGxMZWZ0KSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ID0gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVsc1xuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBIb3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNjcm9sbFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2Nyb2xsWCgpIHtcbiAgICAgIHZhciB4ID0gMDtcblxuICAgICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHRoaXMud3JhcHBlci5zY3JvbGxMZWZ0ICogcGl4ZWxSYXRpbyk7IC8vIEluIGNhc2VzIG9mIGVsYXN0aWMgc2Nyb2xsIChzYWZhcmkgd2l0aCBtb3VzZSB3aGVlbCkgeW91IGNhblxuICAgICAgICAvLyBzY3JvbGwgYmV5b25kIHRoZSBsaW1pdHMgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAvLyBDYWxjdWxhdGUgYW5kIGZsb29yIHRoZSBzY3JvbGxhYmxlIGV4dGVudCB0byBtYWtlIHN1cmUgYW4gb3V0XG4gICAgICAgIC8vIG9mIGJvdW5kcyB2YWx1ZSBpcyBub3QgcmV0dXJuZWRcbiAgICAgICAgLy8gVGlja2V0ICMxMzEyXG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCkge1xuICAgICAgICAgIHZhciBtYXhTY3JvbGwgPSB+fih0aGlzLndyYXBwZXIuc2Nyb2xsV2lkdGggKiBwaXhlbFJhdGlvIC0gdGhpcy5nZXRXaWR0aCgpKTtcbiAgICAgICAgICB4ID0gTWF0aC5taW4obWF4U2Nyb2xsLCBNYXRoLm1heCgwLCB4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCAqIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIHdhcyB1cGRhdGVkIG9yIG5vdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V2lkdGgod2lkdGgpIHtcbiAgICAgIGlmICh0aGlzLndpZHRoID09IHdpZHRoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuZmlsbFBhcmVudCB8fCB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLndyYXBwZXIsIHtcbiAgICAgICAgICB3aWR0aDogJydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSB+fih0aGlzLndpZHRoIC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbykgKyAncHgnO1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMud3JhcHBlciwge1xuICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIHdhcyB1cGRhdGVkIG9yIG5vdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgIGlmIChoZWlnaHQgPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy53cmFwcGVyLCB7XG4gICAgICAgIGhlaWdodDogfn4odGhpcy5oZWlnaHQgLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKSArICdweCdcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHdhdmVzdXJmZXIgd2hlbiBwcm9ncmVzcyBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzcyBGcm9tIDAgdG8gMVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgICB2YXIgbWluUHhEZWx0YSA9IDEgLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvO1xuICAgICAgdmFyIHBvcyA9IE1hdGgucm91bmQoX3Byb2dyZXNzICogdGhpcy53aWR0aCkgKiBtaW5QeERlbHRhO1xuXG4gICAgICBpZiAocG9zIDwgdGhpcy5sYXN0UG9zIHx8IHBvcyAtIHRoaXMubGFzdFBvcyA+PSBtaW5QeERlbHRhKSB7XG4gICAgICAgIHRoaXMubGFzdFBvcyA9IHBvcztcblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ICYmIHRoaXMucGFyYW1zLmF1dG9DZW50ZXIpIHtcbiAgICAgICAgICB2YXIgbmV3UG9zID0gfn4odGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoICogX3Byb2dyZXNzKTtcbiAgICAgICAgICB0aGlzLnJlY2VudGVyT25Qb3NpdGlvbihuZXdQb3MsIHRoaXMucGFyYW1zLmF1dG9DZW50ZXJJbW1lZGlhdGVseSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gd2F2ZXN1cmZlciBpcyBkZXN0cm95ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5BbGwoKTtcblxuICAgICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVyLnBhcmVudE5vZGUgPT0gdGhpcy5jb250YWluZXIuZG9tRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlci5kb21FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud3JhcHBlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFJlbmRlcmVyLXNwZWNpZmljIG1ldGhvZHMgKi9cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciBjdXJzb3IgcmVsYXRlZCBwYXJhbXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKCkge31cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGNoYW5nZXMgc28gdGhlIHJlbmRlcmVyIGNhbiBhZGp1c3RcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaXplKCkge31cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgd2F2ZWZvcm0gd2l0aCBiYXJzXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIENhbiBhbHNvIGJlIGFuIGFycmF5IG9mIGFycmF5cyBmb3Igc3BsaXQgY2hhbm5lbFxuICAgICAqIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuIE5vcm1hbGx5XG4gICAgICogc2hvdWxkIGJlIDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhcnMocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCkge31cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQ2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgYXJyYXlzIGZvciBzcGxpdCBjaGFubmVsXG4gICAgICogcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbC4gTm9ybWFsbHlcbiAgICAgKiBzaG91bGQgYmUgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeC1vZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgYXJlYSB0aGF0IHNob3VsZCBiZVxuICAgICAqIHJlbmRlcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3V2F2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3V2F2ZShwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kKSB7fVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhcldhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJXYXZlKCkge31cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIG5ldyBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFgtT2Zmc2V0IG9mIHByb2dyZXNzIHBvc2l0aW9uIGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pIHt9XG4gIH1dKTtcblxuICByZXR1cm4gRHJhd2VyO1xufSh1dGlsLk9ic2VydmVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhd2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RyYXdlci5tdWx0aWNhbnZhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZHJhd2VyLm11bHRpY2FudmFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2RyYXdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kcmF3ZXIgKi8gXCIuL3NyYy9kcmF3ZXIuanNcIikpO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIikpO1xuXG52YXIgX2RyYXdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHJhd2VyLmNhbnZhc2VudHJ5ICovIFwiLi9zcmMvZHJhd2VyLmNhbnZhc2VudHJ5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogTXVsdGlDYW52YXMgcmVuZGVyZXIgZm9yIHdhdmVzdXJmZXIuIElzIGN1cnJlbnRseSB0aGUgZGVmYXVsdCBhbmQgc29sZVxuICogYnVpbHRpbiByZW5kZXJlci5cbiAqXG4gKiBBIGBNdWx0aUNhbnZhc2AgY29uc2lzdHMgb2Ygb25lIG9yIG1vcmUgYENhbnZhc0VudHJ5YCBpbnN0YW5jZXMsIGRlcGVuZGluZ1xuICogb24gdGhlIHpvb20gbGV2ZWwuXG4gKi9cbnZhciBNdWx0aUNhbnZhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RyYXdlcikge1xuICBfaW5oZXJpdHMoTXVsdGlDYW52YXMsIF9EcmF3ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTXVsdGlDYW52YXMpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBub2RlIG9mIHRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFRoZSB3YXZlc3VyZmVyIGluaXRpYWxpc2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIE11bHRpQ2FudmFzKGNvbnRhaW5lciwgcGFyYW1zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpQ2FudmFzKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyLCBwYXJhbXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5tYXhDYW52YXNXaWR0aCA9IHBhcmFtcy5tYXhDYW52YXNXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoID0gTWF0aC5yb3VuZChwYXJhbXMubWF4Q2FudmFzV2lkdGggLyBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIHByb2dyZXNzIHdhdmUgaXMgcmVuZGVyZWQuIElmIHRoZSBgd2F2ZUNvbG9yYFxuICAgICAqIGFuZCBgcHJvZ3Jlc3NDb2xvcmAgYXJlIHRoZSBzYW1lIGNvbG9yIGl0IGlzIG5vdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgX3RoaXMuaGFzUHJvZ3Jlc3NDYW52YXMgPSBwYXJhbXMud2F2ZUNvbG9yICE9IHBhcmFtcy5wcm9ncmVzc0NvbG9yO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICBfdGhpcy5oYWxmUGl4ZWwgPSAwLjUgLyBwYXJhbXMucGl4ZWxSYXRpbztcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGBDYW52YXNFbnRyeWAgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgX3RoaXMuY2FudmFzZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG5cbiAgICBfdGhpcy5wcm9ncmVzc1dhdmUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIENsYXNzIHVzZWQgdG8gZ2VuZXJhdGUgZW50cmllcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cblxuICAgIF90aGlzLkVudHJ5Q2xhc3MgPSBfZHJhd2VyMi5kZWZhdWx0O1xuICAgIC8qKlxuICAgICAqIENhbnZhcyAyZCBjb250ZXh0IGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgX3RoaXMuY2FudmFzQ29udGV4dEF0dHJpYnV0ZXMgPSBwYXJhbXMuZHJhd2luZ0NvbnRleHRBdHRyaWJ1dGVzO1xuICAgIC8qKlxuICAgICAqIE92ZXJsYXAgYWRkZWQgYmV0d2VlbiBlbnRyaWVzIHRvIHByZXZlbnQgdmVydGljYWwgd2hpdGUgc3RyaXBlc1xuICAgICAqIGJldHdlZW4gYGNhbnZhc2AgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgX3RoaXMub3ZlcmxhcCA9IDIgKiBNYXRoLmNlaWwocGFyYW1zLnBpeGVsUmF0aW8gLyAyKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSB3YXZlIGJhcnMuIE1ha2VzIGJhcnMgcm91bmRlZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLmJhclJhZGl1cyA9IHBhcmFtcy5iYXJSYWRpdXMgfHwgMDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHJlbmRlciB0aGUgd2F2ZWZvcm0gdmVydGljYWxseS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIF90aGlzLnZlcnRpY2FsID0gcGFyYW1zLnZlcnRpY2FsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZHJhd2VyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE11bHRpQ2FudmFzLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmNyZWF0ZVdyYXBwZXIoKTtcbiAgICAgIHRoaXMuY3JlYXRlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBjYW52YXMgZWxlbWVudHMgYW5kIHN0eWxlIHRoZW1cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgICB0aGlzLnByb2dyZXNzV2F2ZSA9IHV0aWwud2l0aE9yaWVudGF0aW9uKHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd3YXZlJykpLCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICB0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IDMsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAnMCcsXG4gICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGJvcmRlclJpZ2h0U3R5bGU6ICdzb2xpZCcsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZENhbnZhcygpO1xuICAgICAgdGhpcy51cGRhdGVDdXJzb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGN1cnNvciBzdHlsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcigpIHtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUsIHtcbiAgICAgICAgYm9yZGVyUmlnaHRXaWR0aDogdGhpcy5wYXJhbXMuY3Vyc29yV2lkdGggKyAncHgnLFxuICAgICAgICBib3JkZXJSaWdodENvbG9yOiB0aGlzLnBhcmFtcy5jdXJzb3JDb2xvclxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0byB0aGUgdXBkYXRlZCBzaXplIGJ5IGFkZGluZyBvciByZW1vdmluZyBjYW52YXNlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaXplKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB0b3RhbFdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoIC8gdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICB2YXIgcmVxdWlyZWRDYW52YXNlcyA9IE1hdGguY2VpbCh0b3RhbFdpZHRoIC8gKHRoaXMubWF4Q2FudmFzRWxlbWVudFdpZHRoICsgdGhpcy5vdmVybGFwKSk7IC8vIGFkZCByZXF1aXJlZCBjYW52YXNlc1xuXG4gICAgICB3aGlsZSAodGhpcy5jYW52YXNlcy5sZW5ndGggPCByZXF1aXJlZENhbnZhc2VzKSB7XG4gICAgICAgIHRoaXMuYWRkQ2FudmFzKCk7XG4gICAgICB9IC8vIHJlbW92ZSBvbGRlciBleGlzdGluZyBjYW52YXNlcywgaWYgYW55XG5cblxuICAgICAgd2hpbGUgKHRoaXMuY2FudmFzZXMubGVuZ3RoID4gcmVxdWlyZWRDYW52YXNlcykge1xuICAgICAgICB0aGlzLnJlbW92ZUNhbnZhcygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLm1heENhbnZhc1dpZHRoICsgdGhpcy5vdmVybGFwO1xuICAgICAgdmFyIGxhc3RDYW52YXMgPSB0aGlzLmNhbnZhc2VzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIGlmIChpID09IGxhc3RDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXNXaWR0aCA9IF90aGlzMi53aWR0aCAtIF90aGlzMi5tYXhDYW52YXNXaWR0aCAqIGxhc3RDYW52YXM7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIudXBkYXRlRGltZW5zaW9ucyhlbnRyeSwgY2FudmFzV2lkdGgsIF90aGlzMi5oZWlnaHQpO1xuXG4gICAgICAgIGVudHJ5LmNsZWFyV2F2ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbnZhcyB0byB0aGUgY2FudmFzIGxpc3RcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENhbnZhcygpIHtcbiAgICAgIHZhciBlbnRyeSA9IG5ldyB0aGlzLkVudHJ5Q2xhc3MoKTtcbiAgICAgIGVudHJ5LmNhbnZhc0NvbnRleHRBdHRyaWJ1dGVzID0gdGhpcy5jYW52YXNDb250ZXh0QXR0cmlidXRlcztcbiAgICAgIGVudHJ5Lmhhc1Byb2dyZXNzQ2FudmFzID0gdGhpcy5oYXNQcm9ncmVzc0NhbnZhcztcbiAgICAgIGVudHJ5LmhhbGZQaXhlbCA9IHRoaXMuaGFsZlBpeGVsO1xuICAgICAgdmFyIGxlZnRPZmZzZXQgPSB0aGlzLm1heENhbnZhc0VsZW1lbnRXaWR0aCAqIHRoaXMuY2FudmFzZXMubGVuZ3RoOyAvLyB3YXZlXG5cbiAgICAgIHZhciB3YXZlID0gdXRpbC53aXRoT3JpZW50YXRpb24odGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSwgdGhpcy5wYXJhbXMudmVydGljYWwpO1xuICAgICAgdGhpcy5zdHlsZSh3YXZlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgIGxlZnQ6IGxlZnRPZmZzZXQgKyAncHgnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBlbnRyeS5pbml0V2F2ZSh3YXZlKTsgLy8gcHJvZ3Jlc3NcblxuICAgICAgaWYgKHRoaXMuaGFzUHJvZ3Jlc3NDYW52YXMpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gdXRpbC53aXRoT3JpZW50YXRpb24odGhpcy5wcm9ncmVzc1dhdmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpLCB0aGlzLnBhcmFtcy52ZXJ0aWNhbCk7XG4gICAgICAgIHRoaXMuc3R5bGUocHJvZ3Jlc3MsIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBsZWZ0OiBsZWZ0T2Zmc2V0ICsgJ3B4JyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgIH0pO1xuICAgICAgICBlbnRyeS5pbml0UHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc2VzLnB1c2goZW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3Agc2luZ2xlIGNhbnZhcyBmcm9tIHRoZSBsaXN0XG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDYW52YXMoKSB7XG4gICAgICB2YXIgbGFzdEVudHJ5ID0gdGhpcy5jYW52YXNlc1t0aGlzLmNhbnZhc2VzLmxlbmd0aCAtIDFdOyAvLyB3YXZlXG5cbiAgICAgIGxhc3RFbnRyeS53YXZlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobGFzdEVudHJ5LndhdmUuZG9tRWxlbWVudCk7IC8vIHByb2dyZXNzXG5cbiAgICAgIGlmICh0aGlzLmhhc1Byb2dyZXNzQ2FudmFzKSB7XG4gICAgICAgIGxhc3RFbnRyeS5wcm9ncmVzcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGxhc3RFbnRyeS5wcm9ncmVzcy5kb21FbGVtZW50KTtcbiAgICAgIH0gLy8gY2xlYW51cFxuXG5cbiAgICAgIGlmIChsYXN0RW50cnkpIHtcbiAgICAgICAgbGFzdEVudHJ5LmRlc3Ryb3koKTtcbiAgICAgICAgbGFzdEVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXNlcy5wb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaW1lbnNpb25zIG9mIGEgY2FudmFzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRW50cnl9IGVudHJ5IFRhcmdldCBlbnRyeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgbmV3IHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaW1lbnNpb25zKGVudHJ5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbWVudFdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAvIHRoaXMucGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgdmFyIHRvdGFsV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggLyB0aGlzLnBhcmFtcy5waXhlbFJhdGlvKTsgLy8gdXBkYXRlIGNhbnZhcyBkaW1lbnNpb25zXG5cbiAgICAgIGVudHJ5LnVwZGF0ZURpbWVuc2lvbnMoZWxlbWVudFdpZHRoLCB0b3RhbFdpZHRoLCB3aWR0aCwgaGVpZ2h0KTsgLy8gc3R5bGUgZWxlbWVudFxuXG4gICAgICB0aGlzLnN0eWxlKHRoaXMucHJvZ3Jlc3NXYXZlLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgd2hvbGUgbXVsdGktY2FudmFzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhcldhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJXYXZlKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHV0aWwuZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuY2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cnkuY2xlYXJXYXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHdhdmVmb3JtIHdpdGggYmFyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXNcbiAgICAgKiBmb3Igc3BsaXQgY2hhbm5lbCByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLiBOb3JtYWxseVxuICAgICAqIHNob3VsZCBiZSAwLiBNdXN0IGJlIGFuIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4LW9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmVhIHRoYXRcbiAgICAgKiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCYXJzKHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlRHJhdyhwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgYWJzbWF4ID0gX3JlZi5hYnNtYXgsXG4gICAgICAgICAgICBoYXNNaW5WYWxzID0gX3JlZi5oYXNNaW5WYWxzLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZLFxuICAgICAgICAgICAgaGFsZkggPSBfcmVmLmhhbGZILFxuICAgICAgICAgICAgcGVha3MgPSBfcmVmLnBlYWtzLFxuICAgICAgICAgICAgY2ggPSBfcmVmLmNoYW5uZWxJbmRleDtcblxuICAgICAgICAvLyBpZiBkcmF3QmFycyB3YXMgY2FsbGVkIHdpdGhpbiB3cy5lbXB0eSB3ZSBkb24ndCBwYXNzIGEgc3RhcnQgYW5kXG4gICAgICAgIC8vIGRvbid0IHdhbnQgYW55dGhpbmcgdG8gaGFwcGVuXG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFNraXAgZXZlcnkgb3RoZXIgdmFsdWUgaWYgdGhlcmUgYXJlIG5lZ2F0aXZlcy5cblxuXG4gICAgICAgIHZhciBwZWFrSW5kZXhTY2FsZSA9IGhhc01pblZhbHMgPyAyIDogMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBlYWtzLmxlbmd0aCAvIHBlYWtJbmRleFNjYWxlO1xuICAgICAgICB2YXIgYmFyID0gX3RoaXM0LnBhcmFtcy5iYXJXaWR0aCAqIF90aGlzNC5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICAgICAgdmFyIGdhcCA9IF90aGlzNC5wYXJhbXMuYmFyR2FwID09PSBudWxsID8gTWF0aC5tYXgoX3RoaXM0LnBhcmFtcy5waXhlbFJhdGlvLCB+fihiYXIgLyAyKSkgOiBNYXRoLm1heChfdGhpczQucGFyYW1zLnBpeGVsUmF0aW8sIF90aGlzNC5wYXJhbXMuYmFyR2FwICogX3RoaXM0LnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdmFyIHN0ZXAgPSBiYXIgKyBnYXA7XG4gICAgICAgIHZhciBzY2FsZSA9IGxlbmd0aCAvIF90aGlzNC53aWR0aDtcbiAgICAgICAgdmFyIGZpcnN0ID0gc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0ID0gZW5kO1xuICAgICAgICB2YXIgaSA9IGZpcnN0O1xuXG4gICAgICAgIGZvciAoaTsgaSA8IGxhc3Q7IGkgKz0gc3RlcCkge1xuICAgICAgICAgIHZhciBwZWFrID0gcGVha3NbTWF0aC5mbG9vcihpICogc2NhbGUgKiBwZWFrSW5kZXhTY2FsZSldIHx8IDA7XG4gICAgICAgICAgdmFyIGggPSBNYXRoLnJvdW5kKHBlYWsgLyBhYnNtYXggKiBoYWxmSCk7XG4gICAgICAgICAgLyogaW4gY2FzZSBvZiBzaWxlbmNlcywgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGF0IHdlXG4gICAgICAgICAgICogYWx3YXlzIGRyYXcgKnNvbWV0aGluZyogKG5vcm1hbGx5IGEgMXB4IGhpZ2ggYmFyKSAqL1xuXG4gICAgICAgICAgaWYgKGggPT0gMCAmJiBfdGhpczQucGFyYW1zLmJhck1pbkhlaWdodCkge1xuICAgICAgICAgICAgaCA9IF90aGlzNC5wYXJhbXMuYmFyTWluSGVpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNC5maWxsUmVjdChpICsgX3RoaXM0LmhhbGZQaXhlbCwgaGFsZkggLSBoICsgb2Zmc2V0WSwgYmFyICsgX3RoaXM0LmhhbGZQaXhlbCwgaCAqIDIsIF90aGlzNC5iYXJSYWRpdXMsIGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSB3YXZlZm9ybVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXNcbiAgICAgKiBmb3Igc3BsaXQgY2hhbm5lbCByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLiBOb3JtYWxseVxuICAgICAqIHNob3VsZCBiZSAwXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkIChJZiB0aGlzIGlzbid0IHNldCBvbmx5IGEgZmxhdCBsaW5lIGlzIHJlbmRlcmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gZW5kIFRoZSB4LW9mZnNldCBvZiB0aGUgZW5kIG9mIHRoZSBhcmVhIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVuZGVyZWRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdXYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXYXZlKHBlYWtzLCBjaGFubmVsSW5kZXgsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlRHJhdyhwZWFrcywgY2hhbm5lbEluZGV4LCBzdGFydCwgZW5kLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIGFic21heCA9IF9yZWYyLmFic21heCxcbiAgICAgICAgICAgIGhhc01pblZhbHMgPSBfcmVmMi5oYXNNaW5WYWxzLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0WSA9IF9yZWYyLm9mZnNldFksXG4gICAgICAgICAgICBoYWxmSCA9IF9yZWYyLmhhbGZILFxuICAgICAgICAgICAgcGVha3MgPSBfcmVmMi5wZWFrcyxcbiAgICAgICAgICAgIGNoYW5uZWxJbmRleCA9IF9yZWYyLmNoYW5uZWxJbmRleDtcblxuICAgICAgICBpZiAoIWhhc01pblZhbHMpIHtcbiAgICAgICAgICB2YXIgcmVmbGVjdGVkUGVha3MgPSBbXTtcbiAgICAgICAgICB2YXIgbGVuID0gcGVha3MubGVuZ3RoO1xuICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRQZWFrc1syICogaV0gPSBwZWFrc1tpXTtcbiAgICAgICAgICAgIHJlZmxlY3RlZFBlYWtzWzIgKiBpICsgMV0gPSAtcGVha3NbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVha3MgPSByZWZsZWN0ZWRQZWFrcztcbiAgICAgICAgfSAvLyBpZiBkcmF3V2F2ZSB3YXMgY2FsbGVkIHdpdGhpbiB3cy5lbXB0eSB3ZSBkb24ndCBwYXNzIGEgc3RhcnQgYW5kXG4gICAgICAgIC8vIGVuZCBhbmQgc2ltcGx5IHdhbnQgYSBmbGF0IGxpbmVcblxuXG4gICAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXM1LmRyYXdMaW5lKHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kLCBjaGFubmVsSW5kZXgpO1xuICAgICAgICB9IC8vIGFsd2F5cyBkcmF3IGEgbWVkaWFuIGxpbmVcblxuXG4gICAgICAgIF90aGlzNS5maWxsUmVjdCgwLCBoYWxmSCArIG9mZnNldFkgLSBfdGhpczUuaGFsZlBpeGVsLCBfdGhpczUud2lkdGgsIF90aGlzNS5oYWxmUGl4ZWwsIF90aGlzNS5iYXJSYWRpdXMsIGNoYW5uZWxJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVsbCB0aGUgY2FudmFzIGVudHJpZXMgdG8gcmVuZGVyIHRoZWlyIHBvcnRpb24gb2YgdGhlIHdhdmVmb3JtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwZWFrcyBQZWFrcyBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFic21heCBNYXhpbXVtIHBlYWsgdmFsdWUgKGFic29sdXRlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYWxmSCBIYWxmIHRoZSBoZWlnaHQgb2YgdGhlIHdhdmVmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgT2Zmc2V0IHRvIHRoZSB0b3BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7Y2hhbm5lbEluZGV4fSBjaGFubmVsSW5kZXggVGhlIGNoYW5uZWwgaW5kZXggb2YgdGhlIGxpbmUgZHJhd25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKHBlYWtzLCBhYnNtYXgsIGhhbGZILCBvZmZzZXRZLCBzdGFydCwgZW5kLCBjaGFubmVsSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZjMgPSB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5jaGFubmVsQ29sb3JzW2NoYW5uZWxJbmRleF0gfHwge30sXG4gICAgICAgICAgd2F2ZUNvbG9yID0gX3JlZjMud2F2ZUNvbG9yLFxuICAgICAgICAgIHByb2dyZXNzQ29sb3IgPSBfcmVmMy5wcm9ncmVzc0NvbG9yO1xuXG4gICAgICB0aGlzLmNhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gICAgICAgIF90aGlzNi5zZXRGaWxsU3R5bGVzKGVudHJ5LCB3YXZlQ29sb3IsIHByb2dyZXNzQ29sb3IpO1xuXG4gICAgICAgIF90aGlzNi5hcHBseUNhbnZhc1RyYW5zZm9ybXMoZW50cnksIF90aGlzNi5wYXJhbXMudmVydGljYWwpO1xuXG4gICAgICAgIGVudHJ5LmRyYXdMaW5lcyhwZWFrcywgYWJzbWF4LCBoYWxmSCwgb2Zmc2V0WSwgc3RhcnQsIGVuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJlY3RhbmdsZSBvbiB0aGUgbXVsdGktY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYLXBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZLXBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtjaGFubmVsSW5kZXh9IGNoYW5uZWxJbmRleCBUaGUgY2hhbm5lbCBpbmRleCBvZiB0aGUgYmFyIGRyYXduXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaWxsUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGNoYW5uZWxJbmRleCkge1xuICAgICAgdmFyIHN0YXJ0Q2FudmFzID0gTWF0aC5mbG9vcih4IC8gdGhpcy5tYXhDYW52YXNXaWR0aCk7XG4gICAgICB2YXIgZW5kQ2FudmFzID0gTWF0aC5taW4oTWF0aC5jZWlsKCh4ICsgd2lkdGgpIC8gdGhpcy5tYXhDYW52YXNXaWR0aCkgKyAxLCB0aGlzLmNhbnZhc2VzLmxlbmd0aCk7XG4gICAgICB2YXIgaSA9IHN0YXJ0Q2FudmFzO1xuXG4gICAgICBmb3IgKGk7IGkgPCBlbmRDYW52YXM7IGkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmNhbnZhc2VzW2ldO1xuICAgICAgICB2YXIgbGVmdE9mZnNldCA9IGkgKiB0aGlzLm1heENhbnZhc1dpZHRoO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0ge1xuICAgICAgICAgIHgxOiBNYXRoLm1heCh4LCBpICogdGhpcy5tYXhDYW52YXNXaWR0aCksXG4gICAgICAgICAgeTE6IHksXG4gICAgICAgICAgeDI6IE1hdGgubWluKHggKyB3aWR0aCwgaSAqIHRoaXMubWF4Q2FudmFzV2lkdGggKyBlbnRyeS53YXZlLndpZHRoKSxcbiAgICAgICAgICB5MjogeSArIGhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24ueDEgPCBpbnRlcnNlY3Rpb24ueDIpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSB0aGlzLnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucy5jaGFubmVsQ29sb3JzW2NoYW5uZWxJbmRleF0gfHwge30sXG4gICAgICAgICAgICAgIHdhdmVDb2xvciA9IF9yZWY0LndhdmVDb2xvcixcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NDb2xvciA9IF9yZWY0LnByb2dyZXNzQ29sb3I7XG5cbiAgICAgICAgICB0aGlzLnNldEZpbGxTdHlsZXMoZW50cnksIHdhdmVDb2xvciwgcHJvZ3Jlc3NDb2xvcik7XG4gICAgICAgICAgdGhpcy5hcHBseUNhbnZhc1RyYW5zZm9ybXMoZW50cnksIHRoaXMucGFyYW1zLnZlcnRpY2FsKTtcbiAgICAgICAgICBlbnRyeS5maWxsUmVjdHMoaW50ZXJzZWN0aW9uLngxIC0gbGVmdE9mZnNldCwgaW50ZXJzZWN0aW9uLnkxLCBpbnRlcnNlY3Rpb24ueDIgLSBpbnRlcnNlY3Rpb24ueDEsIGludGVyc2VjdGlvbi55MiAtIGludGVyc2VjdGlvbi55MSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdG8gaGlkZSB0aGUgY2hhbm5lbCBmcm9tIGJlaW5nIGRyYXduIGJhc2VkIG9uIHBhcmFtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYW5uZWwuXG4gICAgICogQHJldHVybnMge2Jvb2x9IFRydWUgdG8gaGlkZSB0aGUgY2hhbm5lbCwgZmFsc2UgdG8gZHJhdy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhpZGVDaGFubmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVDaGFubmVsKGNoYW5uZWxJbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHMgJiYgdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMuZmlsdGVyQ2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbEluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgcHJlcGFyYXRpb24gdGFza3MgYW5kIGNhbGN1bGF0aW9ucyB3aGljaCBhcmUgc2hhcmVkIGJ5IGBkcmF3QmFyc2BcbiAgICAgKiBhbmQgYGRyYXdXYXZlYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBDYW4gYWxzbyBiZSBhbiBhcnJheSBvZiBhcnJheXMgZm9yXG4gICAgICogc3BsaXQgY2hhbm5lbCByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFubmVsLiBOb3JtYWxseVxuICAgICAqIHNob3VsZCBiZSAwXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBzdGFydCBUaGUgeC1vZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJlYSB0aGF0XG4gICAgICogc2hvdWxkIGJlIHJlbmRlcmVkLiBJZiB0aGlzIGlzbid0IHNldCBvbmx5IGEgZmxhdCBsaW5lIGlzIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBlbmQgVGhlIHgtb2Zmc2V0IG9mIHRoZSBlbmQgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSByZW5kZXIgZnVuY3Rpb24gdG8gY2FsbCwgZS5nLiBgZHJhd1dhdmVgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRyYXdJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhbm5lbCBhZnRlciBmaWx0ZXJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBub3JtYWxpemVkTWF4IE1heGltdW0gbW9kdWxhdGlvbiB2YWx1ZSBhY3Jvc3MgY2hhbm5lbHMgZm9yIHVzZSB3aXRoIHJlbGF0aXZlTm9ybWFsaXphdGlvbi4gSWdub3JlZCB3aGVuIHVuZGVmaW5lZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZURyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZURyYXcocGVha3MsIGNoYW5uZWxJbmRleCwgc3RhcnQsIGVuZCwgZm4sIGRyYXdJbmRleCwgbm9ybWFsaXplZE1heCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB1dGlsLmZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU3BsaXQgY2hhbm5lbHMgYW5kIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBjaGFubmVsSW5kZXggc2V0XG4gICAgICAgIGlmIChwZWFrc1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdmFyIGNoYW5uZWxzID0gcGVha3M7XG5cbiAgICAgICAgICBpZiAoX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRDaGFubmVscyA9IGNoYW5uZWxzLmZpbHRlcihmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gIV90aGlzNy5oaWRlQ2hhbm5lbChpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIV90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgICBfdGhpczcuc2V0SGVpZ2h0KE1hdGgubWF4KGZpbHRlcmVkQ2hhbm5lbHMubGVuZ3RoLCAxKSAqIF90aGlzNy5wYXJhbXMuaGVpZ2h0ICogX3RoaXM3LnBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG92ZXJhbGxBYnNNYXg7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zICYmIF90aGlzNy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMucmVsYXRpdmVOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBtYXhpbXVtIHBlYWsgYWNyb3NzIGNoYW5uZWxzIHRvIHVzZSBmb3Igbm9ybWFsaXphdGlvblxuICAgICAgICAgICAgICBvdmVyYWxsQWJzTWF4ID0gdXRpbC5tYXgoY2hhbm5lbHMubWFwKGZ1bmN0aW9uIChjaGFubmVsUGVha3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5hYnNNYXgoY2hhbm5lbFBlYWtzKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbFBlYWtzLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczcucHJlcGFyZURyYXcoY2hhbm5lbFBlYWtzLCBpLCBzdGFydCwgZW5kLCBmbiwgZmlsdGVyZWRDaGFubmVscy5pbmRleE9mKGNoYW5uZWxQZWFrcyksIG92ZXJhbGxBYnNNYXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVha3MgPSBjaGFubmVsc1swXTtcbiAgICAgICAgfSAvLyBSZXR1cm4gYW5kIGRvIG5vdCBkcmF3IGNoYW5uZWwgcGVha3MgaWYgaGlkZGVuLlxuXG5cbiAgICAgICAgaWYgKF90aGlzNy5oaWRlQ2hhbm5lbChjaGFubmVsSW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGNhbGN1bGF0ZSBtYXhpbXVtIG1vZHVsYXRpb24gdmFsdWUsIGVpdGhlciBmcm9tIHRoZSBiYXJIZWlnaHRcbiAgICAgICAgLy8gcGFyYW1ldGVyIG9yIGlmIG5vcm1hbGl6ZT10cnVlIGZyb20gdGhlIGxhcmdlc3QgdmFsdWUgaW4gdGhlIHBlYWtcbiAgICAgICAgLy8gc2V0XG5cblxuICAgICAgICB2YXIgYWJzbWF4ID0gMSAvIF90aGlzNy5wYXJhbXMuYmFySGVpZ2h0O1xuXG4gICAgICAgIGlmIChfdGhpczcucGFyYW1zLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIGFic21heCA9IG5vcm1hbGl6ZWRNYXggPT09IHVuZGVmaW5lZCA/IHV0aWwuYWJzTWF4KHBlYWtzKSA6IG5vcm1hbGl6ZWRNYXg7XG4gICAgICAgIH0gLy8gQmFyIHdhdmUgZHJhd3MgdGhlIGJvdHRvbSBvbmx5IGFzIGEgcmVmbGVjdGlvbiBvZiB0aGUgdG9wLFxuICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIG5lZ2F0aXZlIHZhbHVlc1xuXG5cbiAgICAgICAgdmFyIGhhc01pblZhbHMgPSBbXS5zb21lLmNhbGwocGVha3MsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfdGhpczcucGFyYW1zLmhlaWdodCAqIF90aGlzNy5wYXJhbXMucGl4ZWxSYXRpbztcbiAgICAgICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBoZWlnaHQgKiBkcmF3SW5kZXggfHwgMDsgLy8gT3ZlcnJpZGUgb2Zmc2V0WSBpZiBvdmVybGF5IGlzIHRydWVcblxuICAgICAgICBpZiAoX3RoaXM3LnBhcmFtcy5zcGxpdENoYW5uZWxzT3B0aW9ucyAmJiBfdGhpczcucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICBvZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbih7XG4gICAgICAgICAgYWJzbWF4OiBhYnNtYXgsXG4gICAgICAgICAgaGFzTWluVmFsczogaGFzTWluVmFscyxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgICAgICAgIGhhbGZIOiBoYWxmSCxcbiAgICAgICAgICBwZWFrczogcGVha3MsXG4gICAgICAgICAgY2hhbm5lbEluZGV4OiBjaGFubmVsSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbGwgc3R5bGVzIGZvciBhIGNlcnRhaW4gZW50cnkgKHdhdmUgYW5kIHByb2dyZXNzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNFbnRyeX0gZW50cnkgVGFyZ2V0IGVudHJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhdmVDb2xvciBXYXZlIGNvbG9yIHRvIGRyYXcgdGhpcyBlbnRyeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmVzc0NvbG9yIFByb2dyZXNzIGNvbG9yIHRvIGRyYXcgdGhpcyBlbnRyeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsbFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWxsU3R5bGVzKGVudHJ5KSB7XG4gICAgICB2YXIgd2F2ZUNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnBhcmFtcy53YXZlQ29sb3I7XG4gICAgICB2YXIgcHJvZ3Jlc3NDb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5wYXJhbXMucHJvZ3Jlc3NDb2xvcjtcbiAgICAgIGVudHJ5LnNldEZpbGxTdHlsZXMod2F2ZUNvbG9yLCBwcm9ncmVzc0NvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYW52YXMgdHJhbnNmb3JtcyBmb3IgYSBjZXJ0YWluIGVudHJ5ICh3YXZlIGFuZCBwcm9ncmVzcylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRW50cnl9IGVudHJ5IFRhcmdldCBlbnRyeVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmVydGljYWwgV2hldGhlciB0byByZW5kZXIgdGhlIHdhdmVmb3JtIHZlcnRpY2FsbHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5Q2FudmFzVHJhbnNmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUNhbnZhc1RyYW5zZm9ybXMoZW50cnkpIHtcbiAgICAgIHZhciB2ZXJ0aWNhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBlbnRyeS5hcHBseUNhbnZhc1RyYW5zZm9ybXModmVydGljYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gaW1hZ2UgZGF0YSBvZiB0aGUgbXVsdGktY2FudmFzXG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIGEgYHR5cGVgIG9mIGAnYmxvYidgLCB0aGlzIHdpbGwgcmV0dXJuIGEgYFByb21pc2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdD0naW1hZ2UvcG5nJyBBbiBvcHRpb25hbCB2YWx1ZSBvZiBhIGZvcm1hdCB0eXBlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5PTAuOTIgQW4gb3B0aW9uYWwgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlPSdkYXRhVVJMJyBFaXRoZXIgJ2RhdGFVUkwnIG9yICdibG9iJy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW118UHJvbWlzZX0gV2hlbiB1c2luZyB0aGUgZGVmYXVsdCBgJ2RhdGFVUkwnYFxuICAgICAqIGB0eXBlYCB0aGlzIHJldHVybnMgYSBzaW5nbGUgZGF0YSBVUkwgb3IgYW4gYXJyYXkgb2YgZGF0YSBVUkxzLFxuICAgICAqIG9uZSBmb3IgZWFjaCBjYW52YXMuIFdoZW4gdXNpbmcgdGhlIGAnYmxvYidgIGB0eXBlYCB0aGlzIHJldHVybnMgYVxuICAgICAqIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgYEJsb2JgIGluc3RhbmNlcywgb25lIGZvciBlYWNoXG4gICAgICogY2FudmFzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmNhbnZhc2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cnkuZ2V0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGF0YVVSTCcpIHtcbiAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuY2FudmFzZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeS5nZXRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlcy5sZW5ndGggPiAxID8gaW1hZ2VzIDogaW1hZ2VzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIG5ldyBwcm9ncmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFgtb2Zmc2V0IG9mIHByb2dyZXNzIHBvc2l0aW9uIGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5wcm9ncmVzc1dhdmUsIHtcbiAgICAgICAgd2lkdGg6IHBvc2l0aW9uICsgJ3B4J1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpQ2FudmFzO1xufShfZHJhd2VyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNdWx0aUNhbnZhcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9tZWRpYWVsZW1lbnQtd2ViYXVkaW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21lZGlhZWxlbWVudC13ZWJhdWRpby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9tZWRpYWVsZW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVkaWFlbGVtZW50ICovIFwiLi9zcmMvbWVkaWFlbGVtZW50LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIE1lZGlhRWxlbWVudFdlYkF1ZGlvIGJhY2tlbmQ6IGxvYWQgYXVkaW8gdmlhIGFuIEhUTUw1IGF1ZGlvIHRhZywgYnV0IHBsYXliYWNrIHdpdGggdGhlIFdlYkF1ZGlvIEFQSS5cbiAqIFRoZSBhZHZhbnRhZ2UgaGVyZSBpcyB0aGF0IHRoZSBodG1sNSA8YXVkaW8+IHRhZyBjYW4gcGVyZm9ybSByYW5nZSByZXF1ZXN0cyBvbiB0aGUgc2VydmVyIGFuZCBub3RcbiAqIGJ1ZmZlciB0aGUgZW50aXJlIGZpbGUgaW4gb25lIHJlcXVlc3QsIGFuZCB5b3Ugc3RpbGwgZ2V0IHRoZSBmaWx0ZXJpbmcgYW5kIHNjcmlwdGluZyBmdW5jdGlvbmFsaXR5XG4gKiBvZiB0aGUgd2ViYXVkaW8gQVBJLlxuICogTm90ZSB0aGF0IGluIG9yZGVyIHRvIHVzZSByYW5nZSByZXF1ZXN0cyBhbmQgcHJldmVudCBidWZmZXJpbmcsIHlvdSBtdXN0IHByb3ZpZGUgcGVhayBkYXRhLlxuICpcbiAqIEBzaW5jZSAzLjIuMFxuICovXG52YXIgTWVkaWFFbGVtZW50V2ViQXVkaW8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NZWRpYUVsZW1lbnQpIHtcbiAgX2luaGVyaXRzKE1lZGlhRWxlbWVudFdlYkF1ZGlvLCBfTWVkaWFFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE1lZGlhRWxlbWVudFdlYkF1ZGlvKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBiYWNrZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFdhdmVzdXJmZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gTWVkaWFFbGVtZW50V2ViQXVkaW8ocGFyYW1zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhRWxlbWVudFdlYkF1ZGlvKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnNvdXJjZU1lZGlhRWxlbWVudCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBiYWNrZW5kLCBjYWxsZWQgaW4gYHdhdmVzdXJmZXIuY3JlYXRlQmFja2VuZCgpYFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNZWRpYUVsZW1lbnRXZWJBdWRpbywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wYXJhbXMuYXVkaW9SYXRlKTtcbiAgICAgIHRoaXMuY3JlYXRlVGltZXIoKTtcbiAgICAgIHRoaXMuY3JlYXRlVm9sdW1lTm9kZSgpO1xuICAgICAgdGhpcy5jcmVhdGVTY3JpcHROb2RlKCk7XG4gICAgICB0aGlzLmNyZWF0ZUFuYWx5c2VyTm9kZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBjYWxsZWQgYnkgYm90aCBgbG9hZGAgKGZyb20gdXJsKVxuICAgICAqIGFuZCBgbG9hZEVsdGAgKGV4aXN0aW5nIG1lZGlhIGVsZW1lbnQpIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhIEhUTUw1IEF1ZGlvIG9yIFZpZGVvIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfE51bWJlci48QXJyYXlbXT59IHBlYWtzIEFycmF5IG9mIHBlYWsgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVsb2FkIEhUTUwgNSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZChtZWRpYSwgcGVha3MsIHByZWxvYWQpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lZGlhRWxlbWVudFdlYkF1ZGlvLnByb3RvdHlwZSksIFwiX2xvYWRcIiwgdGhpcykuY2FsbCh0aGlzLCBtZWRpYSwgcGVha3MsIHByZWxvYWQpO1xuXG4gICAgICB0aGlzLmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBNZWRpYUVsZW1lbnRTb3VyY2Ugbm9kZVxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnQgSFRNTDUgQXVkaW8gdG8gbG9hZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc291cmNlTWVkaWFFbGVtZW50ID0gdGhpcy5hYy5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KTtcbiAgICAgIHRoaXMuc291cmNlTWVkaWFFbGVtZW50LmNvbm5lY3QodGhpcy5hbmFseXNlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShzdGFydCwgZW5kKSB7XG4gICAgICB0aGlzLnJlc3VtZUF1ZGlvQ29udGV4dCgpO1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lZGlhRWxlbWVudFdlYkF1ZGlvLnByb3RvdHlwZSksIFwicGxheVwiLCB0aGlzKS5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHdhdmVzdXJmZXIgaXMgZGVzdHJveWVkXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lZGlhRWxlbWVudFdlYkF1ZGlvLnByb3RvdHlwZSksIFwiZGVzdHJveVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLmRlc3Ryb3lXZWJBdWRpbygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZWRpYUVsZW1lbnRXZWJBdWRpbztcbn0oX21lZGlhZWxlbWVudC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWVkaWFFbGVtZW50V2ViQXVkaW87XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWVkaWFlbGVtZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9tZWRpYWVsZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfd2ViYXVkaW8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vd2ViYXVkaW8gKi8gXCIuL3NyYy93ZWJhdWRpby5qc1wiKSk7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIE1lZGlhRWxlbWVudCBiYWNrZW5kXG4gKi9cbnZhciBNZWRpYUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9XZWJBdWRpbykge1xuICBfaW5oZXJpdHMoTWVkaWFFbGVtZW50LCBfV2ViQXVkaW8pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTWVkaWFFbGVtZW50KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBiYWNrZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIFdhdmVzdXJmZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gTWVkaWFFbGVtZW50KHBhcmFtcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxseSBhIGR1bW15IG1lZGlhIGVsZW1lbnQgdG8gY2F0Y2ggZXJyb3JzLiBPbmNlIGBfbG9hZGAgaXNcbiAgICAgKiBjYWxsZWQsIHRoaXMgd2lsbCBjb250YWluIHRoZSBhY3R1YWwgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICBfdGhpcy5tZWRpYSA9IHtcbiAgICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICBwbGF5YmFja1JhdGU6IDEsXG4gICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge30sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7fSxcbiAgICAgIHZvbHVtZTogMFxuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5tZWRpYVR5cGUgPSBwYXJhbXMubWVkaWFUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5lbGVtZW50UG9zaXRpb24gPSBwYXJhbXMuZWxlbWVudFBvc2l0aW9uO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGVha3MgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnZvbHVtZSA9IDE7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMub25QbGF5RW5kID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLm1lZGlhTGlzdGVuZXJzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBiYWNrZW5kLCBjYWxsZWQgaW4gYHdhdmVzdXJmZXIuY3JlYXRlQmFja2VuZCgpYFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNZWRpYUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGFyYW1zLmF1ZGlvUmF0ZSk7XG4gICAgICB0aGlzLmNyZWF0ZVRpbWVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gbWVkaWEgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cE1lZGlhTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cE1lZGlhTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2Vycm9yJywgJ0Vycm9yIGxvYWRpbmcgbWVkaWEgZWxlbWVudCcpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5tZWRpYUxpc3RlbmVycy5jYW5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdjYW5wbGF5Jyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLmVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdmaW5pc2gnKTtcbiAgICAgIH07IC8vIGxpc3RlbiB0byBhbmQgcmVsYXkgcGxheSwgcGF1c2UgYW5kIHNlZWtlZCBldmVudHMgdG8gZW5hYmxlXG4gICAgICAvLyBwbGF5YmFjayBjb250cm9sIGZyb20gdGhlIGV4dGVybmFsIG1lZGlhIGVsZW1lbnRcblxuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ3BsYXknKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubWVkaWFMaXN0ZW5lcnMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ3BhdXNlJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLnNlZWtlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdzZWVrJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm1lZGlhTGlzdGVuZXJzLnZvbHVtZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuaXNNdXRlZCA9IF90aGlzMi5tZWRpYS5tdXRlZDtcblxuICAgICAgICBpZiAoX3RoaXMyLmlzTXV0ZWQpIHtcbiAgICAgICAgICBfdGhpczIudm9sdW1lID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIudm9sdW1lID0gX3RoaXMyLm1lZGlhLnZvbHVtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ3ZvbHVtZScpO1xuICAgICAgfTsgLy8gcmVzZXQgZXZlbnQgbGlzdGVuZXJzXG5cblxuICAgICAgT2JqZWN0LmtleXModGhpcy5tZWRpYUxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgX3RoaXMyLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoaWQsIF90aGlzMi5tZWRpYUxpc3RlbmVyc1tpZF0pO1xuXG4gICAgICAgIF90aGlzMi5tZWRpYS5hZGRFdmVudExpc3RlbmVyKGlkLCBfdGhpczIubWVkaWFMaXN0ZW5lcnNbaWRdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aW1lciB0byBwcm92aWRlIGEgbW9yZSBwcmVjaXNlIGBhdWRpb3Byb2Nlc3NgIGV2ZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGltZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG9uQXVkaW9Qcm9jZXNzID0gZnVuY3Rpb24gb25BdWRpb1Byb2Nlc3MoKSB7XG4gICAgICAgIGlmIChfdGhpczMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ2F1ZGlvcHJvY2VzcycsIF90aGlzMy5nZXRDdXJyZW50VGltZSgpKTsgLy8gQ2FsbCBhZ2FpbiBpbiB0aGUgbmV4dCBmcmFtZVxuXG5cbiAgICAgICAgdXRpbC5mcmFtZShvbkF1ZGlvUHJvY2VzcykoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ3BsYXknLCBvbkF1ZGlvUHJvY2Vzcyk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3Mgb25lIG1vcmUgdGltZSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgc3R1Y2sgaW5cbiAgICAgIC8vIGNhc2Ugb2YgbG93ZXIgZnJhbWVyYXRlc1xuXG4gICAgICB0aGlzLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnYXVkaW9wcm9jZXNzJywgX3RoaXMzLmdldEN1cnJlbnRUaW1lKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtZWRpYSBlbGVtZW50IHdpdGggdXJsIGFzIGl0cyBzb3VyY2UsXG4gICAgICogYW5kIGFwcGVuZCB0byBjb250YWluZXIgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgUGF0aCB0byBtZWRpYSBmaWxlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIEhUTUwgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgQXJyYXkgb2YgcGVhayBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWxvYWQgSFRNTCA1IHByZWxvYWQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBgdXJsYCBhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBtZWRpYVxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBjb250YWluZXIsIHBlYWtzLCBwcmVsb2FkKSB7XG4gICAgICB2YXIgbWVkaWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubWVkaWFUeXBlKTtcbiAgICAgIG1lZGlhLmNvbnRyb2xzID0gdGhpcy5wYXJhbXMubWVkaWFDb250cm9scztcbiAgICAgIG1lZGlhLmF1dG9wbGF5ID0gdGhpcy5wYXJhbXMuYXV0b3BsYXkgfHwgZmFsc2U7XG4gICAgICBtZWRpYS5wcmVsb2FkID0gcHJlbG9hZCA9PSBudWxsID8gJ2F1dG8nIDogcHJlbG9hZDtcbiAgICAgIG1lZGlhLnNyYyA9IHVybDtcbiAgICAgIG1lZGlhLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdmFyIHByZXZNZWRpYSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHRoaXMubWVkaWFUeXBlKTtcblxuICAgICAgaWYgKHByZXZNZWRpYSkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocHJldk1lZGlhKTtcbiAgICAgIH1cblxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1lZGlhKTtcblxuICAgICAgdGhpcy5fbG9hZChtZWRpYSwgcGVha3MsIHByZWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGV4aXN0aW5nIG1lZGlhIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IGVsdCBIVE1MNSBBdWRpbyBvciBWaWRlbyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBBcnJheSBvZiBwZWFrIGRhdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRFbHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEVsdChlbHQsIHBlYWtzKSB7XG4gICAgICBlbHQuY29udHJvbHMgPSB0aGlzLnBhcmFtcy5tZWRpYUNvbnRyb2xzO1xuICAgICAgZWx0LmF1dG9wbGF5ID0gdGhpcy5wYXJhbXMuYXV0b3BsYXkgfHwgZmFsc2U7XG5cbiAgICAgIHRoaXMuX2xvYWQoZWx0LCBwZWFrcywgZWx0LnByZWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIGJ5IGJvdGggYGxvYWRgIChmcm9tIHVybClcbiAgICAgKiBhbmQgYGxvYWRFbHRgIChleGlzdGluZyBtZWRpYSBlbGVtZW50KSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYSBIVE1MNSBBdWRpbyBvciBWaWRlbyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBBcnJheSBvZiBwZWFrIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZCBIVE1MIDUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGBtZWRpYWAgYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgbWVkaWFcbiAgICAgKiBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZChtZWRpYSwgcGVha3MsIHByZWxvYWQpIHtcbiAgICAgIC8vIHZlcmlmeSBtZWRpYSBlbGVtZW50IGlzIHZhbGlkXG4gICAgICBpZiAoIShtZWRpYSBpbnN0YW5jZW9mIEhUTUxNZWRpYUVsZW1lbnQpIHx8IHR5cGVvZiBtZWRpYS5hZGRFdmVudExpc3RlbmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lZGlhIHBhcmFtZXRlciBpcyBub3QgYSB2YWxpZCBtZWRpYSBlbGVtZW50Jyk7XG4gICAgICB9IC8vIGxvYWQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkgb24gaU9TLCBvdGhlcndpc2UgcGVha3Mgd29uJ3QgZHJhd1xuICAgICAgLy8gdW50aWwgYSB1c2VyIGludGVyYWN0aW9uIHRyaWdnZXJzIGxvYWQgLS0+ICdyZWFkeScgZXZlbnRcbiAgICAgIC8vXG4gICAgICAvLyBub3RlIHRoYXQgd2UgYXZvaWQgY2FsbGluZyBtZWRpYS5sb2FkIGhlcmUgd2hlbiBnaXZlbiBwZWFrcyBhbmQgcHJlbG9hZCA9PSAnbm9uZSdcbiAgICAgIC8vIGFzIHRoaXMgYWxtb3N0IGFsd2F5cyB0cmlnZ2VycyBzb21lIGJyb3dzZXIgZmV0Y2ggb2YgdGhlIG1lZGlhLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgbWVkaWEubG9hZCA9PSAnZnVuY3Rpb24nICYmICEocGVha3MgJiYgcHJlbG9hZCA9PSAnbm9uZScpKSB7XG4gICAgICAgIC8vIFJlc2V0cyB0aGUgbWVkaWEgZWxlbWVudCBhbmQgcmVzdGFydHMgdGhlIG1lZGlhIHJlc291cmNlLiBBbnlcbiAgICAgICAgLy8gcGVuZGluZyBldmVudHMgYXJlIGRpc2NhcmRlZC4gSG93IG11Y2ggbWVkaWEgZGF0YSBpcyBmZXRjaGVkIGlzXG4gICAgICAgIC8vIHN0aWxsIGFmZmVjdGVkIGJ5IHRoZSBwcmVsb2FkIGF0dHJpYnV0ZS5cbiAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG5cbiAgICAgIHRoaXMuX3NldHVwTWVkaWFMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5wZWFrcyA9IHBlYWtzO1xuICAgICAgdGhpcy5vblBsYXlFbmQgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5pc011dGVkID0gbWVkaWEubXV0ZWQ7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBsYXliYWNrUmF0ZSk7XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLnZvbHVtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuaXNQbGF5aW5nKClgIGFuZCBgd2F2ZXN1cmZlci5wbGF5UGF1c2UoKWBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IE1lZGlhIHBhdXNlZCBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzUGF1c2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGF1c2VkKCkge1xuICAgICAgcmV0dXJuICF0aGlzLm1lZGlhIHx8IHRoaXMubWVkaWEucGF1c2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLmdldER1cmF0aW9uKClgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IER1cmF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV4cGxpY2l0RHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXREdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gKHRoaXMuYnVmZmVyIHx8IHRoaXMubWVkaWEpLmR1cmF0aW9uO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPj0gSW5maW5pdHkpIHtcbiAgICAgICAgLy8gc3RyZWFtaW5nIGF1ZGlvXG4gICAgICAgIGR1cmF0aW9uID0gdGhpcy5tZWRpYS5zZWVrYWJsZS5lbmQoMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgcmVsYXRpdmUgdG8gdGhlIGF1ZGlvLWNsaXAnc1xuICAgICAqIGR1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBDdXJyZW50IHRpbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBmcm9tIDAgdG8gMVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBDdXJyZW50IHBvc2l0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5ZWRQZXJjZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbGF5ZWRQZXJjZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkgLyB0aGlzLmdldER1cmF0aW9uKCkgfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdWRpbyBzb3VyY2UgcGxheWJhY2sgcmF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gUGxheWJhY2sgcmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXliYWNrUmF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZSB8fCB0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdWRpbyBzb3VyY2UgcGxheWJhY2sgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBQbGF5YmFjayByYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheWJhY2tSYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlIHx8IDE7XG4gICAgICB0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLnNlZWtUbygpYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFBvc2l0aW9uIHRvIHN0YXJ0IGF0IGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlZWtUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVrVG8oc3RhcnQpIHtcbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhclBsYXlFbmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIGxvYWRlZCBhdWRpbyByZWdpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0IGluIHNlY29uZHMsIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgKiBvZiBhIGNsaXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBXaGVuIHRvIHN0b3AsIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSBjbGlwLlxuICAgICAqIEBlbWl0cyBNZWRpYUVsZW1lbnQjcGxheVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc3VsdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHRoaXMuc2Vla1RvKHN0YXJ0KTtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5tZWRpYS5wbGF5KCk7XG4gICAgICBlbmQgJiYgdGhpcy5zZXRQbGF5RW5kKGVuZCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBsb2FkZWQgYXVkaW8uXG4gICAgICpcbiAgICAgKiBAZW1pdHMgTWVkaWFFbGVtZW50I3BhdXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzdWx0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5tZWRpYS5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyUGxheUVuZCgpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGxheSBlbmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgV2hlcmUgdG8gZW5kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXlFbmQoZW5kKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhclBsYXlFbmQoKTtcblxuICAgICAgdGhpcy5fb25QbGF5RW5kID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgPj0gZW5kKSB7XG4gICAgICAgICAgX3RoaXM0LnBhdXNlKCk7XG5cbiAgICAgICAgICBfdGhpczQuc2Vla1RvKGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ2F1ZGlvcHJvY2VzcycsIHRoaXMuX29uUGxheUVuZCk7XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJQbGF5RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUGxheUVuZCgpIHtcbiAgICAgIGlmICh0aGlzLl9vblBsYXlFbmQpIHtcbiAgICAgICAgdGhpcy51bignYXVkaW9wcm9jZXNzJywgdGhpcy5fb25QbGF5RW5kKTtcbiAgICAgICAgdGhpcy5fb25QbGF5RW5kID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbWF4IGFuZCBtaW4gdmFsdWUgb2YgdGhlIHdhdmVmb3JtIHdoZW4gYnJva2VuIGludG9cbiAgICAgKiA8bGVuZ3RoPiBzdWJyYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIEhvdyBtYW55IHN1YnJhbmdlcyB0byBicmVhayB0aGUgd2F2ZWZvcm0gaW50by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlyc3QgRmlyc3Qgc2FtcGxlIGluIHRoZSByZXF1aXJlZCByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdCBMYXN0IHNhbXBsZSBpbiB0aGUgcmVxdWlyZWQgcmFuZ2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gQXJyYXkgb2YgMio8bGVuZ3RoPiBwZWFrcyBvciBhcnJheSBvZlxuICAgICAqIGFycmF5cyBvZiBwZWFrcyBjb25zaXN0aW5nIG9mIChtYXgsIG1pbikgdmFsdWVzIGZvciBlYWNoIHN1YnJhbmdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGVha3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGVha3MobGVuZ3RoLCBmaXJzdCwgbGFzdCkge1xuICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZWRpYUVsZW1lbnQucHJvdG90eXBlKSwgXCJnZXRQZWFrc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGxlbmd0aCwgZmlyc3QsIGxhc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wZWFrcyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaW5rIGlkIGZvciB0aGUgbWVkaWEgcGxheWVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSWQgU3RyaW5nIHZhbHVlIHJlcHJlc2VudGluZyBhdWRpbyBkZXZpY2UgaWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGB1bmRlZmluZWRgIHdoZW4gdGhlcmVcbiAgICAgKiBhcmUgbm8gZXJyb3JzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2lua0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpbmtJZChkZXZpY2VJZCkge1xuICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYS5zZXRTaW5rSWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzZXRTaW5rSWQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXInKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIGRldmljZUlkOiAnICsgZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZvbHVtZVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSBBIGZsb2F0aW5nIHBvaW50IHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52b2x1bWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXVkaW8gdm9sdW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQSBmbG9hdGluZyBwb2ludCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbHVlKSB7XG4gICAgICB0aGlzLnZvbHVtZSA9IHZhbHVlOyAvLyBubyBuZWVkIHRvIGNoYW5nZSB3aGVuIGl0J3MgYWxyZWFkeSBhdCB0aGF0IHZvbHVtZVxuXG4gICAgICBpZiAodGhpcy5tZWRpYS52b2x1bWUgIT09IHRoaXMudm9sdW1lKSB7XG4gICAgICAgIHRoaXMubWVkaWEudm9sdW1lID0gdGhpcy52b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIG11dGVkIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkIFNwZWNpZnkgYHRydWVgIHRvIG11dGUgYXVkaW8uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE11dGUobXV0ZWQpIHtcbiAgICAgIC8vIFRoaXMgY2F1c2VzIGEgdm9sdW1lIGNoYW5nZSB0byBiZSBlbWl0dGVkIHRvbyB0aHJvdWdoIHRoZVxuICAgICAgLy8gdm9sdW1lY2hhbmdlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgdGhpcy5pc011dGVkID0gdGhpcy5tZWRpYS5tdXRlZCA9IG11dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHdhdmVzdXJmZXIgaXMgZGVzdHJveWVkXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLnVuQWxsKCk7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7IC8vIGNsZWFudXAgbWVkaWEgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubWVkaWFMaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChfdGhpczUubWVkaWEpIHtcbiAgICAgICAgICBfdGhpczUubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihpZCwgX3RoaXM1Lm1lZGlhTGlzdGVuZXJzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMucmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95ICYmIHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMubWVkaWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1lZGlhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lZGlhRWxlbWVudDtcbn0oX3dlYmF1ZGlvLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYUVsZW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcGVha2NhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wZWFrY2FjaGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQ2FjaGVzIHRoZSBkZWNvZGVkIHBlYWtzIGRhdGEgdG8gaW1wcm92ZSByZW5kZXJpbmcgc3BlZWQgZm9yIGxhcmdlIGF1ZGlvXG4gKlxuICogSXMgdXNlZCBpZiB0aGUgb3B0aW9uIHBhcmFtZXRlciBgcGFydGlhbFJlbmRlcmAgaXMgc2V0IHRvIGB0cnVlYFxuICovXG52YXIgUGVha0NhY2hlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGNhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBQZWFrQ2FjaGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlYWtDYWNoZSk7XG5cbiAgICB0aGlzLmNsZWFyUGVha0NhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtcHR5IHRoZSBjYWNoZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQZWFrQ2FjaGUsIFt7XG4gICAga2V5OiBcImNsZWFyUGVha0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUGVha0NhY2hlKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBGbGF0IGFycmF5IHdpdGggZW50cmllcyB0aGF0IGFyZSBhbHdheXMgaW4gcGFpcnMgdG8gbWFyayB0aGVcbiAgICAgICAqIGJlZ2lubmluZyBhbmQgZW5kIG9mIGVhY2ggc3VicmFuZ2UuICBUaGlzIGlzIGEgY29udmVuaWVuY2Ugc28gd2UgY2FuXG4gICAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIHBhaXJzIGZvciBlYXN5IHNldCBkaWZmZXJlbmNlIG9wZXJhdGlvbnMuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB0aGlzLnBlYWtDYWNoZVJhbmdlcyA9IFtdO1xuICAgICAgLyoqXG4gICAgICAgKiBMZW5ndGggb2YgdGhlIGVudGlyZSBjYWNoYWJsZSByZWdpb24sIHVzZWQgZm9yIHJlc2V0dGluZyB0aGUgY2FjaGVcbiAgICAgICAqIHdoZW4gdGhpcyBjaGFuZ2VzICh6b29tIGV2ZW50cywgZm9yIGluc3RhbmNlKS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy5wZWFrQ2FjaGVMZW5ndGggPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcmFuZ2Ugb2YgcGVha3MgdG8gdGhlIGNhY2hlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSB4IG9mZnNldCBvZiB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgeCBvZmZzZXQgb2YgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXIuPEFycmF5W10+fSBBcnJheSB3aXRoIGFycmF5cyBvZiBudW1iZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRSYW5nZVRvUGVha0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJhbmdlVG9QZWFrQ2FjaGUobGVuZ3RoLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAobGVuZ3RoICE9IHRoaXMucGVha0NhY2hlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQZWFrQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5wZWFrQ2FjaGVMZW5ndGggPSBsZW5ndGg7XG4gICAgICB9IC8vIFJldHVybiByYW5nZXMgdGhhdCB3ZXJlbid0IGluIHRoZSBjYWNoZSBiZWZvcmUgdGhlIGNhbGwuXG5cblxuICAgICAgdmFyIHVuY2FjaGVkUmFuZ2VzID0gW107XG4gICAgICB2YXIgaSA9IDA7IC8vIFNraXAgcmFuZ2VzIGJlZm9yZSB0aGUgY3VycmVudCBzdGFydC5cblxuICAgICAgd2hpbGUgKGkgPCB0aGlzLnBlYWtDYWNoZVJhbmdlcy5sZW5ndGggJiYgdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaV0gPCBzdGFydCkge1xuICAgICAgICBpKys7XG4gICAgICB9IC8vIElmIHxpfCBpcyBldmVuLCB8c3RhcnR8IGZhbGxzIGFmdGVyIGFuIGV4aXN0aW5nIHJhbmdlLiAgT3RoZXJ3aXNlLFxuICAgICAgLy8gfHN0YXJ0fCBmYWxscyBiZXR3ZWVuIGFuIGV4aXN0aW5nIHJhbmdlLCBhbmQgdGhlIHVuY2FjaGVkIHJlZ2lvblxuICAgICAgLy8gc3RhcnRzIHdoZW4gd2UgZW5jb3VudGVyIHRoZSBuZXh0IG5vZGUgaW4gfHBlYWtDYWNoZVJhbmdlc3wgb3JcbiAgICAgIC8vIHxlbmR8LCB3aGljaGV2ZXIgY29tZXMgZmlyc3QuXG5cblxuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgdW5jYWNoZWRSYW5nZXMucHVzaChzdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpIDwgdGhpcy5wZWFrQ2FjaGVSYW5nZXMubGVuZ3RoICYmIHRoaXMucGVha0NhY2hlUmFuZ2VzW2ldIDw9IGVuZCkge1xuICAgICAgICB1bmNhY2hlZFJhbmdlcy5wdXNoKHRoaXMucGVha0NhY2hlUmFuZ2VzW2ldKTtcbiAgICAgICAgaSsrO1xuICAgICAgfSAvLyBJZiB8aXwgaXMgZXZlbiwgfGVuZHwgaXMgYWZ0ZXIgYWxsIGV4aXN0aW5nIHJhbmdlcy5cblxuXG4gICAgICBpZiAoaSAlIDIgPT0gMCkge1xuICAgICAgICB1bmNhY2hlZFJhbmdlcy5wdXNoKGVuZCk7XG4gICAgICB9IC8vIEZpbHRlciBvdXQgdGhlIDAtbGVuZ3RoIHJhbmdlcy5cblxuXG4gICAgICB1bmNhY2hlZFJhbmdlcyA9IHVuY2FjaGVkUmFuZ2VzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgcG9zLCBhcnIpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT0gYXJyW3BvcyArIDFdO1xuICAgICAgICB9IGVsc2UgaWYgKHBvcyA9PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgLSAxXSAmJiBpdGVtICE9IGFycltwb3MgKyAxXTtcbiAgICAgIH0pOyAvLyBNZXJnZSB0aGUgdHdvIHJhbmdlcyB0b2dldGhlciwgdW5jYWNoZWRSYW5nZXMgd2lsbCBlaXRoZXIgY29udGFpblxuICAgICAgLy8gd2hvbGx5IG5ldyBwb2ludHMsIG9yIGR1cGxpY2F0ZXMgb2YgcG9pbnRzIGluIHBlYWtDYWNoZVJhbmdlcy4gIElmXG4gICAgICAvLyBkdXBsaWNhdGVzIGFyZSBkZXRlY3RlZCwgcmVtb3ZlIGJvdGggYW5kIGV4dGVuZCB0aGUgcmFuZ2UuXG5cbiAgICAgIHRoaXMucGVha0NhY2hlUmFuZ2VzID0gdGhpcy5wZWFrQ2FjaGVSYW5nZXMuY29uY2F0KHVuY2FjaGVkUmFuZ2VzKTtcbiAgICAgIHRoaXMucGVha0NhY2hlUmFuZ2VzID0gdGhpcy5wZWFrQ2FjaGVSYW5nZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIHBvcywgYXJyKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9IGFycltwb3MgKyAxXTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbSAhPSBhcnJbcG9zIC0gMV0gJiYgaXRlbSAhPSBhcnJbcG9zICsgMV07XG4gICAgICB9KTsgLy8gUHVzaCB0aGUgdW5jYWNoZWQgcmFuZ2VzIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIGZvciBlYXNlIG9mXG4gICAgICAvLyBpdGVyYXRpb24gaW4gdGhlIGZ1bmN0aW9ucyB0aGF0IGNhbGwgdGhpcy5cblxuICAgICAgdmFyIHVuY2FjaGVkUmFuZ2VQYWlycyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdW5jYWNoZWRSYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdW5jYWNoZWRSYW5nZVBhaXJzLnB1c2goW3VuY2FjaGVkUmFuZ2VzW2ldLCB1bmNhY2hlZFJhbmdlc1tpICsgMV1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuY2FjaGVkUmFuZ2VQYWlycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRlc3RpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlci48QXJyYXlbXT59IEFycmF5IHdpdGggYXJyYXlzIG9mIG51bWJlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENhY2hlUmFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlUmFuZ2VzKCkge1xuICAgICAgdmFyIHBlYWtDYWNoZVJhbmdlUGFpcnMgPSBbXTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wZWFrQ2FjaGVSYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcGVha0NhY2hlUmFuZ2VQYWlycy5wdXNoKFt0aGlzLnBlYWtDYWNoZVJhbmdlc1tpXSwgdGhpcy5wZWFrQ2FjaGVSYW5nZXNbaSArIDFdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZWFrQ2FjaGVSYW5nZVBhaXJzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQZWFrQ2FjaGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBlYWtDYWNoZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2Fic01heC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2Fic01heC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFic01heDtcblxudmFyIF9tYXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF4ICovIFwiLi9zcmMvdXRpbC9tYXguanNcIikpO1xuXG52YXIgX21pbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taW4gKi8gXCIuL3NyYy91dGlsL21pbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGxhcmdlc3QgYWJzb2x1dGUgdmFsdWUgaW4gYW4gYXJyYXlcclxuICpcclxuICogQHBhcmFtICAge0FycmF5fSB2YWx1ZXMgQXJyYXkgb2YgbnVtYmVyc1xyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBMYXJnZXN0IG51bWJlciBmb3VuZFxyXG4gKiBAZXhhbXBsZSBjb25zb2xlLmxvZyhtYXgoWy0zLCAyLCAxXSksIG1heChbLTMsIDIsIDRdKSk7IC8vIGxvZ3MgMyA0XHJcbiAqIEBzaW5jZSA0LjMuMFxyXG4gKi9cbmZ1bmN0aW9uIGFic01heCh2YWx1ZXMpIHtcbiAgdmFyIG1heCA9ICgwLCBfbWF4LmRlZmF1bHQpKHZhbHVlcyk7XG4gIHZhciBtaW4gPSAoMCwgX21pbi5kZWZhdWx0KSh2YWx1ZXMpO1xuICByZXR1cm4gLW1pbiA+IG1heCA/IC1taW4gOiBtYXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2NsYW1wLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9jbGFtcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xhbXA7XG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciBsaW1pdGVkIHRvIHRoZSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFRoZSBudW1iZXIgdG8gYmUgbGltaXRlZCB0byBhIHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgbGltaXQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBsaW1pdCByYW5nZVxuICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heF1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWwpLCBtYXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9mZXRjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvZmV0Y2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoRmlsZTtcblxudmFyIF9vYnNlcnZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vYnNlcnZlciAqLyBcIi4vc3JjL3V0aWwvb2JzZXJ2ZXIuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBQcm9ncmVzc0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogSW5zdGFudGlhdGUgUHJvZ3Jlc3NIYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IGluc3RhbmNlIFRoZSBgZmV0Y2hGaWxlYCBvYnNlcnZlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRlbnRMZW5ndGggQ29udGVudCBsZW5ndGguXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIFJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzSGFuZGxlcihpbnN0YW5jZSwgY29udGVudExlbmd0aCwgcmVzcG9uc2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3Jlc3NIYW5kbGVyKTtcblxuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB0aGlzLmluc3RhbmNlLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIHRoaXMudG90YWwgPSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCk7XG4gICAgdGhpcy5sb2FkZWQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBvbmNlLCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYFJlYWRhYmxlU3RyZWFtYGBcbiAgICogaXMgY29uc3RydWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcn0gY29udHJvbGxlciBDb250cm9sbGVyIGluc3RhbmNlXG4gICAqICAgICB1c2VkIHRvIGNvbnRyb2wgdGhlIHN0cmVhbS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUHJvZ3Jlc3NIYW5kbGVyLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIC8vIGluc3RhbmNlLl9yZWFkZXIucmVhZCgpIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAgICAgICAgLy8gd2hlbiBhIHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkXG4gICAgICAgIF90aGlzLmluc3RhbmNlLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgZG9uZSA9IF9yZWYuZG9uZSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gICAgICAgICAgLy8gcmVzdWx0IG9iamVjdHMgY29udGFpbiB0d28gcHJvcGVydGllczpcbiAgICAgICAgICAvLyBkb25lICAtIHRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBnaXZlbiB5b3UgYWxsIGl0cyBkYXRhLlxuICAgICAgICAgIC8vIHZhbHVlIC0gc29tZSBkYXRhLiBBbHdheXMgdW5kZWZpbmVkIHdoZW4gZG9uZSBpcyB0cnVlLlxuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgb25Qcm9ncmVzcyBjYWxsZWQgd2hlbiBjb250ZW50LWxlbmd0aD0wXG4gICAgICAgICAgICBpZiAoX3RoaXMudG90YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2Uub25Qcm9ncmVzcy5jYWxsKF90aGlzLmluc3RhbmNlLCB7XG4gICAgICAgICAgICAgICAgbG9hZGVkOiBfdGhpcy5sb2FkZWQsXG4gICAgICAgICAgICAgICAgdG90YWw6IF90aGlzLnRvdGFsLFxuICAgICAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cblxuXG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMubG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5vblByb2dyZXNzLmNhbGwoX3RoaXMuaW5zdGFuY2UsIHtcbiAgICAgICAgICAgIGxvYWRlZDogX3RoaXMubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IF90aGlzLnRvdGFsLFxuICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogIShfdGhpcy50b3RhbCA9PT0gMClcbiAgICAgICAgICB9KTsgLy8gZW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cblxuXG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICByZWFkKCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJlYWQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJvZ3Jlc3NIYW5kbGVyO1xufSgpO1xuLyoqXG4gKiBMb2FkIGEgZmlsZSB1c2luZyBgZmV0Y2hgLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFJlcXVlc3Qgb3B0aW9ucyB0byB1c2UuIFNlZSBleGFtcGxlIGJlbG93LlxuICogQHJldHVybnMge09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICogQGV4YW1wbGVcbiAqIC8vIGRlZmF1bHQgb3B0aW9uc1xuICogbGV0IG9wdGlvbnMgPSB7XG4gKiAgICAgdXJsOiB1bmRlZmluZWQsXG4gKiAgICAgbWV0aG9kOiAnR0VUJyxcbiAqICAgICBtb2RlOiAnY29ycycsXG4gKiAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gKiAgICAgY2FjaGU6ICdkZWZhdWx0JyxcbiAqICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAqICAgICByZXF1ZXN0SGVhZGVyczogW10sXG4gKiAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICogICAgIHJlZmVycmVyOiAnY2xpZW50J1xuICogfTtcbiAqXG4gKiAvLyBvdmVycmlkZSBzb21lIG9wdGlvbnNcbiAqIG9wdGlvbnMudXJsID0gJy4uL21lZGlhL2RlbW8ud2F2JztcblxuICogLy8gYXZhaWxhYmxlIHR5cGVzOiAnYXJyYXlidWZmZXInLCAnYmxvYicsICdqc29uJyBvciAndGV4dCdcbiAqIG9wdGlvbnMucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAqXG4gKiAvLyBtYWtlIGZldGNoIGNhbGxcbiAqIGxldCByZXF1ZXN0ID0gdXRpbC5mZXRjaEZpbGUob3B0aW9ucyk7XG4gKlxuICogLy8gbGlzdGVuIGZvciBldmVudHNcbiAqIHJlcXVlc3Qub24oJ3Byb2dyZXNzJywgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ3Byb2dyZXNzJywgZSk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0Lm9uKCdzdWNjZXNzJywgZGF0YSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ3N1Y2Nlc3MhJywgZGF0YSk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0Lm9uKCdlcnJvcicsIGUgPT4ge1xuICogICAgIGNvbnNvbGUud2FybignZmV0Y2hGaWxlIGVycm9yOiAnLCBlKTtcbiAqIH0pO1xuICovXG5cblxuZnVuY3Rpb24gZmV0Y2hGaWxlKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaCBvcHRpb25zIG1pc3NpbmcnKTtcbiAgfSBlbHNlIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoIHVybCBtaXNzaW5nJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgX29ic2VydmVyLmRlZmF1bHQoKTtcbiAgdmFyIGZldGNoSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIHZhciBmZXRjaFJlcXVlc3QgPSBuZXcgUmVxdWVzdChvcHRpb25zLnVybCk7IC8vIGFkZCBhYmlsaXR5IHRvIGFib3J0XG5cbiAgaW5zdGFuY2UuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTsgLy8gY2hlY2sgaWYgaGVhZGVycyBoYXZlIHRvIGJlIGFkZGVkXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXF1ZXN0SGVhZGVycykge1xuICAgIC8vIGFkZCBjdXN0b20gcmVxdWVzdCBoZWFkZXJzXG4gICAgb3B0aW9ucy5yZXF1ZXN0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIGZldGNoSGVhZGVycy5hcHBlbmQoaGVhZGVyLmtleSwgaGVhZGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgfSAvLyBwYXJzZSBmZXRjaCBvcHRpb25zXG5cblxuICB2YXIgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGUgfHwgJ2pzb24nO1xuICB2YXIgZmV0Y2hPcHRpb25zID0ge1xuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgIG1vZGU6IG9wdGlvbnMubW9kZSB8fCAnY29ycycsXG4gICAgY3JlZGVudGlhbHM6IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJyxcbiAgICBjYWNoZTogb3B0aW9ucy5jYWNoZSB8fCAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6IG9wdGlvbnMucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG4gICAgcmVmZXJyZXI6IG9wdGlvbnMucmVmZXJyZXIgfHwgJ2NsaWVudCcsXG4gICAgc2lnbmFsOiBpbnN0YW5jZS5jb250cm9sbGVyLnNpZ25hbFxuICB9O1xuICBmZXRjaChmZXRjaFJlcXVlc3QsIGZldGNoT3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAvLyBzdG9yZSByZXNwb25zZSByZWZlcmVuY2VcbiAgICBpbnN0YW5jZS5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHZhciBwcm9ncmVzc0F2YWlsYWJsZSA9IHRydWU7XG5cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIC8vIFJlYWRhYmxlU3RyZWFtIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclxuICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZWFkYWJsZVN0cmVhbVxuICAgICAgcHJvZ3Jlc3NBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB9IC8vIFNlcnZlciBtdXN0IHNlbmQgQ09SUyBoZWFkZXIgXCJBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyczogY29udGVudC1sZW5ndGhcIlxuXG5cbiAgICB2YXIgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpO1xuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIC8vIENvbnRlbnQtTGVuZ3RoIHNlcnZlciByZXNwb25zZSBoZWFkZXIgbWlzc2luZy5cbiAgICAgIC8vIERvbid0IGV2YWx1YXRlIGRvd25sb2FkIHByb2dyZXNzIGlmIHdlIGNhbid0IGNvbXBhcmUgYWdhaW5zdCBhIHRvdGFsIHNpemVcbiAgICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0NPUlMjQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNcbiAgICAgIHByb2dyZXNzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9ncmVzc0F2YWlsYWJsZSkge1xuICAgICAgLy8gbm90IGFibGUgdG8gY2hlY2sgZG93bmxvYWQgcHJvZ3Jlc3Mgc28gc2tpcCBpdFxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gLy8gZmlyZSBwcm9ncmVzcyBldmVudCB3aGVuIGR1cmluZyBsb2FkXG5cblxuICAgIGluc3RhbmNlLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaW5zdGFuY2UuZmlyZUV2ZW50KCdwcm9ncmVzcycsIGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG5ldyBSZWFkYWJsZVN0cmVhbShuZXcgUHJvZ3Jlc3NIYW5kbGVyKGluc3RhbmNlLCBjb250ZW50TGVuZ3RoLCByZXNwb25zZSkpLCBmZXRjaE9wdGlvbnMpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHZhciBlcnJNc2c7XG5cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVyck1zZyA9ICdVbmtub3duIHJlc3BvbnNlVHlwZTogJyArIHJlc3BvbnNlVHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWVyck1zZykge1xuICAgICAgZXJyTXNnID0gJ0hUVFAgZXJyb3Igc3RhdHVzOiAnICsgcmVzcG9uc2Uuc3RhdHVzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGluc3RhbmNlLmZpcmVFdmVudCgnc3VjY2VzcycsIHJlc3BvbnNlKTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaW5zdGFuY2UuZmlyZUV2ZW50KCdlcnJvcicsIGVycm9yKTtcbiAgfSk7IC8vIHJldHVybiB0aGUgZmV0Y2ggcmVxdWVzdFxuXG4gIGluc3RhbmNlLmZldGNoUmVxdWVzdCA9IGZldGNoUmVxdWVzdDtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9mcmFtZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvZnJhbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZyYW1lO1xuXG52YXIgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZSAqLyBcIi4vc3JjL3V0aWwvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICogY3ljbGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKlxuICogQHJldHVybiB7ZnVuY30gVGhlIGZ1bmN0aW9uIHdyYXBwZWQgd2l0aGluIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKi9cbmZ1bmN0aW9uIGZyYW1lKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2dldC1pZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2dldC1pZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldElkO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBwcmVmaXhlZCBJRFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggUHJlZml4IHRvIHVzZS4gRGVmYXVsdCBpcyBgJ3dhdmVzdXJmZXJfJ2AuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBSYW5kb20gcHJlZml4ZWQgSURcbiAqIEBleGFtcGxlXG4gKiBjb25zb2xlLmxvZyhnZXRJZCgpKTsgLy8gbG9ncyAnd2F2ZXN1cmZlcl9iNXBvcnM0cnU2ZydcbiAqXG4gKiBsZXQgcHJlZml4ID0gJ2Zvby0nO1xuICogY29uc29sZS5sb2coZ2V0SWQocHJlZml4KSk7IC8vIGxvZ3MgJ2Zvby1iNXBvcnM0cnU2ZydcbiAqL1xuZnVuY3Rpb24gZ2V0SWQocHJlZml4KSB7XG4gIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgIHByZWZpeCA9ICd3YXZlc3VyZmVyXyc7XG4gIH1cblxuICByZXR1cm4gcHJlZml4ICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc3Vic3RyaW5nKDIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SWRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRJZC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXhcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tYXguZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWluXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWluLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFic01heFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Fic01heC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYnNlcnZlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX29ic2VydmVyLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0eWxlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3R5bGUuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmRlZmF1bHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyYW1lXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZnJhbWUuZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVib3VuY2VcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kZWJvdW5jZS5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcmV2ZW50Q2xpY2tcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wcmV2ZW50Q2xpY2suZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmV0Y2hGaWxlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmV0Y2guZGVmYXVsdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xhbXBcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jbGFtcC5kZWZhdWx0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aXRoT3JpZW50YXRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9vcmllbnRhdGlvbi5kZWZhdWx0O1xuICB9XG59KSk7XG5cbnZhciBfZ2V0SWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LWlkICovIFwiLi9zcmMvdXRpbC9nZXQtaWQuanNcIikpO1xuXG52YXIgX21heCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXggKi8gXCIuL3NyYy91dGlsL21heC5qc1wiKSk7XG5cbnZhciBfbWluID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21pbiAqLyBcIi4vc3JjL3V0aWwvbWluLmpzXCIpKTtcblxudmFyIF9hYnNNYXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWJzTWF4ICovIFwiLi9zcmMvdXRpbC9hYnNNYXguanNcIikpO1xuXG52YXIgX29ic2VydmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29ic2VydmVyICovIFwiLi9zcmMvdXRpbC9vYnNlcnZlci5qc1wiKSk7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3R5bGUgKi8gXCIuL3NyYy91dGlsL3N0eWxlLmpzXCIpKTtcblxudmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVxdWVzdC1hbmltYXRpb24tZnJhbWUgKi8gXCIuL3NyYy91dGlsL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzXCIpKTtcblxudmFyIF9mcmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFtZSAqLyBcIi4vc3JjL3V0aWwvZnJhbWUuanNcIikpO1xuXG52YXIgX2RlYm91bmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkZWJvdW5jZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzXCIpKTtcblxudmFyIF9wcmV2ZW50Q2xpY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJldmVudC1jbGljayAqLyBcIi4vc3JjL3V0aWwvcHJldmVudC1jbGljay5qc1wiKSk7XG5cbnZhciBfZmV0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmV0Y2ggKi8gXCIuL3NyYy91dGlsL2ZldGNoLmpzXCIpKTtcblxudmFyIF9jbGFtcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jbGFtcCAqLyBcIi4vc3JjL3V0aWwvY2xhbXAuanNcIikpO1xuXG52YXIgX29yaWVudGF0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29yaWVudGF0aW9uICovIFwiLi9zcmMvdXRpbC9vcmllbnRhdGlvbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvbWF4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvbWF4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWF4O1xuXG4vKipcbiAqIEdldCB0aGUgbGFyZ2VzdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSAgIHtBcnJheX0gdmFsdWVzIEFycmF5IG9mIG51bWJlcnNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IExhcmdlc3QgbnVtYmVyIGZvdW5kXG4gKiBAZXhhbXBsZSBjb25zb2xlLmxvZyhtYXgoWzEsIDIsIDNdKSk7IC8vIGxvZ3MgM1xuICovXG5mdW5jdGlvbiBtYXgodmFsdWVzKSB7XG4gIHZhciBsYXJnZXN0ID0gLUluZmluaXR5O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAodmFsdWVzW2ldID4gbGFyZ2VzdCkge1xuICAgICAgbGFyZ2VzdCA9IHZhbHVlc1tpXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGFyZ2VzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvbWluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvbWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWluO1xuXG4vKipcbiAqIEdldCB0aGUgc21hbGxlc3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0gICB7QXJyYXl9IHZhbHVlcyBBcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBTbWFsbGVzdCBudW1iZXIgZm91bmRcbiAqIEBleGFtcGxlIGNvbnNvbGUubG9nKG1pbihbMSwgMiwgM10pKTsgLy8gbG9ncyAxXG4gKi9cbmZ1bmN0aW9uIG1pbih2YWx1ZXMpIHtcbiAgdmFyIHNtYWxsZXN0ID0gTnVtYmVyKEluZmluaXR5KTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKHZhbHVlc1tpXSA8IHNtYWxsZXN0KSB7XG4gICAgICBzbWFsbGVzdCA9IHZhbHVlc1tpXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc21hbGxlc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL29ic2VydmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9vYnNlcnZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTGlzdGVuZXJEZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdW4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICovXG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3NcbiAqL1xudmFyIE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIE9ic2VydmVyXG4gICAqL1xuICBmdW5jdGlvbiBPYnNlcnZlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JzZXJ2ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdG9kbyBJbml0aWFsaXNlIHRoZSBoYW5kbGVycyBoZXJlIGFscmVhZHkgYW5kIHJlbW92ZSB0aGUgY29uZGl0aW9uYWxcbiAgICAgKiBhc3NpZ25tZW50IGluIGBvbigpYFxuICAgICAqL1xuICAgIHRoaXMuX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmhhbmRsZXJzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIGEgaGFuZGxlciBmdW5jdGlvbiBmb3IgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWRcbiAgICogQHJldHVybiB7TGlzdGVuZXJEZXNjcmlwdG9yfSBUaGUgZXZlbnQgZGVzY3JpcHRvclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhPYnNlcnZlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XTtcblxuICAgICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgICBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXJzLnB1c2goZm4pOyAvLyBSZXR1cm4gYW4gZXZlbnQgZGVzY3JpcHRvclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBldmVudCxcbiAgICAgICAgY2FsbGJhY2s6IGZuLFxuICAgICAgICB1bjogZnVuY3Rpb24gdW4oZSwgZm4pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudW4oZSwgZm4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudCB0aGUgbGlzdGVuZXIgdGhhdCBzaG91bGQgYmVcbiAgICAgKiByZW1vdmVkIGxpc3RlbnMgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW4oZXZlbnQsIGZuKSB7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgZm9yIChpID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PSBmbikge1xuICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuQWxsKCkge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIGhhbmRsZXIgdG8gYW4gZXZlbnQuIFRoZSBoYW5kbGVyIGlzIGV4ZWN1dGVkIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVudCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBjYWxsYmFjayB0aGF0IGlzIG9ubHkgdG8gYmUgY2FsbGVkIG9uY2VcbiAgICAgKiBAcmV0dXJuIHtMaXN0ZW5lckRlc2NyaXB0b3J9IFRoZSBldmVudCBkZXNjcmlwdG9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cbiAgICAgICAgaGFuZGxlci5hcHBseShfdGhpczIsIGFyZ3MpO1xuICAgICAgICAvKiAgZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIudW4oZXZlbnQsIGZuKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5vbihldmVudCwgZm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGZpcmluZyBhIGxpc3Qgb2YgZXZlbnRzIGJ5IG5hbWUuIFdoZW4gc3BlY2lmaWVkLCBldmVudCBoYW5kbGVycyBmb3IgYW55IGV2ZW50IHR5cGVcbiAgICAgKiBwYXNzZWQgaW4gaGVyZSB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRpc2FibGUgZW1pc3Npb25zIGZvclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZGlzYWJsZSBzZWVrIGFuZCBpbnRlcmFjdGlvbiBldmVudHNcbiAgICAgKiB3YXZlc3VyZmVyLnNldERpc2FibGVkRXZlbnRFbWlzc2lvbnMoWydzZWVrJywgJ2ludGVyYWN0aW9uJ10pO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGlzYWJsZWRFdmVudEVtaXNzaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXNhYmxlZEV2ZW50RW1pc3Npb25zKGV2ZW50TmFtZXMpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnMgPSBldmVudE5hbWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwbHVnaW5zIGJvcnJvdyBwYXJ0IG9mIHRoaXMgY2xhc3Mgd2l0aG91dCBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgKiBzbyB3ZSBoYXZlIHRvIGJlIGNhcmVmdWwgYWJvdXQgX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0Rpc2FibGVkRXZlbnRFbWlzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNEaXNhYmxlZEV2ZW50RW1pc3Npb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZEV2ZW50RW1pc3Npb25zICYmIHRoaXMuX2Rpc2FibGVkRXZlbnRFbWlzc2lvbnMuaW5jbHVkZXMoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBmaXJlIGFuIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHRvIGZpcmUgbWFudWFsbHlcbiAgICAgKiBAcGFyYW0gey4uLmFueX0gYXJncyBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggdG8gY2FsbCB0aGUgbGlzdGVuZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXJlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFuZGxlcnMgfHwgdGhpcy5faXNEaXNhYmxlZEV2ZW50RW1pc3Npb24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF07XG4gICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBPYnNlcnZlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL29yaWVudGF0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9vcmllbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gd2l0aE9yaWVudGF0aW9uO1xudmFyIHZlcnRpY2FsUHJvcE1hcCA9IHtcbiAgd2lkdGg6ICdoZWlnaHQnLFxuICBoZWlnaHQ6ICd3aWR0aCcsXG4gIG92ZXJmbG93WDogJ292ZXJmbG93WScsXG4gIG92ZXJmbG93WTogJ292ZXJmbG93WCcsXG4gIGNsaWVudFdpZHRoOiAnY2xpZW50SGVpZ2h0JyxcbiAgY2xpZW50SGVpZ2h0OiAnY2xpZW50V2lkdGgnLFxuICBjbGllbnRYOiAnY2xpZW50WScsXG4gIGNsaWVudFk6ICdjbGllbnRYJyxcbiAgc2Nyb2xsV2lkdGg6ICdzY3JvbGxIZWlnaHQnLFxuICBzY3JvbGxMZWZ0OiAnc2Nyb2xsVG9wJyxcbiAgb2Zmc2V0TGVmdDogJ29mZnNldFRvcCcsXG4gIG9mZnNldFRvcDogJ29mZnNldExlZnQnLFxuICBvZmZzZXRIZWlnaHQ6ICdvZmZzZXRXaWR0aCcsXG4gIG9mZnNldFdpZHRoOiAnb2Zmc2V0SGVpZ2h0JyxcbiAgbGVmdDogJ3RvcCcsXG4gIHJpZ2h0OiAnYm90dG9tJyxcbiAgdG9wOiAnbGVmdCcsXG4gIGJvdHRvbTogJ3JpZ2h0JyxcbiAgYm9yZGVyUmlnaHRTdHlsZTogJ2JvcmRlckJvdHRvbVN0eWxlJyxcbiAgYm9yZGVyUmlnaHRXaWR0aDogJ2JvcmRlckJvdHRvbVdpZHRoJyxcbiAgYm9yZGVyUmlnaHRDb2xvcjogJ2JvcmRlckJvdHRvbUNvbG9yJ1xufTtcbi8qKlxuICogQ29udmVydCBhIGhvcml6b250YWxseS1vcmllbnRlZCBwcm9wZXJ0eSBuYW1lIHRvIGEgdmVydGljYWwgb25lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIEEgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtib29sfSB2ZXJ0aWNhbCBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIG9yaWVudGVkIHZlcnRpY2FsbHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHByb3AsIGNvbnZlcnRlZCBhcHByb3ByaWF0ZWx5XG4gKi9cblxuZnVuY3Rpb24gbWFwUHJvcChwcm9wLCB2ZXJ0aWNhbCkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnRpY2FsUHJvcE1hcCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdmVydGljYWwgPyB2ZXJ0aWNhbFByb3BNYXBbcHJvcF0gOiBwcm9wO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59XG5cbnZhciBpc1Byb3h5ID0gU3ltYm9sKFwiaXNQcm94eVwiKTtcbi8qKlxuICogUmV0dXJucyBhbiBhcHByb3ByaWF0ZWx5IG9yaWVudGVkIG9iamVjdCBiYXNlZCBvbiB2ZXJ0aWNhbC5cbiAqIElmIHZlcnRpY2FsIGlzIHRydWUsIGF0dHJpYnV0ZSBnZXR0aW5nIGFuZCBzZXR0aW5nIHdpbGwgYmUgbWFwcGVkIHRocm91Z2hcbiAqIHZlcnRpY2FsUHJvcE1hcCwgc28gdGhhdCBlLmcuIGdldHRpbmcgdGhlIG9iamVjdCdzIC53aWR0aCB3aWxsIGdpdmUgaXRzXG4gKiAuaGVpZ2h0IGluc3RlYWQuXG4gKiBDZXJ0YWluIG1ldGhvZHMgb2YgYW4gb3JpZW50ZWQgb2JqZWN0IHdpbGwgcmV0dXJuIG9yaWVudGVkIG9iamVjdHMgYXMgd2VsbC5cbiAqIE9yaWVudGVkIG9iamVjdHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlIERPTSBkaXJlY3RseSBzaW5jZSB0aGV5IGFyZSBQcm94eSBvYmplY3RzXG4gKiBhbmQgdGh1cyBmYWlsIHR5cGVjaGVja3MuIFVzZSBkb21FbGVtZW50IHRvIGdldCB0aGUgYWN0dWFsIGVsZW1lbnQgZm9yIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIGJlIHdyYXBwZWQgYW5kIG9yaWVudGVkXG4gKiBAcGFyYW0ge2Jvb2x9IHZlcnRpY2FsIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgb3JpZW50ZWQgdmVydGljYWxseVxuICogQHJldHVybnMge1Byb3h5fSBBbiBvcmllbnRlZCBvYmplY3Qgd2l0aCBhdHRyIHRyYW5zbGF0aW9uIHZpYSB2ZXJ0aWNhbEF0dHJNYXBcbiAqIEBzaW5jZSA1LjAuMFxuICovXG5cbmZ1bmN0aW9uIHdpdGhPcmllbnRhdGlvbih0YXJnZXQsIHZlcnRpY2FsKSB7XG4gIGlmICh0YXJnZXRbaXNQcm94eV0pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChvYmosIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChwcm9wID09PSBpc1Byb3h5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2RvbUVsZW1lbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhPcmllbnRhdGlvbihvYmouc3R5bGUsIHZlcnRpY2FsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnY2FudmFzJykge1xuICAgICAgICAgIHJldHVybiB3aXRoT3JpZW50YXRpb24ob2JqLmNhbnZhcywgdmVydGljYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoT3JpZW50YXRpb24ob2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdC5hcHBseShvYmosIGFyZ3VtZW50cyksIHZlcnRpY2FsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdnZXRDb250ZXh0Jykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aE9yaWVudGF0aW9uKG9iai5nZXRDb250ZXh0LmFwcGx5KG9iaiwgYXJndW1lbnRzKSwgdmVydGljYWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqW21hcFByb3AocHJvcCwgdmVydGljYWwpXTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZS5iaW5kKG9iaikgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgb2JqW21hcFByb3AocHJvcCwgdmVydGljYWwpXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9wcmV2ZW50LWNsaWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3ByZXZlbnQtY2xpY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gcHJldmVudENsaWNrO1xuXG4vKipcbiAqIFN0b3BzIHByb3BhZ2F0aW9uIG9mIGNsaWNrIGV2ZW50IGFuZCByZW1vdmVzIGV2ZW50IGxpc3RlbmVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgY2xpY2sgZXZlbnRcbiAqL1xuZnVuY3Rpb24gcHJldmVudENsaWNrSGFuZGxlcihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXZlbnRDbGlja0hhbmRsZXIsIHRydWUpO1xufVxuLyoqXG4gKiBTdGFydHMgbGlzdGVuaW5nIGZvciBjbGljayBldmVudCBhbmQgcHJldmVudCBwcm9wYWdhdGlvblxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgVmFsdWVzXG4gKi9cblxuXG5mdW5jdGlvbiBwcmV2ZW50Q2xpY2sodmFsdWVzKSB7XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2ZW50Q2xpY2tIYW5kbGVyLCB0cnVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgZnVuY3Rpb24gZm9yIHRoZSBicm93c2VyLCBvciBhIHNoaW0gd2l0aFxuICogYHNldFRpbWVvdXRgIGlmIHRoZSBmdW5jdGlvbiBpcyBub3QgZm91bmRcbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gQXZhaWxhYmxlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGZ1bmN0aW9uIGZvciB0aGUgYnJvd3NlclxuICovXG52YXIgX2RlZmF1bHQgPSAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xuICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbn0pLmJpbmQod2luZG93KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9zdHlsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvc3R5bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN0eWxlO1xuXG4vKipcbiAqIEFwcGx5IGEgbWFwIG9mIHN0eWxlcyB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdGhhdCB0aGUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBUaGUgbWFwIG9mIHByb3BOYW1lOiBhdHRyaWJ1dGUsIGJvdGggYXJlIHVzZWQgYXMtaXNcbiAqXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gZWxcbiAqL1xuZnVuY3Rpb24gc3R5bGUoZWwsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAoZWwuc3R5bGVbcHJvcF0gIT09IHN0eWxlc1twcm9wXSkge1xuICAgICAgZWwuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvd2F2ZXN1cmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3dhdmVzdXJmZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIikpO1xuXG52YXIgX2RyYXdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kcmF3ZXIubXVsdGljYW52YXMgKi8gXCIuL3NyYy9kcmF3ZXIubXVsdGljYW52YXMuanNcIikpO1xuXG52YXIgX3dlYmF1ZGlvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYmF1ZGlvICovIFwiLi9zcmMvd2ViYXVkaW8uanNcIikpO1xuXG52YXIgX21lZGlhZWxlbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZWRpYWVsZW1lbnQgKi8gXCIuL3NyYy9tZWRpYWVsZW1lbnQuanNcIikpO1xuXG52YXIgX3BlYWtjYWNoZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wZWFrY2FjaGUgKi8gXCIuL3NyYy9wZWFrY2FjaGUuanNcIikpO1xuXG52YXIgX21lZGlhZWxlbWVudFdlYmF1ZGlvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lZGlhZWxlbWVudC13ZWJhdWRpbyAqLyBcIi4vc3JjL21lZGlhZWxlbWVudC13ZWJhdWRpby5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIGEgQlNELTMtQ2xhdXNlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBleHRlcm5hbCB7SFRNTEVsZW1lbnR9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudCAqL1xuXG4vKiogQGV4dGVybmFsIHtPZmZsaW5lQXVkaW9Db250ZXh0fSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvT2ZmbGluZUF1ZGlvQ29udGV4dCAqL1xuXG4vKiogQGV4dGVybmFsIHtGaWxlfSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSAqL1xuXG4vKiogQGV4dGVybmFsIHtCbG9ifSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYiAqL1xuXG4vKiogQGV4dGVybmFsIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgKi9cblxuLyoqIEBleHRlcm5hbCB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU3RyZWFtQ29uc3RyYWludHMgKi9cblxuLyoqIEBleHRlcm5hbCB7QXVkaW9Ob2RlfSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2F2ZXN1cmZlclBhcmFtc1xuICogQHByb3BlcnR5IHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dD1udWxsIFVzZSB5b3VyIG93biBwcmV2aW91c2x5XG4gKiBpbml0aWFsaXplZCBBdWRpb0NvbnRleHQgb3IgbGVhdmUgYmxhbmsuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXVkaW9SYXRlPTEgU3BlZWQgYXQgd2hpY2ggdG8gcGxheSBhdWRpby4gTG93ZXIgbnVtYmVyIGlzXG4gKiBzbG93ZXIuXG4gKiBAcHJvcGVydHkge1NjcmlwdFByb2Nlc3Nvck5vZGV9IGF1ZGlvU2NyaXB0UHJvY2Vzc29yPW51bGwgVXNlIHlvdXIgb3duIHByZXZpb3VzbHlcbiAqIGluaXRpYWxpemVkIFNjcmlwdFByb2Nlc3Nvck5vZGUgb3IgbGVhdmUgYmxhbmsuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGF1dG9DZW50ZXI9dHJ1ZSBJZiBhIHNjcm9sbGJhciBpcyBwcmVzZW50LCBjZW50ZXIgdGhlXG4gKiB3YXZlZm9ybSBvbiBjdXJyZW50IHByb2dyZXNzXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXV0b0NlbnRlclJhdGU9NSBJZiBhdXRvQ2VudGVyIGlzIGFjdGl2ZSwgcmF0ZSBhdCB3aGljaCB0aGVcbiAqIHdhdmVmb3JtIGlzIGNlbnRlcmVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGF1dG9DZW50ZXJJbW1lZGlhdGVseT1mYWxzZSBJZiBhdXRvQ2VudGVyIGlzIGFjdGl2ZSwgaW1tZWRpYXRlbHlcbiAqIGNlbnRlciB3YXZlZm9ybSBvbiBjdXJyZW50IHByb2dyZXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2VuZD0nV2ViQXVkaW8nIGAnV2ViQXVkaW8nfCdNZWRpYUVsZW1lbnQnfCdNZWRpYUVsZW1lbnRXZWJBdWRpbydgIEluIG1vc3QgY2FzZXNcbiAqIHlvdSBkb24ndCBoYXZlIHRvIHNldCB0aGlzIG1hbnVhbGx5LiBNZWRpYUVsZW1lbnQgaXMgYSBmYWxsYmFjayBmb3IgdW5zdXBwb3J0ZWQgYnJvd3NlcnMuXG4gKiBNZWRpYUVsZW1lbnRXZWJBdWRpbyBhbGxvd3MgdG8gdXNlIFdlYkF1ZGlvIEFQSSBhbHNvIHdpdGggYmlnIGF1ZGlvIGZpbGVzLCBsb2FkaW5nIGF1ZGlvIGxpa2Ugd2l0aFxuICogTWVkaWFFbGVtZW50IGJhY2tlbmQgKEhUTUw1IGF1ZGlvIHRhZykuIFlvdSBoYXZlIHRvIHVzZSB0aGUgc2FtZSBtZXRob2RzIG9mIE1lZGlhRWxlbWVudCBiYWNrZW5kIGZvciBsb2FkaW5nIGFuZFxuICogcGxheWJhY2ssIGdpdmluZyBhbHNvIHBlYWtzLCBzbyB0aGUgYXVkaW8gZGF0YSBhcmUgbm90IGRlY29kZWQuIEluIHRoaXMgd2F5IHlvdSBjYW4gdXNlIFdlYkF1ZGlvIGZlYXR1cmVzLCBsaWtlIGZpbHRlcnMsXG4gKiBhbHNvIHdpdGggYXVkaW8gd2l0aCBiaWcgZHVyYXRpb24uIEZvciBleGFtcGxlOlxuICogYCB3YXZlc3VyZmVyLmxvYWQodXJsIHwgSFRNTE1lZGlhRWxlbWVudCwgcGVha3MsIHByZWxvYWQsIGR1cmF0aW9uKTtcbiAqICAgd2F2ZXN1cmZlci5wbGF5KCk7XG4gKiAgIHdhdmVzdXJmZXIuc2V0RmlsdGVyKGN1c3RvbUZpbHRlcik7XG4gKiBgXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZENvbG9yPW51bGwgQ2hhbmdlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlXG4gKiB3YXZlZm9ybSBjb250YWluZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmFySGVpZ2h0PTEgVGhlIGhlaWdodCBvZiB0aGUgd2F2ZSBiYXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJhclJhZGl1cz0wIFRoZSByYWRpdXMgb2YgdGhlIHdhdmUgYmFycy4gTWFrZXMgYmFycyByb3VuZGVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmFyR2FwPW51bGwgVGhlIG9wdGlvbmFsIHNwYWNpbmcgYmV0d2VlbiBiYXJzIG9mIHRoZSB3YXZlLFxuICogaWYgbm90IHByb3ZpZGVkIHdpbGwgYmUgY2FsY3VsYXRlZCBpbiBsZWdhY3kgZm9ybWF0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJhcldpZHRoPW51bGwgRHJhdyB0aGUgd2F2ZWZvcm0gdXNpbmcgYmFycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYXJNaW5IZWlnaHQ9bnVsbCBJZiBzcGVjaWZpZWQsIGRyYXcgYXQgbGVhc3QgYSBiYXIgb2YgdGhpcyBoZWlnaHQsXG4gKiBlbGltaW5hdGluZyB3YXZlZm9ybSBnYXBzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsb3NlQXVkaW9Db250ZXh0PWZhbHNlIENsb3NlIGFuZCBudWxsaWZ5IGFsbCBhdWRpb1xuICogY29udGV4dHMgd2hlbiB0aGUgZGVzdHJveSBtZXRob2QgaXMgY2FsbGVkLlxuICogQHByb3BlcnR5IHshc3RyaW5nfEhUTUxFbGVtZW50fSBjb250YWluZXIgQ1NTIHNlbGVjdG9yIG9yIEhUTUwgZWxlbWVudCB3aGVyZVxuICogdGhlIHdhdmVmb3JtIHNob3VsZCBiZSBkcmF3bi4gVGhpcyBpcyB0aGUgb25seSByZXF1aXJlZCBwYXJhbWV0ZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3Vyc29yQ29sb3I9JyMzMzMnIFRoZSBmaWxsIGNvbG9yIG9mIHRoZSBjdXJzb3IgaW5kaWNhdGluZ1xuICogdGhlIHBsYXloZWFkIHBvc2l0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGN1cnNvcldpZHRoPTEgTWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGRyYXdpbmdDb250ZXh0QXR0cmlidXRlcz17ZGVzeW5jaHJvbml6ZWQ6IGZhbHNlfSBEcmF3aW5nIGNvbnRleHRcbiAqIGF0dHJpYnV0ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb249bnVsbCBPcHRpb25hbCBhdWRpbyBsZW5ndGggc28gcHJlLXJlbmRlcmVkIHBlYWtzXG4gKiBjYW4gYmUgZGlzcGxheSBpbW1lZGlhdGVseSBmb3IgZXhhbXBsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmlsbFBhcmVudD10cnVlIFdoZXRoZXIgdG8gZmlsbCB0aGUgZW50aXJlIGNvbnRhaW5lciBvclxuICogZHJhdyBvbmx5IGFjY29yZGluZyB0byBgbWluUHhQZXJTZWNgLlxuICogQHByb3BlcnR5IHtib29sZWFufSBmb3JjZURlY29kZT1mYWxzZSBGb3JjZSBkZWNvZGluZyBvZiBhdWRpbyB1c2luZyB3ZWIgYXVkaW9cbiAqIHdoZW4gem9vbWluZyB0byBnZXQgYSBtb3JlIGRldGFpbGVkIHdhdmVmb3JtLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodD0xMjggVGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm0uIE1lYXN1cmVkIGluXG4gKiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZGVTY3JvbGxiYXI9ZmFsc2UgV2hldGhlciB0byBoaWRlIHRoZSBob3Jpem9udGFsXG4gKiBzY3JvbGxiYXIgd2hlbiBvbmUgd291bGQgbm9ybWFsbHkgYmUgc2hvd24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGludGVyYWN0PXRydWUgV2hldGhlciB0aGUgbW91c2UgaW50ZXJhY3Rpb24gd2lsbCBiZVxuICogZW5hYmxlZCBhdCBpbml0aWFsaXphdGlvbi4gWW91IGNhbiBzd2l0Y2ggdGhpcyBwYXJhbWV0ZXIgYXQgYW55IHRpbWUgbGF0ZXJcbiAqIG9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBsb29wU2VsZWN0aW9uPXRydWUgKFVzZSB3aXRoIHJlZ2lvbnMgcGx1Z2luKSBFbmFibGVcbiAqIGxvb3Bpbmcgb2Ygc2VsZWN0ZWQgcmVnaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heENhbnZhc1dpZHRoPTQwMDAgTWF4aW11bSB3aWR0aCBvZiBhIHNpbmdsZSBjYW52YXMgaW5cbiAqIHBpeGVscywgZXhjbHVkaW5nIGEgc21hbGwgb3ZlcmxhcCAoMiAqIGBwaXhlbFJhdGlvYCwgcm91bmRlZCB1cCB0byB0aGUgbmV4dFxuICogZXZlbiBpbnRlZ2VyKS4gSWYgdGhlIHdhdmVmb3JtIGlzIGxvbmdlciB0aGFuIHRoaXMgdmFsdWUsIGFkZGl0aW9uYWwgY2FudmFzZXNcbiAqIHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhlIHdhdmVmb3JtLCB3aGljaCBpcyB1c2VmdWwgZm9yIHZlcnkgbGFyZ2Ugd2F2ZWZvcm1zXG4gKiB0aGF0IG1heSBiZSB0b28gd2lkZSBmb3IgYnJvd3NlcnMgdG8gZHJhdyBvbiBhIHNpbmdsZSBjYW52YXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG1lZGlhQ29udHJvbHM9ZmFsc2UgKFVzZSB3aXRoIGJhY2tlbmQgYE1lZGlhRWxlbWVudGAgb3IgYE1lZGlhRWxlbWVudFdlYkF1ZGlvYClcbiAqIHRoaXMgZW5hYmxlcyB0aGUgbmF0aXZlIGNvbnRyb2xzIGZvciB0aGUgbWVkaWEgZWxlbWVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lZGlhVHlwZT0nYXVkaW8nIChVc2Ugd2l0aCBiYWNrZW5kIGBNZWRpYUVsZW1lbnRgIG9yIGBNZWRpYUVsZW1lbnRXZWJBdWRpb2ApXG4gKiBgJ2F1ZGlvJ3wndmlkZW8nYCAoJ3ZpZGVvJyBvbmx5IGZvciBgTWVkaWFFbGVtZW50YClcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5QeFBlclNlYz0yMCBNaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgcGVyIHNlY29uZCBvZlxuICogYXVkaW8uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vcm1hbGl6ZT1mYWxzZSBJZiB0cnVlLCBub3JtYWxpemUgYnkgdGhlIG1heGltdW0gcGVha1xuICogaW5zdGVhZCBvZiAxLjAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhcnRpYWxSZW5kZXI9ZmFsc2UgVXNlIHRoZSBQZWFrQ2FjaGUgdG8gaW1wcm92ZVxuICogcmVuZGVyaW5nIHNwZWVkIG9mIGxhcmdlIHdhdmVmb3Jtc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW8gVGhlIHBpeGVsIHJhdGlvIHVzZWQgdG9cbiAqIGNhbGN1bGF0ZSBkaXNwbGF5XG4gKiBAcHJvcGVydHkge1BsdWdpbkRlZmluaXRpb25bXX0gcGx1Z2lucz1bXSBBbiBhcnJheSBvZiBwbHVnaW4gZGVmaW5pdGlvbnMgdG9cbiAqIHJlZ2lzdGVyIGR1cmluZyBpbnN0YW50aWF0aW9uLCB0aGV5IHdpbGwgYmUgZGlyZWN0bHkgaW5pdGlhbGlzZWQgdW5sZXNzIHRoZXlcbiAqIGFyZSBhZGRlZCB3aXRoIHRoZSBgZGVmZXJJbml0YCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm9ncmVzc0NvbG9yPScjNTU1JyBUaGUgZmlsbCBjb2xvciBvZiB0aGUgcGFydCBvZiB0aGVcbiAqIHdhdmVmb3JtIGJlaGluZCB0aGUgY3Vyc29yLiBXaGVuIGBwcm9ncmVzc0NvbG9yYCBhbmQgYHdhdmVDb2xvcmAgYXJlIHRoZSBzYW1lXG4gKiB0aGUgcHJvZ3Jlc3Mgd2F2ZSBpcyBub3QgcmVuZGVyZWQgYXQgYWxsLlxuICogQHByb3BlcnR5IHtib29sZWFufSByZW1vdmVNZWRpYUVsZW1lbnRPbkRlc3Ryb3k9dHJ1ZSBTZXQgdG8gZmFsc2UgdG8ga2VlcCB0aGVcbiAqIG1lZGlhIGVsZW1lbnQgaW4gdGhlIERPTSB3aGVuIHRoZSBwbGF5ZXIgaXMgZGVzdHJveWVkLiBUaGlzIGlzIHVzZWZ1bCB3aGVuXG4gKiByZXVzaW5nIGFuIGV4aXN0aW5nIG1lZGlhIGVsZW1lbnQgdmlhIHRoZSBgbG9hZE1lZGlhRWxlbWVudGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHJlbmRlcmVyPU11bHRpQ2FudmFzIENhbiBiZSB1c2VkIHRvIGluamVjdCBhIGN1c3RvbVxuICogcmVuZGVyZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58bnVtYmVyfSByZXNwb25zaXZlPWZhbHNlIElmIHNldCB0byBgdHJ1ZWAgcmVzaXplIHRoZVxuICogd2F2ZWZvcm0sIHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemVkLiBUaGlzIGlzIGRlYm91bmNlZCB3aXRoIGEgYDEwMG1zYFxuICogdGltZW91dCBieSBkZWZhdWx0LiBJZiB0aGlzIHBhcmFtZXRlciBpcyBhIG51bWJlciBpdCByZXByZXNlbnRzIHRoYXQgdGltZW91dC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcnRsPWZhbHNlIElmIHNldCB0byBgdHJ1ZWAsIHJlbmRlcnMgd2F2ZWZvcm0gZnJvbVxuICogcmlnaHQtdG8tbGVmdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2Nyb2xsUGFyZW50PWZhbHNlIFdoZXRoZXIgdG8gc2Nyb2xsIHRoZSBjb250YWluZXIgd2l0aCBhXG4gKiBsZW5ndGh5IHdhdmVmb3JtLiBPdGhlcndpc2UgdGhlIHdhdmVmb3JtIGlzIHNocnVuayB0byB0aGUgY29udGFpbmVyIHdpZHRoXG4gKiAoc2VlIGZpbGxQYXJlbnQpLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNraXBMZW5ndGg9MiBOdW1iZXIgb2Ygc2Vjb25kcyB0byBza2lwIHdpdGggdGhlXG4gKiBza2lwRm9yd2FyZCgpIGFuZCBza2lwQmFja3dhcmQoKSBtZXRob2RzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzcGxpdENoYW5uZWxzPWZhbHNlIFJlbmRlciB3aXRoIHNlcGFyYXRlIHdhdmVmb3JtcyBmb3JcbiAqIHRoZSBjaGFubmVscyBvZiB0aGUgYXVkaW9cbiAqIEBwcm9wZXJ0eSB7U3BsaXRDaGFubmVsT3B0aW9uc30gc3BsaXRDaGFubmVsc09wdGlvbnM9e30gT3B0aW9ucyBmb3Igc3BsaXRDaGFubmVsIHJlbmRlcmluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSB2ZXJ0aWNhbD1mYWxzZSBSZW5kZXIgdGhlIHdhdmVmb3JtIHZlcnRpY2FsbHkgaW5zdGVhZCBvZiBob3Jpem9udGFsbHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gd2F2ZUNvbG9yPScjOTk5JyBUaGUgZmlsbCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gYWZ0ZXIgdGhlXG4gKiBjdXJzb3IuXG4gKiBAcHJvcGVydHkge29iamVjdH0geGhyPXt9IFhIUiBvcHRpb25zLiBGb3IgZXhhbXBsZTpcbiAqIGBsZXQgeGhyID0ge1xuICogICAgIGNhY2hlOiAnZGVmYXVsdCcsXG4gKiAgICAgbW9kZTogJ2NvcnMnLFxuICogICAgIG1ldGhvZDogJ0dFVCcsXG4gKiAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gKiAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICogICAgIHJlZmVycmVyOiAnY2xpZW50JyxcbiAqICAgICByZXF1ZXN0SGVhZGVyczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgICBrZXk6ICdBdXRob3JpemF0aW9uJyxcbiAqICAgICAgICAgICAgIHZhbHVlOiAnbXktdG9rZW4nXG4gKiAgICAgICAgIH1cbiAqICAgICBdXG4gKiB9O2BcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBsdWdpbkRlZmluaXRpb25cbiAqIEBkZXNjIFRoZSBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIHBsdWdpblxuICogQGV4YW1wbGUgd2F2ZXN1cmZlci5hZGRQbHVnaW4ocGx1Z2luRGVmaW5pdGlvbik7XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLCB0aGUgcGx1Z2luIGluc3RhbmNlIHdpbGwgYmVcbiAqIGFkZGVkIGFzIGEgcHJvcGVydHkgdG8gdGhlIHdhdmVzdXJmZXIgaW5zdGFuY2UgdW5kZXIgdGhpcyBuYW1lXG4gKiBAcHJvcGVydHkgez9PYmplY3R9IHN0YXRpY1Byb3BzIFRoZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZVxuICogd2F2ZXN1cmZlciBpbnN0YW5jZSBhcyBzdGF0aWMgcHJvcGVydGllc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGVmZXJJbml0IERvbid0IGluaXRpYWxpc2UgcGx1Z2luXG4gKiBhdXRvbWF0aWNhbGx5XG4gKiBAcHJvcGVydHkge09iamVjdH0gcGFyYW1zPXt9IFRoZSBwbHVnaW4gcGFyYW1ldGVycywgdGhleSBhcmUgdGhlIGZpcnN0IHBhcmFtZXRlclxuICogcGFzc2VkIHRvIHRoZSBwbHVnaW4gY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqIEBwcm9wZXJ0eSB7UGx1Z2luQ2xhc3N9IGluc3RhbmNlIFRoZSBwbHVnaW4gaW5zdGFuY2UgZmFjdG9yeSwgaXMgY2FsbGVkIHdpdGhcbiAqIHRoZSBkZXBlbmRlbmN5IHNwZWNpZmllZCBpbiBleHRlbmRzLiBSZXR1cm5zIHRoZSBwbHVnaW4gY2xhc3MuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGxpdENoYW5uZWxPcHRpb25zXG4gKiBAZGVzYyBwYXJhbWV0ZXJzIGFwcGxpZWQgd2hlbiBzcGxpdENoYW5uZWxzIG9wdGlvbiBpcyB0cnVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG92ZXJsYXk9ZmFsc2UgZGV0ZXJtaW5lcyB3aGV0aGVyIGNoYW5uZWxzIGFyZSByZW5kZXJlZCBvbiB0b3Agb2YgZWFjaCBvdGhlciBvciBvbiBzZXBhcmF0ZSB0cmFja3NcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjaGFubmVsQ29sb3JzPXt9IG9iamVjdCBkZXNjcmliaW5nIGNvbG9yIGZvciBlYWNoIGNoYW5uZWwuIEV4YW1wbGU6XG4gKiB7XG4gKiAgICAgMDoge1xuICogICAgICAgICBwcm9ncmVzc0NvbG9yOiAnZ3JlZW4nLFxuICogICAgICAgICB3YXZlQ29sb3I6ICdwaW5rJ1xuICogICAgIH0sXG4gKiAgICAgMToge1xuICogICAgICAgICBwcm9ncmVzc0NvbG9yOiAnb3JhbmdlJyxcbiAqICAgICAgICAgd2F2ZUNvbG9yOiAncHVycGxlJ1xuICogICAgIH1cbiAqIH1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGZpbHRlckNoYW5uZWxzPVtdIGluZGV4ZXMgb2YgY2hhbm5lbHMgdG8gYmUgaGlkZGVuIGZyb20gcmVuZGVyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbGF0aXZlTm9ybWFsaXphdGlvbj1mYWxzZSBkZXRlcm1pbmVzIHdoZXRoZXJcbiAqIG5vcm1hbGl6YXRpb24gaXMgZG9uZSBwZXIgY2hhbm5lbCBvciBtYWludGFpbnMgcHJvcG9ydGlvbmFsaXR5IGJldHdlZW5cbiAqIGNoYW5uZWxzLiBPbmx5IGFwcGxpZWQgd2hlbiBub3JtYWxpemUgYW5kIHNwbGl0Q2hhbm5lbHMgYXJlIGJvdGggdHJ1ZS5cbiAqIEBzaW5jZSA0LjMuMFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZSBQbHVnaW5DbGFzc1xuICpcbiAqIEBkZXNjIFRoaXMgaXMgdGhlIGludGVyZmFjZSB3aGljaCBpcyBpbXBsZW1lbnRlZCBieSBhbGwgcGx1Z2luIGNsYXNzZXMuIE5vdGVcbiAqIHRoYXQgdGhpcyBvbmx5IHR1cm5zIGludG8gYW4gb2JzZXJ2ZXIgYWZ0ZXIgYmVpbmcgcGFzc2VkIHRocm91Z2hcbiAqIGB3YXZlc3VyZmVyLmFkZFBsdWdpbmAuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICovXG52YXIgUGx1Z2luQ2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBwbHVnaW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcz17fSBUaGUgcGx1Z2luIHBhcmFtcyAoc3BlY2lmaWMgdG8gdGhlIHBsdWdpbilcbiAgICogQHBhcmFtIHtPYmplY3R9IHdzIFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQbHVnaW5DbGFzcyhwYXJhbXMsIHdzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsdWdpbkNsYXNzKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgcGx1Z2luXG4gICAqXG4gICAqIFN0YXJ0IGRvaW5nIHNvbWV0aGluZy4gVGhpcyBpcyBjYWxsZWQgYnlcbiAgICogYHdhdmVzdXJmZXIuaW5pdFBsdWdpbihwbHVnaW5OYW1lKWBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUGx1Z2luQ2xhc3MsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFBsdWdpbiBkZWZpbml0aW9uIGZhY3RvcnlcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHBsdWdpbiBkZWZpbml0aW9uIHdoaWNoIGNhbiBiZVxuICAgICAqIHVzZWQgYnkgd2F2ZXN1cmZlciB0byBjb3JyZWN0bHkgaW5zdGFudGlhdGUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybnMgYSBgUGx1Z2luRGVmaW5pdGlvbmAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcz17fSBUaGUgcGx1Z2luIHBhcmFtcyAoc3BlY2lmaWMgdG8gdGhlIHBsdWdpbilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocGFyYW1zKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHt9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBTdG9wIGRvaW5nIHNvbWV0aGluZy4gVGhpcyBpcyBjYWxsZWQgYnlcbiAgICAgKiBgd2F2ZXN1cmZlci5kZXN0cm95UGx1Z2luKHBsdWdpbk5hbWUpYFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBQbHVnaW5DbGFzcztcbn0oKTtcbi8qKlxuICogV2F2ZVN1cmZlciBjb3JlIGxpYnJhcnkgY2xhc3NcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2ZXJ9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGFyYW1zID0ge1xuICogICBjb250YWluZXI6ICcjd2F2ZWZvcm0nLFxuICogICB3YXZlQ29sb3I6ICd2aW9sZXQnLFxuICogICBwcm9ncmVzc0NvbG9yOiAncHVycGxlJ1xuICogfTtcbiAqXG4gKiAvLyBpbml0aWFsaXNlIGxpa2UgdGhpc1xuICogY29uc3Qgd2F2ZXN1cmZlciA9IFdhdmVTdXJmZXIuY3JlYXRlKHBhcmFtcyk7XG4gKlxuICogLy8gb3IgbGlrZSB0aGlzIC4uLlxuICogY29uc3Qgd2F2ZXN1cmZlciA9IG5ldyBXYXZlU3VyZmVyKHBhcmFtcyk7XG4gKiB3YXZlc3VyZmVyLmluaXQoKTtcbiAqXG4gKiAvLyBsb2FkIGF1ZGlvIGZpbGVcbiAqIHdhdmVzdXJmZXIubG9hZCgnZXhhbXBsZS9tZWRpYS9kZW1vLndhdicpO1xuICovXG5cblxudmFyIFdhdmVTdXJmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF91dGlsJE9ic2VydmVyKSB7XG4gIF9pbmhlcml0cyhXYXZlU3VyZmVyLCBfdXRpbCRPYnNlcnZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXYXZlU3VyZmVyKTtcblxuICAvKipcbiAgICogSW5pdGlhbGlzZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXN1cmZlclBhcmFtc30gcGFyYW1zIEluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3Igd2F2ZXN1cmZlclxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB3YXZlc3VyZmVyID0gbmV3IFdhdmVTdXJmZXIocGFyYW1zKTtcbiAgICogQHJldHVybnMge3RoaXN9IFdhdmVzdXJmZXIgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFdhdmVTdXJmZXIocGFyYW1zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdhdmVTdXJmZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHJlbGV2YW50IHBhcmFtZXRlcnMgKG9yIGRlZmF1bHRzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICBfdGhpcy5kZWZhdWx0UGFyYW1zID0ge1xuICAgICAgYXVkaW9Db250ZXh0OiBudWxsLFxuICAgICAgYXVkaW9TY3JpcHRQcm9jZXNzb3I6IG51bGwsXG4gICAgICBhdWRpb1JhdGU6IDEsXG4gICAgICBhdXRvQ2VudGVyOiB0cnVlLFxuICAgICAgYXV0b0NlbnRlclJhdGU6IDUsXG4gICAgICBhdXRvQ2VudGVySW1tZWRpYXRlbHk6IGZhbHNlLFxuICAgICAgYmFja2VuZDogJ1dlYkF1ZGlvJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogbnVsbCxcbiAgICAgIGJhckhlaWdodDogMSxcbiAgICAgIGJhclJhZGl1czogMCxcbiAgICAgIGJhckdhcDogbnVsbCxcbiAgICAgIGJhck1pbkhlaWdodDogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIGN1cnNvckNvbG9yOiAnIzMzMycsXG4gICAgICBjdXJzb3JXaWR0aDogMSxcbiAgICAgIGRyYWdTZWxlY3Rpb246IHRydWUsXG4gICAgICBkcmF3aW5nQ29udGV4dEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLy8gQm9vbGVhbiB0aGF0IGhpbnRzIHRoZSB1c2VyIGFnZW50IHRvIHJlZHVjZSB0aGUgbGF0ZW5jeVxuICAgICAgICAvLyBieSBkZXN5bmNocm9uaXppbmcgdGhlIGNhbnZhcyBwYWludCBjeWNsZSBmcm9tIHRoZSBldmVudFxuICAgICAgICAvLyBsb29wXG4gICAgICAgIGRlc3luY2hyb25pemVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICAgZmlsbFBhcmVudDogdHJ1ZSxcbiAgICAgIGZvcmNlRGVjb2RlOiBmYWxzZSxcbiAgICAgIGhlaWdodDogMTI4LFxuICAgICAgaGlkZVNjcm9sbGJhcjogZmFsc2UsXG4gICAgICBpbnRlcmFjdDogdHJ1ZSxcbiAgICAgIGxvb3BTZWxlY3Rpb246IHRydWUsXG4gICAgICBtYXhDYW52YXNXaWR0aDogNDAwMCxcbiAgICAgIG1lZGlhQ29udGFpbmVyOiBudWxsLFxuICAgICAgbWVkaWFDb250cm9sczogZmFsc2UsXG4gICAgICBtZWRpYVR5cGU6ICdhdWRpbycsXG4gICAgICBtaW5QeFBlclNlYzogMjAsXG4gICAgICBub3JtYWxpemU6IGZhbHNlLFxuICAgICAgcGFydGlhbFJlbmRlcjogZmFsc2UsXG4gICAgICBwaXhlbFJhdGlvOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCBzY3JlZW4uZGV2aWNlWERQSSAvIHNjcmVlbi5sb2dpY2FsWERQSSxcbiAgICAgIHBsdWdpbnM6IFtdLFxuICAgICAgcHJvZ3Jlc3NDb2xvcjogJyM1NTUnLFxuICAgICAgcmVtb3ZlTWVkaWFFbGVtZW50T25EZXN0cm95OiB0cnVlLFxuICAgICAgcmVuZGVyZXI6IF9kcmF3ZXIuZGVmYXVsdCxcbiAgICAgIHJlc3BvbnNpdmU6IGZhbHNlLFxuICAgICAgcnRsOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudDogZmFsc2UsXG4gICAgICBza2lwTGVuZ3RoOiAyLFxuICAgICAgc3BsaXRDaGFubmVsczogZmFsc2UsXG4gICAgICBzcGxpdENoYW5uZWxzT3B0aW9uczoge1xuICAgICAgICBvdmVybGF5OiBmYWxzZSxcbiAgICAgICAgY2hhbm5lbENvbG9yczoge30sXG4gICAgICAgIGZpbHRlckNoYW5uZWxzOiBbXSxcbiAgICAgICAgcmVsYXRpdmVOb3JtYWxpemF0aW9uOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgIHdhdmVDb2xvcjogJyM5OTknLFxuICAgICAgeGhyOiB7fVxuICAgIH07XG4gICAgX3RoaXMuYmFja2VuZHMgPSB7XG4gICAgICBNZWRpYUVsZW1lbnQ6IF9tZWRpYWVsZW1lbnQuZGVmYXVsdCxcbiAgICAgIFdlYkF1ZGlvOiBfd2ViYXVkaW8uZGVmYXVsdCxcbiAgICAgIE1lZGlhRWxlbWVudFdlYkF1ZGlvOiBfbWVkaWFlbGVtZW50V2ViYXVkaW8uZGVmYXVsdFxuICAgIH07XG4gICAgX3RoaXMudXRpbCA9IHV0aWw7XG4gICAgX3RoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMuZGVmYXVsdFBhcmFtcywgcGFyYW1zKTtcbiAgICBfdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpcy5kZWZhdWx0UGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLCBwYXJhbXMuc3BsaXRDaGFubmVsc09wdGlvbnMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuY29udGFpbmVyID0gJ3N0cmluZycgPT0gdHlwZW9mIHBhcmFtcy5jb250YWluZXIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLnBhcmFtcy5jb250YWluZXIpIDogX3RoaXMucGFyYW1zLmNvbnRhaW5lcjtcblxuICAgIGlmICghX3RoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRhaW5lciBlbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5wYXJhbXMubWVkaWFDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfdGhpcy5tZWRpYUNvbnRhaW5lciA9IF90aGlzLmNvbnRhaW5lcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpcy5wYXJhbXMubWVkaWFDb250YWluZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX3RoaXMubWVkaWFDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF90aGlzLnBhcmFtcy5tZWRpYUNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX3RoaXMubWVkaWFDb250YWluZXIgPSBfdGhpcy5wYXJhbXMubWVkaWFDb250YWluZXI7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5tZWRpYUNvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZWRpYSBDb250YWluZXIgZWxlbWVudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMucGFyYW1zLm1heENhbnZhc1dpZHRoIDw9IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWF4Q2FudmFzV2lkdGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgIH0gZWxzZSBpZiAoX3RoaXMucGFyYW1zLm1heENhbnZhc1dpZHRoICUgMiA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heENhbnZhc1dpZHRoIG11c3QgYmUgYW4gZXZlbiBudW1iZXInKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMucGFyYW1zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKF90aGlzLnBhcmFtcy52ZXJ0aWNhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB1dGlsLnN0eWxlKF90aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZVgoMTgwZGVnKSdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLnN0eWxlKF90aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZVkoMTgwZGVnKSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIF90aGlzLnNldEJhY2tncm91bmRDb2xvcihfdGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgVXNlZCB0byBzYXZlIHRoZSBjdXJyZW50IHZvbHVtZSB3aGVuIG11dGluZyBzbyB3ZSBjYW5cbiAgICAgKiByZXN0b3JlIG9uY2UgdW5tdXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cblxuICAgIF90aGlzLnNhdmVkVm9sdW1lID0gMDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBUaGUgY3VycmVudCBtdXRlZCBzdGF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgX3RoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIFdpbGwgaG9sZCBhIGxpc3Qgb2YgZXZlbnQgZGVzY3JpcHRvcnMgdGhhdCBuZWVkIHRvIGJlXG4gICAgICogY2FuY2VsZWQgb24gc3Vic2VxdWVudCBsb2FkcyBvZiBhdWRpb1xuICAgICAqIEB0eXBlIHtPYmplY3RbXX1cbiAgICAgKi9cblxuICAgIF90aGlzLnRtcEV2ZW50cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIEhvbGRzIGFueSBydW5uaW5nIGF1ZGlvIGRvd25sb2Fkc1xuICAgICAqIEB0eXBlIHtPYnNlcnZlcn1cbiAgICAgKi9cblxuICAgIF90aGlzLmN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmFycmF5YnVmZmVyID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmRyYXdlciA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5iYWNrZW5kID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnBlYWtDYWNoZSA9IG51bGw7IC8vIGNhY2hlIGNvbnN0cnVjdG9yIG9iamVjdHNcblxuICAgIGlmICh0eXBlb2YgX3RoaXMucGFyYW1zLnJlbmRlcmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyIHBhcmFtZXRlciBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIFRoZSB1bmluaXRpYWxpc2VkIERyYXdlciBjbGFzc1xuICAgICAqL1xuXG5cbiAgICBfdGhpcy5EcmF3ZXIgPSBfdGhpcy5wYXJhbXMucmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgVGhlIHVuaW5pdGlhbGlzZWQgQmFja2VuZCBjbGFzc1xuICAgICAqL1xuICAgIC8vIEJhY2sgY29tcGF0XG5cbiAgICBpZiAoX3RoaXMucGFyYW1zLmJhY2tlbmQgPT0gJ0F1ZGlvRWxlbWVudCcpIHtcbiAgICAgIF90aGlzLnBhcmFtcy5iYWNrZW5kID0gJ01lZGlhRWxlbWVudCc7XG4gICAgfVxuXG4gICAgaWYgKChfdGhpcy5wYXJhbXMuYmFja2VuZCA9PSAnV2ViQXVkaW8nIHx8IF90aGlzLnBhcmFtcy5iYWNrZW5kID09PSAnTWVkaWFFbGVtZW50V2ViQXVkaW8nKSAmJiAhX3dlYmF1ZGlvLmRlZmF1bHQucHJvdG90eXBlLnN1cHBvcnRzV2ViQXVkaW8uY2FsbChudWxsKSkge1xuICAgICAgX3RoaXMucGFyYW1zLmJhY2tlbmQgPSAnTWVkaWFFbGVtZW50JztcbiAgICB9XG5cbiAgICBfdGhpcy5CYWNrZW5kID0gX3RoaXMuYmFja2VuZHNbX3RoaXMucGFyYW1zLmJhY2tlbmRdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIG1hcCBvZiBwbHVnaW4gbmFtZXMgdGhhdCBhcmUgY3VycmVudGx5IGluaXRpYWxpc2VkXG4gICAgICovXG5cbiAgICBfdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QgPSB7fTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLmlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHJlYWR5IHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNvbnN0IGlzUmVhZHkgPSB3YXZlc3VyZmVyLmlzUmVhZHk7XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIF90aGlzLmlzUmVhZHkgPSBmYWxzZTsgLy8gcmVzcG9uc2l2ZSBkZWJvdW5jZWQgZXZlbnQgbGlzdGVuZXIuIElmIHRoaXMucGFyYW1zLnJlc3BvbnNpdmUgaXMgbm90XG4gICAgLy8gc2V0LCB0aGlzIGlzIG5ldmVyIGNhbGxlZC4gVXNlIDEwMG1zIG9yIHRoaXMucGFyYW1zLnJlc3BvbnNpdmUgYXNcbiAgICAvLyB0aW1lb3V0IGZvciB0aGUgZGVib3VuY2UgZnVuY3Rpb24uXG5cbiAgICB2YXIgcHJldldpZHRoID0gMDtcbiAgICBfdGhpcy5fb25SZXNpemUgPSB1dGlsLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcmV2V2lkdGggIT0gX3RoaXMuZHJhd2VyLndyYXBwZXIuY2xpZW50V2lkdGggJiYgIV90aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgcHJldldpZHRoID0gX3RoaXMuZHJhd2VyLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgX3RoaXMuZHJhd2VyLmZpcmVFdmVudCgncmVkcmF3Jyk7XG4gICAgICB9XG4gICAgfSwgdHlwZW9mIF90aGlzLnBhcmFtcy5yZXNwb25zaXZlID09PSAnbnVtYmVyJyA/IF90aGlzLnBhcmFtcy5yZXNwb25zaXZlIDogMTAwKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgd2F2ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgd2F2ZXN1cmZlciA9IG5ldyBXYXZlU3VyZmVyKHBhcmFtcyk7XG4gICAqIHdhdmVzdXJmZXIuaW5pdCgpO1xuICAgKiBAcmV0dXJuIHt0aGlzfSBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhXYXZlU3VyZmVyLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh0aGlzLnBhcmFtcy5wbHVnaW5zKTtcbiAgICAgIHRoaXMuY3JlYXRlRHJhd2VyKCk7XG4gICAgICB0aGlzLmNyZWF0ZUJhY2tlbmQoKTtcbiAgICAgIHRoaXMuY3JlYXRlUGVha0NhY2hlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuZCBpbml0aWFsaXNlIGFycmF5IG9mIHBsdWdpbnMgKGlmIGBwbHVnaW4uZGVmZXJJbml0YCBpcyBmYWxzZXkpLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluIHRoZSBpbml0IGZ1bmN0aW9uIG9mIHdhdmVzdXJmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGx1Z2luRGVmaW5pdGlvbltdfSBwbHVnaW5zIEFuIGFycmF5IG9mIHBsdWdpbiBkZWZpbml0aW9uc1xuICAgICAqIEBlbWl0cyB7V2F2ZVN1cmZlciNwbHVnaW5zLXJlZ2lzdGVyZWR9IENhbGxlZCB3aXRoIHRoZSBhcnJheSBvZiBwbHVnaW4gZGVmaW5pdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt0aGlzfSBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gZmlyc3QgaW5zdGFudGlhdGUgYWxsIHRoZSBwbHVnaW5zXG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmFkZFBsdWdpbihwbHVnaW4pO1xuICAgICAgfSk7IC8vIG5vdyBydW4gdGhlIGluaXQgZnVuY3Rpb25zXG5cbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIC8vIGNhbGwgaW5pdCBmdW5jdGlvbiBvZiB0aGUgcGx1Z2luIGlmIGRlZmVySW5pdCBpcyBmYWxzZXlcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHlvdSB3b3VsZCBtYW51YWxseSB1c2UgaW5pdFBsdWdpbnMoKVxuICAgICAgICBpZiAoIXBsdWdpbi5kZWZlckluaXQpIHtcbiAgICAgICAgICBfdGhpczIuaW5pdFBsdWdpbihwbHVnaW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsdWdpbnMtcmVnaXN0ZXJlZCcsIHBsdWdpbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIG1hcCBvZiBwbHVnaW4gbmFtZXMgdGhhdCBhcmUgY3VycmVudGx5IGluaXRpYWxpc2VkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLmdldFBsdWdpbnMoKTtcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHBsdWdpbiBuYW1lc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWN0aXZlUGx1Z2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmVQbHVnaW5zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwbHVnaW4gb2JqZWN0IHRvIHdhdmVzdXJmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGx1Z2luRGVmaW5pdGlvbn0gcGx1Z2luIEEgcGx1Z2luIGRlZmluaXRpb25cbiAgICAgKiBAZW1pdHMge1dhdmVTdXJmZXIjcGx1Z2luLWFkZGVkfSBDYWxsZWQgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgd2FzIGFkZGVkXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5hZGRQbHVnaW4oV2F2ZVN1cmZlci5taW5pbWFwKCkpO1xuICAgICAqIEByZXR1cm4ge3RoaXN9IFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRQbHVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghcGx1Z2luLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gZG9lcyBub3QgaGF2ZSBhIG5hbWUhJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGx1Z2luLmluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQocGx1Z2luLm5hbWUsIFwiIGRvZXMgbm90IGhhdmUgYW4gaW5zdGFuY2UgcHJvcGVydHkhXCIpKTtcbiAgICAgIH0gLy8gc3RhdGljUHJvcHMgcHJvcGVydGllcyBhcmUgYXBwbGllZCB0byB3YXZlc3VyZmVyIGluc3RhbmNlXG5cblxuICAgICAgaWYgKHBsdWdpbi5zdGF0aWNQcm9wcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW4uc3RhdGljUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpblN0YXRpY1Byb3ApIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBQcm9wZXJ0aWVzIGRlZmluZWQgaW4gYSBwbHVnaW4gZGVmaW5pdGlvbidzIGBzdGF0aWNQcm9wc2AgcHJvcGVydHkgYXJlIGFkZGVkIGFzXG4gICAgICAgICAgICogc3RhdGljUHJvcHMgcHJvcGVydGllcyBvZiB0aGUgV2F2ZVN1cmZlciBpbnN0YW5jZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzM1twbHVnaW5TdGF0aWNQcm9wXSA9IHBsdWdpbi5zdGF0aWNQcm9wc1twbHVnaW5TdGF0aWNQcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBJbnN0YW5jZSA9IHBsdWdpbi5pbnN0YW5jZTsgLy8gdHVybiB0aGUgcGx1Z2luIGluc3RhbmNlIGludG8gYW4gb2JzZXJ2ZXJcblxuICAgICAgdmFyIG9ic2VydmVyUHJvdG90eXBlS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHV0aWwuT2JzZXJ2ZXIucHJvdG90eXBlKTtcbiAgICAgIG9ic2VydmVyUHJvdG90eXBlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgSW5zdGFuY2UucHJvdG90eXBlW2tleV0gPSB1dGlsLk9ic2VydmVyLnByb3RvdHlwZVtrZXldO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEluc3RhbnRpYXRlZCBwbHVnaW4gY2xhc3NlcyBhcmUgYWRkZWQgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgd2F2ZXN1cmZlclxuICAgICAgICogaW5zdGFuY2VcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cblxuICAgICAgdGhpc1twbHVnaW4ubmFtZV0gPSBuZXcgSW5zdGFuY2UocGx1Z2luLnBhcmFtcyB8fCB7fSwgdGhpcyk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGx1Z2luLWFkZGVkJywgcGx1Z2luLm5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYSBwbHVnaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgcGx1Z2luIG5hbWVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNwbHVnaW4taW5pdGlhbGlzZWRcbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLmluaXRQbHVnaW4oJ21pbmltYXAnKTtcbiAgICAgKiBAcmV0dXJuIHt0aGlzfSBUaGUgd2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBsdWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGx1Z2luKG5hbWUpIHtcbiAgICAgIGlmICghdGhpc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KG5hbWUsIFwiIGhhcyBub3QgYmVlbiBhZGRlZCB5ZXQhXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W25hbWVdKSB7XG4gICAgICAgIC8vIGRlc3Ryb3kgYW55IGFscmVhZHkgaW5pdGlhbGlzZWQgcGx1Z2luc1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW4obmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbbmFtZV0uaW5pdCgpO1xuICAgICAgdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3RbbmFtZV0gPSB0cnVlO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsdWdpbi1pbml0aWFsaXNlZCcsIG5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYSBwbHVnaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgcGx1Z2luIG5hbWVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNwbHVnaW4tZGVzdHJveWVkXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5kZXN0cm95UGx1Z2luKCdtaW5pbWFwJyk7XG4gICAgICogQHJldHVybnMge3RoaXN9IFRoZSB3YXZlc3VyZmVyIGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95UGx1Z2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lQbHVnaW4obmFtZSkge1xuICAgICAgaWYgKCF0aGlzW25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQobmFtZSwgXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHlldCBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQobmFtZSwgXCIgaXMgbm90IGFjdGl2ZSBhbmQgY2Fubm90IGJlIGRlc3Ryb3llZCFcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXNbbmFtZV0uZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KG5hbWUsIFwiIGRvZXMgbm90IGhhdmUgYSBkZXN0cm95IGZ1bmN0aW9uIVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbbmFtZV0uZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0W25hbWVdO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BsdWdpbi1kZXN0cm95ZWQnLCBuYW1lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCBpbml0aWFsaXNlZCBwbHVnaW5zLiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byB1c2Ugd2hlblxuICAgICAqIHdhdmVzdXJmZXIgaXMgcmVtb3ZlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lBbGxQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lBbGxQbHVnaW5zKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW5pdGlhbGlzZWRQbHVnaW5MaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuZGVzdHJveVBsdWdpbihuYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGRyYXdlciBhbmQgZHJhdyB0aGUgd2F2ZWZvcm1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjZHJhd2VyLWNyZWF0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZURyYXdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVEcmF3ZXIoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy5kcmF3ZXIgPSBuZXcgdGhpcy5EcmF3ZXIodGhpcy5jb250YWluZXIsIHRoaXMucGFyYW1zKTtcbiAgICAgIHRoaXMuZHJhd2VyLmluaXQoKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdkcmF3ZXItY3JlYXRlZCcsIHRoaXMuZHJhd2VyKTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3ZXIub24oJ3JlZHJhdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LmRyYXdCdWZmZXIoKTtcblxuICAgICAgICBfdGhpczUuZHJhd2VyLnByb2dyZXNzKF90aGlzNS5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpO1xuICAgICAgfSk7IC8vIENsaWNrLXRvLXNlZWtcblxuICAgICAgdGhpcy5kcmF3ZXIub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUsIHByb2dyZXNzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuc2Vla1RvKHByb2dyZXNzKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTsgLy8gUmVsYXkgdGhlIHNjcm9sbCBldmVudCBmcm9tIHRoZSBkcmF3ZXJcblxuICAgICAgdGhpcy5kcmF3ZXIub24oJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpczUucGFyYW1zLnBhcnRpYWxSZW5kZXIpIHtcbiAgICAgICAgICBfdGhpczUuZHJhd0J1ZmZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM1LmZpcmVFdmVudCgnc2Nyb2xsJywgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBiYWNrZW5kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2JhY2tlbmQtY3JlYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQmFja2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYWNrZW5kID0gbmV3IHRoaXMuQmFja2VuZCh0aGlzLnBhcmFtcyk7XG4gICAgICB0aGlzLmJhY2tlbmQuaW5pdCgpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ2JhY2tlbmQtY3JlYXRlZCcsIHRoaXMuYmFja2VuZCk7XG4gICAgICB0aGlzLmJhY2tlbmQub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM2LmRyYXdlci5wcm9ncmVzcyhfdGhpczYuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKTtcblxuICAgICAgICBfdGhpczYuZmlyZUV2ZW50KCdmaW5pc2gnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYWNrZW5kLm9uKCdwbGF5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LmZpcmVFdmVudCgncGxheScpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJhY2tlbmQub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LmZpcmVFdmVudCgncGF1c2UnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYWNrZW5kLm9uKCdhdWRpb3Byb2Nlc3MnLCBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBfdGhpczYuZHJhd2VyLnByb2dyZXNzKF90aGlzNi5iYWNrZW5kLmdldFBsYXllZFBlcmNlbnRzKCkpO1xuXG4gICAgICAgIF90aGlzNi5maXJlRXZlbnQoJ2F1ZGlvcHJvY2VzcycsIHRpbWUpO1xuICAgICAgfSk7IC8vIG9ubHkgbmVlZGVkIGZvciBNZWRpYUVsZW1lbnQgYW5kIE1lZGlhRWxlbWVudFdlYkF1ZGlvIGJhY2tlbmRcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmJhY2tlbmQgPT09ICdNZWRpYUVsZW1lbnQnIHx8IHRoaXMucGFyYW1zLmJhY2tlbmQgPT09ICdNZWRpYUVsZW1lbnRXZWJBdWRpbycpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLm9uKCdzZWVrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNi5kcmF3ZXIucHJvZ3Jlc3MoX3RoaXM2LmJhY2tlbmQuZ2V0UGxheWVkUGVyY2VudHMoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhY2tlbmQub24oJ3ZvbHVtZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbmV3Vm9sdW1lID0gX3RoaXM2LmdldFZvbHVtZSgpO1xuXG4gICAgICAgICAgX3RoaXM2LmZpcmVFdmVudCgndm9sdW1lJywgbmV3Vm9sdW1lKTtcblxuICAgICAgICAgIGlmIChfdGhpczYuYmFja2VuZC5pc011dGVkICE9PSBfdGhpczYuaXNNdXRlZCkge1xuICAgICAgICAgICAgX3RoaXM2LmlzTXV0ZWQgPSBfdGhpczYuYmFja2VuZC5pc011dGVkO1xuXG4gICAgICAgICAgICBfdGhpczYuZmlyZUV2ZW50KCdtdXRlJywgX3RoaXM2LmlzTXV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgcGVhayBjYWNoZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVBlYWtDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQZWFrQ2FjaGUoKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMucGFydGlhbFJlbmRlcikge1xuICAgICAgICB0aGlzLnBlYWtDYWNoZSA9IG5ldyBfcGVha2NhY2hlLmRlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8gY2xpcFxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY29uc3QgZHVyYXRpb24gPSB3YXZlc3VyZmVyLmdldER1cmF0aW9uKCk7XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0RHVyYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBjb25zdCBjdXJyZW50VGltZSA9IHdhdmVzdXJmZXIuZ2V0Q3VycmVudFRpbWUoKTtcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBsYXliYWNrIHBvc2l0aW9uIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRDdXJyZW50VGltZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgcGxheSB0aW1lIGluIHNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyBBIHBvc2l0aXZlIG51bWJlciBpbiBzZWNvbmRzLiBFLmcuIDEwIG1lYW5zIDEwXG4gICAgICogc2Vjb25kcywgNjAgbWVhbnMgMSBtaW51dGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnJlbnRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICAgIGlmIChzZWNvbmRzID49IHRoaXMuZ2V0RHVyYXRpb24oKSkge1xuICAgICAgICB0aGlzLnNlZWtUbygxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Vla1RvKHNlY29uZHMgLyB0aGlzLmdldER1cmF0aW9uKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcGxheWJhY2sgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi4gT3B0aW9uYWwgc3RhcnQgYW5kIGVuZFxuICAgICAqIG1lYXN1cmVkIGluIHNlY29uZHMgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSByYW5nZSBvZiBhdWRpbyB0byBwbGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzdGFydCBQb3NpdGlvbiB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZW5kIFBvc2l0aW9uIHRvIGVuZCBhdFxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2ludGVyYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzdWx0IG9mIHRoZSBiYWNrZW5kIHBsYXkgbWV0aG9kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBwbGF5IGZyb20gc2Vjb25kIDEgdG8gNVxuICAgICAqIHdhdmVzdXJmZXIucGxheSgxLCA1KTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy5maXJlRXZlbnQoJ2ludGVyYWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM3LnBsYXkoc3RhcnQsIGVuZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQucGxheShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgcG9pbnQgaW4gc2Vjb25kcyBmb3IgcGxheWJhY2sgdG8gc3RvcCBhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBQb3NpdGlvbiAoaW4gc2Vjb25kcykgdG8gc3RvcCBhdFxuICAgICAqIEB2ZXJzaW9uIDMuMy4wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXlFbmQocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuYmFja2VuZC5zZXRQbGF5RW5kKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgYW5kIHBhdXNlcyBwbGF5YmFja1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5wYXVzZSgpO1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc3VsdCBvZiB0aGUgYmFja2VuZCBwYXVzZSBtZXRob2RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBwbGF5YmFja1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5wbGF5UGF1c2UoKTtcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXN1bHQgb2YgdGhlIGJhY2tlbmQgcGxheSBvciBwYXVzZSBtZXRob2RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlQYXVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5UGF1c2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCkgPyB0aGlzLnBsYXkoKSA6IHRoaXMucGF1c2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHBsYXliYWNrIHN0YXRlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBjb25zdCBpc1BsYXlpbmcgPSB3YXZlc3VyZmVyLmlzUGxheWluZygpO1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlIGlmIHBhdXNlZCwgdHJ1ZSBpZiBwbGF5aW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1BsYXlpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQbGF5aW5nKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmJhY2tlbmQuaXNQYXVzZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCBiYWNrd2FyZFxuICAgICAqXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzZWNvbmRzIEFtb3VudCB0byBza2lwIGJhY2ssIGlmIG5vdCBzcGVjaWZpZWQgYHNraXBMZW5ndGhgXG4gICAgICogaXMgdXNlZFxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2tpcEJhY2t3YXJkKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJza2lwQmFja3dhcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcEJhY2t3YXJkKHNlY29uZHMpIHtcbiAgICAgIHRoaXMuc2tpcCgtc2Vjb25kcyB8fCAtdGhpcy5wYXJhbXMuc2tpcExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgZm9yd2FyZFxuICAgICAqXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzZWNvbmRzIEFtb3VudCB0byBza2lwIGJhY2ssIGlmIG5vdCBzcGVjaWZpZWQgYHNraXBMZW5ndGhgXG4gICAgICogaXMgdXNlZFxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2tpcEZvcndhcmQoKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNraXBGb3J3YXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBGb3J3YXJkKHNlY29uZHMpIHtcbiAgICAgIHRoaXMuc2tpcChzZWNvbmRzIHx8IHRoaXMucGFyYW1zLnNraXBMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIGEgbnVtYmVyIG9mIHNlY29uZHMgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbiAodXNlIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgKiB0byBnbyBiYWNrd2FyZHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBBbW91bnQgdG8gc2tpcCBiYWNrIG9yIGZvcndhcmRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnbyBiYWNrIDIgc2Vjb25kc1xuICAgICAqIHdhdmVzdXJmZXIuc2tpcCgtMik7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJza2lwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXAob2Zmc2V0KSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmdldER1cmF0aW9uKCkgfHwgMTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0Q3VycmVudFRpbWUoKSB8fCAwO1xuICAgICAgcG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkdXJhdGlvbiwgcG9zaXRpb24gKyAob2Zmc2V0IHx8IDApKSk7XG4gICAgICB0aGlzLnNlZWtBbmRDZW50ZXIocG9zaXRpb24gLyBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZWtzIHRvIGEgcG9zaXRpb24gYW5kIGNlbnRlcnMgdGhlIHZpZXdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzcyBCZXR3ZWVuIDAgKD1iZWdpbm5pbmcpIGFuZCAxICg9ZW5kKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gc2VlayBhbmQgZ28gdG8gdGhlIG1pZGRsZSBvZiB0aGUgYXVkaW9cbiAgICAgKiB3YXZlc3VyZmVyLnNlZWtUbygwLjUpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Vla0FuZENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVrQW5kQ2VudGVyKHByb2dyZXNzKSB7XG4gICAgICB0aGlzLnNlZWtUbyhwcm9ncmVzcyk7XG4gICAgICB0aGlzLmRyYXdlci5yZWNlbnRlcihwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZWtzIHRvIGEgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzcyBCZXR3ZWVuIDAgKD1iZWdpbm5pbmcpIGFuZCAxICg9ZW5kKVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI2ludGVyYWN0aW9uXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjc2Vla1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gc2VlayB0byB0aGUgbWlkZGxlIG9mIHRoZSBhdWRpb1xuICAgICAqIHdhdmVzdXJmZXIuc2Vla1RvKDAuNSk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWVrVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla1RvKHByb2dyZXNzKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgLy8gcmV0dXJuIGFuIGVycm9yIGlmIHByb2dyZXNzIGlzIG5vdCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwcm9ncmVzcykgfHwgcHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNhbGxpbmcgd2F2ZXN1cmZlci5zZWVrVG8sIHBhcmFtZXRlciBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maXJlRXZlbnQoJ2ludGVyYWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM4LnNlZWtUbyhwcm9ncmVzcyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBpc1dlYkF1ZGlvQmFja2VuZCA9IHRoaXMucGFyYW1zLmJhY2tlbmQgPT09ICdXZWJBdWRpbyc7XG4gICAgICB2YXIgcGF1c2VkID0gdGhpcy5iYWNrZW5kLmlzUGF1c2VkKCk7XG5cbiAgICAgIGlmIChpc1dlYkF1ZGlvQmFja2VuZCAmJiAhcGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5wYXVzZSgpO1xuICAgICAgfSAvLyBhdm9pZCBzbWFsbCBzY3JvbGxzIHdoaWxlIHBhdXNlZCBzZWVraW5nXG5cblxuICAgICAgdmFyIG9sZFNjcm9sbFBhcmVudCA9IHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudDtcbiAgICAgIHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5iYWNrZW5kLnNlZWtUbyhwcm9ncmVzcyAqIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICB0aGlzLmRyYXdlci5wcm9ncmVzcyhwcm9ncmVzcyk7XG5cbiAgICAgIGlmIChpc1dlYkF1ZGlvQmFja2VuZCAmJiAhcGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCA9IG9sZFNjcm9sbFBhcmVudDtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdzZWVrJywgcHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbmQgZ29lcyB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zdG9wKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLnNlZWtUbygwKTtcbiAgICAgIHRoaXMuZHJhd2VyLnByb2dyZXNzKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBJRCBvZiB0aGUgYXVkaW8gZGV2aWNlIHRvIHVzZSBmb3Igb3V0cHV0IGFuZCByZXR1cm5zIGEgUHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCBTdHJpbmcgdmFsdWUgcmVwcmVzZW50aW5nIHVuZGVybHlpbmcgb3V0cHV0XG4gICAgICogZGV2aWNlXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGB1bmRlZmluZWRgIHdoZW4gdGhlcmUgYXJlXG4gICAgICogbm8gZXJyb3JzIGRldGVjdGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2lua0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpbmtJZChkZXZpY2VJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBsYXliYWNrIHZvbHVtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWb2x1bWUgQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIDAgYmVpbmcgbm9cbiAgICAgKiB2b2x1bWUgYW5kIDEgYmVpbmcgZnVsbCB2b2x1bWUuXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjdm9sdW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKG5ld1ZvbHVtZSkge1xuICAgICAgdGhpcy5iYWNrZW5kLnNldFZvbHVtZShuZXdWb2x1bWUpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3ZvbHVtZScsIG5ld1ZvbHVtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGxheWJhY2sgdm9sdW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgMCBiZWluZyBub1xuICAgICAqIHZvbHVtZSBhbmQgMSBiZWluZyBmdWxsIHZvbHVtZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldFZvbHVtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBsYXliYWNrIHJhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZSBBIHBvc2l0aXZlIG51bWJlci4gRS5nLiAwLjUgbWVhbnMgaGFsZiB0aGUgbm9ybWFsXG4gICAgICogc3BlZWQsIDIgbWVhbnMgZG91YmxlIHNwZWVkIGFuZCBzbyBvbi5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldFBsYXliYWNrUmF0ZSgyKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXliYWNrUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQbGF5YmFja1JhdGUocmF0ZSkge1xuICAgICAgdGhpcy5iYWNrZW5kLnNldFBsYXliYWNrUmF0ZShyYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXliYWNrUmF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0UGxheWJhY2tSYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgdm9sdW1lIG9uIGFuZCBvZmYuIElmIG5vdCBjdXJyZW50bHkgbXV0ZWQgaXQgd2lsbCBzYXZlIHRoZVxuICAgICAqIGN1cnJlbnQgdm9sdW1lIHZhbHVlIGFuZCB0dXJuIHRoZSB2b2x1bWUgb2ZmLiBJZiBjdXJyZW50bHkgbXV0ZWQgdGhlbiBpdFxuICAgICAqIHdpbGwgcmVzdG9yZSB0aGUgdm9sdW1lIHRvIHRoZSBzYXZlZCB2YWx1ZSwgYW5kIHRoZW4gcmVzdCB0aGUgc2F2ZWRcbiAgICAgKiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIudG9nZ2xlTXV0ZSgpO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlTXV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlKCkge1xuICAgICAgdGhpcy5zZXRNdXRlKCF0aGlzLmlzTXV0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBtdXRlZCBhdWRpb1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdXRlIFNwZWNpZnkgYHRydWVgIHRvIG11dGUgYXVkaW8uXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjdm9sdW1lXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjbXV0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdW5tdXRlXG4gICAgICogd2F2ZXN1cmZlci5zZXRNdXRlKGZhbHNlKTtcbiAgICAgKiBjb25zb2xlLmxvZyh3YXZlc3VyZmVyLmdldE11dGUoKSkgLy8gbG9ncyBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TXV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNdXRlKG11dGUpIHtcbiAgICAgIC8vIGlnbm9yZSBhbGwgbXV0aW5nIHJlcXVlc3RzIGlmIHRoZSBhdWRpbyBpcyBhbHJlYWR5IGluIHRoYXQgc3RhdGVcbiAgICAgIGlmIChtdXRlID09PSB0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ211dGUnLCB0aGlzLmlzTXV0ZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhY2tlbmQuc2V0TXV0ZSkge1xuICAgICAgICAvLyBCYWNrZW5kcyBzdWNoIGFzIHRoZSBNZWRpYUVsZW1lbnQgYmFja2VuZCBoYXZlIHRoZWlyIG93biBoYW5kbGluZ1xuICAgICAgICAvLyBvZiBtdXRlLCBsZXQgdGhlbSBoYW5kbGUgaXQuXG4gICAgICAgIHRoaXMuYmFja2VuZC5zZXRNdXRlKG11dGUpO1xuICAgICAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG11dGUpIHtcbiAgICAgICAgICAvLyBJZiBjdXJyZW50bHkgbm90IG11dGVkIHRoZW4gc2F2ZSBjdXJyZW50IHZvbHVtZSxcbiAgICAgICAgICAvLyB0dXJuIG9mZiB0aGUgdm9sdW1lIGFuZCB1cGRhdGUgdGhlIG11dGUgcHJvcGVydGllc1xuICAgICAgICAgIHRoaXMuc2F2ZWRWb2x1bWUgPSB0aGlzLmJhY2tlbmQuZ2V0Vm9sdW1lKCk7XG4gICAgICAgICAgdGhpcy5iYWNrZW5kLnNldFZvbHVtZSgwKTtcbiAgICAgICAgICB0aGlzLmlzTXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd2b2x1bWUnLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBjdXJyZW50bHkgbXV0ZWQgdGhlbiByZXN0b3JlIHRvIHRoZSBzYXZlZCB2b2x1bWVcbiAgICAgICAgICAvLyBhbmQgdXBkYXRlIHRoZSBtdXRlIHByb3BlcnRpZXNcbiAgICAgICAgICB0aGlzLmJhY2tlbmQuc2V0Vm9sdW1lKHRoaXMuc2F2ZWRWb2x1bWUpO1xuICAgICAgICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd2b2x1bWUnLCB0aGlzLnNhdmVkVm9sdW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZpcmVFdmVudCgnbXV0ZScsIHRoaXMuaXNNdXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBtdXRlIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNvbnN0IGlzTXV0ZWQgPSB3YXZlc3VyZmVyLmdldE11dGUoKTtcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDdXJyZW50IG11dGUgc3RhdHVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRNdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE11dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc011dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgY3VycmVudCBzZXQgZmlsdGVycyBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEZpbHRlcnMgbXVzdCBiZSBzZXQgd2l0aCBzZXRGaWx0ZXJzIG1ldGhvZCBmaXJzdFxuICAgICAqXG4gICAgICogQHJldHVybiB7YXJyYXl9IExpc3Qgb2YgZW5hYmxlZCBmaWx0ZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWx0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbHRlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmZpbHRlcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYHNjcm9sbFBhcmVudGAgYW5kIHJlZHJhd3NcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIudG9nZ2xlU2Nyb2xsKCk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlU2Nyb2xsKCkge1xuICAgICAgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ID0gIXRoaXMucGFyYW1zLnNjcm9sbFBhcmVudDtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgbW91c2UgaW50ZXJhY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIudG9nZ2xlSW50ZXJhY3Rpb24oKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUludGVyYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUludGVyYWN0aW9uKCkge1xuICAgICAgdGhpcy5wYXJhbXMuaW50ZXJhY3QgPSAhdGhpcy5wYXJhbXMuaW50ZXJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gYWZ0ZXIgdGhlIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V2F2ZUNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdhdmVDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy53YXZlQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gYWZ0ZXIgdGhlIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRXYXZlQ29sb3IoJyNkZGQnKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFdhdmVDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXYXZlQ29sb3IoY29sb3IpIHtcbiAgICAgIHRoaXMucGFyYW1zLndhdmVDb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gYmVoaW5kIHRoZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFByb2dyZXNzQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5wcm9ncmVzc0NvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbGwgY29sb3Igb2YgdGhlIHdhdmVmb3JtIGJlaGluZCB0aGUgY3Vyc29yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbG9yIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZSB3YXZlc3VyZmVyLnNldFByb2dyZXNzQ29sb3IoJyM0MDAnKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFByb2dyZXNzQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvZ3Jlc3NDb2xvcihjb2xvcikge1xuICAgICAgdGhpcy5wYXJhbXMucHJvZ3Jlc3NDb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5kcmF3QnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgd2F2ZWZvcm0gY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB3YXZlZm9ybSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0QmFja2dyb3VuZENvbG9yKCcjRkYwMEZGJyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgICB0aGlzLnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIHV0aWwuc3R5bGUodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5wYXJhbXMuYmFja2dyb3VuZENvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaWxsIGNvbG9yIG9mIHRoZSBjdXJzb3IgaW5kaWNhdGluZyB0aGUgcGxheWhlYWRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3Vyc29yQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3Vyc29yQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuY3Vyc29yQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsbCBjb2xvciBvZiB0aGUgY3Vyc29yIGluZGljYXRpbmcgdGhlIHBsYXloZWFkXG4gICAgICogcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQSBDU1MgY29sb3Igc3RyaW5nLlxuICAgICAqIEBleGFtcGxlIHdhdmVzdXJmZXIuc2V0Q3Vyc29yQ29sb3IoJyMyMjInKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnNvckNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnNvckNvbG9yKGNvbG9yKSB7XG4gICAgICB0aGlzLnBhcmFtcy5jdXJzb3JDb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5kcmF3ZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSB3YXZlZm9ybS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IG1lYXN1cmVkIGluIHBpeGVscy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGhlaWdodCBvZiB0aGUgd2F2ZWZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci5zZXRIZWlnaHQoMjAwKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICB0aGlzLnBhcmFtcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmRyYXdlci5zZXRIZWlnaHQoaGVpZ2h0ICogdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBjaGFubmVscyBmcm9tIGJlaW5nIGRyYXduIG9uIHRoZSB3YXZlZm9ybSBpZiBzcGxpdHRpbmcgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2Ugd2FudCB0byBkcmF3IG9ubHkgdGhlIHBlYWtzIGZvciB0aGUgcmlnaHQgc3RlcmVvIGNoYW5uZWw6XG4gICAgICpcbiAgICAgKiBjb25zdCB3YXZlc3VyZmVyID0gbmV3IFdhdmVTdXJmZXIuY3JlYXRlKHsuLi5zcGxpdENoYW5uZWxzOiB0cnVlfSk7XG4gICAgICogd2F2ZXN1cmZlci5sb2FkKCdzdGVyZW9fYXVkaW8ubXAzJyk7XG4gICAgICpcbiAgICAgKiB3YXZlc3VyZmVyLnNldEZpbHRlcmVkQ2hhbm5lbChbMF0pOyA8LS0gaGlkZSBsZWZ0IGNoYW5uZWwgcGVha3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBjaGFubmVsSW5kaWNlcyBDaGFubmVscyB0byBiZSBmaWx0ZXJlZCBvdXQgZnJvbSBkcmF3aW5nLlxuICAgICAqIEB2ZXJzaW9uIDQuMC4wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGaWx0ZXJlZENoYW5uZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbHRlcmVkQ2hhbm5lbHMoY2hhbm5lbEluZGljZXMpIHtcbiAgICAgIHRoaXMucGFyYW1zLnNwbGl0Q2hhbm5lbHNPcHRpb25zLmZpbHRlckNoYW5uZWxzID0gY2hhbm5lbEluZGljZXM7XG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb3JyZWN0IHBlYWtzIGZvciBjdXJyZW50IHdhdmUgdmlldy1wb3J0IGFuZCByZW5kZXIgd2F2ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciNyZWRyYXdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0J1ZmZlcigpIHtcbiAgICAgIHZhciBub21pbmFsV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuZ2V0RHVyYXRpb24oKSAqIHRoaXMucGFyYW1zLm1pblB4UGVyU2VjICogdGhpcy5wYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLmRyYXdlci5nZXRXaWR0aCgpO1xuICAgICAgdmFyIHdpZHRoID0gbm9taW5hbFdpZHRoOyAvLyBhbHdheXMgc3RhcnQgYXQgMCBhZnRlciB6b29taW5nIGZvciBzY3JvbGxpbmcgOiBpc3N1ZSByZWRyYXcgbGVmdCBwYXJ0XG5cbiAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICB2YXIgZW5kID0gTWF0aC5tYXgoc3RhcnQgKyBwYXJlbnRXaWR0aCwgd2lkdGgpOyAvLyBGaWxsIGNvbnRhaW5lclxuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuZmlsbFBhcmVudCAmJiAoIXRoaXMucGFyYW1zLnNjcm9sbFBhcmVudCB8fCBub21pbmFsV2lkdGggPCBwYXJlbnRXaWR0aCkpIHtcbiAgICAgICAgd2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBlYWtzO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMucGFydGlhbFJlbmRlcikge1xuICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5wZWFrQ2FjaGUuYWRkUmFuZ2VUb1BlYWtDYWNoZSh3aWR0aCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwZWFrcyA9IHRoaXMuYmFja2VuZC5nZXRQZWFrcyh3aWR0aCwgbmV3UmFuZ2VzW2ldWzBdLCBuZXdSYW5nZXNbaV1bMV0pO1xuICAgICAgICAgIHRoaXMuZHJhd2VyLmRyYXdQZWFrcyhwZWFrcywgd2lkdGgsIG5ld1Jhbmdlc1tpXVswXSwgbmV3UmFuZ2VzW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVha3MgPSB0aGlzLmJhY2tlbmQuZ2V0UGVha3Mod2lkdGgsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLmRyYXdlci5kcmF3UGVha3MocGVha3MsIHdpZHRoLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlZHJhdycsIHBlYWtzLCB3aWR0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWxseSB6b29tcyB0aGUgd2F2ZWZvcm0gaW4gYW5kIG91dC4gSXQgYWxzbyBjaGFuZ2VzIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBgbWluUHhQZXJTZWNgIGFuZCBlbmFibGVzIHRoZSBgc2Nyb2xsUGFyZW50YCBvcHRpb24uIENhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAgICogd2l0aCBhIGZhbHNleSBwYXJhbWV0ZXIgd2lsbCByZXNldCB0aGUgem9vbSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gcHhQZXJTZWMgTnVtYmVyIG9mIGhvcml6b250YWwgcGl4ZWxzIHBlciBzZWNvbmQgb2ZcbiAgICAgKiBhdWRpbywgaWYgbm9uZSBpcyBzZXQgdGhlIHdhdmVmb3JtIHJldHVybnMgdG8gdW56b29tZWQgc3RhdGVcbiAgICAgKiBAZW1pdHMgV2F2ZVN1cmZlciN6b29tXG4gICAgICogQGV4YW1wbGUgd2F2ZXN1cmZlci56b29tKDIwKTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShweFBlclNlYykge1xuICAgICAgaWYgKCFweFBlclNlYykge1xuICAgICAgICB0aGlzLnBhcmFtcy5taW5QeFBlclNlYyA9IHRoaXMuZGVmYXVsdFBhcmFtcy5taW5QeFBlclNlYztcbiAgICAgICAgdGhpcy5wYXJhbXMuc2Nyb2xsUGFyZW50ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmFtcy5taW5QeFBlclNlYyA9IHB4UGVyU2VjO1xuICAgICAgICB0aGlzLnBhcmFtcy5zY3JvbGxQYXJlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICAgIHRoaXMuZHJhd2VyLnByb2dyZXNzKHRoaXMuYmFja2VuZC5nZXRQbGF5ZWRQZXJjZW50cygpKTtcbiAgICAgIHRoaXMuZHJhd2VyLnJlY2VudGVyKHRoaXMuZ2V0Q3VycmVudFRpbWUoKSAvIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgnem9vbScsIHB4UGVyU2VjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGJ1ZmZlciBhbmQgbG9hZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheWJ1ZmZlciBCdWZmZXIgdG8gcHJvY2Vzc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZEFycmF5QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRBcnJheUJ1ZmZlcihhcnJheWJ1ZmZlcikge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGVjb2RlQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghX3RoaXM5LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgX3RoaXM5LmxvYWREZWNvZGVkQnVmZmVyKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlyZWN0bHkgbG9hZCBhbiBleHRlcm5hbGx5IGRlY29kZWQgQXVkaW9CdWZmZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byBwcm9jZXNzXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjcmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWREZWNvZGVkQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWREZWNvZGVkQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgdGhpcy5iYWNrZW5kLmxvYWQoYnVmZmVyKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdyZWFkeScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhdWRpbyBkYXRhIGZyb20gYSBCbG9iIG9yIEZpbGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jsb2J8RmlsZX0gYmxvYiBBdWRpbyBkYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRCbG9iXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRCbG9iKGJsb2IpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgLy8gQ3JlYXRlIGZpbGUgcmVhZGVyXG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczEwLm9uUHJvZ3Jlc3MoZSk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAubG9hZEFycmF5QnVmZmVyKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAuZmlyZUV2ZW50KCdlcnJvcicsICdFcnJvciByZWFkaW5nIGZpbGUnKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgICAgdGhpcy5lbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhdWRpbyBhbmQgcmUtcmVuZGVycyB0aGUgd2F2ZWZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MTWVkaWFFbGVtZW50fSB1cmwgVGhlIHVybCBvZiB0aGUgYXVkaW8gZmlsZSBvciB0aGVcbiAgICAgKiBhdWRpbyBlbGVtZW50IHdpdGggdGhlIGF1ZGlvXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBXYXZlc3VyZmVyIGRvZXMgbm90IGhhdmUgdG8gZGVjb2RlXG4gICAgICogdGhlIGF1ZGlvIHRvIHJlbmRlciB0aGUgd2F2ZWZvcm0gaWYgdGhpcyBpcyBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHByZWxvYWQgKFVzZSB3aXRoIGJhY2tlbmQgYE1lZGlhRWxlbWVudGAgYW5kIGBNZWRpYUVsZW1lbnRXZWJBdWRpb2ApXG4gICAgICogYCdub25lJ3wnbWV0YWRhdGEnfCdhdXRvJ2AgUHJlbG9hZCBhdHRyaWJ1dGUgZm9yIHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIGF1ZGlvLiBUaGlzIGlzIHVzZWQgdG9cbiAgICAgKiByZW5kZXIgdGhlIHBlYWtzIGRhdGEgaW4gdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgdGhlIGF1ZGlvIGR1cmF0aW9uIChhc1xuICAgICAqIGJlZml0cyB0aGUgY3VycmVudCBgbWluUHhQZXJTZWNgIGFuZCB6b29tIHZhbHVlKSB3aXRob3V0IGhhdmluZyB0byBkZWNvZGVcbiAgICAgKiB0aGUgYXVkaW8uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBgdXJsYCBhcmd1bWVudCBpcyBlbXB0eS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHVzZXMgZmV0Y2ggb3IgbWVkaWEgZWxlbWVudCB0byBsb2FkIGZpbGUgKGRlcGVuZGluZyBvbiBiYWNrZW5kKVxuICAgICAqIHdhdmVzdXJmZXIubG9hZCgnaHR0cDovL2V4YW1wbGUuY29tL2RlbW8ud2F2Jyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXR0aW5nIHByZWxvYWQgYXR0cmlidXRlIHdpdGggbWVkaWEgZWxlbWVudCBiYWNrZW5kIGFuZCBzdXBwbHlpbmdcbiAgICAgKiAvLyBwZWFrc1xuICAgICAqIHdhdmVzdXJmZXIubG9hZChcbiAgICAgKiAgICdodHRwOi8vZXhhbXBsZS5jb20vZGVtby53YXYnLFxuICAgICAqICAgWzAuMDIxOCwgMC4wMTgzLCAwLjAxNjUsIDAuMDE5OCwgMC4yMTM3LCAwLjI4ODhdLFxuICAgICAqICAgdHJ1ZVxuICAgICAqICk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBwZWFrcywgcHJlbG9hZCwgZHVyYXRpb24pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXJsIHBhcmFtZXRlciBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbXB0eSgpO1xuXG4gICAgICBpZiAocHJlbG9hZCkge1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwcmVsb2FkIGF0dHJpYnV0ZSB3aWxsIGJlIHVzYWJsZSBhbmQgaWYgbm90IGxvZ1xuICAgICAgICAvLyBhIHdhcm5pbmcgbGlzdGluZyB0aGUgcmVhc29ucyB3aHkgbm90IGFuZCBudWxsaWZ5IHRoZSB2YXJpYWJsZVxuICAgICAgICB2YXIgcHJlbG9hZElnbm9yZVJlYXNvbnMgPSB7XG4gICAgICAgICAgXCJQcmVsb2FkIGlzIG5vdCAnYXV0bycsICdub25lJyBvciAnbWV0YWRhdGEnXCI6IFsnYXV0bycsICdtZXRhZGF0YScsICdub25lJ10uaW5kZXhPZihwcmVsb2FkKSA9PT0gLTEsXG4gICAgICAgICAgJ1BlYWtzIGFyZSBub3QgcHJvdmlkZWQnOiAhcGVha3MsXG4gICAgICAgICAgXCJCYWNrZW5kIGlzIG5vdCBvZiB0eXBlICdNZWRpYUVsZW1lbnQnIG9yICdNZWRpYUVsZW1lbnRXZWJBdWRpbydcIjogWydNZWRpYUVsZW1lbnQnLCAnTWVkaWFFbGVtZW50V2ViQXVkaW8nXS5pbmRleE9mKHRoaXMucGFyYW1zLmJhY2tlbmQpID09PSAtMSxcbiAgICAgICAgICAnVXJsIGlzIG5vdCBvZiB0eXBlIHN0cmluZyc6IHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhY3RpdmVSZWFzb25zID0gT2JqZWN0LmtleXMocHJlbG9hZElnbm9yZVJlYXNvbnMpLmZpbHRlcihmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWxvYWRJZ25vcmVSZWFzb25zW3JlYXNvbl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhY3RpdmVSZWFzb25zLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdQcmVsb2FkIHBhcmFtZXRlciBvZiB3YXZlc3VyZmVyLmxvYWQgd2lsbCBiZSBpZ25vcmVkIGJlY2F1c2U6XFxuXFx0LSAnICsgYWN0aXZlUmVhc29ucy5qb2luKCdcXG5cXHQtICcpKTsgLy8gc3RvcCBpbnZhbGlkIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWRcblxuICAgICAgICAgIHByZWxvYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IC8vIGxvYWRCdWZmZXIodXJsLCBwZWFrcywgZHVyYXRpb24pIHJlcXVpcmVzIHRoYXQgdXJsIGlzIGEgc3RyaW5nXG4gICAgICAvLyBidXQgdXNlcnMgY2FuIHBhc3MgaW4gYSBIVE1MTWVkaWFFbGVtZW50IHRvIFdhdmVTdXJmZXJcblxuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuYmFja2VuZCA9PT0gJ1dlYkF1ZGlvJyAmJiB1cmwgaW5zdGFuY2VvZiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgICAgIHVybCA9IHVybC5zcmM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5wYXJhbXMuYmFja2VuZCkge1xuICAgICAgICBjYXNlICdXZWJBdWRpbyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEJ1ZmZlcih1cmwsIHBlYWtzLCBkdXJhdGlvbik7XG5cbiAgICAgICAgY2FzZSAnTWVkaWFFbGVtZW50JzpcbiAgICAgICAgY2FzZSAnTWVkaWFFbGVtZW50V2ViQXVkaW8nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRNZWRpYUVsZW1lbnQodXJsLCBwZWFrcywgcHJlbG9hZCwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhdWRpbyB1c2luZyBXZWIgQXVkaW8gYnVmZmVyIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBlbWl0cyBXYXZlU3VyZmVyI3dhdmVmb3JtLXJlYWR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgb2YgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgUGVha3MgZGF0YVxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZHVyYXRpb24gT3B0aW9uYWwgZHVyYXRpb24gb2YgYXVkaW8gZmlsZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkQnVmZmVyKHVybCwgcGVha3MsIGR1cmF0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciBsb2FkID0gZnVuY3Rpb24gbG9hZChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgIF90aGlzMTEudG1wRXZlbnRzLnB1c2goX3RoaXMxMS5vbmNlKCdyZWFkeScsIGFjdGlvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMTEuZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczExLmxvYWRBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAocGVha3MpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLnNldFBlYWtzKHBlYWtzLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcigpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgnd2F2ZWZvcm0tcmVhZHknKTtcbiAgICAgICAgdGhpcy50bXBFdmVudHMucHVzaCh0aGlzLm9uY2UoJ2ludGVyYWN0aW9uJywgbG9hZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWl0aGVyIGNyZWF0ZSBhIG1lZGlhIGVsZW1lbnQsIG9yIGxvYWQgYW4gZXhpc3RpbmcgbWVkaWEgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjd2F2ZWZvcm0tcmVhZHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MTWVkaWFFbGVtZW50fSB1cmxPckVsdCBFaXRoZXIgYSBwYXRoIHRvIGEgbWVkaWEgZmlsZSwgb3IgYW5cbiAgICAgKiBleGlzdGluZyBIVE1MNSBBdWRpby9WaWRlbyBFbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxOdW1iZXIuPEFycmF5W10+fSBwZWFrcyBBcnJheSBvZiBwZWFrcy4gUmVxdWlyZWQgdG8gYnlwYXNzIHdlYiBhdWRpb1xuICAgICAqIGRlcGVuZGVuY3lcbiAgICAgKiBAcGFyYW0gez9ib29sZWFufSBwcmVsb2FkIFNldCB0byB0cnVlIGlmIHRoZSBwcmVsb2FkIGF0dHJpYnV0ZSBvZiB0aGVcbiAgICAgKiBhdWRpbyBlbGVtZW50IHNob3VsZCBiZSBlbmFibGVkXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBkdXJhdGlvbiBPcHRpb25hbCBkdXJhdGlvbiBvZiBhdWRpbyBmaWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTWVkaWFFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRNZWRpYUVsZW1lbnQodXJsT3JFbHQsIHBlYWtzLCBwcmVsb2FkLCBkdXJhdGlvbikge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgdXJsID0gdXJsT3JFbHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgdXJsT3JFbHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5sb2FkKHVybCwgdGhpcy5tZWRpYUNvbnRhaW5lciwgcGVha3MsIHByZWxvYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsdCA9IHVybE9yRWx0O1xuICAgICAgICB0aGlzLmJhY2tlbmQubG9hZEVsdChlbHQsIHBlYWtzKTsgLy8gSWYgcGVha3MgYXJlIG5vdCBwcm92aWRlZCxcbiAgICAgICAgLy8gdXJsID0gZWxlbWVudC5zcmMgc28gd2UgY2FuIGdldCBwZWFrcyB3aXRoIHdlYiBhdWRpb1xuXG4gICAgICAgIHVybCA9IGVsdC5zcmM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG1wRXZlbnRzLnB1c2godGhpcy5iYWNrZW5kLm9uY2UoJ2NhbnBsYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlnbm9yZSB3aGVuIGJhY2tlbmQgd2FzIGFscmVhZHkgZGVzdHJveWVkXG4gICAgICAgIGlmICghX3RoaXMxMi5iYWNrZW5kLmRlc3Ryb3llZCkge1xuICAgICAgICAgIF90aGlzMTIuZHJhd0J1ZmZlcigpO1xuXG4gICAgICAgICAgX3RoaXMxMi5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzMTIuZmlyZUV2ZW50KCdyZWFkeScpO1xuICAgICAgICB9XG4gICAgICB9KSwgdGhpcy5iYWNrZW5kLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gX3RoaXMxMi5maXJlRXZlbnQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0pKTsgLy8gSWYgcGVha3MgYXJlIHByb3ZpZGVkLCByZW5kZXIgdGhlbSBhbmQgZmlyZSB0aGUgYHdhdmVmb3JtLXJlYWR5YCBldmVudC5cblxuICAgICAgaWYgKHBlYWtzKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5zZXRQZWFrcyhwZWFrcywgZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmRyYXdCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3dhdmVmb3JtLXJlYWR5Jyk7XG4gICAgICB9IC8vIElmIG5vIHByZS1kZWNvZGVkIHBlYWtzIGFyZSBwcm92aWRlZCwgb3IgYXJlIHByb3ZpZGVkIHdpdGhcbiAgICAgIC8vIGZvcmNlRGVjb2RlIGZsYWcsIGF0dGVtcHQgdG8gZG93bmxvYWQgdGhlIGF1ZGlvIGZpbGUgYW5kIGRlY29kZSBpdFxuICAgICAgLy8gd2l0aCBXZWIgQXVkaW8uXG5cblxuICAgICAgaWYgKCghcGVha3MgfHwgdGhpcy5wYXJhbXMuZm9yY2VEZWNvZGUpICYmIHRoaXMuYmFja2VuZC5zdXBwb3J0c1dlYkF1ZGlvKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBcnJheUJ1ZmZlcih1cmwsIGZ1bmN0aW9uIChhcnJheWJ1ZmZlcikge1xuICAgICAgICAgIF90aGlzMTIuZGVjb2RlQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIF90aGlzMTIuYmFja2VuZC5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgICAgICAgIF90aGlzMTIuYmFja2VuZC5zZXRQZWFrcyhudWxsKTtcblxuICAgICAgICAgICAgX3RoaXMxMi5kcmF3QnVmZmVyKCk7XG5cbiAgICAgICAgICAgIF90aGlzMTIuZmlyZUV2ZW50KCd3YXZlZm9ybS1yZWFkeScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFycmF5IGJ1ZmZlciBhbmQgcGFzcyBkYXRhIHRvIGEgY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5YnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gY29tcGxldGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUFycmF5QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUFycmF5QnVmZmVyKGFycmF5YnVmZmVyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFycmF5YnVmZmVyID0gYXJyYXlidWZmZXI7XG4gICAgICB0aGlzLmJhY2tlbmQuZGVjb2RlQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIE9ubHkgdXNlIHRoZSBkZWNvZGVkIGRhdGEgaWYgd2UgaGF2ZW4ndCBiZWVuIGRlc3Ryb3llZCBvclxuICAgICAgICAvLyBhbm90aGVyIGRlY29kZSBzdGFydGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICBpZiAoIV90aGlzMTMuaXNEZXN0cm95ZWQgJiYgX3RoaXMxMy5hcnJheWJ1ZmZlciA9PSBhcnJheWJ1ZmZlcikge1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIF90aGlzMTMuYXJyYXlidWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczEzLmZpcmVFdmVudCgnZXJyb3InLCAnRXJyb3IgZGVjb2RpbmcgYXVkaW9idWZmZXInKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGFuIGFycmF5IGJ1ZmZlciB1c2luZyBmZXRjaCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGEgY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZmlsZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHt1dGlsLmZldGNoRmlsZX0gZmV0Y2ggY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRBcnJheUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcidcbiAgICAgIH0sIHRoaXMucGFyYW1zLnhocik7XG4gICAgICB2YXIgcmVxdWVzdCA9IHV0aWwuZmV0Y2hGaWxlKG9wdGlvbnMpO1xuICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICB0aGlzLnRtcEV2ZW50cy5wdXNoKHJlcXVlc3Qub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMxNC5vblByb2dyZXNzKGUpO1xuICAgICAgfSksIHJlcXVlc3Qub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgX3RoaXMxNC5jdXJyZW50UmVxdWVzdCA9IG51bGw7XG4gICAgICB9KSwgcmVxdWVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczE0LmZpcmVFdmVudCgnZXJyb3InLCBlKTtcblxuICAgICAgICBfdGhpczE0LmN1cnJlbnRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hpbGUgdGhlIGF1ZGlvIGZpbGUgaXMgbG9hZGluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFByb2dyZXNzIGV2ZW50XG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjbG9hZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGUpIHtcbiAgICAgIHZhciBwZXJjZW50Q29tcGxldGU7XG5cbiAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgcGVyY2VudENvbXBsZXRlID0gZS5sb2FkZWQgLyBlLnRvdGFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgcHJvZ3Jlc3Mgd2l0aCBhbiBhc3ltcHRvdGljXG4gICAgICAgIC8vIGZ1bmN0aW9uLCBhbmQgYXNzdW1lIGRvd25sb2FkcyBpbiB0aGUgMS0zIE1CIHJhbmdlLlxuICAgICAgICBwZXJjZW50Q29tcGxldGUgPSBlLmxvYWRlZCAvIChlLmxvYWRlZCArIDEwMDAwMDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpcmVFdmVudCgnbG9hZGluZycsIE1hdGgucm91bmQocGVyY2VudENvbXBsZXRlICogMTAwKSwgZS50YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIFBDTSBkYXRhIGludG8gYSBKU09OIGFycmF5IGFuZCBvcHRpb25hbGx5IG9wZW5zIGluIGEgbmV3IHdpbmRvd1xuICAgICAqIGFzIHZhbGlkIEpTT04gQmxvYiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGg9MTAyNCBUaGUgc2NhbGUgaW4gd2hpY2ggdG8gZXhwb3J0IHRoZSBwZWFrc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY2N1cmFjeT0xMDAwMFxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IG5vV2luZG93IFNldCB0byB0cnVlIHRvIGRpc2FibGUgb3BlbmluZyBhIG5ld1xuICAgICAqIHdpbmRvdyB3aXRoIHRoZSBKU09OXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhcnJheSBvZiBwZWFrc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwb3J0UENNXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFBDTShsZW5ndGgsIGFjY3VyYWN5LCBub1dpbmRvdywgc3RhcnQsIGVuZCkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDEwMjQ7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBhY2N1cmFjeSA9IGFjY3VyYWN5IHx8IDEwMDAwO1xuICAgICAgbm9XaW5kb3cgPSBub1dpbmRvdyB8fCBmYWxzZTtcbiAgICAgIHZhciBwZWFrcyA9IHRoaXMuYmFja2VuZC5nZXRQZWFrcyhsZW5ndGgsIHN0YXJ0LCBlbmQpO1xuICAgICAgdmFyIGFyciA9IFtdLm1hcC5jYWxsKHBlYWtzLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIGFjY3VyYWN5KSAvIGFjY3VyYWN5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIW5vV2luZG93KSB7XG4gICAgICAgICAgdmFyIGJsb2JKU09OID0gbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGFycildLCB7XG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBvYmpVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2JKU09OKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihvYmpVUkwpO1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqVVJMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoYXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlIHdhdmVmb3JtIGltYWdlIGFzIGRhdGEgVVJJLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgZm9ybWF0IGlzIGAnaW1hZ2UvcG5nJ2AuIE90aGVyIHN1cHBvcnRlZCB0eXBlcyBhcmVcbiAgICAgKiBgJ2ltYWdlL2pwZWcnYCBhbmQgYCdpbWFnZS93ZWJwJ2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0PSdpbWFnZS9wbmcnIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGltYWdlIGZvcm1hdC5cbiAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgdHlwZSBpcyBgJ2ltYWdlL3BuZydgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5PTEgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluZGljYXRpbmcgdGhlIGltYWdlXG4gICAgICogcXVhbGl0eSB0byB1c2UgZm9yIGltYWdlIGZvcm1hdHMgdGhhdCB1c2UgbG9zc3kgY29tcHJlc3Npb24gc3VjaCBhc1xuICAgICAqIGAnaW1hZ2UvanBlZydgYCBhbmQgYCdpbWFnZS93ZWJwJ2AuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgSW1hZ2UgZGF0YSB0eXBlIHRvIHJldHVybi4gRWl0aGVyICdkYXRhVVJMJyAoZGVmYXVsdClcbiAgICAgKiBvciAnYmxvYicuXG4gICAgICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfFByb21pc2V9IFdoZW4gdXNpbmcgYCdkYXRhVVJMJ2AgdHlwZSB0aGlzIHJldHVybnNcbiAgICAgKiBhIHNpbmdsZSBkYXRhIFVSTCBvciBhbiBhcnJheSBvZiBkYXRhIFVSTHMsIG9uZSBmb3IgZWFjaCBjYW52YXMuIFdoZW4gdXNpbmdcbiAgICAgKiBgJ2Jsb2InYCB0eXBlIHRoaXMgcmV0dXJucyBhIGBQcm9taXNlYCByZXNvbHZpbmcgd2l0aCBhbiBhcnJheSBvZiBgQmxvYmBcbiAgICAgKiBpbnN0YW5jZXMsIG9uZSBmb3IgZWFjaCBjYW52YXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHBvcnRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRJbWFnZShmb3JtYXQsIHF1YWxpdHksIHR5cGUpIHtcbiAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdCA9ICdpbWFnZS9wbmcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXF1YWxpdHkpIHtcbiAgICAgICAgcXVhbGl0eSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0eXBlID0gJ2RhdGFVUkwnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5kcmF3ZXIuZ2V0SW1hZ2UoZm9ybWF0LCBxdWFsaXR5LCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFueSBmZXRjaCByZXF1ZXN0IGN1cnJlbnRseSBpbiBwcm9ncmVzc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQWpheFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWxBamF4KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFJlcXVlc3QgJiYgdGhpcy5jdXJyZW50UmVxdWVzdC5jb250cm9sbGVyKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHJlcXVlc3QgaGFzIGEgUHJvZ3Jlc3NIYW5kbGVyLCB0aGVuIGl0cyBSZWFkYWJsZVN0cmVhbSBtaWdodCBuZWVkIHRvIGJlIGNhbmNlbGxlZCB0b29cbiAgICAgICAgLy8gU2VlOiBXYXZlc3VyZmVyIGlzc3VlICMyMDQyXG4gICAgICAgIC8vIFNlZSBGaXJlZm94IGJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU4MzgxNVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdC5fcmVhZGVyKSB7XG4gICAgICAgICAgLy8gSWdub3JpbmcgZXhjZXB0aW9ucyB0aHJvd24gYnkgY2FsbCB0byBjYW5jZWwoKVxuICAgICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QuX3JlYWRlci5jYW5jZWwoKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7fSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0LmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclRtcEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclRtcEV2ZW50cygpIHtcbiAgICAgIHRoaXMudG1wRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudW4oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGVtcHR5IHdhdmVmb3JtLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2VuZC5pc1BhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmJhY2tlbmQuZGlzY29ubmVjdFNvdXJjZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2FuY2VsQWpheCgpO1xuICAgICAgdGhpcy5jbGVhclRtcEV2ZW50cygpOyAvLyBlbXB0eSBkcmF3ZXJcblxuICAgICAgdGhpcy5kcmF3ZXIucHJvZ3Jlc3MoMCk7XG4gICAgICB0aGlzLmRyYXdlci5zZXRXaWR0aCgwKTtcbiAgICAgIHRoaXMuZHJhd2VyLmRyYXdQZWFrcyh7XG4gICAgICAgIGxlbmd0aDogdGhpcy5kcmF3ZXIuZ2V0V2lkdGgoKVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudHMsIGVsZW1lbnRzIGFuZCBkaXNjb25uZWN0IFdlYkF1ZGlvIG5vZGVzLlxuICAgICAqXG4gICAgICogQGVtaXRzIFdhdmVTdXJmZXIjZGVzdHJveVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kZXN0cm95QWxsUGx1Z2lucygpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ2Rlc3Ryb3knKTtcbiAgICAgIHRoaXMuY2FuY2VsQWpheCgpO1xuICAgICAgdGhpcy5jbGVhclRtcEV2ZW50cygpO1xuICAgICAgdGhpcy51bkFsbCgpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25SZXNpemUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iYWNrZW5kKSB7XG4gICAgICAgIHRoaXMuYmFja2VuZC5kZXN0cm95KCk7IC8vIGNsZWFycyBtZW1vcnkgdXNhZ2VcblxuICAgICAgICB0aGlzLmJhY2tlbmQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kcmF3ZXIpIHtcbiAgICAgICAgdGhpcy5kcmF3ZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5hcnJheWJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIHRoaXMgY2xhc3MsIGNhbGwgaXRzIGBpbml0YCBmdW5jdGlvbiBhbmQgcmV0dXJucyBpdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgVGhlIHdhdmVzdXJmZXIgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gV2F2ZVN1cmZlciBpbnN0YW5jZVxuICAgICAqIEBleGFtcGxlIGNvbnN0IHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZShwYXJhbXMpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgIHZhciB3YXZlc3VyZmVyID0gbmV3IFdhdmVTdXJmZXIocGFyYW1zKTtcbiAgICAgIHJldHVybiB3YXZlc3VyZmVyLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpYnJhcnkgdmVyc2lvbiBudW1iZXIgaXMgYXZhaWxhYmxlIGFzIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZVxuICAgICAqIFdhdmVTdXJmZXIgY2xhc3NcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zb2xlLmxvZygnVXNpbmcgd2F2ZXN1cmZlci5qcyAnICsgV2F2ZVN1cmZlci5WRVJTSU9OKTtcbiAgICAgKi9cblxuICB9XSk7XG5cbiAgcmV0dXJuIFdhdmVTdXJmZXI7XG59KHV0aWwuT2JzZXJ2ZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXYXZlU3VyZmVyO1xuV2F2ZVN1cmZlci5WRVJTSU9OID0gXCI1LjEuMFwiO1xuV2F2ZVN1cmZlci51dGlsID0gdXRpbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy93ZWJhdWRpby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy93ZWJhdWRpby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL3V0aWwvaW5kZXguanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy8gdXNpbmcgY29uc3RhbnRzIHRvIHByZXZlbnQgc29tZW9uZSB3cml0aW5nIHRoZSBzdHJpbmcgd3JvbmdcbnZhciBQTEFZSU5HID0gJ3BsYXlpbmcnO1xudmFyIFBBVVNFRCA9ICdwYXVzZWQnO1xudmFyIEZJTklTSEVEID0gJ2ZpbmlzaGVkJztcbi8qKlxuICogV2ViQXVkaW8gYmFja2VuZFxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqL1xuXG52YXIgV2ViQXVkaW8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF91dGlsJE9ic2VydmVyKSB7XG4gIF9pbmhlcml0cyhXZWJBdWRpbywgX3V0aWwkT2JzZXJ2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoV2ViQXVkaW8pO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIGJhY2tlbmRcbiAgICpcbiAgICogQHBhcmFtIHtXYXZlc3VyZmVyUGFyYW1zfSBwYXJhbXMgV2F2ZXN1cmZlciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBXZWJBdWRpbyhwYXJhbXMpIHtcbiAgICB2YXIgX3RoaXMkc3RhdGVCZWhhdmlvcnMsIF90aGlzJHN0YXRlcztcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJBdWRpbyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuYXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICBfdGhpcy5vZmZsaW5lQXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICBfdGhpcy5zdGF0ZUJlaGF2aW9ycyA9IChfdGhpcyRzdGF0ZUJlaGF2aW9ycyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc3RhdGVCZWhhdmlvcnMsIFBMQVlJTkcsIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMuYWRkT25BdWRpb1Byb2Nlc3MoKTtcbiAgICAgIH0sXG4gICAgICBnZXRQbGF5ZWRQZXJjZW50czogZnVuY3Rpb24gZ2V0UGxheWVkUGVyY2VudHMoKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFRpbWUoKSAvIGR1cmF0aW9uIHx8IDA7XG4gICAgICB9LFxuICAgICAgZ2V0Q3VycmVudFRpbWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9uICsgdGhpcy5nZXRQbGF5ZWRUaW1lKCk7XG4gICAgICB9XG4gICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZUJlaGF2aW9ycywgUEFVU0VELCB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB0aGlzLnJlbW92ZU9uQXVkaW9Qcm9jZXNzKCk7XG4gICAgICB9LFxuICAgICAgZ2V0UGxheWVkUGVyY2VudHM6IGZ1bmN0aW9uIGdldFBsYXllZFBlcmNlbnRzKCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmdldER1cmF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRUaW1lKCkgLyBkdXJhdGlvbiB8fCAwO1xuICAgICAgfSxcbiAgICAgIGdldEN1cnJlbnRUaW1lOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlQmVoYXZpb3JzLCBGSU5JU0hFRCwge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPbkF1ZGlvUHJvY2VzcygpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgnZmluaXNoJyk7XG4gICAgICB9LFxuICAgICAgZ2V0UGxheWVkUGVyY2VudHM6IGZ1bmN0aW9uIGdldFBsYXllZFBlcmNlbnRzKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0sXG4gICAgICBnZXRDdXJyZW50VGltZTogZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldER1cmF0aW9uKCk7XG4gICAgICB9XG4gICAgfSksIF90aGlzJHN0YXRlQmVoYXZpb3JzKTtcbiAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgLyoqIGFjOiBBdWRpbyBDb250ZXh0IGluc3RhbmNlICovXG5cbiAgICBfdGhpcy5hYyA9IHBhcmFtcy5hdWRpb0NvbnRleHQgfHwgKF90aGlzLnN1cHBvcnRzV2ViQXVkaW8oKSA/IF90aGlzLmdldEF1ZGlvQ29udGV4dCgpIDoge30pO1xuICAgIC8qKkBwcml2YXRlICovXG5cbiAgICBfdGhpcy5sYXN0UGxheSA9IF90aGlzLmFjLmN1cnJlbnRUaW1lO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zY2hlZHVsZWRQYXVzZSA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zdGF0ZXMgPSAoX3RoaXMkc3RhdGVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzdGF0ZXMsIFBMQVlJTkcsIE9iamVjdC5jcmVhdGUoX3RoaXMuc3RhdGVCZWhhdmlvcnNbUExBWUlOR10pKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlcywgUEFVU0VELCBPYmplY3QuY3JlYXRlKF90aGlzLnN0YXRlQmVoYXZpb3JzW1BBVVNFRF0pKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHN0YXRlcywgRklOSVNIRUQsIE9iamVjdC5jcmVhdGUoX3RoaXMuc3RhdGVCZWhhdmlvcnNbRklOSVNIRURdKSksIF90aGlzJHN0YXRlcyk7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMuZmlsdGVycyA9IFtdO1xuICAgIC8qKiBnYWluTm9kZTogYWxsb3dzIHRvIGNvbnRyb2wgYXVkaW8gdm9sdW1lICovXG5cbiAgICBfdGhpcy5nYWluTm9kZSA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5tZXJnZWRQZWFrcyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5vZmZsaW5lQWMgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGVha3MgPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgX3RoaXMucGxheWJhY2tSYXRlID0gMTtcbiAgICAvKiogYW5hbHlzZXI6IHByb3ZpZGVzIGF1ZGlvIGFuYWx5c2lzIGluZm9ybWF0aW9uICovXG5cbiAgICBfdGhpcy5hbmFseXNlciA9IG51bGw7XG4gICAgLyoqIHNjcmlwdE5vZGU6IGFsbG93cyBwcm9jZXNzaW5nIGF1ZGlvICovXG5cbiAgICBfdGhpcy5zY3JpcHROb2RlID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zcGxpdFBlYWtzID0gW107XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy5leHBsaWNpdER1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYmFja2VuZCB3YXMgZGVzdHJveWVkLlxuICAgICAqL1xuXG4gICAgX3RoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBiYWNrZW5kLCBjYWxsZWQgaW4gYHdhdmVzdXJmZXIuY3JlYXRlQmFja2VuZCgpYFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhXZWJBdWRpbywgW3tcbiAgICBrZXk6IFwic3VwcG9ydHNXZWJBdWRpb1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKiBzY3JpcHRCdWZmZXJTaXplOiBzaXplIG9mIHRoZSBwcm9jZXNzaW5nIGJ1ZmZlciAqL1xuXG4gICAgLyoqIGF1ZGlvQ29udGV4dDogYWxsb3dzIHRvIHByb2Nlc3MgYXVkaW8gd2l0aCBXZWJBdWRpbyBBUEkgKi9cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgdGhpcyBiYWNrZW5kXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBiYWNrZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VwcG9ydHNXZWJBdWRpbygpIHtcbiAgICAgIHJldHVybiAhISh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGlzIGJhY2tlbmQgb3IgY3JlYXRlIG9uZVxuICAgICAqXG4gICAgICogQHJldHVybiB7QXVkaW9Db250ZXh0fSBFeGlzdGluZyBhdWRpbyBjb250ZXh0LCBvciBjcmVhdGVzIGEgbmV3IG9uZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXVkaW9Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF1ZGlvQ29udGV4dCgpIHtcbiAgICAgIGlmICghd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgd2luZG93LldhdmVTdXJmZXJBdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRvdy5XYXZlU3VyZmVyQXVkaW9Db250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZmxpbmUgYXVkaW8gY29udGV4dCB1c2VkIGJ5IHRoaXMgYmFja2VuZCBvciBjcmVhdGUgb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlIHJhdGUgdG8gdXNlXG4gICAgICogQHJldHVybiB7T2ZmbGluZUF1ZGlvQ29udGV4dH0gRXhpc3Rpbmcgb2ZmbGluZSBhdWRpbyBjb250ZXh0LCBvciBjcmVhdGVzXG4gICAgICogYSBuZXcgb25lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPZmZsaW5lQXVkaW9Db250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9mZmxpbmVBdWRpb0NvbnRleHQoc2FtcGxlUmF0ZSkge1xuICAgICAgaWYgKCF3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCkoMSwgMiwgc2FtcGxlUmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kb3cuV2F2ZVN1cmZlck9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuY3JlYXRlVm9sdW1lTm9kZSgpO1xuICAgICAgdGhpcy5jcmVhdGVTY3JpcHROb2RlKCk7XG4gICAgICB0aGlzLmNyZWF0ZUFuYWx5c2VyTm9kZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShQQVVTRUQpO1xuICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUodGhpcy5wYXJhbXMuYXVkaW9SYXRlKTtcbiAgICAgIHRoaXMuc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RGaWx0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3RGaWx0ZXJzKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgZmlsdGVyICYmIGZpbHRlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBudWxsOyAvLyBSZWNvbm5lY3QgZGlyZWN0IHBhdGhcblxuICAgICAgICB0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgVGhlIG5ldyBzdGF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlc1tzdGF0ZV0pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbml0LmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGFja2VkIGBzZXRGaWx0ZXJzKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLkF1ZGlvTm9kZX0gZmlsdGVycyBPbmUgb3IgbW9yZSBmaWx0ZXJzIHRvIHNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbHRlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmaWx0ZXJzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBmaWx0ZXJzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEZpbHRlcnMoZmlsdGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBjdXN0b20gV2ViIEF1ZGlvIG5vZGVzIGludG8gdGhlIGdyYXBoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBmaWx0ZXJzIFBhY2tlZCBmaWx0ZXJzIGFycmF5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBsb3dwYXNzID0gd2F2ZXN1cmZlci5iYWNrZW5kLmFjLmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAqIHdhdmVzdXJmZXIuYmFja2VuZC5zZXRGaWx0ZXIobG93cGFzcyk7XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGaWx0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbHRlcnMoZmlsdGVycykge1xuICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGZpbHRlcnNcbiAgICAgIHRoaXMuZGlzY29ubmVjdEZpbHRlcnMoKTsgLy8gSW5zZXJ0IGZpbHRlcnMgaWYgZmlsdGVyIGFycmF5IG5vdCBlbXB0eVxuXG4gICAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzOyAvLyBEaXNjb25uZWN0IGRpcmVjdCBwYXRoIGJlZm9yZSBpbnNlcnRpbmcgZmlsdGVyc1xuXG4gICAgICAgIHRoaXMuYW5hbHlzZXIuZGlzY29ubmVjdCgpOyAvLyBDb25uZWN0IGVhY2ggZmlsdGVyIGluIHR1cm5cblxuICAgICAgICBmaWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgIHByZXYuY29ubmVjdChjdXJyKTtcbiAgICAgICAgICByZXR1cm4gY3VycjtcbiAgICAgICAgfSwgdGhpcy5hbmFseXNlcikuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIENyZWF0ZSBTY3JpcHRQcm9jZXNzb3JOb2RlIHRvIHByb2Nlc3MgYXVkaW8gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNjcmlwdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2NyaXB0Tm9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5hdWRpb1NjcmlwdFByb2Nlc3Nvcikge1xuICAgICAgICB0aGlzLnNjcmlwdE5vZGUgPSB0aGlzLnBhcmFtcy5hdWRpb1NjcmlwdFByb2Nlc3NvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFjLmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcikge1xuICAgICAgICAgIHRoaXMuc2NyaXB0Tm9kZSA9IHRoaXMuYWMuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKFdlYkF1ZGlvLnNjcmlwdEJ1ZmZlclNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2NyaXB0Tm9kZSA9IHRoaXMuYWMuY3JlYXRlSmF2YVNjcmlwdE5vZGUoV2ViQXVkaW8uc2NyaXB0QnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JpcHROb2RlLmNvbm5lY3QodGhpcy5hYy5kZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT25BdWRpb1Byb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT25BdWRpb1Byb2Nlc3MoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5zY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZSA9IF90aGlzMi5nZXRDdXJyZW50VGltZSgpO1xuXG4gICAgICAgIGlmICh0aW1lID49IF90aGlzMi5nZXREdXJhdGlvbigpKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKEZJTklTSEVEKTtcblxuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ3BhdXNlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZSA+PSBfdGhpczIuc2NoZWR1bGVkUGF1c2UpIHtcbiAgICAgICAgICBfdGhpczIucGF1c2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpczIuc3RhdGUgPT09IF90aGlzMi5zdGF0ZXNbUExBWUlOR10pIHtcbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdhdWRpb3Byb2Nlc3MnLCB0aW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVPbkF1ZGlvUHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVPbkF1ZGlvUHJvY2VzcygpIHtcbiAgICAgIHRoaXMuc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2VzcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgYW5hbHlzZXIgbm9kZSB0byBwZXJmb3JtIGF1ZGlvIGFuYWx5c2lzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBbmFseXNlck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQW5hbHlzZXJOb2RlKCkge1xuICAgICAgdGhpcy5hbmFseXNlciA9IHRoaXMuYWMuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgIHRoaXMuYW5hbHlzZXIuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBnYWluIG5vZGUgbmVlZGVkIHRvIGNvbnRyb2wgdGhlIHBsYXliYWNrIHZvbHVtZS5cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVm9sdW1lTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVWb2x1bWVOb2RlKCkge1xuICAgICAgLy8gQ3JlYXRlIGdhaW4gbm9kZSB1c2luZyB0aGUgQXVkaW9Db250ZXh0XG4gICAgICBpZiAodGhpcy5hYy5jcmVhdGVHYWluKSB7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLmFjLmNyZWF0ZUdhaW5Ob2RlKCk7XG4gICAgICB9IC8vIEFkZCB0aGUgZ2FpbiBub2RlIHRvIHRoZSBncmFwaFxuXG5cbiAgICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmFjLmRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaW5rIGlkIGZvciB0aGUgbWVkaWEgcGxheWVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSWQgU3RyaW5nIHZhbHVlIHJlcHJlc2VudGluZyBhdWRpbyBkZXZpY2UgaWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGB1bmRlZmluZWRgIHdoZW4gdGhlcmVcbiAgICAgKiBhcmUgbm8gZXJyb3JzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2lua0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpbmtJZChkZXZpY2VJZCkge1xuICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2ViYXVkaW8gQVBJIGRvZXNuJ3QgY3VycmVudGx5IHN1cHBvcnQgc2V0dGluZyB0aGUgZGV2aWNlXG4gICAgICAgICAqIG91dHB1dC4gSGVyZSB3ZSBjcmVhdGUgYW4gSFRNTEF1ZGlvRWxlbWVudCwgY29ubmVjdCB0aGVcbiAgICAgICAgICogd2ViYXVkaW8gc3RyZWFtIHRvIHRoYXQgZWxlbWVudCBhbmQgc2V0U2lua0lkIHRoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGF1ZGlvID0gbmV3IHdpbmRvdy5BdWRpbygpO1xuXG4gICAgICAgIGlmICghYXVkaW8uc2V0U2lua0lkKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignc2V0U2lua0lkIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXVkaW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB2YXIgZGVzdCA9IHRoaXMuYWMuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgICAgICB0aGlzLmdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KGRlc3QpO1xuICAgICAgICBhdWRpby5zcmNPYmplY3QgPSBkZXN0LnN0cmVhbTtcbiAgICAgICAgcmV0dXJuIGF1ZGlvLnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIGRldmljZUlkOiAnICsgZGV2aWNlSWQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdWRpbyB2b2x1bWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBBIGZsb2F0aW5nIHBvaW50IHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWb2x1bWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgdGhpcy5hYy5jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB2b2x1bWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgQSBmbG9hdGluZyBwb2ludCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vm9sdW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFycmF5IGJ1ZmZlciBhbmQgcGFzcyBkYXRhIHRvIGEgY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBkZWNvZGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBjb21wbGV0ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVycm9yLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlQXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlQXJyYXlCdWZmZXIoYXJyYXlidWZmZXIsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMub2ZmbGluZUFjKSB7XG4gICAgICAgIHRoaXMub2ZmbGluZUFjID0gdGhpcy5nZXRPZmZsaW5lQXVkaW9Db250ZXh0KHRoaXMuYWMgJiYgdGhpcy5hYy5zYW1wbGVSYXRlID8gdGhpcy5hYy5zYW1wbGVSYXRlIDogNDQxMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3dlYmtpdEF1ZGlvQ29udGV4dCcgaW4gd2luZG93KSB7XG4gICAgICAgIC8vIFNhZmFyaTogbm8gc3VwcG9ydCBmb3IgUHJvbWlzZS1iYXNlZCBkZWNvZGVBdWRpb0RhdGEgZW5hYmxlZFxuICAgICAgICAvLyBFbmFibGUgaXQgaW4gU2FmYXJpIHVzaW5nIHRoZSBFeHBlcmltZW50YWwgRmVhdHVyZXMgPiBNb2Rlcm4gV2ViQXVkaW8gQVBJIG9wdGlvblxuICAgICAgICB0aGlzLm9mZmxpbmVBYy5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9LCBlcnJiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2ZmbGluZUFjLmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJldHVybiBlcnJiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcHJlLWRlY29kZWQgcGVha3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gcGVha3MgUGVha3MgZGF0YVxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gZHVyYXRpb24gRXhwbGljaXQgZHVyYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBlYWtzKHBlYWtzLCBkdXJhdGlvbikge1xuICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5leHBsaWNpdER1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVha3MgPSBwZWFrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZW5kZXJlZCBsZW5ndGggKGRpZmZlcmVudCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGF1ZGlvKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcmVuZGVyZWQgbGVuZ3RoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgICAgLy8gTm8gcmVzaXplLCB3ZSBjYW4gcHJlc2VydmUgdGhlIGNhY2hlZCBwZWFrcy5cbiAgICAgIGlmICh0aGlzLm1lcmdlZFBlYWtzICYmIGxlbmd0aCA9PSAyICogdGhpcy5tZXJnZWRQZWFrcy5sZW5ndGggLSAxICsgMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3BsaXRQZWFrcyA9IFtdO1xuICAgICAgdGhpcy5tZXJnZWRQZWFrcyA9IFtdOyAvLyBTZXQgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgc3BhcnNlIGFycmF5IHNvIHRoZSBwZWFrIGFycmF5cyBhcmVcbiAgICAgIC8vIGFwcHJvcHJpYXRlbHkgc2l6ZWQgZm9yIG90aGVyIGNhbGN1bGF0aW9ucy5cblxuICAgICAgdmFyIGNoYW5uZWxzID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzIDogMTtcbiAgICAgIHZhciBjO1xuXG4gICAgICBmb3IgKGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuICAgICAgICB0aGlzLnNwbGl0UGVha3NbY10gPSBbXTtcbiAgICAgICAgdGhpcy5zcGxpdFBlYWtzW2NdWzIgKiAobGVuZ3RoIC0gMSldID0gMDtcbiAgICAgICAgdGhpcy5zcGxpdFBlYWtzW2NdWzIgKiAobGVuZ3RoIC0gMSkgKyAxXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVyZ2VkUGVha3NbMiAqIChsZW5ndGggLSAxKV0gPSAwO1xuICAgICAgdGhpcy5tZXJnZWRQZWFrc1syICogKGxlbmd0aCAtIDEpICsgMV0gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXggYW5kIG1pbiB2YWx1ZSBvZiB0aGUgd2F2ZWZvcm0gd2hlbiBicm9rZW4gaW50byA8bGVuZ3RoPiBzdWJyYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIEhvdyBtYW55IHN1YnJhbmdlcyB0byBicmVhayB0aGUgd2F2ZWZvcm0gaW50by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlyc3QgRmlyc3Qgc2FtcGxlIGluIHRoZSByZXF1aXJlZCByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdCBMYXN0IHNhbXBsZSBpbiB0aGUgcmVxdWlyZWQgcmFuZ2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyW118TnVtYmVyLjxBcnJheVtdPn0gQXJyYXkgb2YgMio8bGVuZ3RoPiBwZWFrcyBvciBhcnJheSBvZiBhcnJheXMgb2ZcbiAgICAgKiBwZWFrcyBjb25zaXN0aW5nIG9mIChtYXgsIG1pbikgdmFsdWVzIGZvciBlYWNoIHN1YnJhbmdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGVha3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGVha3MobGVuZ3RoLCBmaXJzdCwgbGFzdCkge1xuICAgICAgaWYgKHRoaXMucGVha3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVha3M7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBmaXJzdCA9IGZpcnN0IHx8IDA7XG4gICAgICBsYXN0ID0gbGFzdCB8fCBsZW5ndGggLSAxO1xuICAgICAgdGhpcy5zZXRMZW5ndGgobGVuZ3RoKTtcblxuICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVscyA/IHRoaXMuc3BsaXRQZWFrcyA6IHRoaXMubWVyZ2VkUGVha3M7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmb2xsb3dpbmcgc25pcHBldCBmaXhlcyBhIGJ1ZmZlcmluZyBkYXRhIGlzc3VlIG9uIHRoZSBTYWZhcmlcbiAgICAgICAqIGJyb3dzZXIgd2hpY2ggcmV0dXJuZWQgdW5kZWZpbmVkIEl0IGNyZWF0ZXMgdGhlIG1pc3NpbmcgYnVmZmVyIGJhc2VkXG4gICAgICAgKiBvbiAxIGNoYW5uZWwsIDQwOTYgc2FtcGxlcyBhbmQgdGhlIHNhbXBsZVJhdGUgZnJvbSB0aGUgY3VycmVudFxuICAgICAgICogd2ViYXVkaW8gY29udGV4dCA0MDk2IHNhbXBsZXMgc2VlbWVkIHRvIGJlIHRoZSBiZXN0IGZpdCBmb3IgcmVuZGVyaW5nXG4gICAgICAgKiB3aWxsIHJldmlldyB0aGlzIGNvZGUgb25jZSBhIHN0YWJsZSB2ZXJzaW9uIG9mIFNhZmFyaSBUUCBpcyBvdXRcbiAgICAgICAqL1xuXG5cbiAgICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcigxLCA0MDk2LCB0aGlzLnNhbXBsZVJhdGUpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld0J1ZmZlci5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1wbGVTaXplID0gdGhpcy5idWZmZXIubGVuZ3RoIC8gbGVuZ3RoO1xuICAgICAgdmFyIHNhbXBsZVN0ZXAgPSB+fihzYW1wbGVTaXplIC8gMTApIHx8IDE7XG4gICAgICB2YXIgY2hhbm5lbHMgPSB0aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgdmFyIGM7XG5cbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjaGFubmVsczsgYysrKSB7XG4gICAgICAgIHZhciBwZWFrcyA9IHRoaXMuc3BsaXRQZWFrc1tjXTtcbiAgICAgICAgdmFyIGNoYW4gPSB0aGlzLmJ1ZmZlci5nZXRDaGFubmVsRGF0YShjKTtcbiAgICAgICAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gfn4oaSAqIHNhbXBsZVNpemUpO1xuICAgICAgICAgIHZhciBlbmQgPSB+fihzdGFydCArIHNhbXBsZVNpemUpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEluaXRpYWxpemUgdGhlIG1heCBhbmQgbWluIHRvIHRoZSBmaXJzdCBzYW1wbGUgb2YgdGhpc1xuICAgICAgICAgICAqIHN1YnJhbmdlLCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHNhbXBsZXMgYXJlIGVudGlyZWx5XG4gICAgICAgICAgICogb24gb25lIHNpZGUgb2YgemVybywgd2Ugc3RpbGwgcmV0dXJuIHRoZSB0cnVlIG1heCBhbmRcbiAgICAgICAgICAgKiBtaW4gdmFsdWVzIGluIHRoZSBzdWJyYW5nZS5cbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIHZhciBtaW4gPSBjaGFuW3N0YXJ0XTtcbiAgICAgICAgICB2YXIgbWF4ID0gbWluO1xuICAgICAgICAgIHZhciBqID0gdm9pZCAwO1xuXG4gICAgICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCBlbmQ7IGogKz0gc2FtcGxlU3RlcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbltqXTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVha3NbMiAqIGldID0gbWF4O1xuICAgICAgICAgIHBlYWtzWzIgKiBpICsgMV0gPSBtaW47XG5cbiAgICAgICAgICBpZiAoYyA9PSAwIHx8IG1heCA+IHRoaXMubWVyZ2VkUGVha3NbMiAqIGldKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlZFBlYWtzWzIgKiBpXSA9IG1heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PSAwIHx8IG1pbiA8IHRoaXMubWVyZ2VkUGVha3NbMiAqIGkgKyAxXSkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZWRQZWFrc1syICogaSArIDFdID0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbXMuc3BsaXRDaGFubmVscyA/IHRoaXMuc3BsaXRQZWFrcyA6IHRoaXMubWVyZ2VkUGVha3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9zaXRpb24gZnJvbSAwIHRvIDFcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gUG9zaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXllZFBlcmNlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsYXllZFBlcmNlbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0UGxheWVkUGVyY2VudHMuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjb25uZWN0U291cmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3RTb3VyY2UoKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCByZWZlcmVuY2VzIHdpdGggV2ViQXVkaW8sIGRpc2Nvbm5lY3RpbmcgYXVkaW8gbm9kZXMgYW5kIGNsb3NpbmcgQXVkaW8gQ29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVdlYkF1ZGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lXZWJBdWRpbygpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdEZpbHRlcnMoKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuICAgICAgdGhpcy5nYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnNjcmlwdE5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCk7IC8vIGNsb3NlIHRoZSBhdWRpb0NvbnRleHQgaWYgY2xvc2VBdWRpb0NvbnRleHQgb3B0aW9uIGlzIHNldCB0byB0cnVlXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5jbG9zZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAvLyBjaGVjayBpZiBicm93c2VyIHN1cHBvcnRzIEF1ZGlvQ29udGV4dC5jbG9zZSgpXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hYy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmFjLnN0YXRlICE9ICdjbG9zZWQnKSB7XG4gICAgICAgICAgdGhpcy5hYy5jbG9zZSgpO1xuICAgICAgICB9IC8vIGNsZWFyIHRoZSByZWZlcmVuY2UgdG8gdGhlIGF1ZGlvY29udGV4dFxuXG5cbiAgICAgICAgdGhpcy5hYyA9IG51bGw7IC8vIGNsZWFyIHRoZSBhY3R1YWwgYXVkaW9jb250ZXh0LCBlaXRoZXIgcGFzc2VkIGFzIHBhcmFtIG9yIHRoZVxuICAgICAgICAvLyBnbG9iYWwgc2luZ2xldG9uXG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICB3aW5kb3cuV2F2ZVN1cmZlckF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJhbXMuYXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgfSAvLyBjbGVhciB0aGUgb2ZmbGluZUF1ZGlvQ29udGV4dFxuXG5cbiAgICAgICAgd2luZG93LldhdmVTdXJmZXJPZmZsaW5lQXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB3YXZlc3VyZmVyIGlzIGRlc3Ryb3llZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVuQWxsKCk7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLmRlc3Ryb3lXZWJBdWRpbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkZWQgYSBkZWNvZGVkIGF1ZGlvIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJ1ZmZlciBEZWNvZGVkIGF1ZGlvIGJ1ZmZlciB0byBsb2FkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoYnVmZmVyKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy5sYXN0UGxheSA9IHRoaXMuYWMuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKCk7XG4gICAgfVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU291cmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZSgpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLmFjLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpOyAvLyBhZGp1c3QgZm9yIG9sZCBicm93c2Vyc1xuXG4gICAgICB0aGlzLnNvdXJjZS5zdGFydCA9IHRoaXMuc291cmNlLnN0YXJ0IHx8IHRoaXMuc291cmNlLm5vdGVHcmFpbk9uO1xuICAgICAgdGhpcy5zb3VyY2Uuc3RvcCA9IHRoaXMuc291cmNlLnN0b3AgfHwgdGhpcy5zb3VyY2Uubm90ZU9mZjtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKTtcbiAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIHNvbWUgYnJvd3NlcnMgcmVxdWlyZSBhbiBleHBsaWNpdCBjYWxsIHRvICNyZXN1bWUgYmVmb3JlIHRoZXkgd2lsbCBwbGF5IGJhY2sgYXVkaW9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc3VtZUF1ZGlvQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWVBdWRpb0NvbnRleHQoKSB7XG4gICAgICBpZiAodGhpcy5hYy5zdGF0ZSA9PSAnc3VzcGVuZGVkJykge1xuICAgICAgICB0aGlzLmFjLnJlc3VtZSAmJiB0aGlzLmFjLnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB3YXZlc3VyZmVyLmlzUGxheWluZygpYCBhbmQgYHdhdmVzdXJmZXIucGxheVBhdXNlKClgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGlzIGJhY2tlbmQgaXMgY3VycmVudGx5IHBhdXNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQYXVzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXNbUExBWUlOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHdhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKWBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb24gb2YgbG9hZGVkIGJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5leHBsaWNpdER1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgd2F2ZXN1cmZlci5zZWVrVG8oKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBQb3NpdGlvbiB0byBzdGFydCBhdCBpbiBzZWNvbmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBQb3NpdGlvbiB0byBlbmQgYXQgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IE9iamVjdCBjb250YWluaW5nIHN0YXJ0IGFuZCBlbmRcbiAgICAgKiBwb3NpdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlZWtUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVrVG8oc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NoZWR1bGVkUGF1c2UgPSBudWxsO1xuXG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IHRoaXMuZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgICAgICBpZiAoc3RhcnQgPj0gdGhpcy5nZXREdXJhdGlvbigpKSB7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSB0aGlzLmdldER1cmF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0O1xuICAgICAgdGhpcy5sYXN0UGxheSA9IHRoaXMuYWMuY3VycmVudFRpbWU7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlc1tGSU5JU0hFRF0pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShQQVVTRUQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYXliYWNrIHBvc2l0aW9uIGluIHNlY29uZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBsYXliYWNrIHBvc2l0aW9uIGluIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYXllZFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWVkVGltZSgpIHtcbiAgICAgIHJldHVybiAodGhpcy5hYy5jdXJyZW50VGltZSAtIHRoaXMubGFzdFBsYXkpICogdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBsb2FkZWQgYXVkaW8gcmVnaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldCBpbiBzZWNvbmRzLCByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nXG4gICAgICogb2YgYSBjbGlwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgV2hlbiB0byBzdG9wIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSBjbGlwLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBuZWVkIHRvIHJlLWNyZWF0ZSBzb3VyY2Ugb24gZWFjaCBwbGF5YmFja1xuXG5cbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKCk7XG4gICAgICB2YXIgYWRqdXN0ZWRUaW1lID0gdGhpcy5zZWVrVG8oc3RhcnQsIGVuZCk7XG4gICAgICBzdGFydCA9IGFkanVzdGVkVGltZS5zdGFydDtcbiAgICAgIGVuZCA9IGFkanVzdGVkVGltZS5lbmQ7XG4gICAgICB0aGlzLnNjaGVkdWxlZFBhdXNlID0gZW5kO1xuICAgICAgdGhpcy5zb3VyY2Uuc3RhcnQoMCwgc3RhcnQpO1xuICAgICAgdGhpcy5yZXN1bWVBdWRpb0NvbnRleHQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoUExBWUlORyk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgncGxheScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIGxvYWRlZCBhdWRpby5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgdGhpcy5zY2hlZHVsZWRQYXVzZSA9IG51bGw7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gKz0gdGhpcy5nZXRQbGF5ZWRUaW1lKCk7XG4gICAgICB0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5zdG9wKDApO1xuICAgICAgdGhpcy5zZXRTdGF0ZShQQVVTRUQpO1xuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BhdXNlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzIHJlbGF0aXZlIHRvIHRoZSBhdWRpby1jbGlwJ3NcbiAgICAgKiBkdXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50VGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmdldEN1cnJlbnRUaW1lLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gKDA9bm8gcGxheWJhY2ssIDE9bm9ybWFsIHBsYXliYWNrKVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBwbGF5YmFjayByYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWJhY2tSYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF1ZGlvIHNvdXJjZSBwbGF5YmFjayByYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBwbGF5YmFjayByYXRlIHRvIHVzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGxheWJhY2tSYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYXliYWNrUmF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZSB8fCAxO1xuICAgICAgdGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgcG9pbnQgaW4gc2Vjb25kcyBmb3IgcGxheWJhY2sgdG8gc3RvcCBhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgUG9zaXRpb24gdG8gZW5kIGF0XG4gICAgICogQHZlcnNpb24gMy4zLjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBsYXlFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheUVuZChlbmQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVkUGF1c2UgPSBlbmQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYkF1ZGlvO1xufSh1dGlsLk9ic2VydmVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViQXVkaW87XG5XZWJBdWRpby5zY3JpcHRCdWZmZXJTaXplID0gMjU2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gKiBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gKiBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAqIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuIFRoZSBmdW5jdGlvbiBhbHNvIGhhcyBhIHByb3BlcnR5ICdjbGVhcicgXG4gKiB0aGF0IGlzIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBjbGVhciB0aGUgdGltZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IHNjaGVkdWxlZCBleGVjdXRpb25zLiBcbiAqXG4gKiBAc291cmNlIHVuZGVyc2NvcmUuanNcbiAqIEBzZWUgaHR0cDovL3Vuc2NyaXB0YWJsZS5jb20vMjAwOS8wMy8yMC9kZWJvdW5jaW5nLWphdmFzY3JpcHQtbWV0aG9kcy9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IGluIG1zIChgMTAwYClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgKGBmYWxzZWApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpe1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIGlmIChudWxsID09IHdhaXQpIHdhaXQgPSAxMDA7XG5cbiAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWJvdW5jZWQgPSBmdW5jdGlvbigpe1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIFxuICBkZWJvdW5jZWQuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuXG4vLyBBZGRzIGNvbXBhdGliaWxpdHkgZm9yIEVTIG1vZHVsZXNcbmRlYm91bmNlLmRlYm91bmNlID0gZGVib3VuY2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3dhdmVzdXJmZXIuanNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F2ZXN1cmZlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3dhdmVzdXJmZXIuanMiLCIvKiFcbiAqIHdhdmVzdXJmZXIuanMgY3Vyc29yIHBsdWdpbiA1LjEuMCAoMjAyMS0wNi0yMClcbiAqIGh0dHBzOi8vd2F2ZXN1cmZlci1qcy5vcmdcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIldhdmVTdXJmZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiV2F2ZVN1cmZlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJXYXZlU3VyZmVyXCJdID0gcm9vdFtcIldhdmVTdXJmZXJcIl0gfHwge30sIHJvb3RbXCJXYXZlU3VyZmVyXCJdW1wiY3Vyc29yXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9jdXJzb3IvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vY3Vyc29yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ3Vyc29yUGx1Z2luUGFyYW1zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZWZlckluaXQgU2V0IHRvIHRydWUgdG8gc3RvcCBhdXRvIGluaXQgaW4gYGFkZFBsdWdpbigpYFxuICogQHByb3BlcnR5IHtib29sZWFufSBoaWRlT25CbHVyPXRydWUgSGlkZSB0aGUgY3Vyc29yIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGVcbiAqIHdhdmVmb3JtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gd2lkdGg9JzFweCcgVGhlIHdpZHRoIG9mIHRoZSBjdXJzb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvcj0nYmxhY2snIFRoZSBjb2xvciBvZiB0aGUgY3Vyc29yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3BhY2l0eT0nMC4yNScgVGhlIG9wYWNpdHkgb2YgdGhlIGN1cnNvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0eWxlPSdzb2xpZCcgVGhlIGJvcmRlciBzdHlsZSBvZiB0aGUgY3Vyc29yXG4gKiBAcHJvcGVydHkge251bWJlcn0gekluZGV4PTMgVGhlIHotaW5kZXggb2YgdGhlIGN1cnNvciBlbGVtZW50XG4gKiBAcHJvcGVydHkge29iamVjdH0gY3VzdG9tU3R5bGUgQW4gb2JqZWN0IHdpdGggY3VzdG9tIHN0eWxlcyB3aGljaCBhcmUgYXBwbGllZFxuICogdG8gdGhlIGN1cnNvciBlbGVtZW50XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3dUaW1lPWZhbHNlIFNob3cgdGhlIHRpbWUgb24gdGhlIGN1cnNvci5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjdXN0b21TaG93VGltZVN0eWxlIEFuIG9iamVjdCB3aXRoIGN1c3RvbSBzdHlsZXMgd2hpY2ggYXJlXG4gKiBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgdGltZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvbGxvd0N1cnNvclk9ZmFsc2UgVXNlIGB0cnVlYCB0byBtYWtlIHRoZSB0aW1lIG9uXG4gKiB0aGUgY3Vyc29yIGZvbGxvdyB0aGUgeCBhbmQgdGhlIHktcG9zaXRpb24gb2YgdGhlIG1vdXNlLiBVc2UgYGZhbHNlYCB0byBtYWtlIHRoZVxuICogaXQgb25seSBmb2xsb3cgdGhlIHgtcG9zaXRpb24gb2YgdGhlIG1vdXNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZm9ybWF0VGltZUNhbGxiYWNrIEZvcm1hdHMgdGhlIHRpbWVzdGFtcCBvbiB0aGUgY3Vyc29yLlxuICovXG5cbi8qKlxuICogRGlzcGxheXMgYSB0aGluIGxpbmUgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3Igb24gdGhlIHdhdmVmb3JtLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtQbHVnaW5DbGFzc31cbiAqIEBleHRlbmRzIHtPYnNlcnZlcn1cbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCBDdXJzb3JQbHVnaW4gZnJvbSAnd2F2ZXN1cmZlci5jdXJzb3IuanMnO1xuICpcbiAqIC8vIGNvbW1vbmpzXG4gKiB2YXIgQ3Vyc29yUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5jdXJzb3IuanMnKTtcbiAqXG4gKiAvLyBpZiB5b3UgYXJlIHVzaW5nIDxzY3JpcHQ+IHRhZ3NcbiAqIHZhciBDdXJzb3JQbHVnaW4gPSB3aW5kb3cuV2F2ZVN1cmZlci5jdXJzb3I7XG4gKlxuICogLy8gLi4uIGluaXRpYWxpc2luZyB3YXZlc3VyZmVyIHdpdGggdGhlIHBsdWdpblxuICogdmFyIHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZSh7XG4gKiAgIC8vIHdhdmVzdXJmZXIgb3B0aW9ucyAuLi5cbiAqICAgcGx1Z2luczogW1xuICogICAgIEN1cnNvclBsdWdpbi5jcmVhdGUoe1xuICogICAgICAgLy8gcGx1Z2luIG9wdGlvbnMgLi4uXG4gKiAgICAgfSlcbiAqICAgXVxuICogfSk7XG4gKi9cbnZhciBDdXJzb3JQbHVnaW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBwbHVnaW4gY2xhc3MuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSBgQ3Vyc29yUGx1Z2luLmNyZWF0ZWBcbiAgICogaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtDdXJzb3JQbHVnaW5QYXJhbXN9IHBhcmFtcyBQbHVnaW4gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gd3MgV2F2ZXN1cmZlciBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gQ3Vyc29yUGx1Z2luKHBhcmFtcywgd3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnNvclBsdWdpbik7XG5cbiAgICB0aGlzLmRlZmF1bHRQYXJhbXMgPSB7XG4gICAgICBoaWRlT25CbHVyOiB0cnVlLFxuICAgICAgd2lkdGg6ICcxcHgnLFxuICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICBvcGFjaXR5OiAnMC4yNScsXG4gICAgICBzdHlsZTogJ3NvbGlkJyxcbiAgICAgIHpJbmRleDogNCxcbiAgICAgIGN1c3RvbVN0eWxlOiB7fSxcbiAgICAgIGN1c3RvbVNob3dUaW1lU3R5bGU6IHt9LFxuICAgICAgc2hvd1RpbWU6IGZhbHNlLFxuICAgICAgZm9sbG93Q3Vyc29yWTogZmFsc2UsXG4gICAgICBmb3JtYXRUaW1lQ2FsbGJhY2s6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5fb25Nb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGJib3ggPSBfdGhpcy53YXZlc3VyZmVyLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIHggPSBlLmNsaWVudFggLSBiYm94LmxlZnQ7XG5cbiAgICAgIHZhciBmbGlwID0gYmJveC5yaWdodCA8IGUuY2xpZW50WCArIF90aGlzLm91dGVyV2lkdGgoX3RoaXMuZGlzcGxheVRpbWUpO1xuXG4gICAgICBpZiAoX3RoaXMucGFyYW1zLnNob3dUaW1lICYmIF90aGlzLnBhcmFtcy5mb2xsb3dDdXJzb3JZKSB7XG4gICAgICAgIC8vIGZvbGxvdyB5LXBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICAgICB5ID0gZS5jbGllbnRZIC0gKGJib3gudG9wICsgYmJveC5oZWlnaHQgLyAyKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudXBkYXRlQ3Vyc29yUG9zaXRpb24oeCwgeSwgZmxpcCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zaG93Q3Vyc29yKCk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTW91c2VsZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5oaWRlQ3Vyc29yKCk7XG4gICAgfTtcblxuICAgIHRoaXMud2F2ZXN1cmZlciA9IHdzO1xuICAgIHRoaXMuc3R5bGUgPSB3cy51dGlsLnN0eWxlO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJzb3IgSFRNTCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAdHlwZSB7P0hUTUxFbGVtZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSB0aW1lIG5leHQgdG8gdGhlIGN1cnNvclxuICAgICAqXG4gICAgICogQHR5cGUgez9IVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMuc2hvd1RpbWUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBodG1sIGNvbnRhaW5lciB0aGF0IHdpbGwgZGlzcGxheSB0aGUgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUgez9IVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICAgIHRoaXMuZGlzcGxheVRpbWUgPSBudWxsO1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0UGFyYW1zLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBwbHVnaW4gKHVzZWQgYnkgdGhlIFBsdWdpbiBBUEkpXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnNvclBsdWdpbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy53cmFwcGVyID0gdGhpcy53YXZlc3VyZmVyLmNvbnRhaW5lcjtcbiAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3R5bGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3Vyc29yJyksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiB0aGlzLnBhcmFtcy56SW5kZXgsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICB3aWR0aDogJzAnLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRoaXMucGFyYW1zLnN0eWxlLFxuICAgICAgICBib3JkZXJSaWdodFdpZHRoOiB0aGlzLnBhcmFtcy53aWR0aCxcbiAgICAgICAgYm9yZGVyUmlnaHRDb2xvcjogdGhpcy5wYXJhbXMuY29sb3IsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMucGFyYW1zLm9wYWNpdHksXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSwgdGhpcy5wYXJhbXMuY3VzdG9tU3R5bGUpKSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5zaG93VGltZSkge1xuICAgICAgICB0aGlzLnNob3dUaW1lID0gdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3R5bGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2hvd1RpdGxlJyksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHpJbmRleDogdGhpcy5wYXJhbXMuekluZGV4LFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLnBhcmFtcy5vcGFjaXR5LFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICB9LCB0aGlzLnBhcmFtcy5jdXN0b21TdHlsZSkpKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VGltZSA9IHRoaXMuc2hvd1RpbWUuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgZGlzcGxheTogJ2lubGluZScsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nIC8vIGluaXRpYWwgdmFsdWUgd2lsbCBiZSBoaWRkZW4ganVzdCBmb3IgbWVhc3VyaW5nIHB1cnBvc2VcblxuICAgICAgICB9LCB0aGlzLnBhcmFtcy5jdXN0b21TaG93VGltZVN0eWxlKSkpOyAvLyBpbml0aWFsIHZhbHVlIHRvIG1lYXN1cmUgZGlzcGxheSB3aWR0aFxuXG4gICAgICAgIHRoaXMuZGlzcGxheVRpbWUuaW5uZXJIVE1MID0gdGhpcy5mb3JtYXRUaW1lKDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZW1vdmUpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaGlkZU9uQmx1cikge1xuICAgICAgICAvLyBlbnN1cmUgZWxlbWVudHMgYXJlIGhpZGRlbiBpbml0aWFsbHlcbiAgICAgICAgdGhpcy5oaWRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fb25Nb3VzZWVudGVyKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbk1vdXNlbGVhdmUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBwbHVnaW4gKHVzZWQgYnkgdGhlIFBsdWdpbiBBUEkpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMuc2hvd1RpbWUpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNob3dUaW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJzb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmN1cnNvcik7XG4gICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZW1vdmUpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuaGlkZU9uQmx1cikge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX29uTW91c2VlbnRlcik7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fb25Nb3VzZWxlYXZlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4cG9zIFRoZSB4IG9mZnNldCBvZiB0aGUgY3Vyc29yIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5cG9zIFRoZSB5IG9mZnNldCBvZiB0aGUgY3Vyc29yIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxpcCBGbGFnIHRvIGZsaXAgZHVyYXRpb24gdGV4dCBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUN1cnNvclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUN1cnNvclBvc2l0aW9uKHhwb3MsIHlwb3MpIHtcbiAgICAgIHZhciBmbGlwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5jdXJzb3IsIHtcbiAgICAgICAgbGVmdDogXCJcIi5jb25jYXQoeHBvcywgXCJweFwiKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5zaG93VGltZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIud2lkdGggLyB0aGlzLndhdmVzdXJmZXIucGFyYW1zLnBpeGVsUmF0aW87XG4gICAgICAgIHZhciBzY3JvbGxXaWR0aCA9IHRoaXMud2F2ZXN1cmZlci5kcmF3ZXIuZ2V0U2Nyb2xsWCgpO1xuICAgICAgICB2YXIgc2Nyb2xsVGltZSA9IGR1cmF0aW9uIC8gdGhpcy53YXZlc3VyZmVyLmRyYXdlci53aWR0aCAqIHNjcm9sbFdpZHRoO1xuICAgICAgICB2YXIgdGltZVZhbHVlID0gTWF0aC5tYXgoMCwgeHBvcyAvIGVsZW1lbnRXaWR0aCAqIGR1cmF0aW9uKSArIHNjcm9sbFRpbWU7XG4gICAgICAgIHZhciBmb3JtYXRWYWx1ZSA9IHRoaXMuZm9ybWF0VGltZSh0aW1lVmFsdWUpO1xuXG4gICAgICAgIGlmIChmbGlwKSB7XG4gICAgICAgICAgdmFyIHRleHRPZmZzZXQgPSB0aGlzLm91dGVyV2lkdGgodGhpcy5kaXNwbGF5VGltZSk7XG4gICAgICAgICAgeHBvcyAtPSB0ZXh0T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLnNob3dUaW1lLCB7XG4gICAgICAgICAgbGVmdDogXCJcIi5jb25jYXQoeHBvcywgXCJweFwiKSxcbiAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KHlwb3MsIFwicHhcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy5kaXNwbGF5VGltZSwge1xuICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VGltZS5pbm5lckhUTUwgPSBcIlwiLmNvbmNhdChmb3JtYXRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGN1cnNvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd0N1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93Q3Vyc29yKCkge1xuICAgICAgdGhpcy5zdHlsZSh0aGlzLmN1cnNvciwge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuc2hvd1RpbWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZSh0aGlzLnNob3dUaW1lLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBjdXJzb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhpZGVDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUN1cnNvcigpIHtcbiAgICAgIHRoaXMuc3R5bGUodGhpcy5jdXJzb3IsIHtcbiAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLnNob3dUaW1lKSB7XG4gICAgICAgIHRoaXMuc3R5bGUodGhpcy5zaG93VGltZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRoZSB0aW1lc3RhbXAgZm9yIGBjdXJzb3JUaW1lYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJzb3JUaW1lIFRpbWUgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGltZShjdXJzb3JUaW1lKSB7XG4gICAgICBjdXJzb3JUaW1lID0gaXNOYU4oY3Vyc29yVGltZSkgPyAwIDogY3Vyc29yVGltZTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1zLmZvcm1hdFRpbWVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZm9ybWF0VGltZUNhbGxiYWNrKGN1cnNvclRpbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2N1cnNvclRpbWVdLm1hcChmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gW01hdGguZmxvb3IodGltZSAlIDM2MDAgLyA2MCksIC8vIG1pbnV0ZXNcbiAgICAgICAgKCcwMCcgKyBNYXRoLmZsb29yKHRpbWUgJSA2MCkpLnNsaWNlKC0yKSwgLy8gc2Vjb25kc1xuICAgICAgICAoJzAwMCcgKyBNYXRoLmZsb29yKHRpbWUgJSAxICogMTAwMCkpLnNsaWNlKC0zKSAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgXS5qb2luKCc6Jyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG91dGVyIHdpZHRoIG9mIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCBET00gRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG91dGVyIHdpZHRoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvdXRlcldpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQgKyBzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHBsdWdpbiBkZWZpbml0aW9uIGZhY3RvcnlcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGNyZWF0ZSBhIHBsdWdpbiBkZWZpbml0aW9uIHdoaWNoIGNhbiBiZVxuICAgICAqIHVzZWQgYnkgd2F2ZXN1cmZlciB0byBjb3JyZWN0bHkgaW5zdGFudGlhdGUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0N1cnNvclBsdWdpblBhcmFtc30gcGFyYW1zIHBhcmFtZXRlcnMgdXNlIHRvIGluaXRpYWxpc2UgdGhlXG4gICAgICogcGx1Z2luXG4gICAgICogQHJldHVybiB7UGx1Z2luRGVmaW5pdGlvbn0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGx1Z2luXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHBhcmFtcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ2N1cnNvcicsXG4gICAgICAgIGRlZmVySW5pdDogcGFyYW1zICYmIHBhcmFtcy5kZWZlckluaXQgPyBwYXJhbXMuZGVmZXJJbml0IDogZmFsc2UsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBzdGF0aWNQcm9wczoge30sXG4gICAgICAgIGluc3RhbmNlOiBDdXJzb3JQbHVnaW5cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDdXJzb3JQbHVnaW5QYXJhbXN9XG4gICAgICovXG5cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJzb3JQbHVnaW47XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEN1cnNvclBsdWdpbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvcGx1Z2luL2N1cnNvci9pbmRleC5qc1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXZlc3VyZmVyLmN1cnNvci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsdWdpbi93YXZlc3VyZmVyLmN1cnNvci5qcyIsIi8qIVxuICogd2F2ZXN1cmZlci5qcyByZWdpb25zIHBsdWdpbiA1LjEuMCAoMjAyMS0wNi0yMClcbiAqIGh0dHBzOi8vd2F2ZXN1cmZlci1qcy5vcmdcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIldhdmVTdXJmZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiV2F2ZVN1cmZlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJXYXZlU3VyZmVyXCJdID0gcm9vdFtcIldhdmVTdXJmZXJcIl0gfHwge30sIHJvb3RbXCJXYXZlU3VyZmVyXCJdW1wicmVnaW9uc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL3NyYy9wbHVnaW4vcmVnaW9ucy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vcmVnaW9ucy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWdpb24uanMgKi8gXCIuL3NyYy9wbHVnaW4vcmVnaW9ucy9yZWdpb24uanNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIFJlZ2lvbnMgYXJlIHZpc3VhbCBvdmVybGF5cyBvbiB3YXZlZm9ybSB0aGF0IGNhbiBiZSB1c2VkIHRvIHBsYXkgYW5kIGxvb3BcbiAqIHBvcnRpb25zIG9mIGF1ZGlvLiBSZWdpb25zIGNhbiBiZSBkcmFnZ2VkIGFuZCByZXNpemVkLlxuICpcbiAqIFZpc3VhbCBjdXN0b21pemF0aW9uIGlzIHBvc3NpYmxlIHZpYSBDU1MgKHVzaW5nIHRoZSBzZWxlY3RvcnNcbiAqIGAud2F2ZXN1cmZlci1yZWdpb25gIGFuZCBgLndhdmVzdXJmZXItaGFuZGxlYCkuXG4gKlxuICogQGltcGxlbWVudHMge1BsdWdpbkNsYXNzfVxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlczZcbiAqIGltcG9ydCBSZWdpb25zUGx1Z2luIGZyb20gJ3dhdmVzdXJmZXIucmVnaW9ucy5qcyc7XG4gKlxuICogLy8gY29tbW9uanNcbiAqIHZhciBSZWdpb25zUGx1Z2luID0gcmVxdWlyZSgnd2F2ZXN1cmZlci5yZWdpb25zLmpzJyk7XG4gKlxuICogLy8gaWYgeW91IGFyZSB1c2luZyA8c2NyaXB0PiB0YWdzXG4gKiB2YXIgUmVnaW9uc1BsdWdpbiA9IHdpbmRvdy5XYXZlU3VyZmVyLnJlZ2lvbnM7XG4gKlxuICogLy8gLi4uIGluaXRpYWxpc2luZyB3YXZlc3VyZmVyIHdpdGggdGhlIHBsdWdpblxuICogdmFyIHdhdmVzdXJmZXIgPSBXYXZlU3VyZmVyLmNyZWF0ZSh7XG4gKiAgIC8vIHdhdmVzdXJmZXIgb3B0aW9ucyAuLi5cbiAqICAgcGx1Z2luczogW1xuICogICAgIFJlZ2lvbnNQbHVnaW4uY3JlYXRlKHtcbiAqICAgICAgIC8vIHBsdWdpbiBvcHRpb25zIC4uLlxuICogICAgIH0pXG4gKiAgIF1cbiAqIH0pO1xuICovXG52YXIgUmVnaW9uc1BsdWdpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlZ2lvbnNQbHVnaW4ocGFyYW1zLCB3cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVnaW9uc1BsdWdpbik7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLndhdmVzdXJmZXIgPSB3cztcbiAgICB0aGlzLnV0aWwgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHdzLnV0aWwpLCB7fSwge1xuICAgICAgZ2V0UmVnaW9uU25hcFRvR3JpZFZhbHVlOiBmdW5jdGlvbiBnZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZSh2YWx1ZSwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm1heFJlZ2lvbnMgPSBwYXJhbXMubWF4UmVnaW9ucztcbiAgICB0aGlzLnJlZ2lvbnNNaW5MZW5ndGggPSBwYXJhbXMucmVnaW9uc01pbkxlbmd0aCB8fCBudWxsOyAvLyB0dXJuIHRoZSBwbHVnaW4gaW5zdGFuY2UgaW50byBhbiBvYnNlcnZlclxuXG4gICAgdmFyIG9ic2VydmVyUHJvdG90eXBlS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMudXRpbC5PYnNlcnZlci5wcm90b3R5cGUpO1xuICAgIG9ic2VydmVyUHJvdG90eXBlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9yZWdpb24uUmVnaW9uLnByb3RvdHlwZVtrZXldID0gX3RoaXMudXRpbC5PYnNlcnZlci5wcm90b3R5cGVba2V5XTtcbiAgICB9KTtcbiAgICB0aGlzLndhdmVzdXJmZXIuUmVnaW9uID0gX3JlZ2lvbi5SZWdpb247IC8vIEJ5IGRlZmF1bHQsIHNjcm9sbCB0aGUgY29udGFpbmVyIGlmIHRoZSB1c2VyIGRyYWdzIGEgcmVnaW9uXG4gICAgLy8gd2l0aGluIDUlIG9mIGl0cyBlZGdlXG5cbiAgICB2YXIgc2Nyb2xsV2lkdGhQcm9wb3J0aW9uID0gMC4wNTtcblxuICAgIHRoaXMuX29uQmFja2VuZENyZWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy53cmFwcGVyID0gX3RoaXMud2F2ZXN1cmZlci5kcmF3ZXIud3JhcHBlcjtcbiAgICAgIF90aGlzLm9yaWVudGF0aW9uID0gX3RoaXMud2F2ZXN1cmZlci5kcmF3ZXIub3JpZW50YXRpb247XG5cbiAgICAgIGlmIChfdGhpcy5wYXJhbXMucmVnaW9ucykge1xuICAgICAgICBfdGhpcy5wYXJhbXMucmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgICByZWdpb24uZWRnZVNjcm9sbFdpZHRoID0gX3RoaXMucGFyYW1zLmVkZ2VTY3JvbGxXaWR0aCB8fCBfdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoICogc2Nyb2xsV2lkdGhQcm9wb3J0aW9uO1xuXG4gICAgICAgICAgX3RoaXMuYWRkKHJlZ2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIElkLWJhc2VkIGhhc2ggb2YgcmVnaW9uc1xuXG5cbiAgICB0aGlzLmxpc3QgPSB7fTtcblxuICAgIHRoaXMuX29uUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy53cmFwcGVyID0gX3RoaXMud2F2ZXN1cmZlci5kcmF3ZXIud3JhcHBlcjtcbiAgICAgIF90aGlzLnZlcnRpY2FsID0gX3RoaXMud2F2ZXN1cmZlci5kcmF3ZXIucGFyYW1zLnZlcnRpY2FsO1xuXG4gICAgICBpZiAoX3RoaXMucGFyYW1zLmRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgX3RoaXMuZW5hYmxlRHJhZ1NlbGVjdGlvbihfdGhpcy5wYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyhfdGhpcy5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBfdGhpcy5saXN0W2lkXS51cGRhdGVSZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVnaW9uc1BsdWdpbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd3MgaXMgcmVhZHlcbiAgICAgIGlmICh0aGlzLndhdmVzdXJmZXIuaXNSZWFkeSkge1xuICAgICAgICB0aGlzLl9vbkJhY2tlbmRDcmVhdGVkKCk7XG5cbiAgICAgICAgdGhpcy5fb25SZWFkeSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXZlc3VyZmVyLm9uY2UoJ3JlYWR5JywgdGhpcy5fb25SZWFkeSk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci5vbmNlKCdiYWNrZW5kLWNyZWF0ZWQnLCB0aGlzLl9vbkJhY2tlbmRDcmVhdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCdyZWFkeScsIHRoaXMuX29uUmVhZHkpO1xuICAgICAgdGhpcy53YXZlc3VyZmVyLnVuKCdiYWNrZW5kLWNyZWF0ZWQnLCB0aGlzLl9vbkJhY2tlbmRDcmVhdGVkKTtcbiAgICAgIHRoaXMuZGlzYWJsZURyYWdTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2hlY2sgdG8gc2VlIGlmIGFkZGluZyBhIG5ldyByZWdpb24gd291bGQgZXhjZWVkIG1heFJlZ2lvbnNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHdlIHNob3VsZCBwcm9jZWVkIGFuZCBjcmVhdGUgYSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid291bGRFeGNlZWRNYXhSZWdpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdvdWxkRXhjZWVkTWF4UmVnaW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heFJlZ2lvbnMgJiYgT2JqZWN0LmtleXModGhpcy5saXN0KS5sZW5ndGggPj0gdGhpcy5tYXhSZWdpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSByZWdpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgUmVnaW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJuIHtSZWdpb259IFRoZSBjcmVhdGVkIHJlZ2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChwYXJhbXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy53b3VsZEV4Y2VlZE1heFJlZ2lvbnMoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMubWluTGVuZ3RoICYmIHRoaXMucmVnaW9uc01pbkxlbmd0aCkge1xuICAgICAgICBwYXJhbXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgbWluTGVuZ3RoOiB0aGlzLnJlZ2lvbnNNaW5MZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpb24gPSBuZXcgdGhpcy53YXZlc3VyZmVyLlJlZ2lvbihwYXJhbXMsIHRoaXMudXRpbCwgdGhpcy53YXZlc3VyZmVyKTtcbiAgICAgIHRoaXMubGlzdFtyZWdpb24uaWRdID0gcmVnaW9uO1xuICAgICAgcmVnaW9uLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubGlzdFtyZWdpb24uaWRdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHJlZ2lvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgX3RoaXMzLmxpc3RbaWRdLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZURyYWdTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRHJhZ1NlbGVjdGlvbihwYXJhbXMpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpc2FibGVEcmFnU2VsZWN0aW9uKCk7XG4gICAgICB2YXIgc2xvcCA9IHBhcmFtcy5zbG9wIHx8IDI7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci5jb250YWluZXI7XG4gICAgICB2YXIgc2Nyb2xsID0gcGFyYW1zLnNjcm9sbCAhPT0gZmFsc2UgJiYgdGhpcy53YXZlc3VyZmVyLnBhcmFtcy5zY3JvbGxQYXJlbnQ7XG4gICAgICB2YXIgc2Nyb2xsU3BlZWQgPSBwYXJhbXMuc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICAgIHZhciBzY3JvbGxUaHJlc2hvbGQgPSBwYXJhbXMuc2Nyb2xsVGhyZXNob2xkIHx8IDEwO1xuICAgICAgdmFyIGRyYWc7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgIHZhciBtYXhTY3JvbGw7XG4gICAgICB2YXIgc3RhcnQ7XG4gICAgICB2YXIgcmVnaW9uO1xuICAgICAgdmFyIHRvdWNoSWQ7XG4gICAgICB2YXIgcHhNb3ZlID0gMDtcbiAgICAgIHZhciBzY3JvbGxEaXJlY3Rpb247XG4gICAgICB2YXIgd3JhcHBlclJlY3Q7IC8vIFNjcm9sbCB3aGVuIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHdpdGhpbiB0aGUgdGhyZXNob2xkXG5cbiAgICAgIHZhciBlZGdlU2Nyb2xsID0gZnVuY3Rpb24gZWRnZVNjcm9sbChlKSB7XG4gICAgICAgIGlmICghcmVnaW9uIHx8ICFzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVXBkYXRlIHNjcm9sbCBwb3NpdGlvblxuXG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBfdGhpczQud3JhcHBlci5zY3JvbGxMZWZ0ICsgc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgIF90aGlzNC53cmFwcGVyLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0ID0gTWF0aC5taW4obWF4U2Nyb2xsLCBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0KSk7IC8vIFVwZGF0ZSByYW5nZVxuXG4gICAgICAgIHZhciBlbmQgPSBfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZSk7XG5cbiAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKSxcbiAgICAgICAgICBlbmQ6IE1hdGgubWF4KGVuZCAqIGR1cmF0aW9uLCBzdGFydCAqIGR1cmF0aW9uKVxuICAgICAgICB9KTsgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyBtb3JlIHRvIHNjcm9sbCBhbmQgcmVwZWF0XG5cbiAgICAgICAgaWYgKHNjcm9sbExlZnQgPCBtYXhTY3JvbGwgJiYgc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVkZ2VTY3JvbGwoZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBldmVudERvd24gPSBmdW5jdGlvbiBldmVudERvd24oZSkge1xuICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczQud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgICB0b3VjaElkID0gZS50YXJnZXRUb3VjaGVzID8gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXIgOiBudWxsOyAvLyBTdG9yZSBmb3Igc2Nyb2xsIGNhbGN1bGF0aW9uc1xuXG4gICAgICAgIG1heFNjcm9sbCA9IF90aGlzNC53cmFwcGVyLnNjcm9sbFdpZHRoIC0gX3RoaXM0LndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICAgIHdyYXBwZXJSZWN0ID0gX3RoaXM0LnV0aWwud2l0aE9yaWVudGF0aW9uKF90aGlzNC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBfdGhpczQudmVydGljYWwpO1xuICAgICAgICBkcmFnID0gdHJ1ZTtcbiAgICAgICAgc3RhcnQgPSBfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZSwgdHJ1ZSk7XG4gICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnREb3duKTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnREb3duKTtcbiAgICAgIHRoaXMub24oJ2Rpc2FibGUtZHJhZy1zZWxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBldmVudERvd24pO1xuXG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50RG93bik7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGV2ZW50VXAgPSBmdW5jdGlvbiBldmVudFVwKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWcgPSBmYWxzZTtcbiAgICAgICAgcHhNb3ZlID0gMDtcbiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcblxuICAgICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgICAgX3RoaXM0LnV0aWwucHJldmVudENsaWNrKCk7XG5cbiAgICAgICAgICByZWdpb24uZmlyZUV2ZW50KCd1cGRhdGUtZW5kJywgZSk7XG5cbiAgICAgICAgICBfdGhpczQud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi11cGRhdGUtZW5kJywgcmVnaW9uLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lvbiA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGV2ZW50VXApO1xuICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRVcCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG4gICAgICB0aGlzLm9uKCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudFVwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50VXApO1xuXG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZXZlbnRVcCk7XG5cbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50VXApO1xuXG4gICAgICAgIF90aGlzNC53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBldmVudFVwKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZXZlbnRNb3ZlID0gZnVuY3Rpb24gZXZlbnRNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghZHJhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3B4TW92ZSA8PSBzbG9wKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMgJiYgZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyICE9IHRvdWNoSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gYXV0by1jcmVhdGUgYSByZWdpb24gZHVyaW5nIG1vdXNlIGRyYWcsIHVubGVzcyByZWdpb24tY291bnQgd291bGQgZXhjZWVkIFwibWF4UmVnaW9uc1wiXG5cblxuICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgIHJlZ2lvbiA9IF90aGlzNC5hZGQocGFyYW1zIHx8IHt9KTtcblxuICAgICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZCA9IF90aGlzNC53YXZlc3VyZmVyLmRyYXdlci5oYW5kbGVFdmVudChldmVudCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0VXBkYXRlID0gX3RoaXM0LndhdmVzdXJmZXIucmVnaW9ucy51dGlsLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZShzdGFydCAqIGR1cmF0aW9uKTtcblxuICAgICAgICB2YXIgZW5kVXBkYXRlID0gX3RoaXM0LndhdmVzdXJmZXIucmVnaW9ucy51dGlsLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZShlbmQgKiBkdXJhdGlvbik7XG5cbiAgICAgICAgcmVnaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhcnQ6IE1hdGgubWluKGVuZFVwZGF0ZSwgc3RhcnRVcGRhdGUpLFxuICAgICAgICAgIGVuZDogTWF0aC5tYXgoZW5kVXBkYXRlLCBzdGFydFVwZGF0ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG9yaWVudGVkRXZlbnQgPSBfdGhpczQudXRpbC53aXRoT3JpZW50YXRpb24oZXZlbnQsIF90aGlzNC52ZXJ0aWNhbCk7IC8vIElmIHNjcm9sbGluZyBpcyBlbmFibGVkXG5cblxuICAgICAgICBpZiAoc2Nyb2xsICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IF90aGlzNC53cmFwcGVyLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdGhyZXNob2xkIGJhc2VkIG9uIG1vdXNlXG4gICAgICAgICAgdmFyIHggPSBvcmllbnRlZEV2ZW50LmNsaWVudFggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuXG4gICAgICAgICAgaWYgKHggPD0gc2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHggPj0gd3JhcHBlclJlY3QucmlnaHQgLSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uICYmIGVkZ2VTY3JvbGwoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnRNb3ZlKTtcbiAgICAgIHRoaXMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudE1vdmUpO1xuICAgICAgdGhpcy5vbignZGlzYWJsZS1kcmFnLXNlbGVjdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnRNb3ZlKTtcblxuICAgICAgICBfdGhpczQud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBldmVudE1vdmUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndhdmVzdXJmZXIub24oJ3JlZ2lvbi1jcmVhdGVkJywgZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICBpZiAoX3RoaXM0LnJlZ2lvbnNNaW5MZW5ndGgpIHtcbiAgICAgICAgICByZWdpb24ubWluTGVuZ3RoID0gX3RoaXM0LnJlZ2lvbnNNaW5MZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlRHJhZ1NlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRHJhZ1NlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdkaXNhYmxlLWRyYWctc2VsZWN0aW9uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHJlZ2lvblxuICAgICAqXG4gICAgICogVGhlIHNtYWxsZXN0IHJlZ2lvbiB0aGF0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHRpbWUuIElmIHNldmVyYWwgc3VjaFxuICAgICAqIHJlZ2lvbnMgZXhpc3QsIHRha2UgdGhlIGZpcnN0LiBSZXR1cm4gYG51bGxgIGlmIG5vbmUgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UmVnaW9ufSBUaGUgY3VycmVudCByZWdpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRSZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudFJlZ2lvbigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgdGltZSA9IHRoaXMud2F2ZXN1cmZlci5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgdmFyIG1pbiA9IG51bGw7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3QpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBjdXIgPSBfdGhpczUubGlzdFtpZF07XG5cbiAgICAgICAgaWYgKGN1ci5zdGFydCA8PSB0aW1lICYmIGN1ci5lbmQgPj0gdGltZSkge1xuICAgICAgICAgIGlmICghbWluIHx8IGN1ci5lbmQgLSBjdXIuc3RhcnQgPCBtaW4uZW5kIC0gbWluLnN0YXJ0KSB7XG4gICAgICAgICAgICBtaW4gPSBjdXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIHRoZSB2YWx1ZSB0byB0aGUgZ3JpZCwgaWYgcmVxdWlyZWRcbiAgICAgKlxuICAgICAqIElmIHRoZSByZWdpb25zIHBsdWdpbiBwYXJhbXMgaGF2ZSBhIHNuYXBUb0dyaWRJbnRlcnZhbCBzZXQsIHJldHVybiB0aGVcbiAgICAgKiB2YWx1ZSBtYXRjaGluZyB0aGUgbmVhcmVzdCBncmlkIGludGVydmFsLiBJZiBubyBzbmFwVG9HcmlkSW50ZXJ2YWwgaXMgc2V0LFxuICAgICAqIHRoZSBwYXNzZWQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gc25hcCB0byB0aGUgZ3JpZCwgaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyB0aGUgcmVnaW9ucyBwbHVnaW4gcGFyYW1zXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUodmFsdWUsIHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5zbmFwVG9HcmlkSW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gdGhlIHJlZ2lvbnMgc2hvdWxkIHNuYXAgdG8gYSBncmlkXG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJhbXMuc25hcFRvR3JpZE9mZnNldCB8fCAwO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgLSBvZmZzZXQpIC8gcGFyYW1zLnNuYXBUb0dyaWRJbnRlcnZhbCkgKiBwYXJhbXMuc25hcFRvR3JpZEludGVydmFsICsgb2Zmc2V0O1xuICAgICAgfSAvLyBubyBzbmFwLXRvLWdyaWRcblxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmVnaW9ucyBwbHVnaW4gZGVmaW5pdGlvbiBmYWN0b3J5XG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBjcmVhdGUgYSBwbHVnaW4gZGVmaW5pdGlvbiB3aGljaCBjYW4gYmVcbiAgICAgKiB1c2VkIGJ5IHdhdmVzdXJmZXIgdG8gY29ycmVjdGx5IGluc3RhbnRpYXRlIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ2lvbnNQbHVnaW5QYXJhbXN9IHBhcmFtcyBwYXJhbWV0ZXJzIHVzZSB0byBpbml0aWFsaXNlIHRoZSBwbHVnaW5cbiAgICAgKiBAcmV0dXJuIHtQbHVnaW5EZWZpbml0aW9ufSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwbHVnaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocGFyYW1zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAncmVnaW9ucycsXG4gICAgICAgIGRlZmVySW5pdDogcGFyYW1zICYmIHBhcmFtcy5kZWZlckluaXQgPyBwYXJhbXMuZGVmZXJJbml0IDogZmFsc2UsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBzdGF0aWNQcm9wczoge1xuICAgICAgICAgIGFkZFJlZ2lvbjogZnVuY3Rpb24gYWRkUmVnaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsaXNlZFBsdWdpbkxpc3QucmVnaW9ucykge1xuICAgICAgICAgICAgICB0aGlzLmluaXRQbHVnaW4oJ3JlZ2lvbnMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9ucy5hZGQob3B0aW9ucyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGVhclJlZ2lvbnM6IGZ1bmN0aW9uIGNsZWFyUmVnaW9ucygpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9ucyAmJiB0aGlzLnJlZ2lvbnMuY2xlYXIoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuYWJsZURyYWdTZWxlY3Rpb246IGZ1bmN0aW9uIGVuYWJsZURyYWdTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkUGx1Z2luTGlzdC5yZWdpb25zKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5pdFBsdWdpbigncmVnaW9ucycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbnMuZW5hYmxlRHJhZ1NlbGVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2FibGVEcmFnU2VsZWN0aW9uOiBmdW5jdGlvbiBkaXNhYmxlRHJhZ1NlbGVjdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9ucy5kaXNhYmxlRHJhZ1NlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2U6IFJlZ2lvbnNQbHVnaW5cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlZ2lvbnNQbHVnaW47XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZ2lvbnNQbHVnaW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcGx1Z2luL3JlZ2lvbnMvcmVnaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vcmVnaW9ucy9yZWdpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5SZWdpb24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiAgQHNpbmNlIDQuMC4wXG4gKlxuICogKFNpbmdsZSkgUmVnaW9uIHBsdWdpbiBjbGFzc1xuICpcbiAqIE11c3QgYmUgdHVybmVkIGludG8gYW4gb2JzZXJ2ZXIgYmVmb3JlIGluc3RhbnRpYXRpbmcuIFRoaXMgaXMgZG9uZSBpblxuICogYFJlZ2lvbnNQbHVnaW5gIChtYWluIHBsdWdpbiBjbGFzcykuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmVyfVxuICovXG52YXIgUmVnaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnaW9uKHBhcmFtcywgcmVnaW9uc1V0aWxzLCB3cykge1xuICAgIHZhciBfcGFyYW1zJHNob3dUb29sdGlwLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVnaW9uKTtcblxuICAgIHRoaXMud2F2ZXN1cmZlciA9IHdzO1xuICAgIHRoaXMud3JhcHBlciA9IHdzLmRyYXdlci53cmFwcGVyO1xuICAgIHRoaXMudXRpbCA9IHdzLnV0aWw7XG4gICAgdGhpcy5zdHlsZSA9IHRoaXMudXRpbC5zdHlsZTtcbiAgICB0aGlzLnJlZ2lvbnNVdGlsID0gcmVnaW9uc1V0aWxzO1xuICAgIHRoaXMudmVydGljYWwgPSB3cy5kcmF3ZXIucGFyYW1zLnZlcnRpY2FsO1xuICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQgPT0gbnVsbCA/IHdzLnV0aWwuZ2V0SWQoKSA6IHBhcmFtcy5pZDtcbiAgICB0aGlzLnN0YXJ0ID0gTnVtYmVyKHBhcmFtcy5zdGFydCkgfHwgMDtcbiAgICB0aGlzLmVuZCA9IHBhcmFtcy5lbmQgPT0gbnVsbCA/IC8vIHNtYWxsIG1hcmtlci1saWtlIHJlZ2lvblxuICAgIHRoaXMuc3RhcnQgKyA0IC8gdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoICogdGhpcy53YXZlc3VyZmVyLmdldER1cmF0aW9uKCkgOiBOdW1iZXIocGFyYW1zLmVuZCk7XG4gICAgdGhpcy5yZXNpemUgPSBwYXJhbXMucmVzaXplID09PSB1bmRlZmluZWQgPyB0cnVlIDogQm9vbGVhbihwYXJhbXMucmVzaXplKTtcbiAgICB0aGlzLmRyYWcgPSBwYXJhbXMuZHJhZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4ocGFyYW1zLmRyYWcpOyAvLyByZWZsZWN0IHJlc2l6ZSBhbmQgZHJhZyBzdGF0ZSBvZiByZWdpb24gZm9yIHJlZ2lvbi11cGRhdGVkIGxpc3RlbmVyXG5cbiAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3AgPSBCb29sZWFuKHBhcmFtcy5sb29wKTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8ICdyZ2JhKDAsIDAsIDAsIDAuMSknOyAvLyBUaGUgbGVmdCBhbmQgcmlnaHQgaGFuZGxlU3R5bGUgcHJvcGVydGllcyBjYW4gYmUgc2V0IHRvICdub25lJyBmb3JcbiAgICAvLyBubyBzdHlsaW5nIG9yIGNhbiBiZSBhc3NpZ25lZCBhbiBvYmplY3QgY29udGFpbmluZyBDU1MgcHJvcGVydGllcy5cblxuICAgIHRoaXMuaGFuZGxlU3R5bGUgPSBwYXJhbXMuaGFuZGxlU3R5bGUgfHwge1xuICAgICAgbGVmdDoge30sXG4gICAgICByaWdodDoge31cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlTGVmdEVsID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZVJpZ2h0RWwgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtcy5kYXRhIHx8IHt9O1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHBhcmFtcy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoX3BhcmFtcyRzaG93VG9vbHRpcCA9IHBhcmFtcy5zaG93VG9vbHRpcCkgIT09IG51bGwgJiYgX3BhcmFtcyRzaG93VG9vbHRpcCAhPT0gdm9pZCAwID8gX3BhcmFtcyRzaG93VG9vbHRpcCA6IHRydWU7XG4gICAgdGhpcy5tYXhMZW5ndGggPSBwYXJhbXMubWF4TGVuZ3RoOyAvLyBJdCBhc3N1bWVzIHRoZSBtaW5MZW5ndGggcGFyYW1ldGVyIHZhbHVlLCBvciB0aGUgcmVnaW9uc01pbkxlbmd0aCBwYXJhbWV0ZXIgdmFsdWUsIGlmIHRoZSBmaXJzdCBvbmUgbm90IHByb3ZpZGVkXG5cbiAgICB0aGlzLm1pbkxlbmd0aCA9IHBhcmFtcy5taW5MZW5ndGg7XG5cbiAgICB0aGlzLl9vblJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVSZW5kZXIoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zY3JvbGwgPSBwYXJhbXMuc2Nyb2xsICE9PSBmYWxzZSAmJiB3cy5wYXJhbXMuc2Nyb2xsUGFyZW50O1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBwYXJhbXMuc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICB0aGlzLnNjcm9sbFRocmVzaG9sZCA9IHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQgfHwgMTA7IC8vIERldGVybWluZXMgd2hldGhlciB0aGUgY29udGV4dCBtZW51IGlzIHByZXZlbnRlZCBmcm9tIGJlaW5nIG9wZW5lZC5cblxuICAgIHRoaXMucHJldmVudENvbnRleHRNZW51ID0gcGFyYW1zLnByZXZlbnRDb250ZXh0TWVudSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBCb29sZWFuKHBhcmFtcy5wcmV2ZW50Q29udGV4dE1lbnUpOyAvLyBzZWxlY3QgY2hhbm5lbCBJRCB0byBzZXQgcmVnaW9uXG5cbiAgICB2YXIgY2hhbm5lbElkeCA9IHBhcmFtcy5jaGFubmVsSWR4ID09IG51bGwgPyAtMSA6IHBhcnNlSW50KHBhcmFtcy5jaGFubmVsSWR4KTtcbiAgICB0aGlzLnJlZ2lvbkhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLm1hcmdpblRvcCA9ICcwcHgnO1xuXG4gICAgaWYgKGNoYW5uZWxJZHggIT09IC0xKSB7XG4gICAgICB2YXIgY2hhbm5lbENvdW50ID0gdGhpcy53YXZlc3VyZmVyLmJhY2tlbmQuYnVmZmVyICE9IG51bGwgPyB0aGlzLndhdmVzdXJmZXIuYmFja2VuZC5idWZmZXIubnVtYmVyT2ZDaGFubmVscyA6IC0xO1xuXG4gICAgICBpZiAoY2hhbm5lbENvdW50ID49IDAgJiYgY2hhbm5lbElkeCA8IGNoYW5uZWxDb3VudCkge1xuICAgICAgICB0aGlzLnJlZ2lvbkhlaWdodCA9IE1hdGguZmxvb3IoMSAvIGNoYW5uZWxDb3VudCAqIDEwMCkgKyAnJSc7XG4gICAgICAgIHRoaXMubWFyZ2luVG9wID0gdGhpcy53YXZlc3VyZmVyLmdldEhlaWdodCgpICogY2hhbm5lbElkeCArICdweCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXRUaW1lQ2FsbGJhY2sgPSBwYXJhbXMuZm9ybWF0VGltZUNhbGxiYWNrO1xuICAgIHRoaXMuZWRnZVNjcm9sbFdpZHRoID0gcGFyYW1zLmVkZ2VTY3JvbGxXaWR0aDtcbiAgICB0aGlzLmJpbmRJbk91dCgpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgdGhpcy53YXZlc3VyZmVyLm9uKCd6b29tJywgdGhpcy5fb25SZWRyYXcpO1xuICAgIHRoaXMud2F2ZXN1cmZlci5vbigncmVkcmF3JywgdGhpcy5fb25SZWRyYXcpO1xuICAgIHRoaXMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jcmVhdGVkJywgdGhpcyk7XG4gIH1cbiAgLyogVXBkYXRlIHJlZ2lvbiBwYXJhbXMuICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUmVnaW9uLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBOdW1iZXIocGFyYW1zLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5lbmQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVuZCA9IE51bWJlcihwYXJhbXMuZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5sb29wICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5sb29wID0gQm9vbGVhbihwYXJhbXMubG9vcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY29sb3IgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmhhbmRsZVN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZSA9IHBhcmFtcy5oYW5kbGVTdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucmVzaXplICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBCb29sZWFuKHBhcmFtcy5yZXNpemUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXNSZXNpemUodGhpcy5yZXNpemUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmRyYWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRyYWcgPSBCb29sZWFuKHBhcmFtcy5kcmFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5tYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IE51bWJlcihwYXJhbXMubWF4TGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5taW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IE51bWJlcihwYXJhbXMubWluTGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUmVuZGVyKCk7XG4gICAgICB0aGlzLmZpcmVFdmVudCgndXBkYXRlJyk7XG4gICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tdXBkYXRlZCcsIHRoaXMpO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYSBzaW5nbGUgcmVnaW9uLiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudC5kb21FbGVtZW50KTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIudW4oJ3pvb20nLCB0aGlzLl9vblJlZHJhdyk7XG4gICAgICAgIHRoaXMud2F2ZXN1cmZlci51bigncmVkcmF3JywgdGhpcy5fb25SZWRyYXcpO1xuICAgICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tcmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBhdWRpbyByZWdpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IE9wdGlvbmFsIG9mZnNldCB0byBzdGFydCBwbGF5aW5nIGF0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoc3RhcnQpIHtcbiAgICAgIHZhciBzID0gc3RhcnQgfHwgdGhpcy5zdGFydDtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci5wbGF5KHMsIHRoaXMuZW5kKTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwbGF5Jyk7XG4gICAgICB0aGlzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tcGxheScsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBhdWRpbyByZWdpb24gaW4gYSBsb29wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBPcHRpb25hbCBvZmZzZXQgdG8gc3RhcnQgcGxheWluZyBhdFxuICAgICAqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5TG9vcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5TG9vcChzdGFydCkge1xuICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICAgIHRoaXMucGxheShzdGFydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBsb29waW5nIG9uL29mZi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3AgVHJ1ZSBpZiBzaG91bGQgcGxheSBpbiBsb29wXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb29wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvb3AobG9vcCkge1xuICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICB9XG4gICAgLyogUmVuZGVyIGEgcmVnaW9uIGFzIGEgRE9NIGVsZW1lbnQuICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy51dGlsLndpdGhPcmllbnRhdGlvbih0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVnaW9uJykpLCB0aGlzLnZlcnRpY2FsKTtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSAnd2F2ZXN1cmZlci1yZWdpb24nO1xuXG4gICAgICBpZiAodGhpcy5zaG93VG9vbHRpcCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQudGl0bGUgPSB0aGlzLmZvcm1hdFRpbWUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgdGhpcy5pZCk7XG5cbiAgICAgIGZvciAodmFyIGF0dHJuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXJlZ2lvbi0nICsgYXR0cm5hbWUsIHRoaXMuYXR0cmlidXRlc1thdHRybmFtZV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0eWxlKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgekluZGV4OiAyLFxuICAgICAgICBoZWlnaHQ6IHRoaXMucmVnaW9uSGVpZ2h0LFxuICAgICAgICB0b3A6IHRoaXMubWFyZ2luVG9wXG4gICAgICB9KTtcbiAgICAgIC8qIFJlc2l6ZSBoYW5kbGVzICovXG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUxlZnRFbCA9IHRoaXMudXRpbC53aXRoT3JpZW50YXRpb24odGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hhbmRsZScpKSwgdGhpcy52ZXJ0aWNhbCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmlnaHRFbCA9IHRoaXMudXRpbC53aXRoT3JpZW50YXRpb24odGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hhbmRsZScpKSwgdGhpcy52ZXJ0aWNhbCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTGVmdEVsLmNsYXNzTmFtZSA9ICd3YXZlc3VyZmVyLWhhbmRsZSB3YXZlc3VyZmVyLWhhbmRsZS1zdGFydCc7XG4gICAgICAgIHRoaXMuaGFuZGxlUmlnaHRFbC5jbGFzc05hbWUgPSAnd2F2ZXN1cmZlci1oYW5kbGUgd2F2ZXN1cmZlci1oYW5kbGUtZW5kJzsgLy8gRGVmYXVsdCBDU1MgcHJvcGVydGllcyBmb3IgYm90aCBoYW5kbGVzLlxuXG4gICAgICAgIHZhciBjc3MgPSB7XG4gICAgICAgICAgY3Vyc29yOiB0aGlzLnZlcnRpY2FsID8gJ3Jvdy1yZXNpemUnIDogJ2NvbC1yZXNpemUnLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogJzBweCcsXG4gICAgICAgICAgd2lkdGg6ICcycHgnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMSknXG4gICAgICAgIH07IC8vIE1lcmdlIENTUyBwcm9wZXJ0aWVzIHBlciBoYW5kbGUuXG5cbiAgICAgICAgdmFyIGhhbmRsZUxlZnRDc3MgPSB0aGlzLmhhbmRsZVN0eWxlLmxlZnQgIT09ICdub25lJyA/IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGxlZnQ6ICcwcHgnXG4gICAgICAgIH0sIGNzcywgdGhpcy5oYW5kbGVTdHlsZS5sZWZ0KSA6IG51bGw7XG4gICAgICAgIHZhciBoYW5kbGVSaWdodENzcyA9IHRoaXMuaGFuZGxlU3R5bGUucmlnaHQgIT09ICdub25lJyA/IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHJpZ2h0OiAnMHB4J1xuICAgICAgICB9LCBjc3MsIHRoaXMuaGFuZGxlU3R5bGUucmlnaHQpIDogbnVsbDtcblxuICAgICAgICBpZiAoaGFuZGxlTGVmdENzcykge1xuICAgICAgICAgIHRoaXMuc3R5bGUodGhpcy5oYW5kbGVMZWZ0RWwsIGhhbmRsZUxlZnRDc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZVJpZ2h0Q3NzKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZSh0aGlzLmhhbmRsZVJpZ2h0RWwsIGhhbmRsZVJpZ2h0Q3NzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcigpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0VGltZShzdGFydCwgZW5kKSB7XG4gICAgICBpZiAodGhpcy5mb3JtYXRUaW1lQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VGltZUNhbGxiYWNrKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKHN0YXJ0ID09IGVuZCA/IFtzdGFydF0gOiBbc3RhcnQsIGVuZF0pLm1hcChmdW5jdGlvbiAodGltZSkge1xuICAgICAgICByZXR1cm4gW01hdGguZmxvb3IodGltZSAlIDM2MDAgLyA2MCksIC8vIG1pbnV0ZXNcbiAgICAgICAgKCcwMCcgKyBNYXRoLmZsb29yKHRpbWUgJSA2MCkpLnNsaWNlKC0yKSAvLyBzZWNvbmRzXG4gICAgICAgIF0uam9pbignOicpO1xuICAgICAgfSkuam9pbignLScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLndhdmVzdXJmZXIuZHJhd2VyLndpZHRoIC8gdGhpcy53YXZlc3VyZmVyLnBhcmFtcy5waXhlbFJhdGlvO1xuICAgIH1cbiAgICAvKiBVcGRhdGUgZWxlbWVudCdzIHBvc2l0aW9uLCB3aWR0aCwgY29sb3IuICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUmVuZGVyKCkge1xuICAgICAgLy8gZHVyYXRpb24gdmFyaWVzIGR1cmluZyBsb2FkaW5nIHByb2Nlc3MsIHNvIGRvbid0IG92ZXJ3cml0ZSBpbXBvcnRhbnQgZGF0YVxuICAgICAgdmFyIGR1ciA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgdmFyIHN0YXJ0TGltaXRlZCA9IHRoaXMuc3RhcnQ7XG4gICAgICB2YXIgZW5kTGltaXRlZCA9IHRoaXMuZW5kO1xuXG4gICAgICBpZiAoc3RhcnRMaW1pdGVkIDwgMCkge1xuICAgICAgICBzdGFydExpbWl0ZWQgPSAwO1xuICAgICAgICBlbmRMaW1pdGVkID0gZW5kTGltaXRlZCAtIHN0YXJ0TGltaXRlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZExpbWl0ZWQgPiBkdXIpIHtcbiAgICAgICAgZW5kTGltaXRlZCA9IGR1cjtcbiAgICAgICAgc3RhcnRMaW1pdGVkID0gZHVyIC0gKGVuZExpbWl0ZWQgLSBzdGFydExpbWl0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5taW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBlbmRMaW1pdGVkID0gTWF0aC5tYXgoc3RhcnRMaW1pdGVkICsgdGhpcy5taW5MZW5ndGgsIGVuZExpbWl0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBlbmRMaW1pdGVkID0gTWF0aC5taW4oc3RhcnRMaW1pdGVkICsgdGhpcy5tYXhMZW5ndGgsIGVuZExpbWl0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCB3aWR0aCB2YWx1ZXMgb2YgdGhlIHJlZ2lvbiBzdWNoIHRoYXRcbiAgICAgICAgLy8gbm8gZ2FwcyBhcHBlYXIgYmV0d2VlbiByZWdpb25zLlxuICAgICAgICB2YXIgbGVmdCA9IE1hdGgucm91bmQoc3RhcnRMaW1pdGVkIC8gZHVyICogd2lkdGgpO1xuICAgICAgICB2YXIgcmVnaW9uV2lkdGggPSBNYXRoLnJvdW5kKGVuZExpbWl0ZWQgLyBkdXIgKiB3aWR0aCkgLSBsZWZ0O1xuICAgICAgICB0aGlzLnN0eWxlKHRoaXMuZWxlbWVudCwge1xuICAgICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnLFxuICAgICAgICAgIHdpZHRoOiByZWdpb25XaWR0aCArICdweCcsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIGN1cnNvcjogdGhpcy5kcmFnID8gJ21vdmUnIDogJ2RlZmF1bHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGF0dHJuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVnaW9uLScgKyBhdHRybmFtZSwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJuYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaG93VG9vbHRpcCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IHRoaXMuZm9ybWF0VGltZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogQmluZCBhdWRpbyBldmVudHMuICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kSW5PdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEluT3V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZmlyZWRJbiA9IGZhbHNlO1xuICAgICAgdGhpcy5maXJlZE91dCA9IGZhbHNlO1xuXG4gICAgICB2YXIgb25Qcm9jZXNzID0gZnVuY3Rpb24gb25Qcm9jZXNzKHRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5yb3VuZChfdGhpczIuc3RhcnQgKiAxMCkgLyAxMDtcbiAgICAgICAgdmFyIGVuZCA9IE1hdGgucm91bmQoX3RoaXMyLmVuZCAqIDEwKSAvIDEwO1xuICAgICAgICB0aW1lID0gTWF0aC5yb3VuZCh0aW1lICogMTApIC8gMTA7XG5cbiAgICAgICAgaWYgKCFfdGhpczIuZmlyZWRPdXQgJiYgX3RoaXMyLmZpcmVkSW4gJiYgKHN0YXJ0ID4gdGltZSB8fCBlbmQgPD0gdGltZSkpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZWRPdXQgPSB0cnVlO1xuICAgICAgICAgIF90aGlzMi5maXJlZEluID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpczIuZmlyZUV2ZW50KCdvdXQnKTtcblxuICAgICAgICAgIF90aGlzMi53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW91dCcsIF90aGlzMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzMi5maXJlZEluICYmIHN0YXJ0IDw9IHRpbWUgJiYgZW5kID4gdGltZSkge1xuICAgICAgICAgIF90aGlzMi5maXJlZEluID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpczIuZmlyZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICAgIF90aGlzMi5maXJlRXZlbnQoJ2luJyk7XG5cbiAgICAgICAgICBfdGhpczIud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1pbicsIF90aGlzMik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMud2F2ZXN1cmZlci5iYWNrZW5kLm9uKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuICAgICAgdGhpcy5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIud2F2ZXN1cmZlci5iYWNrZW5kLnVuKCdhdWRpb3Byb2Nlc3MnLCBvblByb2Nlc3MpO1xuICAgICAgfSk7XG4gICAgICAvKiBMb29wIHBsYXliYWNrLiAqL1xuXG4gICAgICB0aGlzLm9uKCdvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIubG9vcCkge1xuICAgICAgICAgIHZhciByZWFsVGltZSA9IF90aGlzMi53YXZlc3VyZmVyLmdldEN1cnJlbnRUaW1lKCk7XG5cbiAgICAgICAgICBpZiAocmVhbFRpbWUgPj0gX3RoaXMyLnN0YXJ0ICYmIHJlYWxUaW1lIDw9IF90aGlzMi5lbmQpIHtcbiAgICAgICAgICAgIF90aGlzMi53YXZlc3VyZmVyLnBsYXkoX3RoaXMyLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBCaW5kIERPTSBldmVudHMuICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHByZXZlbnRDb250ZXh0TWVudSA9IHRoaXMucHJldmVudENvbnRleHRNZW51O1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdtb3VzZWVudGVyJywgZSk7XG5cbiAgICAgICAgX3RoaXMzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tbW91c2VlbnRlcicsIF90aGlzMywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnbW91c2VsZWF2ZScsIGUpO1xuXG4gICAgICAgIF90aGlzMy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLW1vdXNlbGVhdmUnLCBfdGhpczMsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgX3RoaXMzLmZpcmVFdmVudCgnY2xpY2snLCBlKTtcblxuICAgICAgICBfdGhpczMud2F2ZXN1cmZlci5maXJlRXZlbnQoJ3JlZ2lvbi1jbGljaycsIF90aGlzMywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCdkYmxjbGljaycsIGUpO1xuXG4gICAgICAgIF90aGlzMy53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLWRibGNsaWNrJywgX3RoaXMzLCBlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHByZXZlbnRDb250ZXh0TWVudSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5maXJlRXZlbnQoJ2NvbnRleHRtZW51JywgZSk7XG5cbiAgICAgICAgX3RoaXMzLndhdmVzdXJmZXIuZmlyZUV2ZW50KCdyZWdpb24tY29udGV4dG1lbnUnLCBfdGhpczMsIGUpO1xuICAgICAgfSk7XG4gICAgICAvKiBEcmFnIG9yIHJlc2l6ZSBvbiBtb3VzZW1vdmUuICovXG5cbiAgICAgIGlmICh0aGlzLmRyYWcgfHwgdGhpcy5yZXNpemUpIHtcbiAgICAgICAgdGhpcy5iaW5kRHJhZ0V2ZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRHJhZ0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRHJhZ0V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy53YXZlc3VyZmVyLmRyYXdlci5jb250YWluZXI7XG4gICAgICB2YXIgc2Nyb2xsU3BlZWQgPSB0aGlzLnNjcm9sbFNwZWVkO1xuICAgICAgdmFyIHNjcm9sbFRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciB0b3VjaElkO1xuICAgICAgdmFyIGRyYWc7XG4gICAgICB2YXIgbWF4U2Nyb2xsO1xuICAgICAgdmFyIHJlc2l6ZTtcbiAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG4gICAgICB2YXIgc2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgdmFyIHdyYXBwZXJSZWN0O1xuICAgICAgdmFyIHJlZ2lvbkxlZnRIYWxmVGltZTtcbiAgICAgIHZhciByZWdpb25SaWdodEhhbGZUaW1lOyAvLyBTY3JvbGwgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuXG4gICAgICB2YXIgZWRnZVNjcm9sbCA9IGZ1bmN0aW9uIGVkZ2VTY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgdmFyIG9yaWVudGVkRXZlbnQgPSBfdGhpczQudXRpbC53aXRoT3JpZW50YXRpb24oZXZlbnQsIF90aGlzNC52ZXJ0aWNhbCk7XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gX3RoaXM0LndhdmVzdXJmZXIuZ2V0RHVyYXRpb24oKTtcblxuICAgICAgICBpZiAoIXNjcm9sbERpcmVjdGlvbiB8fCAhZHJhZyAmJiAhcmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBvcmllbnRlZEV2ZW50LmNsaWVudFg7XG4gICAgICAgIHZhciBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSA9IDA7XG4gICAgICAgIHZhciByZWdpb25IYWxmVGltZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGFkanVzdG1lbnQgPSAwOyAvLyBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0aW1lIGFjY29yZGluZyB0byB0aGUgbW91c2UgcG9zaXRpb25cblxuICAgICAgICB2YXIgdGltZSA9IF90aGlzNC5yZWdpb25zVXRpbC5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUoX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGV2ZW50KSAqIGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoZHJhZykge1xuICAgICAgICAgIC8vIENvbnNpZGVyaW5nIHRoZSBwb2ludCBvZiBjb250YWN0IHdpdGggdGhlIHJlZ2lvbiB3aGlsZSBlZGdlc2Nyb2xsaW5nXG4gICAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlZ2lvbkhhbGZUaW1lV2lkdGggPSByZWdpb25MZWZ0SGFsZlRpbWUgKiBfdGhpczQud2F2ZXN1cmZlci5wYXJhbXMubWluUHhQZXJTZWM7XG4gICAgICAgICAgICBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSA9IHggLSB3cmFwcGVyUmVjdC5sZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdpb25IYWxmVGltZVdpZHRoID0gcmVnaW9uUmlnaHRIYWxmVGltZSAqIF90aGlzNC53YXZlc3VyZmVyLnBhcmFtcy5taW5QeFBlclNlYztcbiAgICAgICAgICAgIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlID0gd3JhcHBlclJlY3QucmlnaHQgLSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb25zaWRlcmluZyBtaW5MZW5ndGggd2hpbGUgZWRnZXNjcm9sbFxuICAgICAgICAgIHZhciBtaW5MZW5ndGggPSBfdGhpczQubWluTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCFtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIG1pbkxlbmd0aCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc2l6ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiBfdGhpczQuZW5kIC0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBfdGhpczQuZW5kIC0gbWluTGVuZ3RoO1xuICAgICAgICAgICAgICBhZGp1c3RtZW50ID0gc2Nyb2xsU3BlZWQgKiBzY3JvbGxEaXJlY3Rpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgICB0aW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc2l6ZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lIDwgX3RoaXM0LnN0YXJ0ICsgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBfdGhpczQuc3RhcnQgKyBtaW5MZW5ndGg7XG4gICAgICAgICAgICAgIGFkanVzdG1lbnQgPSBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWUgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICB0aW1lID0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERvbid0IGVkZ2VzY3JvbGwgaWYgcmVnaW9uIGhhcyByZWFjaGVkIG1pbiBvciBtYXggbGltaXRcblxuXG4gICAgICAgIHZhciB3cmFwcGVyU2Nyb2xsTGVmdCA9IF90aGlzNC53cmFwcGVyLnNjcm9sbExlZnQ7XG5cbiAgICAgICAgaWYgKHNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3cmFwcGVyU2Nyb2xsTGVmdCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3cmFwcGVyU2Nyb2xsTGVmdCAtIHJlZ2lvbkhhbGZUaW1lV2lkdGggKyBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3cmFwcGVyU2Nyb2xsTGVmdCkgPT09IG1heFNjcm9sbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdyYXBwZXJTY3JvbGxMZWZ0ICsgcmVnaW9uSGFsZlRpbWVXaWR0aCAtIGRpc3RhbmNlQmV0d2VlbkN1cnNvckFuZFdyYXBwZXJFZGdlKSA+PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVXBkYXRlIHNjcm9sbCBwb3NpdGlvblxuXG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB3cmFwcGVyU2Nyb2xsTGVmdCAtIGFkanVzdG1lbnQgKyBzY3JvbGxTcGVlZCAqIHNjcm9sbERpcmVjdGlvbjtcblxuICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgIHZhciBjYWxjdWxhdGVkTGVmdCA9IE1hdGgubWF4KDAgKyByZWdpb25IYWxmVGltZVdpZHRoIC0gZGlzdGFuY2VCZXR3ZWVuQ3Vyc29yQW5kV3JhcHBlckVkZ2UsIHNjcm9sbExlZnQpO1xuICAgICAgICAgIF90aGlzNC53cmFwcGVyLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0ID0gY2FsY3VsYXRlZExlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRSaWdodCA9IE1hdGgubWluKG1heFNjcm9sbCAtIHJlZ2lvbkhhbGZUaW1lV2lkdGggKyBkaXN0YW5jZUJldHdlZW5DdXJzb3JBbmRXcmFwcGVyRWRnZSwgc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgX3RoaXM0LndyYXBwZXIuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQgPSBjYWxjdWxhdGVkUmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBzdGFydFRpbWUgPSB0aW1lOyAvLyBDb250aW51ZSBkcmFnZ2luZyBvciByZXNpemluZ1xuXG4gICAgICAgIGRyYWcgPyBfdGhpczQub25EcmFnKGRlbHRhKSA6IF90aGlzNC5vblJlc2l6ZShkZWx0YSwgcmVzaXplKTsgLy8gUmVwZWF0XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWRnZVNjcm9sbChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uRG93biA9IGZ1bmN0aW9uIG9uRG93bihldmVudCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczQud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvdWNoSWQgPSBldmVudC50YXJnZXRUb3VjaGVzID8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyIDogbnVsbDsgLy8gc3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24sIGlmIHRoaXMgcmVnaW9uIGlzIHJlc2l6YWJsZSBvciBkcmFnZ2FibGVcbiAgICAgICAgLy8gYW5kIHRoZSBldmVudCBpcyB0aGVyZWZvcmUgaGFuZGxlZCBoZXJlLlxuXG4gICAgICAgIGlmIChfdGhpczQuZHJhZyB8fCBfdGhpczQucmVzaXplKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHNlbGVjdGVkIHN0YXJ0VGltZSB3ZSBiZWd1biBkcmFnZ2luZyBvciByZXNpemluZ1xuXG5cbiAgICAgICAgc3RhcnRUaW1lID0gX3RoaXM0LnJlZ2lvbnNVdGlsLmdldFJlZ2lvblNuYXBUb0dyaWRWYWx1ZShfdGhpczQud2F2ZXN1cmZlci5kcmF3ZXIuaGFuZGxlRXZlbnQoZXZlbnQsIHRydWUpICogZHVyYXRpb24pOyAvLyBTdG9yZSB0aGUgc2VsZWN0ZWQgcG9pbnQgb2YgY29udGFjdCB3aGVuIHdlIGJlZ2luIGRyYWdnaW5nXG5cbiAgICAgICAgcmVnaW9uTGVmdEhhbGZUaW1lID0gc3RhcnRUaW1lIC0gX3RoaXM0LnN0YXJ0O1xuICAgICAgICByZWdpb25SaWdodEhhbGZUaW1lID0gX3RoaXM0LmVuZCAtIHN0YXJ0VGltZTsgLy8gU3RvcmUgZm9yIHNjcm9sbCBjYWxjdWxhdGlvbnNcblxuICAgICAgICBtYXhTY3JvbGwgPSBfdGhpczQud3JhcHBlci5zY3JvbGxXaWR0aCAtIF90aGlzNC53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgICB3cmFwcGVyUmVjdCA9IF90aGlzNC51dGlsLndpdGhPcmllbnRhdGlvbihfdGhpczQud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgX3RoaXM0LnZlcnRpY2FsKTtcbiAgICAgICAgX3RoaXM0LmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM0LmlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2hhbmRsZScpIHtcbiAgICAgICAgICBfdGhpczQuaXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgICAgcmVzaXplID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnd2F2ZXN1cmZlci1oYW5kbGUtc3RhcnQnKSA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczQuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgZHJhZyA9IHRydWU7XG4gICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvblVwID0gZnVuY3Rpb24gb25VcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZyB8fCByZXNpemUpIHtcbiAgICAgICAgICBfdGhpczQuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzNC5pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgZHJhZyA9IGZhbHNlO1xuICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgcmVzaXplID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIF90aGlzNC51dGlsLnByZXZlbnRDbGljaygpO1xuXG4gICAgICAgICAgX3RoaXM0LmZpcmVFdmVudCgndXBkYXRlLWVuZCcsIGV2ZW50KTtcblxuICAgICAgICAgIF90aGlzNC53YXZlc3VyZmVyLmZpcmVFdmVudCgncmVnaW9uLXVwZGF0ZS1lbmQnLCBfdGhpczQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uTW92ZSA9IGZ1bmN0aW9uIG9uTW92ZShldmVudCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczQud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICAgIHZhciBvcmllbnRlZEV2ZW50ID0gX3RoaXM0LnV0aWwud2l0aE9yaWVudGF0aW9uKGV2ZW50LCBfdGhpczQudmVydGljYWwpO1xuXG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllciAhPSB0b3VjaElkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkcmFnICYmICFyZXNpemUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkVGltZSA9IHN0YXJ0VGltZTtcblxuICAgICAgICB2YXIgdGltZSA9IF90aGlzNC5yZWdpb25zVXRpbC5nZXRSZWdpb25TbmFwVG9HcmlkVmFsdWUoX3RoaXM0LndhdmVzdXJmZXIuZHJhd2VyLmhhbmRsZUV2ZW50KGV2ZW50KSAqIGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoZHJhZykge1xuICAgICAgICAgIC8vIFRvIG1haW50YWluIHJlbGF0aXZlIGN1cnNvciBzdGFydCBwb2ludCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgIHZhciBtYXhFbmQgPSBfdGhpczQud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPiBtYXhFbmQgLSByZWdpb25SaWdodEhhbGZUaW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gbWF4RW5kIC0gcmVnaW9uUmlnaHRIYWxmVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGltZSAtIHJlZ2lvbkxlZnRIYWxmVGltZSA8IDApIHtcbiAgICAgICAgICAgIHRpbWUgPSByZWdpb25MZWZ0SGFsZlRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc2l6ZSkge1xuICAgICAgICAgIC8vIFRvIG1haW50YWluIHJlbGF0aXZlIGN1cnNvciBzdGFydCBwb2ludCB3aGlsZSByZXNpemluZ1xuICAgICAgICAgIC8vIHdlIGhhdmUgdG8gaGFuZGxlIGZvciBtaW5MZW5ndGhcbiAgICAgICAgICB2YXIgbWluTGVuZ3RoID0gX3RoaXM0Lm1pbkxlbmd0aDtcblxuICAgICAgICAgIGlmICghbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICBtaW5MZW5ndGggPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNpemUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID4gX3RoaXM0LmVuZCAtIG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICB0aW1lID0gX3RoaXM0LmVuZCAtIG1pbkxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzaXplID09PSAnZW5kJykge1xuICAgICAgICAgICAgaWYgKHRpbWUgPCBfdGhpczQuc3RhcnQgKyBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGltZSA9IF90aGlzNC5zdGFydCArIG1pbkxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWUgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICB0aW1lID0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZTsgLy8gRHJhZ1xuXG4gICAgICAgIGlmIChfdGhpczQuZHJhZyAmJiBkcmFnKSB7XG4gICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZWQgfHwgISFkZWx0YTtcblxuICAgICAgICAgIF90aGlzNC5vbkRyYWcoZGVsdGEpO1xuICAgICAgICB9IC8vIFJlc2l6ZVxuXG5cbiAgICAgICAgaWYgKF90aGlzNC5yZXNpemUgJiYgcmVzaXplKSB7XG4gICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZWQgfHwgISFkZWx0YTtcblxuICAgICAgICAgIF90aGlzNC5vblJlc2l6ZShkZWx0YSwgcmVzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczQuc2Nyb2xsICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IF90aGlzNC53cmFwcGVyLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgLy8gVHJpZ2dlcmluZyBlZGdlc2Nyb2xsIGZyb20gd2l0aGluIGVkZ2VTY3JvbGxXaWR0aFxuICAgICAgICAgIHZhciB4ID0gb3JpZW50ZWRFdmVudC5jbGllbnRYOyAvLyBDaGVjayBkaXJlY3Rpb25cblxuICAgICAgICAgIGlmICh4IDwgd3JhcHBlclJlY3QubGVmdCArIF90aGlzNC5lZGdlU2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeCA+IHdyYXBwZXJSZWN0LnJpZ2h0IC0gX3RoaXM0LmVkZ2VTY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBlZGdlU2Nyb2xsKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvd24pO1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkRvd24pO1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVXApO1xuICAgICAgdGhpcy5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25VcCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblVwKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uTW92ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud2F2ZXN1cmZlci5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25VcCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZyhkZWx0YSkge1xuICAgICAgdmFyIG1heEVuZCA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICBpZiAodGhpcy5lbmQgKyBkZWx0YSA+IG1heEVuZCkge1xuICAgICAgICBkZWx0YSA9IG1heEVuZCAtIHRoaXMuZW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCArIGRlbHRhIDwgMCkge1xuICAgICAgICBkZWx0YSA9IHRoaXMuc3RhcnQgKiAtMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICBzdGFydDogdGhpcy5zdGFydCArIGRlbHRhLFxuICAgICAgICBlbmQ6IHRoaXMuZW5kICsgZGVsdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9uUmVzaXplKC01LCAnc3RhcnQnKSAvLyBNb3ZlcyB0aGUgc3RhcnQgcG9pbnQgNSBzZWNvbmRzIGJhY2tcbiAgICAgKiBvblJlc2l6ZSgwLjUsICdlbmQnKSAvLyBNb3ZlcyB0aGUgZW5kIHBvaW50IDAuNSBzZWNvbmRzIGZvcndhcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBIb3cgbXVjaCB0byBhZGQgb3Igc3VidHJhY3QsIGdpdmVuIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdzdGFydCAnb3IgJ2VuZCdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplKGRlbHRhLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMud2F2ZXN1cmZlci5nZXREdXJhdGlvbigpO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGNoYW5naW5nIHRoZSBzdGFydCBieSB0aGUgZ2l2ZW4gZGVsdGEgd291bGQgcmVzdWx0IGluIHRoZSByZWdpb24gYmVpbmcgc21hbGxlciB0aGFuIG1pbkxlbmd0aFxuICAgICAgICAvLyBJZ25vcmUgY2FzZXMgd2hlcmUgd2UgYXJlIG1ha2luZyB0aGUgcmVnaW9uIHdpZGVyIHJhdGhlciB0aGFuIHNocmlua2luZyBpdFxuICAgICAgICBpZiAoZGVsdGEgPiAwICYmIHRoaXMuZW5kIC0gKHRoaXMuc3RhcnQgKyBkZWx0YSkgPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICAgIGRlbHRhID0gdGhpcy5lbmQgLSB0aGlzLm1pbkxlbmd0aCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGEgPCAwICYmIHRoaXMuc3RhcnQgKyBkZWx0YSA8IDApIHtcbiAgICAgICAgICBkZWx0YSA9IHRoaXMuc3RhcnQgKiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICBzdGFydDogTWF0aC5taW4odGhpcy5zdGFydCArIGRlbHRhLCB0aGlzLmVuZCksXG4gICAgICAgICAgZW5kOiBNYXRoLm1heCh0aGlzLnN0YXJ0ICsgZGVsdGEsIHRoaXMuZW5kKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGNoYW5naW5nIHRoZSBlbmQgYnkgdGhlIGdpdmVuIGRlbHRhIHdvdWxkIHJlc3VsdCBpbiB0aGUgcmVnaW9uIGJlaW5nIHNtYWxsZXIgdGhhbiBtaW5MZW5ndGhcbiAgICAgICAgLy8gSWdub3JlIGNhc2VzIHdoZXJlIHdlIGFyZSBtYWtpbmcgdGhlIHJlZ2lvbiB3aWRlciByYXRoZXIgdGhhbiBzaHJpbmtpbmcgaXRcbiAgICAgICAgaWYgKGRlbHRhIDwgMCAmJiB0aGlzLmVuZCArIGRlbHRhIC0gdGhpcy5zdGFydCA8IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgICAgZGVsdGEgPSB0aGlzLnN0YXJ0ICsgdGhpcy5taW5MZW5ndGggLSB0aGlzLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSA+IDAgJiYgdGhpcy5lbmQgKyBkZWx0YSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgZGVsdGEgPSBkdXJhdGlvbiAtIHRoaXMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIHN0YXJ0OiBNYXRoLm1pbih0aGlzLmVuZCArIGRlbHRhLCB0aGlzLnN0YXJ0KSxcbiAgICAgICAgICBlbmQ6IE1hdGgubWF4KHRoaXMuZW5kICsgZGVsdGEsIHRoaXMuc3RhcnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVIYW5kbGVzUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUhhbmRsZXNSZXNpemUocmVzaXplKSB7XG4gICAgICB2YXIgY3Vyc29yU3R5bGU7XG5cbiAgICAgIGlmIChyZXNpemUpIHtcbiAgICAgICAgY3Vyc29yU3R5bGUgPSB0aGlzLnZlcnRpY2FsID8gJ3Jvdy1yZXNpemUnIDogJ2NvbC1yZXNpemUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yU3R5bGUgPSAnYXV0byc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFuZGxlTGVmdEVsICYmIHRoaXMuc3R5bGUodGhpcy5oYW5kbGVMZWZ0RWwsIHtcbiAgICAgICAgY3Vyc29yOiBjdXJzb3JTdHlsZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbmRsZVJpZ2h0RWwgJiYgdGhpcy5zdHlsZSh0aGlzLmhhbmRsZVJpZ2h0RWwsIHtcbiAgICAgICAgY3Vyc29yOiBjdXJzb3JTdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlZ2lvbjtcbn0oKTtcblxuZXhwb3J0cy5SZWdpb24gPSBSZWdpb247XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wbHVnaW4vcmVnaW9ucy9pbmRleC5qc1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXZlc3VyZmVyLnJlZ2lvbnMuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC9wbHVnaW4vd2F2ZXN1cmZlci5yZWdpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==